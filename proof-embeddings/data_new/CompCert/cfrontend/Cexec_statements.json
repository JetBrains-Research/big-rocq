{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Cexec.v","fileSamples":[{"statement":"(a : expr) (v : val) (ty : type) : is_val a = Some (v, ty) -> a = Eval v ty.","conclusion":"is_val a = Some (v, ty) -> a = Eval v ty","hypotheses":"(a : expr) (v : val) (ty : type)","proofString":"destruct a; simpl; congruence."},{"statement":"(a : expr) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) : is_loc a = Some (b, ofs, bf, ty) -> a = Eloc b ofs bf ty.","conclusion":"is_loc a = Some (b, ofs, bf, ty) -> a = Eloc b ofs bf ty","hypotheses":"(a : expr) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type)","proofString":"destruct a; simpl; congruence."},{"statement":"(v : val) (t : typ) (ev : eventval) : eventval_of_val v t = Some ev -> eventval_match ge ev t v.","conclusion":"eventval_of_val v t = Some ev -> eventval_match ge ev t v","hypotheses":"(v : val) (t : typ) (ev : eventval)","proofString":"destruct v; simpl; mydestr; constructor.\nauto.\napply Genv.invert_find_symbol; auto."},{"statement":"(b : block) (i : ptrofs) (i0 : ident) (Heqo : Genv.invert_symbol ge b = Some i0) (Heqb0 : Genv.public_symbol ge i0 = true) : Senv.public_symbol ge i0 = true.","conclusion":"Senv.public_symbol ge i0 = true","hypotheses":"(b : block) (i : ptrofs) (i0 : ident) (Heqo : Genv.invert_symbol ge b = Some i0) (Heqb0 : Genv.public_symbol ge i0 = true)","proofString":"auto."},{"statement":"(b : block) (i : ptrofs) (i0 : ident) (Heqo : Genv.invert_symbol ge b = Some i0) (Heqb0 : Genv.public_symbol ge i0 = true) : Senv.find_symbol ge i0 = Some b.","conclusion":"Senv.find_symbol ge i0 = Some b","hypotheses":"(b : block) (i : ptrofs) (i0 : ident) (Heqo : Genv.invert_symbol ge b = Some i0) (Heqb0 : Genv.public_symbol ge i0 = true)","proofString":"apply Genv.invert_find_symbol; auto."},{"statement":"(i : int) : (check typ_eq AST.Tint AST.Tint; Some (EVint i)) = Some (EVint i).","conclusion":"(check typ_eq AST.Tint AST.Tint; Some (EVint i)) = Some (EVint i)","hypotheses":"(i : int)","proofString":"auto."},{"statement":"(i : int64) : (check typ_eq AST.Tlong AST.Tlong; Some (EVlong i)) = Some (EVlong i).","conclusion":"(check typ_eq AST.Tlong AST.Tlong; Some (EVlong i)) = Some (EVlong i)","hypotheses":"(i : int64)","proofString":"auto."},{"statement":"(f : float) : (check typ_eq AST.Tfloat AST.Tfloat; Some (EVfloat f)) = Some (EVfloat f).","conclusion":"(check typ_eq AST.Tfloat AST.Tfloat; Some (EVfloat f)) = Some (EVfloat f)","hypotheses":"(f : float)","proofString":"auto."},{"statement":"(f : float32) : (check typ_eq Tsingle Tsingle; Some (EVsingle f)) = Some (EVsingle f).","conclusion":"(check typ_eq Tsingle Tsingle; Some (EVsingle f)) = Some (EVsingle f)","hypotheses":"(f : float32)","proofString":"auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b) : (do id0 <- Genv.invert_symbol ge b;\n check Genv.public_symbol ge id0;\n check typ_eq Tptr Tptr; Some (EVptr_global id0 ofs)) =\nSome (EVptr_global id ofs).","conclusion":"(do id0 <- Genv.invert_symbol ge b;\n check Genv.public_symbol ge id0;\n check typ_eq Tptr Tptr; Some (EVptr_global id0 ofs)) =\nSome (EVptr_global id ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b)","proofString":"rewrite (Genv.find_invert_symbol _ _ H0).\nsimpl in H; rewrite H.\nrewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b) : (check Genv.public_symbol ge id;\n check typ_eq Tptr Tptr; Some (EVptr_global id ofs)) =\nSome (EVptr_global id ofs).","conclusion":"(check Genv.public_symbol ge id;\n check typ_eq Tptr Tptr; Some (EVptr_global id ofs)) =\nSome (EVptr_global id ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b)","proofString":"simpl in H; rewrite H.\nrewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b) : (check typ_eq Tptr Tptr; Some (EVptr_global id ofs)) =\nSome (EVptr_global id ofs).","conclusion":"(check typ_eq Tptr Tptr; Some (EVptr_global id ofs)) =\nSome (EVptr_global id ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b)","proofString":"rewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b) : Some (EVptr_global id ofs) = Some (EVptr_global id ofs).","conclusion":"Some (EVptr_global id ofs) = Some (EVptr_global id ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b)","proofString":"auto."},{"statement":"eventval_list_match ge nil nil nil.","conclusion":"eventval_list_match ge nil nil nil","hypotheses":"","proofString":"constructor."},{"statement":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl0 : list eventval),\nlist_eventval_of_val vl tl0 = Some evl0 -> eventval_list_match ge evl0 tl0 vl) (t : typ) (tl : list typ) (evl : list eventval) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl') (H1 : Some (ev1 :: evl') = Some evl) : eventval_list_match ge evl (t :: tl) (a :: vl).","conclusion":"eventval_list_match ge evl (t :: tl) (a :: vl)","hypotheses":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl0 : list eventval),\nlist_eventval_of_val vl tl0 = Some evl0 -> eventval_list_match ge evl0 tl0 vl) (t : typ) (tl : list typ) (evl : list eventval) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl') (H1 : Some (ev1 :: evl') = Some evl)","proofString":"inv H1.\nconstructor.\napply eventval_of_val_sound; auto.\neauto."},{"statement":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl : list eventval),\nlist_eventval_of_val vl tl0 = Some evl -> eventval_list_match ge evl tl0 vl) (t : typ) (tl : list typ) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl') : eventval_list_match ge (ev1 :: evl') (t :: tl) (a :: vl).","conclusion":"eventval_list_match ge (ev1 :: evl') (t :: tl) (a :: vl)","hypotheses":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl : list eventval),\nlist_eventval_of_val vl tl0 = Some evl -> eventval_list_match ge evl tl0 vl) (t : typ) (tl : list typ) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl')","proofString":"constructor.\napply eventval_of_val_sound; auto.\neauto."},{"statement":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl : list eventval),\nlist_eventval_of_val vl tl0 = Some evl -> eventval_list_match ge evl tl0 vl) (t : typ) (tl : list typ) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl') : eventval_match ge ev1 t a.","conclusion":"eventval_match ge ev1 t a","hypotheses":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl : list eventval),\nlist_eventval_of_val vl tl0 = Some evl -> eventval_list_match ge evl tl0 vl) (t : typ) (tl : list typ) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl')","proofString":"apply eventval_of_val_sound; auto."},{"statement":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl : list eventval),\nlist_eventval_of_val vl tl0 = Some evl -> eventval_list_match ge evl tl0 vl) (t : typ) (tl : list typ) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl') : eventval_list_match ge evl' tl vl.","conclusion":"eventval_list_match ge evl' tl vl","hypotheses":"(a : val) (vl : list val) (IHvl : forall (tl0 : list typ) (evl : list eventval),\nlist_eventval_of_val vl tl0 = Some evl -> eventval_list_match ge evl tl0 vl) (t : typ) (tl : list typ) (ev1 : eventval) (Heqo : eventval_of_val a t = Some ev1) (evl' : list eventval) (Heqo0 : list_eventval_of_val vl tl = Some evl')","proofString":"eauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge ev1 ty1 v1) (H0 : eventval_list_match ge evl tyl vl) (IHeventval_list_match : list_eventval_of_val vl tyl = Some evl) : (do ev0 <- eventval_of_val v1 ty1;\n do evl0 <- list_eventval_of_val vl tyl; Some (ev0 :: evl0)) =\nSome (ev1 :: evl).","conclusion":"(do ev0 <- eventval_of_val v1 ty1;\n do evl0 <- list_eventval_of_val vl tyl; Some (ev0 :: evl0)) =\nSome (ev1 :: evl)","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge ev1 ty1 v1) (H0 : eventval_list_match ge evl tyl vl) (IHeventval_list_match : list_eventval_of_val vl tyl = Some evl)","proofString":"rewrite (eventval_of_val_complete _ _ _ H).\nrewrite IHeventval_list_match.\nauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge ev1 ty1 v1) (H0 : eventval_list_match ge evl tyl vl) (IHeventval_list_match : list_eventval_of_val vl tyl = Some evl) : (do evl0 <- list_eventval_of_val vl tyl; Some (ev1 :: evl0)) =\nSome (ev1 :: evl).","conclusion":"(do evl0 <- list_eventval_of_val vl tyl; Some (ev1 :: evl0)) =\nSome (ev1 :: evl)","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge ev1 ty1 v1) (H0 : eventval_list_match ge evl tyl vl) (IHeventval_list_match : list_eventval_of_val vl tyl = Some evl)","proofString":"rewrite IHeventval_list_match.\nauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge ev1 ty1 v1) (H0 : eventval_list_match ge evl tyl vl) (IHeventval_list_match : list_eventval_of_val vl tyl = Some evl) : Some (ev1 :: evl) = Some (ev1 :: evl).","conclusion":"Some (ev1 :: evl) = Some (ev1 :: evl)","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge ev1 ty1 v1) (H0 : eventval_list_match ge evl tyl vl) (IHeventval_list_match : list_eventval_of_val vl tyl = Some evl)","proofString":"auto."},{"statement":"(ev : eventval) (t : typ) (v : val) : val_of_eventval ev t = Some v -> eventval_match ge ev t v.","conclusion":"val_of_eventval ev t = Some v -> eventval_match ge ev t v","hypotheses":"(ev : eventval) (t : typ) (v : val)","proofString":"destruct ev; simpl; mydestr; constructor; auto."},{"statement":"(i : int) : (check typ_eq AST.Tint AST.Tint; Some (Vint i)) = Some (Vint i).","conclusion":"(check typ_eq AST.Tint AST.Tint; Some (Vint i)) = Some (Vint i)","hypotheses":"(i : int)","proofString":"auto."},{"statement":"(i : int64) : (check typ_eq AST.Tlong AST.Tlong; Some (Vlong i)) = Some (Vlong i).","conclusion":"(check typ_eq AST.Tlong AST.Tlong; Some (Vlong i)) = Some (Vlong i)","hypotheses":"(i : int64)","proofString":"auto."},{"statement":"(f : float) : (check typ_eq AST.Tfloat AST.Tfloat; Some (Vfloat f)) = Some (Vfloat f).","conclusion":"(check typ_eq AST.Tfloat AST.Tfloat; Some (Vfloat f)) = Some (Vfloat f)","hypotheses":"(f : float)","proofString":"auto."},{"statement":"(f : float32) : (check typ_eq Tsingle Tsingle; Some (Vsingle f)) = Some (Vsingle f).","conclusion":"(check typ_eq Tsingle Tsingle; Some (Vsingle f)) = Some (Vsingle f)","hypotheses":"(f : float32)","proofString":"auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b) : (check Genv.public_symbol ge id;\n check typ_eq Tptr Tptr; do b0 <- Genv.find_symbol ge id; Some (Vptr b0 ofs)) =\nSome (Vptr b ofs).","conclusion":"(check Genv.public_symbol ge id;\n check typ_eq Tptr Tptr; do b0 <- Genv.find_symbol ge id; Some (Vptr b0 ofs)) =\nSome (Vptr b ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge id = true) (H0 : Senv.find_symbol ge id = Some b)","proofString":"simpl in *.\nrewrite H, H0.\nrewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Genv.find_symbol ge id = Some b) : (check Genv.public_symbol ge id;\n check typ_eq Tptr Tptr; do b0 <- Genv.find_symbol ge id; Some (Vptr b0 ofs)) =\nSome (Vptr b ofs).","conclusion":"(check Genv.public_symbol ge id;\n check typ_eq Tptr Tptr; do b0 <- Genv.find_symbol ge id; Some (Vptr b0 ofs)) =\nSome (Vptr b ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Genv.find_symbol ge id = Some b)","proofString":"rewrite H, H0.\nrewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Genv.find_symbol ge id = Some b) : (check typ_eq Tptr Tptr; Some (Vptr b ofs)) = Some (Vptr b ofs).","conclusion":"(check typ_eq Tptr Tptr; Some (Vptr b ofs)) = Some (Vptr b ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Genv.find_symbol ge id = Some b)","proofString":"rewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Genv.find_symbol ge id = Some b) : Some (Vptr b ofs) = Some (Vptr b ofs).","conclusion":"Some (Vptr b ofs) = Some (Vptr b ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Genv.public_symbol ge id = true) (H0 : Genv.find_symbol ge id = Some b)","proofString":"auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) : do_volatile_load w chunk m b ofs = Some (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'.","conclusion":"do_volatile_load w chunk m b ofs = Some (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val)","proofString":"unfold do_volatile_load.\nmydestr.\ndestruct p as [ev w''].\nmydestr.\nsplit.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply val_of_eventval_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor.\nsplit.\nconstructor; auto.\nconstructor."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) : (if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)\n else do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'.","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)\n else do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val)","proofString":"mydestr.\ndestruct p as [ev w''].\nmydestr.\nsplit.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply val_of_eventval_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor.\nsplit.\nconstructor; auto.\nconstructor."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (p : eventval * world) (Heqo0 : nextworld_vload w chunk i ofs = Some p) : (let (res, w'0) := p in\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk i ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'.","conclusion":"(let (res, w'0) := p in\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk i ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (p : eventval * world) (Heqo0 : nextworld_vload w chunk i ofs = Some p)","proofString":"destruct p as [ev w''].\nmydestr.\nsplit.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply val_of_eventval_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (w'' : world) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w'')) : (do vres <- val_of_eventval ev (type_of_chunk chunk);\n Some (w'', Event_vload chunk i ofs ev :: nil, Val.load_result chunk vres)) =\nSome (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'.","conclusion":"(do vres <- val_of_eventval ev (type_of_chunk chunk);\n Some (w'', Event_vload chunk i ofs ev :: nil, Val.load_result chunk vres)) =\nSome (w', t, v) ->\nvolatile_load ge chunk m b ofs t v /\\ possible_trace w t w'","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (w'' : world) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w''))","proofString":"mydestr.\nsplit.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply val_of_eventval_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0) : volatile_load ge chunk m b ofs (Event_vload chunk i ofs ev :: nil)\n  (Val.load_result chunk v0) /\\\npossible_trace w (Event_vload chunk i ofs ev :: nil) w'.","conclusion":"volatile_load ge chunk m b ofs (Event_vload chunk i ofs ev :: nil)\n  (Val.load_result chunk v0) /\\\npossible_trace w (Event_vload chunk i ofs ev :: nil) w'","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0)","proofString":"split.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply val_of_eventval_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0) : volatile_load ge chunk m b ofs (Event_vload chunk i ofs ev :: nil)\n  (Val.load_result chunk v0).","conclusion":"volatile_load ge chunk m b ofs (Event_vload chunk i ofs ev :: nil)\n  (Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0)","proofString":"constructor; auto.\napply Genv.invert_find_symbol; auto.\napply val_of_eventval_sound; auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0) : Senv.find_symbol ge i = Some b.","conclusion":"Senv.find_symbol ge i = Some b","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0)","proofString":"apply Genv.invert_find_symbol; auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0) : eventval_match ge ev (type_of_chunk chunk) v0.","conclusion":"eventval_match ge ev (type_of_chunk chunk) v0","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0)","proofString":"apply val_of_eventval_sound; auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0) : possible_trace w (Event_vload chunk i ofs ev :: nil) w'.","conclusion":"possible_trace w (Event_vload chunk i ofs ev :: nil) w'","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (ev : eventval) (Heqo0 : nextworld_vload w chunk i ofs = Some (ev, w')) (v0 : val) (Heqo1 : val_of_eventval ev (type_of_chunk chunk) = Some v0)","proofString":"econstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : volatile_load ge chunk m b ofs E0 v /\\ possible_trace w' E0 w'.","conclusion":"volatile_load ge chunk m b ofs E0 v /\\ possible_trace w' E0 w'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"split.\nconstructor; auto.\nconstructor."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : volatile_load ge chunk m b ofs E0 v.","conclusion":"volatile_load ge chunk m b ofs E0 v","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"constructor; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"constructor."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (H : volatile_load ge chunk m b ofs t v) (H0 : possible_trace w t w') : (if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)\n else do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', t, v).","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)\n else do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', t, v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (H : volatile_load ge chunk m b ofs t v) (H0 : possible_trace w t w')","proofString":"inv H; simpl in *.\nrewrite H1.\nrewrite (Genv.find_invert_symbol _ _ H2).\ninv H0.\ninv H8.\ninv H6.\nrewrite H9.\nrewrite (val_of_eventval_complete _ _ _ H3).\nauto.\nrewrite H1.\nrewrite H2.\ninv H0.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vload chunk id ofs ev :: nil) w') (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) : (if Genv.block_is_volatile ge b\n then\n  do id0 <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id0 ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some\n    (w'0, Event_vload chunk id0 ofs res :: nil, Val.load_result chunk vres)\n else do v <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id0 <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id0 ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some\n    (w'0, Event_vload chunk id0 ofs res :: nil, Val.load_result chunk vres)\n else do v <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vload chunk id ofs ev :: nil) w') (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0)","proofString":"rewrite H1.\nrewrite (Genv.find_invert_symbol _ _ H2).\ninv H0.\ninv H8.\ninv H6.\nrewrite H9.\nrewrite (val_of_eventval_complete _ _ _ H3).\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vload chunk id ofs ev :: nil) w') (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) : (do id0 <- Genv.invert_symbol ge b;\n do res, w'0 <- nextworld_vload w chunk id0 ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id0 ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"(do id0 <- Genv.invert_symbol ge b;\n do res, w'0 <- nextworld_vload w chunk id0 ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id0 ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vload chunk id ofs ev :: nil) w') (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0)","proofString":"rewrite (Genv.find_invert_symbol _ _ H2).\ninv H0.\ninv H8.\ninv H6.\nrewrite H9.\nrewrite (val_of_eventval_complete _ _ _ H3).\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vload chunk id ofs ev :: nil) w') (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) : (do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"(do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vload chunk id ofs ev :: nil) w') (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0)","proofString":"inv H0.\ninv H8.\ninv H6.\nrewrite H9.\nrewrite (val_of_eventval_complete _ _ _ H3).\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (w2 : world) (H6 : possible_event w (Event_vload chunk id ofs ev) w2) (H8 : possible_trace w2 nil w') : (do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"(do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (w2 : world) (H6 : possible_event w (Event_vload chunk id ofs ev) w2) (H8 : possible_trace w2 nil w')","proofString":"inv H8.\ninv H6.\nrewrite H9.\nrewrite (val_of_eventval_complete _ _ _ H3).\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H6 : possible_event w (Event_vload chunk id ofs ev) w') : (do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"(do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H6 : possible_event w (Event_vload chunk id ofs ev) w')","proofString":"inv H6.\nrewrite H9.\nrewrite (val_of_eventval_complete _ _ _ H3).\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H9 : nextworld_vload w chunk id ofs = Some (ev, w')) : (do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"(do res, w'0 <- nextworld_vload w chunk id ofs;\n do vres <- val_of_eventval res (type_of_chunk chunk);\n Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H9 : nextworld_vload w chunk id ofs = Some (ev, w'))","proofString":"rewrite H9.\nrewrite (val_of_eventval_complete _ _ _ H3).\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H9 : nextworld_vload w chunk id ofs = Some (ev, w')) : (do vres <- val_of_eventval ev (type_of_chunk chunk);\n Some (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"(do vres <- val_of_eventval ev (type_of_chunk chunk);\n Some (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk vres)) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H9 : nextworld_vload w chunk id ofs = Some (ev, w'))","proofString":"rewrite (val_of_eventval_complete _ _ _ H3).\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H9 : nextworld_vload w chunk id ofs = Some (ev, w')) : Some (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0).","conclusion":"Some (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0) =\nSome (w', Event_vload chunk id ofs ev :: nil, Val.load_result chunk v0)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (id : ident) (ev : eventval) (v0 : val) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) (H9 : nextworld_vload w chunk id ofs = Some (ev, w'))","proofString":"auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : (if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)\n else do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', E0, v).","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do res, w'0 <- nextworld_vload w chunk id ofs;\n  do vres <- val_of_eventval res (type_of_chunk chunk);\n  Some (w'0, Event_vload chunk id ofs res :: nil, Val.load_result chunk vres)\n else do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', E0, v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"rewrite H1.\nrewrite H2.\ninv H0.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : (do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', E0, v).","conclusion":"(do v0 <- Mem.load chunk m b (Ptrofs.unsigned ofs); Some (w, E0, v0)) =\nSome (w', E0, v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"rewrite H2.\ninv H0.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : Some (w, E0, v) = Some (w', E0, v).","conclusion":"Some (w, E0, v) = Some (w', E0, v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"inv H0.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : Some (w', E0, v) = Some (w', E0, v).","conclusion":"Some (w', E0, v) = Some (w', E0, v)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) : do_volatile_store w chunk m b ofs v = Some (w', t, m', v') ->\nvolatile_store ge chunk m b ofs v t m' /\\ possible_trace w t w' /\\ v' = v.","conclusion":"do_volatile_store w chunk m b ofs v = Some (w', t, m', v') ->\nvolatile_store ge chunk m b ofs v t m' /\\ possible_trace w t w' /\\ v' = v","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val)","proofString":"unfold do_volatile_store.\nmydestr.\nsplit.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply eventval_of_val_sound; auto.\nsplit.\neconstructor.\nconstructor; eauto.\nconstructor.\nauto.\nsplit.\nconstructor; auto.\nsplit.\nconstructor.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) : (if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do ev <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id ofs ev;\n  Some (w'0, Event_vstore chunk id ofs ev :: nil, m, v)\n else\n  do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', t, m', v') ->\nvolatile_store ge chunk m b ofs v t m' /\\ possible_trace w t w' /\\ v' = v.","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do ev <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id ofs ev;\n  Some (w'0, Event_vstore chunk id ofs ev :: nil, m, v)\n else\n  do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', t, m', v') ->\nvolatile_store ge chunk m b ofs v t m' /\\ possible_trace w t w' /\\ v' = v","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val)","proofString":"mydestr.\nsplit.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply eventval_of_val_sound; auto.\nsplit.\neconstructor.\nconstructor; eauto.\nconstructor.\nauto.\nsplit.\nconstructor; auto.\nsplit.\nconstructor.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w') : volatile_store ge chunk m' b ofs v' (Event_vstore chunk i ofs e :: nil) m' /\\\npossible_trace w (Event_vstore chunk i ofs e :: nil) w' /\\ v' = v'.","conclusion":"volatile_store ge chunk m' b ofs v' (Event_vstore chunk i ofs e :: nil) m' /\\\npossible_trace w (Event_vstore chunk i ofs e :: nil) w' /\\ v' = v'","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w')","proofString":"split.\nconstructor; auto.\napply Genv.invert_find_symbol; auto.\napply eventval_of_val_sound; auto.\nsplit.\neconstructor.\nconstructor; eauto.\nconstructor.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w') : volatile_store ge chunk m' b ofs v' (Event_vstore chunk i ofs e :: nil) m'.","conclusion":"volatile_store ge chunk m' b ofs v' (Event_vstore chunk i ofs e :: nil) m'","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w')","proofString":"constructor; auto.\napply Genv.invert_find_symbol; auto.\napply eventval_of_val_sound; auto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w') : Senv.find_symbol ge i = Some b.","conclusion":"Senv.find_symbol ge i = Some b","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w')","proofString":"apply Genv.invert_find_symbol; auto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w') : eventval_match ge e (type_of_chunk chunk) (Val.load_result chunk v').","conclusion":"eventval_match ge e (type_of_chunk chunk) (Val.load_result chunk v')","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w')","proofString":"apply eventval_of_val_sound; auto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w') : possible_trace w (Event_vstore chunk i ofs e :: nil) w' /\\ v' = v'.","conclusion":"possible_trace w (Event_vstore chunk i ofs e :: nil) w' /\\ v' = v'","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w')","proofString":"split.\neconstructor.\nconstructor; eauto.\nconstructor.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w') : possible_trace w (Event_vstore chunk i ofs e :: nil) w'.","conclusion":"possible_trace w (Event_vstore chunk i ofs e :: nil) w'","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w')","proofString":"econstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w') : v' = v'.","conclusion":"v' = v'","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = true) (i : ident) (Heqo : Genv.invert_symbol ge b = Some i) (e : eventval) (Heqo0 : eventval_of_val (Val.load_result chunk v') (type_of_chunk chunk) = Some e) (Heqo1 : nextworld_vstore w chunk i ofs e = Some w')","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m') : volatile_store ge chunk m b ofs v' E0 m' /\\\npossible_trace w' E0 w' /\\ v' = v'.","conclusion":"volatile_store ge chunk m b ofs v' E0 m' /\\\npossible_trace w' E0 w' /\\ v' = v'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m')","proofString":"split.\nconstructor; auto.\nsplit.\nconstructor.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m') : volatile_store ge chunk m b ofs v' E0 m'.","conclusion":"volatile_store ge chunk m b ofs v' E0 m'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m')","proofString":"constructor; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m') : possible_trace w' E0 w' /\\ v' = v'.","conclusion":"possible_trace w' E0 w' /\\ v' = v'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m')","proofString":"split.\nconstructor.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m') : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m')","proofString":"constructor."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m') : v' = v'.","conclusion":"v' = v'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (Heqb0 : Genv.block_is_volatile ge b = false) (Heqo : Mem.store chunk m b (Ptrofs.unsigned ofs) v' = Some m')","proofString":"auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (H : volatile_store ge chunk m b ofs v t m') (H0 : possible_trace w t w') : (if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do ev <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id ofs ev;\n  Some (w'0, Event_vstore chunk id ofs ev :: nil, m, v)\n else\n  do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', t, m', v).","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do ev <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id ofs ev;\n  Some (w'0, Event_vstore chunk id ofs ev :: nil, m, v)\n else\n  do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', t, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (H : volatile_store ge chunk m b ofs v t m') (H0 : possible_trace w t w')","proofString":"inv H; simpl in *.\nrewrite H1.\nrewrite (Genv.find_invert_symbol _ _ H2).\nrewrite (eventval_of_val_complete _ _ _ H3).\ninv H0.\ninv H8.\ninv H6.\nrewrite H9.\nauto.\nrewrite H1.\nrewrite H2.\ninv H0.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : (if Genv.block_is_volatile ge b\n then\n  do id0 <- Genv.invert_symbol ge b;\n  do ev0 <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id0 ofs ev0;\n  Some (w'0, Event_vstore chunk id0 ofs ev0 :: nil, m', v)\n else\n  do m'0 <- Mem.store chunk m' b (Ptrofs.unsigned ofs) v;\n  Some (w, E0, m'0, v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id0 <- Genv.invert_symbol ge b;\n  do ev0 <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id0 ofs ev0;\n  Some (w'0, Event_vstore chunk id0 ofs ev0 :: nil, m', v)\n else\n  do m'0 <- Mem.store chunk m' b (Ptrofs.unsigned ofs) v;\n  Some (w, E0, m'0, v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"rewrite H1.\nrewrite (Genv.find_invert_symbol _ _ H2).\nrewrite (eventval_of_val_complete _ _ _ H3).\ninv H0.\ninv H8.\ninv H6.\nrewrite H9.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : (do id0 <- Genv.invert_symbol ge b;\n do ev0 <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n do w'0 <- nextworld_vstore w chunk id0 ofs ev0;\n Some (w'0, Event_vstore chunk id0 ofs ev0 :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"(do id0 <- Genv.invert_symbol ge b;\n do ev0 <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n do w'0 <- nextworld_vstore w chunk id0 ofs ev0;\n Some (w'0, Event_vstore chunk id0 ofs ev0 :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"rewrite (Genv.find_invert_symbol _ _ H2).\nrewrite (eventval_of_val_complete _ _ _ H3).\ninv H0.\ninv H8.\ninv H6.\nrewrite H9.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : (do ev0 <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n do w'0 <- nextworld_vstore w chunk id ofs ev0;\n Some (w'0, Event_vstore chunk id ofs ev0 :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"(do ev0 <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n do w'0 <- nextworld_vstore w chunk id ofs ev0;\n Some (w'0, Event_vstore chunk id ofs ev0 :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"rewrite (eventval_of_val_complete _ _ _ H3).\ninv H0.\ninv H8.\ninv H6.\nrewrite H9.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : (do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"(do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H0 : possible_trace w (Event_vstore chunk id ofs ev :: nil) w') (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"inv H0.\ninv H8.\ninv H6.\nrewrite H9.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (w2 : world) (H6 : possible_event w (Event_vstore chunk id ofs ev) w2) (H8 : possible_trace w2 nil w') : (do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"(do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (w2 : world) (H6 : possible_event w (Event_vstore chunk id ofs ev) w2) (H8 : possible_trace w2 nil w')","proofString":"inv H8.\ninv H6.\nrewrite H9.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H6 : possible_event w (Event_vstore chunk id ofs ev) w') : (do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"(do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H6 : possible_event w (Event_vstore chunk id ofs ev) w')","proofString":"inv H6.\nrewrite H9.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H9 : nextworld_vstore w chunk id ofs ev = Some w') : (do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"(do w'0 <- nextworld_vstore w chunk id ofs ev;\n Some (w'0, Event_vstore chunk id ofs ev :: nil, m', v)) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H9 : nextworld_vstore w chunk id ofs ev = Some w')","proofString":"rewrite H9.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H9 : nextworld_vstore w chunk id ofs ev = Some w') : Some (w', Event_vstore chunk id ofs ev :: nil, m', v) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v).","conclusion":"Some (w', Event_vstore chunk id ofs ev :: nil, m', v) =\nSome (w', Event_vstore chunk id ofs ev :: nil, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (id : ident) (ev : eventval) (H1 : Genv.block_is_volatile ge b = true) (H2 : Genv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H9 : nextworld_vstore w chunk id ofs ev = Some w')","proofString":"auto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') : (if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do ev <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id ofs ev;\n  Some (w'0, Event_vstore chunk id ofs ev :: nil, m, v)\n else\n  do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', E0, m', v).","conclusion":"(if Genv.block_is_volatile ge b\n then\n  do id <- Genv.invert_symbol ge b;\n  do ev <- eventval_of_val (Val.load_result chunk v) (type_of_chunk chunk);\n  do w'0 <- nextworld_vstore w chunk id ofs ev;\n  Some (w'0, Event_vstore chunk id ofs ev :: nil, m, v)\n else\n  do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', E0, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m')","proofString":"rewrite H1.\nrewrite H2.\ninv H0.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') : (do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', E0, m', v).","conclusion":"(do m'0 <- Mem.store chunk m b (Ptrofs.unsigned ofs) v; Some (w, E0, m'0, v)) =\nSome (w', E0, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m')","proofString":"rewrite H2.\ninv H0.\nauto."},{"statement":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') : Some (w, E0, m', v) = Some (w', E0, m', v).","conclusion":"Some (w, E0, m', v) = Some (w', E0, m', v)","hypotheses":"(w : world) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m')","proofString":"inv H0.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') : Some (w', E0, m', v) = Some (w', E0, m', v).","conclusion":"Some (w', E0, m', v) = Some (w', E0, m', v)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (H1 : Genv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m')","proofString":"auto."},{"statement":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) : {b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}.","conclusion":"{b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}","hypotheses":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs))","proofString":"destruct (eq_block b' b); auto.\ndestruct (zeq (Ptrofs.unsigned ofs') (Ptrofs.unsigned ofs)); auto.\ndestruct (zle (Ptrofs.unsigned ofs' + sizeof ge ty) (Ptrofs.unsigned ofs)); auto.\ndestruct (zle (Ptrofs.unsigned ofs + sizeof ge ty) (Ptrofs.unsigned ofs')); auto.\nright; intuition lia."},{"statement":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b) : {b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}.","conclusion":"{b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}","hypotheses":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b)","proofString":"destruct (zeq (Ptrofs.unsigned ofs') (Ptrofs.unsigned ofs)); auto.\ndestruct (zle (Ptrofs.unsigned ofs' + sizeof ge ty) (Ptrofs.unsigned ofs)); auto.\ndestruct (zle (Ptrofs.unsigned ofs + sizeof ge ty) (Ptrofs.unsigned ofs')); auto.\nright; intuition lia."},{"statement":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b) (n : Ptrofs.unsigned ofs' <> Ptrofs.unsigned ofs) : {b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}.","conclusion":"{b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}","hypotheses":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b) (n : Ptrofs.unsigned ofs' <> Ptrofs.unsigned ofs)","proofString":"destruct (zle (Ptrofs.unsigned ofs' + sizeof ge ty) (Ptrofs.unsigned ofs)); auto.\ndestruct (zle (Ptrofs.unsigned ofs + sizeof ge ty) (Ptrofs.unsigned ofs')); auto.\nright; intuition lia."},{"statement":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b) (n : Ptrofs.unsigned ofs' <> Ptrofs.unsigned ofs) (g : Ptrofs.unsigned ofs' + sizeof ge ty > Ptrofs.unsigned ofs) : {b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}.","conclusion":"{b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}","hypotheses":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b) (n : Ptrofs.unsigned ofs' <> Ptrofs.unsigned ofs) (g : Ptrofs.unsigned ofs' + sizeof ge ty > Ptrofs.unsigned ofs)","proofString":"destruct (zle (Ptrofs.unsigned ofs + sizeof ge ty) (Ptrofs.unsigned ofs')); auto.\nright; intuition lia."},{"statement":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b) (n : Ptrofs.unsigned ofs' <> Ptrofs.unsigned ofs) (g : Ptrofs.unsigned ofs' + sizeof ge ty > Ptrofs.unsigned ofs) (g0 : Ptrofs.unsigned ofs + sizeof ge ty > Ptrofs.unsigned ofs') : {b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}.","conclusion":"{b' <> b \\/\n Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'} +\n{~\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')}","hypotheses":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (e : b' = b) (n : Ptrofs.unsigned ofs' <> Ptrofs.unsigned ofs) (g : Ptrofs.unsigned ofs' + sizeof ge ty > Ptrofs.unsigned ofs) (g0 : Ptrofs.unsigned ofs + sizeof ge ty > Ptrofs.unsigned ofs')","proofString":"right; intuition lia."},{"statement":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (o : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') : {(alignof_blockcopy ge ty | Ptrofs.unsigned ofs') /\\\n (alignof_blockcopy ge ty | Ptrofs.unsigned ofs) /\\\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')} +\n{~\n ((alignof_blockcopy ge ty | Ptrofs.unsigned ofs') /\\\n  (alignof_blockcopy ge ty | Ptrofs.unsigned ofs) /\\\n  (b' <> b \\/\n   Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n   Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n   Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'))}.","conclusion":"{(alignof_blockcopy ge ty | Ptrofs.unsigned ofs') /\\\n (alignof_blockcopy ge ty | Ptrofs.unsigned ofs) /\\\n (b' <> b \\/\n  Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n  Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')} +\n{~\n ((alignof_blockcopy ge ty | Ptrofs.unsigned ofs') /\\\n  (alignof_blockcopy ge ty | Ptrofs.unsigned ofs) /\\\n  (b' <> b \\/\n   Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\n   Ptrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\n   Ptrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs'))}","hypotheses":"(ty : type) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (d : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (d0 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (o : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs')","proofString":"left; intuition lia."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (w' : world) (t : trace) (v : val) : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_load w chunk m b ofs\n        else do v0 <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v0)\n    | By_nothing => None\n    | _ => Some (w, E0, Vptr b ofs)\n    end\n| Bits sz sg pos width =>\n    match ty with\n    | Tint sz1 sg1 _ =>\n        check intsize_eq sz1 sz &&\n              signedness_eq sg1\n                (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n              zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n              zle (pos + width) (bitsize_carrier sz);\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs bf t v /\\ possible_trace w t w'.","conclusion":"match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_load w chunk m b ofs\n        else do v0 <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v0)\n    | By_nothing => None\n    | _ => Some (w, E0, Vptr b ofs)\n    end\n| Bits sz sg pos width =>\n    match ty with\n    | Tint sz1 sg1 _ =>\n        check intsize_eq sz1 sz &&\n              signedness_eq sg1\n                (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n              zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n              zle (pos + width) (bitsize_carrier sz);\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs bf t v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (w' : world) (t : trace) (v : val)","proofString":"destruct bf.\ndestruct (access_mode ty) eqn:?; mydestr.\nintros.\nexploit do_volatile_load_sound; eauto.\nintuition.\neapply deref_loc_volatile; eauto.\nsplit.\neapply deref_loc_value; eauto.\nconstructor.\nsplit.\neapply deref_loc_reference; eauto.\nconstructor.\nsplit.\neapply deref_loc_copy; eauto.\nconstructor.\nmydestr.\ndestruct ty; mydestr.\nInvBooleans.\nsubst i.\ndestruct v0; mydestr.\nsplit.\neapply deref_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) : match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk m b ofs\n    else do v0 <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v0)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs Full t v /\\ possible_trace w t w'.","conclusion":"match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk m b ofs\n    else do v0 <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v0)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs Full t v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val)","proofString":"destruct (access_mode ty) eqn:?; mydestr.\nintros.\nexploit do_volatile_load_sound; eauto.\nintuition.\neapply deref_loc_volatile; eauto.\nsplit.\neapply deref_loc_value; eauto.\nconstructor.\nsplit.\neapply deref_loc_reference; eauto.\nconstructor.\nsplit.\neapply deref_loc_copy; eauto.\nconstructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) : do_volatile_load w m0 m b ofs = Some (w', t, v) ->\nderef_loc ge ty m b ofs Full t v /\\ possible_trace w t w'.","conclusion":"do_volatile_load w m0 m b ofs = Some (w', t, v) ->\nderef_loc ge ty m b ofs Full t v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true)","proofString":"intros.\nexploit do_volatile_load_sound; eauto.\nintuition.\neapply deref_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_load w m0 m b ofs = Some (w', t, v)) : deref_loc ge ty m b ofs Full t v /\\ possible_trace w t w'.","conclusion":"deref_loc ge ty m b ofs Full t v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_load w m0 m b ofs = Some (w', t, v))","proofString":"exploit do_volatile_load_sound; eauto.\nintuition.\neapply deref_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_load w m0 m b ofs = Some (w', t, v)) : volatile_load ge m0 m b ofs t v /\\ possible_trace w t w' ->\nderef_loc ge ty m b ofs Full t v /\\ possible_trace w t w'.","conclusion":"volatile_load ge m0 m b ofs t v /\\ possible_trace w t w' ->\nderef_loc ge ty m b ofs Full t v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_load w m0 m b ofs = Some (w', t, v))","proofString":"intuition.\neapply deref_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_load w m0 m b ofs = Some (w', t, v)) (H1 : volatile_load ge m0 m b ofs t v) (H2 : possible_trace w t w') : deref_loc ge ty m b ofs Full t v.","conclusion":"deref_loc ge ty m b ofs Full t v","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_load w m0 m b ofs = Some (w', t, v)) (H1 : volatile_load ge m0 m b ofs t v) (H2 : possible_trace w t w')","proofString":"eapply deref_loc_volatile; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.loadv m0 m (Vptr b ofs) = Some v) : deref_loc ge ty m b ofs Full E0 v /\\ possible_trace w' E0 w'.","conclusion":"deref_loc ge ty m b ofs Full E0 v /\\ possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.loadv m0 m (Vptr b ofs) = Some v)","proofString":"split.\neapply deref_loc_value; eauto.\nconstructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.loadv m0 m (Vptr b ofs) = Some v) : deref_loc ge ty m b ofs Full E0 v.","conclusion":"deref_loc ge ty m b ofs Full E0 v","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.loadv m0 m (Vptr b ofs) = Some v)","proofString":"eapply deref_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.loadv m0 m (Vptr b ofs) = Some v) : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.loadv m0 m (Vptr b ofs) = Some v)","proofString":"constructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_reference) : deref_loc ge ty m b ofs Full E0 (Vptr b ofs) /\\ possible_trace w' E0 w'.","conclusion":"deref_loc ge ty m b ofs Full E0 (Vptr b ofs) /\\ possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_reference)","proofString":"split.\neapply deref_loc_reference; eauto.\nconstructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_reference) : deref_loc ge ty m b ofs Full E0 (Vptr b ofs).","conclusion":"deref_loc ge ty m b ofs Full E0 (Vptr b ofs)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_reference)","proofString":"eapply deref_loc_reference; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_reference) : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_reference)","proofString":"constructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_copy) : deref_loc ge ty m b ofs Full E0 (Vptr b ofs) /\\ possible_trace w' E0 w'.","conclusion":"deref_loc ge ty m b ofs Full E0 (Vptr b ofs) /\\ possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_copy)","proofString":"split.\neapply deref_loc_copy; eauto.\nconstructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_copy) : deref_loc ge ty m b ofs Full E0 (Vptr b ofs).","conclusion":"deref_loc ge ty m b ofs Full E0 (Vptr b ofs)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_copy)","proofString":"eapply deref_loc_copy; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_copy) : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (Heqm0 : access_mode ty = By_copy)","proofString":"constructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v : val) : match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs (Bits sz sg pos width) t v /\\ possible_trace w t w'.","conclusion":"match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs (Bits sz sg pos width) t v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v : val)","proofString":"mydestr.\ndestruct ty; mydestr.\nInvBooleans.\nsubst i.\ndestruct v0; mydestr.\nsplit.\neapply deref_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v : val) : match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs (Bits sz sg pos width) t v /\\ possible_trace w t w'.","conclusion":"match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge ty m b ofs (Bits sz sg pos width) t v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v : val)","proofString":"destruct ty; mydestr.\nInvBooleans.\nsubst i.\ndestruct v0; mydestr.\nsplit.\neapply deref_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v : val) (Heqb0 : intsize_eq i sz &&\nsignedness_eq s (if zlt width (bitsize_intsize sz) then Signed else sg) &&\nzle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\nzle (pos + width) (bitsize_carrier sz) = true) (v0 : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v0) : match v0 with\n| Vint c => Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) t v /\\\npossible_trace w t w'.","conclusion":"match v0 with\n| Vint c => Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) t v /\\\npossible_trace w t w'","hypotheses":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v : val) (Heqb0 : intsize_eq i sz &&\nsignedness_eq s (if zlt width (bitsize_intsize sz) then Signed else sg) &&\nzle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\nzle (pos + width) (bitsize_carrier sz) = true) (v0 : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v0)","proofString":"InvBooleans.\nsubst i.\ndestruct v0; mydestr.\nsplit.\neapply deref_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v v0 : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v0) (H1 : s = (if zlt width (bitsize_intsize sz) then Signed else sg)) (H : i = sz) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : match v0 with\n| Vint c => Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) t v /\\\npossible_trace w t w'.","conclusion":"match v0 with\n| Vint c => Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) t v /\\\npossible_trace w t w'","hypotheses":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v v0 : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v0) (H1 : s = (if zlt width (bitsize_intsize sz) then Signed else sg)) (H : i = sz) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"subst i.\ndestruct v0; mydestr.\nsplit.\neapply deref_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v v0 : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v0) (H1 : s = (if zlt width (bitsize_intsize sz) then Signed else sg)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : match v0 with\n| Vint c => Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge (Tint sz s a) m b ofs (Bits sz sg pos width) t v /\\\npossible_trace w t w'.","conclusion":"match v0 with\n| Vint c => Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n| _ => None\nend = Some (w', t, v) ->\nderef_loc ge (Tint sz s a) m b ofs (Bits sz sg pos width) t v /\\\npossible_trace w t w'","hypotheses":"(w : world) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (t : trace) (v v0 : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v0) (H1 : s = (if zlt width (bitsize_intsize sz) then Signed else sg)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"destruct v0; mydestr.\nsplit.\neapply deref_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : deref_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) E0 (Vint (bitfield_extract sz sg pos width i)) /\\\npossible_trace w' E0 w'.","conclusion":"deref_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) E0 (Vint (bitfield_extract sz sg pos width i)) /\\\npossible_trace w' E0 w'","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"split.\neapply deref_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : deref_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) E0 (Vint (bitfield_extract sz sg pos width i)).","conclusion":"deref_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) E0 (Vint (bitfield_extract sz sg pos width i))","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"eapply deref_loc_bitfield; eauto.\neconstructor; eauto."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : load_bitfield\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) sz sg\n  pos width m (Vptr b ofs) (Vint (bitfield_extract sz sg pos width i)).","conclusion":"load_bitfield\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) sz sg\n  pos width m (Vptr b ofs) (Vint (bitfield_extract sz sg pos width i))","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"econstructor; eauto."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (w' : world) (i : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i)) (H4 : 0 <= pos) (H3 : 0 < width) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"constructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (w' : world) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w') : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_load w chunk m b ofs\n        else do v0 <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v0)\n    | By_nothing => None\n    | _ => Some (w, E0, Vptr b ofs)\n    end\n| Bits sz sg pos width =>\n    match ty with\n    | Tint sz1 sg1 _ =>\n        check intsize_eq sz1 sz &&\n              signedness_eq sg1\n                (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n              zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n              zle (pos + width) (bitsize_carrier sz);\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, v).","conclusion":"match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_load w chunk m b ofs\n        else do v0 <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v0)\n    | By_nothing => None\n    | _ => Some (w, E0, Vptr b ofs)\n    end\n| Bits sz sg pos width =>\n    match ty with\n    | Tint sz1 sg1 _ =>\n        check intsize_eq sz1 sz &&\n              signedness_eq sg1\n                (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n              zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n              zle (pos + width) (bitsize_carrier sz);\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, v)","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (w' : world) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w')","proofString":"inv H.\ninv H0.\nrewrite H1; rewrite H2; rewrite H3; auto.\nrewrite H1; rewrite H2.\napply do_volatile_load_complete; auto.\ninv H0.\nrewrite H1.\nauto.\ninv H0.\nrewrite H1.\nauto.\ninv H0.\ninv H1.\nunfold proj_sumbool; rewrite ! dec_eq_true, ! zle_true, ! zlt_true by lia.\ncbn.\ncbn in H4; rewrite H4.\nauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.loadv chunk m (Vptr b ofs) = Some v) : match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk0 m b ofs\n    else do v0 <- Mem.loadv chunk0 m (Vptr b ofs); Some (w, E0, v0)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', E0, v).","conclusion":"match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk0 m b ofs\n    else do v0 <- Mem.loadv chunk0 m (Vptr b ofs); Some (w, E0, v0)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', E0, v)","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"inv H0.\nrewrite H1; rewrite H2; rewrite H3; auto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.loadv chunk m (Vptr b ofs) = Some v) : match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_load w' chunk0 m b ofs\n    else do v0 <- Mem.loadv chunk0 m (Vptr b ofs); Some (w', E0, v0)\n| By_nothing => None\n| _ => Some (w', E0, Vptr b ofs)\nend = Some (w', E0, v).","conclusion":"match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_load w' chunk0 m b ofs\n    else do v0 <- Mem.loadv chunk0 m (Vptr b ofs); Some (w', E0, v0)\n| By_nothing => None\n| _ => Some (w', E0, Vptr b ofs)\nend = Some (w', E0, v)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"rewrite H1; rewrite H2; rewrite H3; auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_load ge chunk m b ofs t v) : match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk0 m b ofs\n    else do v0 <- Mem.loadv chunk0 m (Vptr b ofs); Some (w, E0, v0)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', t, v).","conclusion":"match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk0 m b ofs\n    else do v0 <- Mem.loadv chunk0 m (Vptr b ofs); Some (w, E0, v0)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', t, v)","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_load ge chunk m b ofs t v)","proofString":"rewrite H1; rewrite H2.\napply do_volatile_load_complete; auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_load ge chunk m b ofs t v) : do_volatile_load w chunk m b ofs = Some (w', t, v).","conclusion":"do_volatile_load w chunk m b ofs = Some (w', t, v)","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (v : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_load ge chunk m b ofs t v)","proofString":"apply do_volatile_load_complete; auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H0 : possible_trace w E0 w') (H1 : access_mode ty = By_reference) : match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs).","conclusion":"match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs)","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H0 : possible_trace w E0 w') (H1 : access_mode ty = By_reference)","proofString":"inv H0.\nrewrite H1.\nauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_reference) : match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w' chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w', E0, v)\n| By_nothing => None\n| _ => Some (w', E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs).","conclusion":"match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w' chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w', E0, v)\n| By_nothing => None\n| _ => Some (w', E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_reference)","proofString":"rewrite H1.\nauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_reference) : Some (w', E0, Vptr b ofs) = Some (w', E0, Vptr b ofs).","conclusion":"Some (w', E0, Vptr b ofs) = Some (w', E0, Vptr b ofs)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_reference)","proofString":"auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H0 : possible_trace w E0 w') (H1 : access_mode ty = By_copy) : match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs).","conclusion":"match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w, E0, v)\n| By_nothing => None\n| _ => Some (w, E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs)","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H0 : possible_trace w E0 w') (H1 : access_mode ty = By_copy)","proofString":"inv H0.\nrewrite H1.\nauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_copy) : match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w' chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w', E0, v)\n| By_nothing => None\n| _ => Some (w', E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs).","conclusion":"match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_load w' chunk m b ofs\n    else do v <- Mem.loadv chunk m (Vptr b ofs); Some (w', E0, v)\n| By_nothing => None\n| _ => Some (w', E0, Vptr b ofs)\nend = Some (w', E0, Vptr b ofs)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_copy)","proofString":"rewrite H1.\nauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_copy) : Some (w', E0, Vptr b ofs) = Some (w', E0, Vptr b ofs).","conclusion":"Some (w', E0, Vptr b ofs) = Some (w', E0, Vptr b ofs)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (H1 : access_mode ty = By_copy)","proofString":"auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (sz : intsize) (sg : signedness) (pos width : Z) (H1 : load_bitfield ty sz sg pos width m (Vptr b ofs) v) : match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, v).","conclusion":"match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w, E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, v)","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (H0 : possible_trace w E0 w') (sz : intsize) (sg : signedness) (pos width : Z) (H1 : load_bitfield ty sz sg pos width m (Vptr b ofs) v)","proofString":"inv H0.\ninv H1.\nunfold proj_sumbool; rewrite ! dec_eq_true, ! zle_true, ! zlt_true by lia.\ncbn.\ncbn in H4; rewrite H4.\nauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (sz : intsize) (sg : signedness) (pos width : Z) (H1 : load_bitfield ty sz sg pos width m (Vptr b ofs) v) : match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w', E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, v).","conclusion":"match ty with\n| Tint sz1 sg1 _ =>\n    check intsize_eq sz1 sz &&\n          signedness_eq sg1\n            (if zlt width (bitsize_intsize sz) then Signed else sg) &&\n          zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        Some (w', E0, Vint (bitfield_extract sz sg pos width c))\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, v)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (v : val) (sz : intsize) (sg : signedness) (pos width : Z) (H1 : load_bitfield ty sz sg pos width m (Vptr b ofs) v)","proofString":"inv H1.\nunfold proj_sumbool; rewrite ! dec_eq_true, ! zle_true, ! zlt_true by lia.\ncbn.\ncbn in H4; rewrite H4.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : (check intsize_eq sz sz &&\n       signedness_eq (if zlt width (bitsize_intsize sz) then Signed else sg)\n         (if zlt width (bitsize_intsize sz) then Signed else sg) && \n       zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     Some (w', E0, Vint (bitfield_extract sz sg pos width c0))\n | _ => None\n end) = Some (w', E0, Vint (bitfield_extract sz sg pos width c)).","conclusion":"(check intsize_eq sz sz &&\n       signedness_eq (if zlt width (bitsize_intsize sz) then Signed else sg)\n         (if zlt width (bitsize_intsize sz) then Signed else sg) && \n       zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     Some (w', E0, Vint (bitfield_extract sz sg pos width c0))\n | _ => None\n end) = Some (w', E0, Vint (bitfield_extract sz sg pos width c))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"unfold proj_sumbool; rewrite ! dec_eq_true, ! zle_true, ! zlt_true by lia.\ncbn.\ncbn in H4; rewrite H4.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : (check true && true && true && true && true && true;\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     Some (w', E0, Vint (bitfield_extract sz sg pos width c0))\n | _ => None\n end) = Some (w', E0, Vint (bitfield_extract sz sg pos width c)).","conclusion":"(check true && true && true && true && true && true;\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     Some (w', E0, Vint (bitfield_extract sz sg pos width c0))\n | _ => None\n end) = Some (w', E0, Vint (bitfield_extract sz sg pos width c))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"cbn.\ncbn in H4; rewrite H4.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : match Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) with\n| Some (Vint c0) => Some (w', E0, Vint (bitfield_extract sz sg pos width c0))\n| _ => None\nend = Some (w', E0, Vint (bitfield_extract sz sg pos width c)).","conclusion":"match Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) with\n| Some (Vint c0) => Some (w', E0, Vint (bitfield_extract sz sg pos width c0))\n| _ => None\nend = Some (w', E0, Vint (bitfield_extract sz sg pos width c))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"cbn in H4; rewrite H4.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) = Some (Vint c)) : Some (w', E0, Vint (bitfield_extract sz sg pos width c)) =\nSome (w', E0, Vint (bitfield_extract sz sg pos width c)).","conclusion":"Some (w', E0, Vint (bitfield_extract sz sg pos width c)) =\nSome (w', E0, Vint (bitfield_extract sz sg pos width c))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) = Some (Vint c))","proofString":"auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_store w chunk m b ofs v\n        else\n         do m'0 <- Mem.storev chunk m (Vptr b ofs) v; Some (w, E0, m'0, v)\n    | By_copy =>\n        match v with\n        | Vptr b' ofs' =>\n            check check_assign_copy ty b ofs b' ofs';\n            do bytes <-\n            Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n            do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n            Some (w, E0, m'0, v)\n        | _ => None\n        end\n    | _ => None\n    end\n| Bits sz sg pos width =>\n    check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match ty with\n    | Tint sz1 sg1 _ =>\n        match v with\n        | Vint n =>\n            match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n            | Some (Vint c) =>\n                check intsize_eq sz1 sz &&\n                      signedness_eq sg1\n                        (if zlt width (bitsize_intsize sz)\n                         then Signed\n                         else sg);\n                do m'0 <-\n                Mem.storev (chunk_for_carrier sz) m \n                  (Vptr b ofs)\n                  (Vint\n                     (Int.bitfield_insert (first_bit sz pos width) width c n));\n                Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs bf v t m' v' /\\ possible_trace w t w'.","conclusion":"match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_store w chunk m b ofs v\n        else\n         do m'0 <- Mem.storev chunk m (Vptr b ofs) v; Some (w, E0, m'0, v)\n    | By_copy =>\n        match v with\n        | Vptr b' ofs' =>\n            check check_assign_copy ty b ofs b' ofs';\n            do bytes <-\n            Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n            do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n            Some (w, E0, m'0, v)\n        | _ => None\n        end\n    | _ => None\n    end\n| Bits sz sg pos width =>\n    check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match ty with\n    | Tint sz1 sg1 _ =>\n        match v with\n        | Vint n =>\n            match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n            | Some (Vint c) =>\n                check intsize_eq sz1 sz &&\n                      signedness_eq sg1\n                        (if zlt width (bitsize_intsize sz)\n                         then Signed\n                         else sg);\n                do m'0 <-\n                Mem.storev (chunk_for_carrier sz) m \n                  (Vptr b ofs)\n                  (Vint\n                     (Int.bitfield_insert (first_bit sz pos width) width c n));\n                Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs bf v t m' v' /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val)","proofString":"destruct bf.\ndestruct (access_mode ty) eqn:?; mydestr.\nintros.\nexploit do_volatile_store_sound; eauto.\nintros (P & Q & R).\nsubst v'.\nintuition.\neapply assign_loc_volatile; eauto.\nsplit.\neapply assign_loc_value; eauto.\nconstructor.\ndestruct v; mydestr.\ndestruct a as [P [Q R]].\nsplit.\neapply assign_loc_copy; eauto.\nconstructor.\nmydestr.\nInvBooleans.\ndestruct ty; mydestr.\ndestruct v; mydestr.\ndestruct v; mydestr.\nInvBooleans.\nsubst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) : match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk m b ofs v\n    else do m'0 <- Mem.storev chunk m (Vptr b ofs) v; Some (w, E0, m'0, v)\n| By_copy =>\n    match v with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w, E0, m'0, v)\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'.","conclusion":"match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk m b ofs v\n    else do m'0 <- Mem.storev chunk m (Vptr b ofs) v; Some (w, E0, m'0, v)\n| By_copy =>\n    match v with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w, E0, m'0, v)\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val)","proofString":"destruct (access_mode ty) eqn:?; mydestr.\nintros.\nexploit do_volatile_store_sound; eauto.\nintros (P & Q & R).\nsubst v'.\nintuition.\neapply assign_loc_volatile; eauto.\nsplit.\neapply assign_loc_value; eauto.\nconstructor.\ndestruct v; mydestr.\ndestruct a as [P [Q R]].\nsplit.\neapply assign_loc_copy; eauto.\nconstructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) : do_volatile_store w m0 m b ofs v = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'.","conclusion":"do_volatile_store w m0 m b ofs v = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true)","proofString":"intros.\nexploit do_volatile_store_sound; eauto.\nintros (P & Q & R).\nsubst v'.\nintuition.\neapply assign_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v')) : assign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'.","conclusion":"assign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v'))","proofString":"exploit do_volatile_store_sound; eauto.\nintros (P & Q & R).\nsubst v'.\nintuition.\neapply assign_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v')) : volatile_store ge m0 m b ofs v t m' /\\ possible_trace w t w' /\\ v' = v ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'.","conclusion":"volatile_store ge m0 m b ofs v t m' /\\ possible_trace w t w' /\\ v' = v ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v'))","proofString":"intros (P & Q & R).\nsubst v'.\nintuition.\neapply assign_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v')) (P : volatile_store ge m0 m b ofs v t m') (Q : possible_trace w t w') (R : v' = v) : assign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'.","conclusion":"assign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v')) (P : volatile_store ge m0 m b ofs v t m') (Q : possible_trace w t w') (R : v' = v)","proofString":"subst v'.\nintuition.\neapply assign_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v)) (P : volatile_store ge m0 m b ofs v t m') (Q : possible_trace w t w') : assign_loc ge ty m b ofs Full v t m' v /\\ possible_trace w t w'.","conclusion":"assign_loc ge ty m b ofs Full v t m' v /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v)) (P : volatile_store ge m0 m b ofs v t m') (Q : possible_trace w t w')","proofString":"intuition.\neapply assign_loc_volatile; eauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v)) (P : volatile_store ge m0 m b ofs v t m') (Q : possible_trace w t w') : assign_loc ge ty m b ofs Full v t m' v.","conclusion":"assign_loc ge ty m b ofs Full v t m' v","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = true) (H : do_volatile_store w m0 m b ofs v = Some (w', t, m', v)) (P : volatile_store ge m0 m b ofs v t m') (Q : possible_trace w t w')","proofString":"eapply assign_loc_volatile; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.storev m0 m (Vptr b ofs) v' = Some m') : assign_loc ge ty m b ofs Full v' E0 m' v' /\\ possible_trace w' E0 w'.","conclusion":"assign_loc ge ty m b ofs Full v' E0 m' v' /\\ possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.storev m0 m (Vptr b ofs) v' = Some m')","proofString":"split.\neapply assign_loc_value; eauto.\nconstructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.storev m0 m (Vptr b ofs) v' = Some m') : assign_loc ge ty m b ofs Full v' E0 m' v'.","conclusion":"assign_loc ge ty m b ofs Full v' E0 m' v'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.storev m0 m (Vptr b ofs) v' = Some m')","proofString":"eapply assign_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.storev m0 m (Vptr b ofs) v' = Some m') : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (m0 : memory_chunk) (Heqm0 : access_mode ty = By_value m0) (Heqb0 : type_is_volatile ty = false) (Heqo : Mem.storev m0 m (Vptr b ofs) v' = Some m')","proofString":"constructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (Heqm0 : access_mode ty = By_copy) : match v with\n| Vptr b' ofs' =>\n    check check_assign_copy ty b ofs b' ofs';\n    do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n    do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n    Some (w, E0, m'0, v)\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'.","conclusion":"match v with\n| Vptr b' ofs' =>\n    check check_assign_copy ty b ofs b' ofs';\n    do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n    do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n    Some (w, E0, m'0, v)\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs Full v t m' v' /\\ possible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (Heqm0 : access_mode ty = By_copy)","proofString":"destruct v; mydestr.\ndestruct a as [P [Q R]].\nsplit.\neapply assign_loc_copy; eauto.\nconstructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (a : assign_copy_ok ty b ofs b0 i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m') : assign_loc ge ty m b ofs Full (Vptr b0 i) E0 m' (Vptr b0 i) /\\\npossible_trace w' E0 w'.","conclusion":"assign_loc ge ty m b ofs Full (Vptr b0 i) E0 m' (Vptr b0 i) /\\\npossible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (a : assign_copy_ok ty b ofs b0 i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m')","proofString":"destruct a as [P [Q R]].\nsplit.\neapply assign_loc_copy; eauto.\nconstructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (P : (alignof_blockcopy ge ty | Ptrofs.unsigned i)) (Q : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (R : b0 <> b \\/\nPtrofs.unsigned i = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned i + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m') : assign_loc ge ty m b ofs Full (Vptr b0 i) E0 m' (Vptr b0 i) /\\\npossible_trace w' E0 w'.","conclusion":"assign_loc ge ty m b ofs Full (Vptr b0 i) E0 m' (Vptr b0 i) /\\\npossible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (P : (alignof_blockcopy ge ty | Ptrofs.unsigned i)) (Q : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (R : b0 <> b \\/\nPtrofs.unsigned i = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned i + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m')","proofString":"split.\neapply assign_loc_copy; eauto.\nconstructor."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (P : (alignof_blockcopy ge ty | Ptrofs.unsigned i)) (Q : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (R : b0 <> b \\/\nPtrofs.unsigned i = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned i + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m') : assign_loc ge ty m b ofs Full (Vptr b0 i) E0 m' (Vptr b0 i).","conclusion":"assign_loc ge ty m b ofs Full (Vptr b0 i) E0 m' (Vptr b0 i)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (P : (alignof_blockcopy ge ty | Ptrofs.unsigned i)) (Q : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (R : b0 <> b \\/\nPtrofs.unsigned i = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned i + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m')","proofString":"eapply assign_loc_copy; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (P : (alignof_blockcopy ge ty | Ptrofs.unsigned i)) (Q : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (R : b0 <> b \\/\nPtrofs.unsigned i = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned i + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m') : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (w' : world) (m' : mem) (Heqm0 : access_mode ty = By_copy) (P : (alignof_blockcopy ge ty | Ptrofs.unsigned i)) (Q : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (R : b0 <> b \\/\nPtrofs.unsigned i = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned i + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned i) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i) (sizeof ge ty) = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned ofs) l = Some m')","proofString":"constructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) : (check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match ty with\n | Tint sz1 sg1 _ =>\n     match v with\n     | Vint n =>\n         match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n         | Some (Vint c) =>\n             check intsize_eq sz1 sz &&\n                   signedness_eq sg1\n                     (if zlt width (bitsize_intsize sz) then Signed else sg);\n             do m'0 <-\n             Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n               (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n             Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n         | _ => None\n         end\n     | _ => None\n     end\n | _ => None\n end) = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'.","conclusion":"(check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match ty with\n | Tint sz1 sg1 _ =>\n     match v with\n     | Vint n =>\n         match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n         | Some (Vint c) =>\n             check intsize_eq sz1 sz &&\n                   signedness_eq sg1\n                     (if zlt width (bitsize_intsize sz) then Signed else sg);\n             do m'0 <-\n             Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n               (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n             Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n         | _ => None\n         end\n     | _ => None\n     end\n | _ => None\n end) = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val)","proofString":"mydestr.\nInvBooleans.\ndestruct ty; mydestr.\ndestruct v; mydestr.\ndestruct v; mydestr.\nInvBooleans.\nsubst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (Heqb0 : zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\nzle (pos + width) (bitsize_carrier sz) = true) : match ty with\n| Tint sz1 sg1 _ =>\n    match v with\n    | Vint n =>\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            check intsize_eq sz1 sz &&\n                  signedness_eq sg1\n                    (if zlt width (bitsize_intsize sz) then Signed else sg);\n            do m'0 <-\n            Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n              (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n            Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'.","conclusion":"match ty with\n| Tint sz1 sg1 _ =>\n    match v with\n    | Vint n =>\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            check intsize_eq sz1 sz &&\n                  signedness_eq sg1\n                    (if zlt width (bitsize_intsize sz) then Signed else sg);\n            do m'0 <-\n            Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n              (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n            Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (Heqb0 : zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\nzle (pos + width) (bitsize_carrier sz) = true)","proofString":"InvBooleans.\ndestruct ty; mydestr.\ndestruct v; mydestr.\ndestruct v; mydestr.\nInvBooleans.\nsubst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : match ty with\n| Tint sz1 sg1 _ =>\n    match v with\n    | Vint n =>\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            check intsize_eq sz1 sz &&\n                  signedness_eq sg1\n                    (if zlt width (bitsize_intsize sz) then Signed else sg);\n            do m'0 <-\n            Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n              (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n            Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'.","conclusion":"match ty with\n| Tint sz1 sg1 _ =>\n    match v with\n    | Vint n =>\n        match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n        | Some (Vint c) =>\n            check intsize_eq sz1 sz &&\n                  signedness_eq sg1\n                    (if zlt width (bitsize_intsize sz) then Signed else sg);\n            do m'0 <-\n            Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n              (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n            Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge ty m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"destruct ty; mydestr.\ndestruct v; mydestr.\ndestruct v; mydestr.\nInvBooleans.\nsubst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) : match v with\n| Vint n =>\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        check intsize_eq i sz &&\n              signedness_eq s\n                (if zlt width (bitsize_intsize sz) then Signed else sg);\n        do m'0 <-\n        Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n          (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n        Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'.","conclusion":"match v with\n| Vint n =>\n    match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n    | Some (Vint c) =>\n        check intsize_eq i sz &&\n              signedness_eq s\n                (if zlt width (bitsize_intsize sz) then Signed else sg);\n        do m'0 <-\n        Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n          (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n        Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) v t m' v' /\\\npossible_trace w t w'","hypotheses":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz)","proofString":"destruct v; mydestr.\ndestruct v; mydestr.\nInvBooleans.\nsubst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (t : trace) (m' : mem) (v' : val) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (v : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v) : match v with\n| Vint c =>\n    check intsize_eq i sz &&\n          signedness_eq s\n            (if zlt width (bitsize_intsize sz) then Signed else sg);\n    do m'0 <-\n    Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n      (Vint (Int.bitfield_insert (first_bit sz pos width) width c i0));\n    Some (w, E0, m'0, Vint (bitfield_normalize sz sg width i0))\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) (Vint i0) t m' v' /\\\npossible_trace w t w'.","conclusion":"match v with\n| Vint c =>\n    check intsize_eq i sz &&\n          signedness_eq s\n            (if zlt width (bitsize_intsize sz) then Signed else sg);\n    do m'0 <-\n    Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n      (Vint (Int.bitfield_insert (first_bit sz pos width) width c i0));\n    Some (w, E0, m'0, Vint (bitfield_normalize sz sg width i0))\n| _ => None\nend = Some (w', t, m', v') ->\nassign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) (Vint i0) t m' v' /\\\npossible_trace w t w'","hypotheses":"(w : world) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (t : trace) (m' : mem) (v' : val) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (v : val) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some v)","proofString":"destruct v; mydestr.\nInvBooleans.\nsubst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqb0 : intsize_eq i sz &&\nsignedness_eq s (if zlt width (bitsize_intsize sz) then Signed else sg) =\ntrue) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m') : assign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) \n  (Vint i0) E0 m' (Vint (bitfield_normalize sz sg width i0)) /\\\npossible_trace w' E0 w'.","conclusion":"assign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) \n  (Vint i0) E0 m' (Vint (bitfield_normalize sz sg width i0)) /\\\npossible_trace w' E0 w'","hypotheses":"(i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqb0 : intsize_eq i sz &&\nsignedness_eq s (if zlt width (bitsize_intsize sz) then Signed else sg) =\ntrue) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m')","proofString":"InvBooleans.\nsubst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m') (H4 : s = (if zlt width (bitsize_intsize sz) then Signed else sg)) (H3 : i = sz) : assign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) \n  (Vint i0) E0 m' (Vint (bitfield_normalize sz sg width i0)) /\\\npossible_trace w' E0 w'.","conclusion":"assign_loc ge (Tint i s a) m b ofs (Bits sz sg pos width) \n  (Vint i0) E0 m' (Vint (bitfield_normalize sz sg width i0)) /\\\npossible_trace w' E0 w'","hypotheses":"(i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m') (H4 : s = (if zlt width (bitsize_intsize sz) then Signed else sg)) (H3 : i = sz)","proofString":"subst s i.\nsplit.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m') : assign_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) (Vint i0) E0 m'\n  (Vint (bitfield_normalize sz sg width i0)) /\\ possible_trace w' E0 w'.","conclusion":"assign_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) (Vint i0) E0 m'\n  (Vint (bitfield_normalize sz sg width i0)) /\\ possible_trace w' E0 w'","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m')","proofString":"split.\neapply assign_loc_bitfield; eauto.\neconstructor; eauto.\nconstructor."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m') : assign_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) (Vint i0) E0 m'\n  (Vint (bitfield_normalize sz sg width i0)).","conclusion":"assign_loc ge\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) m b ofs\n  (Bits sz sg pos width) (Vint i0) E0 m'\n  (Vint (bitfield_normalize sz sg width i0))","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m')","proofString":"eapply assign_loc_bitfield; eauto.\neconstructor; eauto."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m') : store_bitfield\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) sz sg\n  pos width m (Vptr b ofs) (Vint i0) m'\n  (Vint (bitfield_normalize sz sg width i0)).","conclusion":"store_bitfield\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) a) sz sg\n  pos width m (Vptr b ofs) (Vint i0) m'\n  (Vint (bitfield_normalize sz sg width i0))","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m')","proofString":"econstructor; eauto."},{"statement":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m') : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(a : attr) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (i0 : int) (w' : world) (m' : mem) (H1 : 0 < width) (H : 0 <= pos) (H2 : width <= bitsize_intsize sz) (H0 : pos + width <= bitsize_carrier sz) (i1 : int) (Heqo : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint i1)) (Heqo0 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width i1 i0)) = \nSome m')","proofString":"constructor."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (H : assign_loc ge ty m b ofs bf v t m' v') (H0 : possible_trace w t w') : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_store w chunk m b ofs v\n        else\n         do m'0 <- Mem.storev chunk m (Vptr b ofs) v; Some (w, E0, m'0, v)\n    | By_copy =>\n        match v with\n        | Vptr b' ofs' =>\n            check check_assign_copy ty b ofs b' ofs';\n            do bytes <-\n            Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n            do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n            Some (w, E0, m'0, v)\n        | _ => None\n        end\n    | _ => None\n    end\n| Bits sz sg pos width =>\n    check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match ty with\n    | Tint sz1 sg1 _ =>\n        match v with\n        | Vint n =>\n            match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n            | Some (Vint c) =>\n                check intsize_eq sz1 sz &&\n                      signedness_eq sg1\n                        (if zlt width (bitsize_intsize sz)\n                         then Signed\n                         else sg);\n                do m'0 <-\n                Mem.storev (chunk_for_carrier sz) m \n                  (Vptr b ofs)\n                  (Vint\n                     (Int.bitfield_insert (first_bit sz pos width) width c n));\n                Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, m', v').","conclusion":"match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk =>\n        if type_is_volatile ty\n        then do_volatile_store w chunk m b ofs v\n        else\n         do m'0 <- Mem.storev chunk m (Vptr b ofs) v; Some (w, E0, m'0, v)\n    | By_copy =>\n        match v with\n        | Vptr b' ofs' =>\n            check check_assign_copy ty b ofs b' ofs';\n            do bytes <-\n            Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n            do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n            Some (w, E0, m'0, v)\n        | _ => None\n        end\n    | _ => None\n    end\n| Bits sz sg pos width =>\n    check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n          zle (pos + width) (bitsize_carrier sz);\n    match ty with\n    | Tint sz1 sg1 _ =>\n        match v with\n        | Vint n =>\n            match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n            | Some (Vint c) =>\n                check intsize_eq sz1 sz &&\n                      signedness_eq sg1\n                        (if zlt width (bitsize_intsize sz)\n                         then Signed\n                         else sg);\n                do m'0 <-\n                Mem.storev (chunk_for_carrier sz) m \n                  (Vptr b ofs)\n                  (Vint\n                     (Int.bitfield_insert (first_bit sz pos width) width c n));\n                Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (w', t, m', v')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (w' : world) (t : trace) (m' : mem) (v' : val) (H : assign_loc ge ty m b ofs bf v t m' v') (H0 : possible_trace w t w')","proofString":"inv H.\ninv H0.\nrewrite H1; rewrite H2; rewrite H3; auto.\nrewrite H1; rewrite H2.\napply do_volatile_store_complete; auto.\nrewrite H1.\ndestruct (check_assign_copy ty b ofs b' ofs').\ninv H0.\nrewrite H5; rewrite H6; auto.\nelim n.\nred; tauto.\ninv H0.\ninv H1.\nunfold proj_sumbool; rewrite ! zle_true, ! zlt_true by lia.\ncbn.\nrewrite ! dec_eq_true.\ncbn in H4; rewrite H4.\ncbn in H5; rewrite H5.\nauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (H0 : possible_trace w E0 w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.storev chunk m (Vptr b ofs) v' = Some m') : match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk0 m b ofs v'\n    else do m'0 <- Mem.storev chunk0 m (Vptr b ofs) v'; Some (w, E0, m'0, v')\n| By_copy =>\n    match v' with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w, E0, m'0, v')\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, m', v').","conclusion":"match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk0 m b ofs v'\n    else do m'0 <- Mem.storev chunk0 m (Vptr b ofs) v'; Some (w, E0, m'0, v')\n| By_copy =>\n    match v' with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w, E0, m'0, v')\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, m', v')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (H0 : possible_trace w E0 w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.storev chunk m (Vptr b ofs) v' = Some m')","proofString":"inv H0.\nrewrite H1; rewrite H2; rewrite H3; auto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.storev chunk m (Vptr b ofs) v' = Some m') : match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_store w' chunk0 m b ofs v'\n    else\n     do m'0 <- Mem.storev chunk0 m (Vptr b ofs) v'; Some (w', E0, m'0, v')\n| By_copy =>\n    match v' with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w', E0, m'0, v')\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, m', v').","conclusion":"match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_store w' chunk0 m b ofs v'\n    else\n     do m'0 <- Mem.storev chunk0 m (Vptr b ofs) v'; Some (w', E0, m'0, v')\n| By_copy =>\n    match v' with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w', E0, m'0, v')\n    | _ => None\n    end\n| _ => None\nend = Some (w', E0, m', v')","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (v' : val) (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = false) (H3 : Mem.storev chunk m (Vptr b ofs) v' = Some m')","proofString":"rewrite H1; rewrite H2; rewrite H3; auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (m' : mem) (v' : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_store ge chunk m b ofs v' t m') : match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk0 m b ofs v'\n    else do m'0 <- Mem.storev chunk0 m (Vptr b ofs) v'; Some (w, E0, m'0, v')\n| By_copy =>\n    match v' with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w, E0, m'0, v')\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v').","conclusion":"match access_mode ty with\n| By_value chunk0 =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk0 m b ofs v'\n    else do m'0 <- Mem.storev chunk0 m (Vptr b ofs) v'; Some (w, E0, m'0, v')\n| By_copy =>\n    match v' with\n    | Vptr b' ofs' =>\n        check check_assign_copy ty b ofs b' ofs';\n        do bytes <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n        do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes;\n        Some (w, E0, m'0, v')\n    | _ => None\n    end\n| _ => None\nend = Some (w', t, m', v')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (m' : mem) (v' : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_store ge chunk m b ofs v' t m')","proofString":"rewrite H1; rewrite H2.\napply do_volatile_store_complete; auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (m' : mem) (v' : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_store ge chunk m b ofs v' t m') : do_volatile_store w chunk m b ofs v' = Some (w', t, m', v').","conclusion":"do_volatile_store w chunk m b ofs v' = Some (w', t, m', v')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (t : trace) (m' : mem) (v' : val) (H0 : possible_trace w t w') (chunk : memory_chunk) (H1 : access_mode ty = By_value chunk) (H2 : type_is_volatile ty = true) (H3 : volatile_store ge chunk m b ofs v' t m')","proofString":"apply do_volatile_store_complete; auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk m b ofs (Vptr b' ofs')\n    else\n     do m'0 <- Mem.storev chunk m (Vptr b ofs) (Vptr b' ofs');\n     Some (w, E0, m'0, Vptr b' ofs')\n| By_copy =>\n    check check_assign_copy ty b ofs b' ofs';\n    do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n    do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n    Some (w, E0, m'0, Vptr b' ofs')\n| _ => None\nend = Some (w', E0, m', Vptr b' ofs').","conclusion":"match access_mode ty with\n| By_value chunk =>\n    if type_is_volatile ty\n    then do_volatile_store w chunk m b ofs (Vptr b' ofs')\n    else\n     do m'0 <- Mem.storev chunk m (Vptr b ofs) (Vptr b' ofs');\n     Some (w, E0, m'0, Vptr b' ofs')\n| By_copy =>\n    check check_assign_copy ty b ofs b' ofs';\n    do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n    do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n    Some (w, E0, m'0, Vptr b' ofs')\n| _ => None\nend = Some (w', E0, m', Vptr b' ofs')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"rewrite H1.\ndestruct (check_assign_copy ty b ofs b' ofs').\ninv H0.\nrewrite H5; rewrite H6; auto.\nelim n.\nred; tauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : (check check_assign_copy ty b ofs b' ofs';\n do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n Some (w, E0, m'0, Vptr b' ofs')) = Some (w', E0, m', Vptr b' ofs').","conclusion":"(check check_assign_copy ty b ofs b' ofs';\n do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n Some (w, E0, m'0, Vptr b' ofs')) = Some (w', E0, m', Vptr b' ofs')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"destruct (check_assign_copy ty b ofs b' ofs').\ninv H0.\nrewrite H5; rewrite H6; auto.\nelim n.\nred; tauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (a : assign_copy_ok ty b ofs b' ofs') : (do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n Some (w, E0, m'0, Vptr b' ofs')) = Some (w', E0, m', Vptr b' ofs').","conclusion":"(do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n Some (w, E0, m'0, Vptr b' ofs')) = Some (w', E0, m', Vptr b' ofs')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (a : assign_copy_ok ty b ofs b' ofs')","proofString":"inv H0.\nrewrite H5; rewrite H6; auto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (a : assign_copy_ok ty b ofs b' ofs') : (do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n Some (w', E0, m'0, Vptr b' ofs')) = Some (w', E0, m', Vptr b' ofs').","conclusion":"(do bytes0 <- Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty);\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned ofs) bytes0;\n Some (w', E0, m'0, Vptr b' ofs')) = Some (w', E0, m', Vptr b' ofs')","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (a : assign_copy_ok ty b ofs b' ofs')","proofString":"rewrite H5; rewrite H6; auto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (n : ~ assign_copy_ok ty b ofs b' ofs') : None = Some (w', E0, m', Vptr b' ofs').","conclusion":"None = Some (w', E0, m', Vptr b' ofs')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (n : ~ assign_copy_ok ty b ofs b' ofs')","proofString":"elim n.\nred; tauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (n : ~ assign_copy_ok ty b ofs b' ofs') : assign_copy_ok ty b ofs b' ofs'.","conclusion":"assign_copy_ok ty b ofs b' ofs'","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (b' : block) (ofs' : ptrofs) (bytes : list memval) (H1 : access_mode ty = By_copy) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H4 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H5 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H6 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (n : ~ assign_copy_ok ty b ofs b' ofs')","proofString":"red; tauto."},{"statement":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (v' : val) (H0 : possible_trace w E0 w') (sz : intsize) (sg : signedness) (pos width : Z) (H1 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') : (check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match ty with\n | Tint sz1 sg1 _ =>\n     match v with\n     | Vint n =>\n         match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n         | Some (Vint c) =>\n             check intsize_eq sz1 sz &&\n                   signedness_eq sg1\n                     (if zlt width (bitsize_intsize sz) then Signed else sg);\n             do m'0 <-\n             Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n               (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n             Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n         | _ => None\n         end\n     | _ => None\n     end\n | _ => None\n end) = Some (w', E0, m', v').","conclusion":"(check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match ty with\n | Tint sz1 sg1 _ =>\n     match v with\n     | Vint n =>\n         match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n         | Some (Vint c) =>\n             check intsize_eq sz1 sz &&\n                   signedness_eq sg1\n                     (if zlt width (bitsize_intsize sz) then Signed else sg);\n             do m'0 <-\n             Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n               (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n             Some (w, E0, m'0, Vint (bitfield_normalize sz sg width n))\n         | _ => None\n         end\n     | _ => None\n     end\n | _ => None\n end) = Some (w', E0, m', v')","hypotheses":"(w : world) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (v' : val) (H0 : possible_trace w E0 w') (sz : intsize) (sg : signedness) (pos width : Z) (H1 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v')","proofString":"inv H0.\ninv H1.\nunfold proj_sumbool; rewrite ! zle_true, ! zlt_true by lia.\ncbn.\nrewrite ! dec_eq_true.\ncbn in H4; rewrite H4.\ncbn in H5; rewrite H5.\nauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (v' : val) (sz : intsize) (sg : signedness) (pos width : Z) (H1 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') : (check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match ty with\n | Tint sz1 sg1 _ =>\n     match v with\n     | Vint n =>\n         match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n         | Some (Vint c) =>\n             check intsize_eq sz1 sz &&\n                   signedness_eq sg1\n                     (if zlt width (bitsize_intsize sz) then Signed else sg);\n             do m'0 <-\n             Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n               (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n             Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n         | _ => None\n         end\n     | _ => None\n     end\n | _ => None\n end) = Some (w', E0, m', v').","conclusion":"(check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match ty with\n | Tint sz1 sg1 _ =>\n     match v with\n     | Vint n =>\n         match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n         | Some (Vint c) =>\n             check intsize_eq sz1 sz &&\n                   signedness_eq sg1\n                     (if zlt width (bitsize_intsize sz) then Signed else sg);\n             do m'0 <-\n             Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n               (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n             Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n         | _ => None\n         end\n     | _ => None\n     end\n | _ => None\n end) = Some (w', E0, m', v')","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (w' : world) (m' : mem) (v' : val) (sz : intsize) (sg : signedness) (pos width : Z) (H1 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v')","proofString":"inv H1.\nunfold proj_sumbool; rewrite ! zle_true, ! zlt_true by lia.\ncbn.\nrewrite ! dec_eq_true.\ncbn in H4; rewrite H4.\ncbn in H5; rewrite H5.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : (check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     check intsize_eq sz sz &&\n           signedness_eq\n             (if zlt width (bitsize_intsize sz) then Signed else sg)\n             (if zlt width (bitsize_intsize sz) then Signed else sg);\n     do m'0 <-\n     Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n       (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n     Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n | _ => None\n end) = Some (w', E0, m', Vint (bitfield_normalize sz sg width n)).","conclusion":"(check zle 0 pos && zlt 0 width && zle width (bitsize_intsize sz) &&\n       zle (pos + width) (bitsize_carrier sz);\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     check intsize_eq sz sz &&\n           signedness_eq\n             (if zlt width (bitsize_intsize sz) then Signed else sg)\n             (if zlt width (bitsize_intsize sz) then Signed else sg);\n     do m'0 <-\n     Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n       (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n     Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n | _ => None\n end) = Some (w', E0, m', Vint (bitfield_normalize sz sg width n))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"unfold proj_sumbool; rewrite ! zle_true, ! zlt_true by lia.\ncbn.\nrewrite ! dec_eq_true.\ncbn in H4; rewrite H4.\ncbn in H5; rewrite H5.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : (check true && true && true && true;\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     check (if intsize_eq sz sz then true else false) &&\n           (if\n             signedness_eq\n               (if zlt width (bitsize_intsize sz) then Signed else sg)\n               (if zlt width (bitsize_intsize sz) then Signed else sg)\n            then true\n            else false);\n     do m'0 <-\n     Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n       (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n     Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n | _ => None\n end) = Some (w', E0, m', Vint (bitfield_normalize sz sg width n)).","conclusion":"(check true && true && true && true;\n match Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) with\n | Some (Vint c0) =>\n     check (if intsize_eq sz sz then true else false) &&\n           (if\n             signedness_eq\n               (if zlt width (bitsize_intsize sz) then Signed else sg)\n               (if zlt width (bitsize_intsize sz) then Signed else sg)\n            then true\n            else false);\n     do m'0 <-\n     Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n       (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n     Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n | _ => None\n end) = Some (w', E0, m', Vint (bitfield_normalize sz sg width n))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"cbn.\nrewrite ! dec_eq_true.\ncbn in H4; rewrite H4.\ncbn in H5; rewrite H5.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : match Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) with\n| Some (Vint c0) =>\n    check (if intsize_eq sz sz then true else false) &&\n          (if\n            signedness_eq\n              (if zlt width (bitsize_intsize sz) then Signed else sg)\n              (if zlt width (bitsize_intsize sz) then Signed else sg)\n           then true\n           else false);\n    do m'0 <-\n    Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n      (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n    Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n| _ => None\nend = Some (w', E0, m', Vint (bitfield_normalize sz sg width n)).","conclusion":"match Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) with\n| Some (Vint c0) =>\n    check (if intsize_eq sz sz then true else false) &&\n          (if\n            signedness_eq\n              (if zlt width (bitsize_intsize sz) then Signed else sg)\n              (if zlt width (bitsize_intsize sz) then Signed else sg)\n           then true\n           else false);\n    do m'0 <-\n    Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n      (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n    Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n| _ => None\nend = Some (w', E0, m', Vint (bitfield_normalize sz sg width n))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"rewrite ! dec_eq_true.\ncbn in H4; rewrite H4.\ncbn in H5; rewrite H5.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : match Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) with\n| Some (Vint c0) =>\n    check true && true;\n    do m'0 <-\n    Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n      (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n    Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n| _ => None\nend = Some (w', E0, m', Vint (bitfield_normalize sz sg width n)).","conclusion":"match Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) with\n| Some (Vint c0) =>\n    check true && true;\n    do m'0 <-\n    Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n      (Vint (Int.bitfield_insert (first_bit sz pos width) width c0 n));\n    Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))\n| _ => None\nend = Some (w', E0, m', Vint (bitfield_normalize sz sg width n))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"cbn in H4; rewrite H4.\ncbn in H5; rewrite H5.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : (check true && true;\n do m'0 <-\n Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n   (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))) =\nSome (w', E0, m', Vint (bitfield_normalize sz sg width n)).","conclusion":"(check true && true;\n do m'0 <-\n Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n   (Vint (Int.bitfield_insert (first_bit sz pos width) width c n));\n Some (w', E0, m'0, Vint (bitfield_normalize sz sg width n))) =\nSome (w', E0, m', Vint (bitfield_normalize sz sg width n))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) = Some (Vint c)) (H5 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"cbn in H5; rewrite H5.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) = Some (Vint c)) (H5 : Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : (check true && true;\n Some (w', E0, m', Vint (bitfield_normalize sz sg width n))) =\nSome (w', E0, m', Vint (bitfield_normalize sz sg width n)).","conclusion":"(check true && true;\n Some (w', E0, m', Vint (bitfield_normalize sz sg width n))) =\nSome (w', E0, m', Vint (bitfield_normalize sz sg width n))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (w' : world) (m' : mem) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c n : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.load (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs) = Some (Vint c)) (H5 : Mem.store (chunk_for_carrier sz) m b (Ptrofs.unsigned ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"auto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz.","conclusion":"forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem)","proofString":"intros until sz; unfold Vptrofs; destruct v; simpl; destruct Archi.ptr64 eqn:SF;     intros EQ; inv EQ; f_equal; symmetry; eauto with ptrofs."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz)","proofString":"unfold do_builtin_or_external, builtin_or_external_sem; intros.\ndestruct (lookup_builtin_function name sg ) as [bf|].\ndestruct (builtin_function_sem bf vargs) as [vres1|] eqn:BF; inv H.\nsplit.\nconstructor; auto.\nconstructor.\neapply do_external_function_sound; eauto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (H : match lookup_builtin_function name sg with\n| Some bf => do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)\n| None => do_external_function name sg ge w vargs m\nend = Some (w', t, vres, m')) : match lookup_builtin_function name sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem name sg\nend ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"match lookup_builtin_function name sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem name sg\nend ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (H : match lookup_builtin_function name sg with\n| Some bf => do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)\n| None => do_external_function name sg ge w vargs m\nend = Some (w', t, vres, m'))","proofString":"destruct (lookup_builtin_function name sg ) as [bf|].\ndestruct (builtin_function_sem bf vargs) as [vres1|] eqn:BF; inv H.\nsplit.\nconstructor; auto.\nconstructor.\neapply do_external_function_sound; eauto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (H : (do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)) =\nSome (w', t, vres, m')) : known_builtin_sem bf ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"known_builtin_sem bf ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (H : (do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)) =\nSome (w', t, vres, m'))","proofString":"destruct (builtin_function_sem bf vargs) as [vres1|] eqn:BF; inv H.\nsplit.\nconstructor; auto.\nconstructor."},{"statement":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (BF : builtin_function_sem bf vargs = Some vres) : known_builtin_sem bf ge vargs m' E0 vres m' /\\ possible_trace w' E0 w'.","conclusion":"known_builtin_sem bf ge vargs m' E0 vres m' /\\ possible_trace w' E0 w'","hypotheses":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (BF : builtin_function_sem bf vargs = Some vres)","proofString":"split.\nconstructor; auto.\nconstructor."},{"statement":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (BF : builtin_function_sem bf vargs = Some vres) : known_builtin_sem bf ge vargs m' E0 vres m'.","conclusion":"known_builtin_sem bf ge vargs m' E0 vres m'","hypotheses":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (BF : builtin_function_sem bf vargs = Some vres)","proofString":"constructor; auto."},{"statement":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (BF : builtin_function_sem bf vargs = Some vres) : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (bf : builtin_function) (BF : builtin_function_sem bf vargs = Some vres)","proofString":"constructor."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (H : do_external_function name sg ge w vargs m = Some (w', t, vres, m')) : external_functions_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"external_functions_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (name : string) (sg : signature) (H : do_external_function name sg ge w vargs m = Some (w', t, vres, m'))","proofString":"eapply do_external_function_sound; eauto."},{"statement":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name0 : string) (sg0 : signature),\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' /\\\npossible_trace w t w') : do_external_function name sg ge w vargs m = Some (w', t, vres, m') ->\nexternal_functions_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"do_external_function name sg ge w vargs m = Some (w', t, vres, m') ->\nexternal_functions_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name0 : string) (sg0 : signature),\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' /\\\npossible_trace w t w')","proofString":"eapply do_external_function_sound; eauto."},{"statement":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name0 : string) (sg0 : signature),\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' /\\\npossible_trace w t w') : do_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"do_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name0 : string) (sg0 : signature),\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' /\\\npossible_trace w t w')","proofString":"eapply BF_EX; eauto."},{"statement":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name0 : string) (sg0 : signature),\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' /\\\npossible_trace w t w') : do_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"do_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name0 : string) (sg0 : signature),\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' /\\\npossible_trace w t w')","proofString":"eapply BF_EX; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w') : (do w'0, t0, v <- do_volatile_load w chunk m b i; Some (w'0, t0, v, m)) =\nSome (w', t, vres, m') ->\nvolatile_load_sem chunk ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w'.","conclusion":"(do w'0, t0, v <- do_volatile_load w chunk m b i; Some (w'0, t0, v, m)) =\nSome (w', t, vres, m') ->\nvolatile_load_sem chunk ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w')","proofString":"mydestr.\ndestruct p as [[w'' t''] v]; mydestr.\nexploit do_volatile_load_sound; eauto.\nintuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w') (p : world * trace * val) (Heqo : do_volatile_load w chunk m b i = Some p) : (let (p0, v) := p in let (w'0, t0) := p0 in Some (w'0, t0, v, m)) =\nSome (w', t, vres, m') ->\nvolatile_load_sem chunk ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w'.","conclusion":"(let (p0, v) := p in let (w'0, t0) := p0 in Some (w'0, t0, v, m)) =\nSome (w', t, vres, m') ->\nvolatile_load_sem chunk ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w') (p : world * trace * val) (Heqo : do_volatile_load w chunk m b i = Some p)","proofString":"destruct p as [[w'' t''] v]; mydestr.\nexploit do_volatile_load_sound; eauto.\nintuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (Heqo : do_volatile_load w chunk m' b i = Some (w', t, vres)) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m' =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w') : volatile_load_sem chunk ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w'.","conclusion":"volatile_load_sem chunk ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (Heqo : do_volatile_load w chunk m' b i = Some (w', t, vres)) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m' =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w')","proofString":"exploit do_volatile_load_sound; eauto.\nintuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (Heqo : do_volatile_load w chunk m' b i = Some (w', t, vres)) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m' =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w') : volatile_load ge chunk m' b i t vres /\\ possible_trace w t w' ->\nvolatile_load_sem chunk ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w'.","conclusion":"volatile_load ge chunk m' b i t vres /\\ possible_trace w t w' ->\nvolatile_load_sem chunk ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (Heqo : do_volatile_load w chunk m' b i = Some (w', t, vres)) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m' =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w')","proofString":"intuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (Heqo : do_volatile_load w chunk m' b i = Some (w', t, vres)) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m' =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w') (H0 : volatile_load ge chunk m' b i t vres) (H1 : possible_trace w t w') : volatile_load_sem chunk ge (Vptr b i :: nil) m' t vres m'.","conclusion":"volatile_load_sem chunk ge (Vptr b i :: nil) m' t vres m'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (Heqo : do_volatile_load w chunk m' b i = Some (w', t, vres)) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m' =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m' t vres m' /\\\npossible_trace w t w') (H0 : volatile_load ge chunk m' b i t vres) (H1 : possible_trace w t w')","proofString":"econstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w') : (do w'0, t0, m'0, _ <- do_volatile_store w chunk m b i v;\n Some (w'0, t0, Vundef, m'0)) = Some (w', t, vres, m') ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w'.","conclusion":"(do w'0, t0, m'0, _ <- do_volatile_store w chunk m b i v;\n Some (w'0, t0, Vundef, m'0)) = Some (w', t, vres, m') ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w')","proofString":"mydestr.\ndestruct p as [[[w'' t''] m''] v''].\nmydestr.\nexploit do_volatile_store_sound; eauto.\nintuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w') (p : world * trace * mem * val) (Heqo : do_volatile_store w chunk m b i v = Some p) : (let (p0, _) := p in\n let (p1, m'0) := p0 in let (w'0, t0) := p1 in Some (w'0, t0, Vundef, m'0)) =\nSome (w', t, vres, m') ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w'.","conclusion":"(let (p0, _) := p in\n let (p1, m'0) := p0 in let (w'0, t0) := p1 in Some (w'0, t0, Vundef, m'0)) =\nSome (w', t, vres, m') ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w') (p : world * trace * mem * val) (Heqo : do_volatile_store w chunk m b i v = Some p)","proofString":"destruct p as [[[w'' t''] m''] v''].\nmydestr.\nexploit do_volatile_store_sound; eauto.\nintuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w') (w'' : world) (t'' : trace) (m'' : mem) (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w'', t'', m'', v'')) : Some (w'', t'', Vundef, m'') = Some (w', t, vres, m') ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w'.","conclusion":"Some (w'', t'', Vundef, m'') = Some (w', t, vres, m') ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t vres m' /\\\npossible_trace w t w') (w'' : world) (t'' : trace) (m'' : mem) (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w'', t'', m'', v''))","proofString":"mydestr.\nexploit do_volatile_store_sound; eauto.\nintuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w') (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w', t, m', v'')) : volatile_store_sem chunk ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w'.","conclusion":"volatile_store_sem chunk ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w') (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w', t, m', v''))","proofString":"exploit do_volatile_store_sound; eauto.\nintuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w') (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w', t, m', v'')) : volatile_store ge chunk m b i v t m' /\\ possible_trace w t w' /\\ v'' = v ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w'.","conclusion":"volatile_store ge chunk m b i v t m' /\\ possible_trace w t w' /\\ v'' = v ->\nvolatile_store_sem chunk ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w') (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w', t, m', v''))","proofString":"intuition.\neconstructor; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w') (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w', t, m', v'')) (H0 : volatile_store ge chunk m b i v t m') (H : possible_trace w t w') (H2 : v'' = v) : volatile_store_sem chunk ge (Vptr b i :: v :: nil) m t Vundef m'.","conclusion":"volatile_store_sem chunk ge (Vptr b i :: v :: nil) m t Vundef m'","hypotheses":"(chunk : memory_chunk) (w : world) (b : block) (i : ptrofs) (v : val) (m : mem) (w' : world) (t : trace) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: v :: nil) m =\nSome (w', t, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: v :: nil) m t Vundef m' /\\\npossible_trace w t w') (v'' : val) (Heqo : do_volatile_store w chunk m b i v = Some (w', t, m', v'')) (H0 : volatile_store ge chunk m b i v t m') (H : possible_trace w t w') (H2 : v'' = v)","proofString":"econstructor; eauto."},{"statement":"(w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w') : (do sz <- do_alloc_size v;\n let (m'0, b) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) in\n do m'' <- Mem.store Mptr m'0 b (- size_chunk Mptr) v;\n Some (w, E0, Vptr b Ptrofs.zero, m'')) = Some (w', t, vres, m') ->\nextcall_malloc_sem ge (v :: nil) m t vres m' /\\ possible_trace w t w'.","conclusion":"(do sz <- do_alloc_size v;\n let (m'0, b) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) in\n do m'' <- Mem.store Mptr m'0 b (- size_chunk Mptr) v;\n Some (w, E0, Vptr b Ptrofs.zero, m'')) = Some (w', t, vres, m') ->\nextcall_malloc_sem ge (v :: nil) m t vres m' /\\ possible_trace w t w'","hypotheses":"(w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w')","proofString":"mydestr.\ndestruct (Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i)) as [m1 b] eqn:?.\nmydestr.\nsplit.\napply SIZE in Heqo.\nsubst v.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) : (let (m'0, b) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) in\n do m'' <- Mem.store Mptr m'0 b (- size_chunk Mptr) v;\n Some (w, E0, Vptr b Ptrofs.zero, m'')) = Some (w', t, vres, m') ->\nextcall_malloc_sem ge (v :: nil) m t vres m' /\\ possible_trace w t w'.","conclusion":"(let (m'0, b) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) in\n do m'' <- Mem.store Mptr m'0 b (- size_chunk Mptr) v;\n Some (w, E0, Vptr b Ptrofs.zero, m'')) = Some (w', t, vres, m') ->\nextcall_malloc_sem ge (v :: nil) m t vres m' /\\ possible_trace w t w'","hypotheses":"(w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w') (i : ptrofs) (Heqo : do_alloc_size v = Some i)","proofString":"destruct (Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i)) as [m1 b] eqn:?.\nmydestr.\nsplit.\napply SIZE in Heqo.\nsubst v.\neconstructor; eauto.\nconstructor."},{"statement":"(w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) : (do m'' <- Mem.store Mptr m1 b (- size_chunk Mptr) v;\n Some (w, E0, Vptr b Ptrofs.zero, m'')) = Some (w', t, vres, m') ->\nextcall_malloc_sem ge (v :: nil) m t vres m' /\\ possible_trace w t w'.","conclusion":"(do m'' <- Mem.store Mptr m1 b (- size_chunk Mptr) v;\n Some (w, E0, Vptr b Ptrofs.zero, m'')) = Some (w', t, vres, m') ->\nextcall_malloc_sem ge (v :: nil) m t vres m' /\\ possible_trace w t w'","hypotheses":"(w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b))","proofString":"mydestr.\nsplit.\napply SIZE in Heqo.\nsubst v.\neconstructor; eauto.\nconstructor."},{"statement":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m') : extcall_malloc_sem ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_malloc_sem ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w'","hypotheses":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m')","proofString":"split.\napply SIZE in Heqo.\nsubst v.\neconstructor; eauto.\nconstructor."},{"statement":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m') : extcall_malloc_sem ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m'.","conclusion":"extcall_malloc_sem ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m'","hypotheses":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m')","proofString":"apply SIZE in Heqo.\nsubst v.\neconstructor; eauto."},{"statement":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : v = Vptrofs i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m') : extcall_malloc_sem ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m'.","conclusion":"extcall_malloc_sem ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m'","hypotheses":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : v = Vptrofs i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m')","proofString":"subst v.\neconstructor; eauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (b : block) (i : ptrofs) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptrofs i :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (Vptrofs i :: nil) m E0\n  (Vptr b Ptrofs.zero) m' /\\ possible_trace w' E0 w') (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) (Vptrofs i) = Some m') : extcall_malloc_sem ge (Vptrofs i :: nil) m E0 (Vptr b Ptrofs.zero) m'.","conclusion":"extcall_malloc_sem ge (Vptrofs i :: nil) m E0 (Vptr b Ptrofs.zero) m'","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (b : block) (i : ptrofs) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptrofs i :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (Vptrofs i :: nil) m E0\n  (Vptr b Ptrofs.zero) m' /\\ possible_trace w' E0 w') (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) (Vptrofs i) = Some m')","proofString":"econstructor; eauto."},{"statement":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m') : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(v : val) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (b : block) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (v :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m E0 (Vptr b Ptrofs.zero) m' /\\\npossible_trace w' E0 w') (i : ptrofs) (Heqo : do_alloc_size v = Some i) (m1 : Mem.mem') (Heqp : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i) = (m1, b)) (Heqo0 : Mem.store Mptr m1 b (- size_chunk Mptr) v = Some m')","proofString":"constructor."},{"statement":"(w : world) (i : int) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vint i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vint i :: nil) m t vres m' /\\\npossible_trace w t w') : (check Int.eq_dec i Int.zero && negb Archi.ptr64; Some (w, E0, Vundef, m)) =\nSome (w', t, vres, m') ->\nextcall_free_sem ge (Vint i :: nil) m t vres m' /\\ possible_trace w t w'.","conclusion":"(check Int.eq_dec i Int.zero && negb Archi.ptr64; Some (w, E0, Vundef, m)) =\nSome (w', t, vres, m') ->\nextcall_free_sem ge (Vint i :: nil) m t vres m' /\\ possible_trace w t w'","hypotheses":"(w : world) (i : int) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vint i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vint i :: nil) m t vres m' /\\\npossible_trace w t w')","proofString":"mydestr; InvBooleans; subst i.\nreplace (Vint Int.zero) with Vnullptr.\nsplit; constructor.\napply negb_true_iff in H0.\nunfold Vnullptr; rewrite H0; auto."},{"statement":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : negb Archi.ptr64 = true) : extcall_free_sem ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_free_sem ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : negb Archi.ptr64 = true)","proofString":"replace (Vint Int.zero) with Vnullptr.\nsplit; constructor.\napply negb_true_iff in H0.\nunfold Vnullptr; rewrite H0; auto."},{"statement":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : negb Archi.ptr64 = true) : extcall_free_sem ge (Vnullptr :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_free_sem ge (Vnullptr :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : negb Archi.ptr64 = true)","proofString":"split; constructor."},{"statement":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : negb Archi.ptr64 = true) : Vnullptr = Vint Int.zero.","conclusion":"Vnullptr = Vint Int.zero","hypotheses":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : negb Archi.ptr64 = true)","proofString":"apply negb_true_iff in H0.\nunfold Vnullptr; rewrite H0; auto."},{"statement":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = false) : Vnullptr = Vint Int.zero.","conclusion":"Vnullptr = Vint Int.zero","hypotheses":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vint Int.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vint Int.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = false)","proofString":"unfold Vnullptr; rewrite H0; auto."},{"statement":"(w : world) (i : int64) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vlong i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vlong i :: nil) m t vres m' /\\\npossible_trace w t w') : (check Int64.eq_dec i Int64.zero && Archi.ptr64; Some (w, E0, Vundef, m)) =\nSome (w', t, vres, m') ->\nextcall_free_sem ge (Vlong i :: nil) m t vres m' /\\ possible_trace w t w'.","conclusion":"(check Int64.eq_dec i Int64.zero && Archi.ptr64; Some (w, E0, Vundef, m)) =\nSome (w', t, vres, m') ->\nextcall_free_sem ge (Vlong i :: nil) m t vres m' /\\ possible_trace w t w'","hypotheses":"(w : world) (i : int64) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vlong i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vlong i :: nil) m t vres m' /\\\npossible_trace w t w')","proofString":"mydestr; InvBooleans; subst i.\nreplace (Vlong Int64.zero) with Vnullptr.\nsplit; constructor.\nunfold Vnullptr; rewrite H0; auto."},{"statement":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vlong Int64.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = true) : extcall_free_sem ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_free_sem ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vlong Int64.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = true)","proofString":"replace (Vlong Int64.zero) with Vnullptr.\nsplit; constructor.\nunfold Vnullptr; rewrite H0; auto."},{"statement":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vlong Int64.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = true) : extcall_free_sem ge (Vnullptr :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_free_sem ge (Vnullptr :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vlong Int64.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = true)","proofString":"split; constructor."},{"statement":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vlong Int64.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = true) : Vnullptr = Vlong Int64.zero.","conclusion":"Vnullptr = Vlong Int64.zero","hypotheses":"(w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vlong Int64.zero :: nil) m' =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vlong Int64.zero :: nil) m' E0 Vundef m' /\\\npossible_trace w' E0 w') (H0 : Archi.ptr64 = true)","proofString":"unfold Vnullptr; rewrite H0; auto."},{"statement":"(w : world) (b : block) (i : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w') : (do vsz <- Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr);\n do sz <- do_alloc_size vsz;\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n   (Ptrofs.unsigned i + Ptrofs.unsigned sz); Some (w, E0, Vundef, m'0)) =\nSome (w', t, vres, m') ->\nextcall_free_sem ge (Vptr b i :: nil) m t vres m' /\\ possible_trace w t w'.","conclusion":"(do vsz <- Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr);\n do sz <- do_alloc_size vsz;\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n   (Ptrofs.unsigned i + Ptrofs.unsigned sz); Some (w, E0, Vundef, m'0)) =\nSome (w', t, vres, m') ->\nextcall_free_sem ge (Vptr b i :: nil) m t vres m' /\\ possible_trace w t w'","hypotheses":"(w : world) (b : block) (i : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m t vres m' /\\\npossible_trace w t w')","proofString":"mydestr.\nsplit.\napply SIZE in Heqo0.\neconstructor; eauto.\ncongruence.\nconstructor."},{"statement":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : do_alloc_size v = Some i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m') : extcall_free_sem ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_free_sem ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : do_alloc_size v = Some i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m')","proofString":"split.\napply SIZE in Heqo0.\neconstructor; eauto.\ncongruence.\nconstructor."},{"statement":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : do_alloc_size v = Some i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m') : extcall_free_sem ge (Vptr b i :: nil) m E0 Vundef m'.","conclusion":"extcall_free_sem ge (Vptr b i :: nil) m E0 Vundef m'","hypotheses":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : do_alloc_size v = Some i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m')","proofString":"apply SIZE in Heqo0.\neconstructor; eauto.\ncongruence."},{"statement":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : v = Vptrofs i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m') : extcall_free_sem ge (Vptr b i :: nil) m E0 Vundef m'.","conclusion":"extcall_free_sem ge (Vptr b i :: nil) m E0 Vundef m'","hypotheses":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : v = Vptrofs i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m')","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : v = Vptrofs i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m') : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some (Vptrofs i0).","conclusion":"Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some (Vptrofs i0)","hypotheses":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : v = Vptrofs i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m')","proofString":"congruence."},{"statement":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : do_alloc_size v = Some i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m') : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(b : block) (i : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w') (v : val) (Heqo : Mem.load Mptr m b (Ptrofs.unsigned i - size_chunk Mptr) = Some v) (i0 : ptrofs) (Heqo0 : do_alloc_size v = Some i0) (Heqo1 : Mem.free m b (Ptrofs.unsigned i - size_chunk Mptr)\n  (Ptrofs.unsigned i + Ptrofs.unsigned i0) = Some m')","proofString":"constructor."},{"statement":"(sz al : Z) (w : world) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m t vres\n  m' /\\ possible_trace w t w') : (check decide\n         (memcpy_args_ok sz al b (Ptrofs.unsigned i) b0 (Ptrofs.unsigned i0));\n do bytes <- Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz;\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned i) bytes;\n Some (w, E0, Vundef, m'0)) = Some (w', t, vres, m') ->\nextcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m t vres m' /\\\npossible_trace w t w'.","conclusion":"(check decide\n         (memcpy_args_ok sz al b (Ptrofs.unsigned i) b0 (Ptrofs.unsigned i0));\n do bytes <- Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz;\n do m'0 <- Mem.storebytes m b (Ptrofs.unsigned i) bytes;\n Some (w, E0, Vundef, m'0)) = Some (w', t, vres, m') ->\nextcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m t vres m' /\\\npossible_trace w t w'","hypotheses":"(sz al : Z) (w : world) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m t vres\n  m' /\\ possible_trace w t w')","proofString":"mydestr.\napply Decidable_sound in Heqb1.\nred in Heqb1.\nsplit.\neconstructor; eauto; tauto.\nconstructor."},{"statement":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : decide (memcpy_args_ok sz al b (Ptrofs.unsigned i) b0 (Ptrofs.unsigned i0)) =\ntrue) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m') : extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : decide (memcpy_args_ok sz al b (Ptrofs.unsigned i) b0 (Ptrofs.unsigned i0)) =\ntrue) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m')","proofString":"apply Decidable_sound in Heqb1.\nred in Heqb1.\nsplit.\neconstructor; eauto; tauto.\nconstructor."},{"statement":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : memcpy_args_ok sz al b (Ptrofs.unsigned i) b0 (Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m') : extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : memcpy_args_ok sz al b (Ptrofs.unsigned i) b0 (Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m')","proofString":"red in Heqb1.\nsplit.\neconstructor; eauto; tauto.\nconstructor."},{"statement":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : (al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i0)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i)) /\\\n(b0 <> b \\/\n Ptrofs.unsigned i0 = Ptrofs.unsigned i \\/\n Ptrofs.unsigned i0 + sz <= Ptrofs.unsigned i \\/\n Ptrofs.unsigned i + sz <= Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m') : extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'.","conclusion":"extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m' /\\\npossible_trace w' E0 w'","hypotheses":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : (al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i0)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i)) /\\\n(b0 <> b \\/\n Ptrofs.unsigned i0 = Ptrofs.unsigned i \\/\n Ptrofs.unsigned i0 + sz <= Ptrofs.unsigned i \\/\n Ptrofs.unsigned i + sz <= Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m')","proofString":"split.\neconstructor; eauto; tauto.\nconstructor."},{"statement":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : (al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i0)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i)) /\\\n(b0 <> b \\/\n Ptrofs.unsigned i0 = Ptrofs.unsigned i \\/\n Ptrofs.unsigned i0 + sz <= Ptrofs.unsigned i \\/\n Ptrofs.unsigned i + sz <= Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m') : extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m'.","conclusion":"extcall_memcpy_sem sz al ge (Vptr b i :: Vptr b0 i0 :: nil) m E0 Vundef m'","hypotheses":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : (al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i0)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i)) /\\\n(b0 <> b \\/\n Ptrofs.unsigned i0 = Ptrofs.unsigned i \\/\n Ptrofs.unsigned i0 + sz <= Ptrofs.unsigned i \\/\n Ptrofs.unsigned i + sz <= Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m')","proofString":"econstructor; eauto; tauto."},{"statement":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : (al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i0)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i)) /\\\n(b0 <> b \\/\n Ptrofs.unsigned i0 = Ptrofs.unsigned i \\/\n Ptrofs.unsigned i0 + sz <= Ptrofs.unsigned i \\/\n Ptrofs.unsigned i + sz <= Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m') : possible_trace w' E0 w'.","conclusion":"possible_trace w' E0 w'","hypotheses":"(sz al : Z) (b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) (m : mem) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz0 : ptrofs),\ndo_alloc_size v = Some sz0 -> v = Vptrofs sz0) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (Vptr b i :: Vptr b0 i0 :: nil) m =\nSome (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge (Vptr b i :: Vptr b0 i0 :: nil) m E0\n  Vundef m' /\\ possible_trace w' E0 w') (Heqb1 : (al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i0)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned i)) /\\\n(b0 <> b \\/\n Ptrofs.unsigned i0 = Ptrofs.unsigned i \\/\n Ptrofs.unsigned i0 + sz <= Ptrofs.unsigned i \\/\n Ptrofs.unsigned i + sz <= Ptrofs.unsigned i0)) (l : list memval) (Heqo : Mem.loadbytes m b0 (Ptrofs.unsigned i0) sz = Some l) (Heqo0 : Mem.storebytes m b (Ptrofs.unsigned i) l = Some m')","proofString":"constructor."},{"statement":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w') : do_ef_annot text targs w vargs m = Some (w', t, vres, m') ->\nextcall_annot_sem text targs ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"do_ef_annot text targs w vargs m = Some (w', t, vres, m') ->\nextcall_annot_sem text targs ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w')","proofString":"unfold do_ef_annot.\nmydestr.\nsplit.\nconstructor.\napply list_eventval_of_val_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w') : (do args <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args :: E0, Vundef, m)) = \nSome (w', t, vres, m') ->\nextcall_annot_sem text targs ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"(do args <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args :: E0, Vundef, m)) = \nSome (w', t, vres, m') ->\nextcall_annot_sem text targs ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w')","proofString":"mydestr.\nsplit.\nconstructor.\napply list_eventval_of_val_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l) : extcall_annot_sem text targs ge vargs m' (Event_annot text l :: E0) Vundef m' /\\\npossible_trace w' (Event_annot text l :: E0) w'.","conclusion":"extcall_annot_sem text targs ge vargs m' (Event_annot text l :: E0) Vundef m' /\\\npossible_trace w' (Event_annot text l :: E0) w'","hypotheses":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l)","proofString":"split.\nconstructor.\napply list_eventval_of_val_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l) : extcall_annot_sem text targs ge vargs m' (Event_annot text l :: E0) Vundef m'.","conclusion":"extcall_annot_sem text targs ge vargs m' (Event_annot text l :: E0) Vundef m'","hypotheses":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l)","proofString":"constructor.\napply list_eventval_of_val_sound; auto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l) : eventval_list_match ge l targs vargs.","conclusion":"eventval_list_match ge l targs vargs","hypotheses":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l)","proofString":"apply list_eventval_of_val_sound; auto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l) : possible_trace w' (Event_annot text l :: E0) w'.","conclusion":"possible_trace w' (Event_annot text l :: E0) w'","hypotheses":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (l : list eventval) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text l :: E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text l :: E0) Vundef\n  m' /\\ possible_trace w' (Event_annot text l :: E0) w') (Heqo : list_eventval_of_val vargs targs = Some l)","proofString":"econstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(kind : positive) (text : string) (targ : typ) (w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w') : (do arg <- eventval_of_val v targ;\n Some (w, Event_annot text (arg :: nil) :: E0, v, m)) =\nSome (w', t, vres, m') ->\nextcall_annot_val_sem text targ ge (v :: nil) m t vres m' /\\\npossible_trace w t w'.","conclusion":"(do arg <- eventval_of_val v targ;\n Some (w, Event_annot text (arg :: nil) :: E0, v, m)) =\nSome (w', t, vres, m') ->\nextcall_annot_val_sem text targ ge (v :: nil) m t vres m' /\\\npossible_trace w t w'","hypotheses":"(kind : positive) (text : string) (targ : typ) (w : world) (v : val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v0 : val) (sz : ptrofs),\ndo_alloc_size v0 = Some sz -> v0 = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w (v :: nil) m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge (v :: nil) m t vres m' /\\\npossible_trace w t w')","proofString":"mydestr.\nsplit.\nconstructor.\napply eventval_of_val_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w') : extcall_annot_val_sem text targ ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w'.","conclusion":"extcall_annot_val_sem text targ ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w'","hypotheses":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w')","proofString":"split.\nconstructor.\napply eventval_of_val_sound; auto.\neconstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w') : extcall_annot_val_sem text targ ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m'.","conclusion":"extcall_annot_val_sem text targ ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m'","hypotheses":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w')","proofString":"constructor.\napply eventval_of_val_sound; auto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w') : eventval_match ge e targ vres.","conclusion":"eventval_match ge e targ vres","hypotheses":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w')","proofString":"apply eventval_of_val_sound; auto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w') : possible_trace w' (Event_annot text (e :: nil) :: E0) w'.","conclusion":"possible_trace w' (Event_annot text (e :: nil) :: E0) w'","hypotheses":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (e : eventval) (Heqo : eventval_of_val vres targ = Some e) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (e :: nil) :: E0, vres, m') ->\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (e :: nil) :: E0) vres m' /\\\npossible_trace w' (Event_annot text (e :: nil) :: E0) w')","proofString":"econstructor.\nconstructor; eauto.\nconstructor."},{"statement":"(text : string) (sg : signature) (clobbers : list string) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg0 : signature),\ndo_builtin_or_external name sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg0 ge vargs m t vres m' /\\\npossible_trace w t w') : do_inline_assembly text sg ge w vargs m = Some (w', t, vres, m') ->\ninline_assembly_sem text sg ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"do_inline_assembly text sg ge w vargs m = Some (w', t, vres, m') ->\ninline_assembly_sem text sg ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(text : string) (sg : signature) (clobbers : list string) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg0 : signature),\ndo_builtin_or_external name sg0 w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg0 ge vargs m t vres m' /\\\npossible_trace w t w')","proofString":"eapply do_inline_assembly_sound; eauto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w') : do_ef_debug kind text targs w vargs m = Some (w', t, vres, m') ->\nextcall_debug_sem ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"do_ef_debug kind text targs w vargs m = Some (w', t, vres, m') ->\nextcall_debug_sem ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w')","proofString":"unfold do_ef_debug.\nmydestr.\nsplit; constructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w') : Some (w, E0, Vundef, m) = Some (w', t, vres, m') ->\nextcall_debug_sem ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"Some (w, E0, Vundef, m) = Some (w', t, vres, m') ->\nextcall_debug_sem ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->\nbuiltin_or_external_sem name sg ge vargs m t vres m' /\\ possible_trace w t w')","proofString":"mydestr.\nsplit; constructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' = Some (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' E0 Vundef m' /\\\npossible_trace w' E0 w') : extcall_debug_sem ge vargs m' E0 Vundef m' /\\ possible_trace w' E0 w'.","conclusion":"extcall_debug_sem ge vargs m' E0 Vundef m' /\\ possible_trace w' E0 w'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall (v : val) (sz : ptrofs), do_alloc_size v = Some sz -> v = Vptrofs sz) (BF_EX : forall (name : string) (sg : signature),\ndo_builtin_or_external name sg w' vargs m' = Some (w', E0, Vundef, m') ->\nbuiltin_or_external_sem name sg ge vargs m' E0 Vundef m' /\\\npossible_trace w' E0 w')","proofString":"split; constructor."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') : do_external ef w vargs m = Some (w', t, vres, m').","conclusion":"do_external ef w vargs m = Some (w', t, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w')","proofString":"assert (SIZE: forall n, do_alloc_size (Vptrofs n) = Some n).\nunfold Vptrofs, do_alloc_size; intros; destruct Archi.ptr64 eqn:SF.\nrewrite Ptrofs.of_int64_to_int64; auto.\nrewrite Ptrofs.of_int_to_int; auto.\nassert (BF_EX: forall name sg,    builtin_or_external_sem name sg ge vargs m t vres m' ->    do_builtin_or_external name sg w vargs m = Some (w', t, vres, m')).\nunfold do_builtin_or_external, builtin_or_external_sem; intros.\ndestruct (lookup_builtin_function name sg) as [bf|].\ninv H1.\ninv H0.\nrewrite H2.\nauto.\neapply do_external_function_complete; eauto.\ndestruct ef; simpl in *.\neapply do_external_function_complete; eauto.\neapply BF_EX; eauto.\neapply BF_EX; eauto.\ninv H; unfold do_ef_volatile_load.\nexploit do_volatile_load_complete; eauto.\nintros EQ; rewrite EQ; auto.\ninv H; unfold do_ef_volatile_store.\nexploit do_volatile_store_complete; eauto.\nintros EQ; rewrite EQ; auto.\ninv H; unfold do_ef_malloc.\ninv H0.\nerewrite SIZE by eauto.\nrewrite H1, H2.\nauto.\ninv H; unfold do_ef_free.\ninv H0.\nrewrite H1.\nerewrite SIZE by eauto.\nrewrite H2.\nauto.\ninv H0.\nunfold Vnullptr; destruct Archi.ptr64; auto.\ninv H; unfold do_ef_memcpy.\ninv H0.\nrewrite Decidable_complete.\nrewrite H7; rewrite H8; auto.\nred.\ntauto.\ninv H; unfold do_ef_annot.\ninv H0.\ninv H6.\ninv H4.\nrewrite (list_eventval_of_val_complete _ _ _ H1).\nauto.\ninv H; unfold do_ef_annot_val.\ninv H0.\ninv H6.\ninv H4.\nrewrite (eventval_of_val_complete _ _ _ H1).\nauto.\neapply do_inline_assembly_complete; eauto.\ninv H.\ninv H0.\nreflexivity."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n.","conclusion":"forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w')","proofString":"unfold Vptrofs, do_alloc_size; intros; destruct Archi.ptr64 eqn:SF.\nrewrite Ptrofs.of_int64_to_int64; auto.\nrewrite Ptrofs.of_int_to_int; auto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (n : ptrofs) (SF : Archi.ptr64 = true) : Some (Ptrofs.of_int64 (Ptrofs.to_int64 n)) = Some n.","conclusion":"Some (Ptrofs.of_int64 (Ptrofs.to_int64 n)) = Some n","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (n : ptrofs) (SF : Archi.ptr64 = true)","proofString":"rewrite Ptrofs.of_int64_to_int64; auto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (n : ptrofs) (SF : Archi.ptr64 = false) : Some (Ptrofs.of_int (Ptrofs.to_int n)) = Some n.","conclusion":"Some (Ptrofs.of_int (Ptrofs.to_int n)) = Some n","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (n : ptrofs) (SF : Archi.ptr64 = false)","proofString":"rewrite Ptrofs.of_int_to_int; auto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) : do_external ef w vargs m = Some (w', t, vres, m').","conclusion":"do_external ef w vargs m = Some (w', t, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n)","proofString":"assert (BF_EX: forall name sg,    builtin_or_external_sem name sg ge vargs m t vres m' ->    do_builtin_or_external name sg w vargs m = Some (w', t, vres, m')).\nunfold do_builtin_or_external, builtin_or_external_sem; intros.\ndestruct (lookup_builtin_function name sg) as [bf|].\ninv H1.\ninv H0.\nrewrite H2.\nauto.\neapply do_external_function_complete; eauto.\ndestruct ef; simpl in *.\neapply do_external_function_complete; eauto.\neapply BF_EX; eauto.\neapply BF_EX; eauto.\ninv H; unfold do_ef_volatile_load.\nexploit do_volatile_load_complete; eauto.\nintros EQ; rewrite EQ; auto.\ninv H; unfold do_ef_volatile_store.\nexploit do_volatile_store_complete; eauto.\nintros EQ; rewrite EQ; auto.\ninv H; unfold do_ef_malloc.\ninv H0.\nerewrite SIZE by eauto.\nrewrite H1, H2.\nauto.\ninv H; unfold do_ef_free.\ninv H0.\nrewrite H1.\nerewrite SIZE by eauto.\nrewrite H2.\nauto.\ninv H0.\nunfold Vnullptr; destruct Archi.ptr64; auto.\ninv H; unfold do_ef_memcpy.\ninv H0.\nrewrite Decidable_complete.\nrewrite H7; rewrite H8; auto.\nred.\ntauto.\ninv H; unfold do_ef_annot.\ninv H0.\ninv H6.\ninv H4.\nrewrite (list_eventval_of_val_complete _ _ _ H1).\nauto.\ninv H; unfold do_ef_annot_val.\ninv H0.\ninv H6.\ninv H4.\nrewrite (eventval_of_val_complete _ _ _ H1).\nauto.\neapply do_inline_assembly_complete; eauto.\ninv H.\ninv H0.\nreflexivity."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m').","conclusion":"forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n)","proofString":"unfold do_builtin_or_external, builtin_or_external_sem; intros.\ndestruct (lookup_builtin_function name sg) as [bf|].\ninv H1.\ninv H0.\nrewrite H2.\nauto.\neapply do_external_function_complete; eauto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (H1 : match lookup_builtin_function name sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem name sg\nend ge vargs m t vres m') : match lookup_builtin_function name sg with\n| Some bf => do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)\n| None => do_external_function name sg ge w vargs m\nend = Some (w', t, vres, m').","conclusion":"match lookup_builtin_function name sg with\n| Some bf => do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)\n| None => do_external_function name sg ge w vargs m\nend = Some (w', t, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (H1 : match lookup_builtin_function name sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem name sg\nend ge vargs m t vres m')","proofString":"destruct (lookup_builtin_function name sg) as [bf|].\ninv H1.\ninv H0.\nrewrite H2.\nauto.\neapply do_external_function_complete; eauto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m') : (do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)) =\nSome (w', t, vres, m').","conclusion":"(do v <- builtin_function_sem bf vargs; Some (w, E0, v, m)) =\nSome (w', t, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m')","proofString":"inv H1.\ninv H0.\nrewrite H2.\nauto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (w' : world) (vres : val) (m' : mem) (H0 : possible_trace w E0 w') (H : external_call ef ge vargs m' E0 vres m') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H2 : builtin_function_sem bf vargs = Some vres) : (do v <- builtin_function_sem bf vargs; Some (w, E0, v, m')) =\nSome (w', E0, vres, m').","conclusion":"(do v <- builtin_function_sem bf vargs; Some (w, E0, v, m')) =\nSome (w', E0, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (w' : world) (vres : val) (m' : mem) (H0 : possible_trace w E0 w') (H : external_call ef ge vargs m' E0 vres m') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"inv H0.\nrewrite H2.\nauto."},{"statement":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (H : external_call ef ge vargs m' E0 vres m') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H2 : builtin_function_sem bf vargs = Some vres) : (do v <- builtin_function_sem bf vargs; Some (w', E0, v, m')) =\nSome (w', E0, vres, m').","conclusion":"(do v <- builtin_function_sem bf vargs; Some (w', E0, v, m')) =\nSome (w', E0, vres, m')","hypotheses":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (H : external_call ef ge vargs m' E0 vres m') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"rewrite H2.\nauto."},{"statement":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (H : external_call ef ge vargs m' E0 vres m') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H2 : builtin_function_sem bf vargs = Some vres) : Some (w', E0, vres, m') = Some (w', E0, vres, m').","conclusion":"Some (w', E0, vres, m') = Some (w', E0, vres, m')","hypotheses":"(ef : external_function) (vargs : list val) (w' : world) (vres : val) (m' : mem) (H : external_call ef ge vargs m' E0 vres m') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (bf : builtin_function) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"auto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (H1 : external_functions_sem name sg ge vargs m t vres m') : do_external_function name sg ge w vargs m = Some (w', t, vres, m').","conclusion":"do_external_function name sg ge w vargs m = Some (w', t, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (name : string) (sg : signature) (H1 : external_functions_sem name sg ge vargs m t vres m')","proofString":"eapply do_external_function_complete; eauto."},{"statement":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_external ef w vargs m = Some (w', t, vres, m').","conclusion":"do_external ef w vargs m = Some (w', t, vres, m')","hypotheses":"(ef : external_function) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"destruct ef; simpl in *.\neapply do_external_function_complete; eauto.\neapply BF_EX; eauto.\neapply BF_EX; eauto.\ninv H; unfold do_ef_volatile_load.\nexploit do_volatile_load_complete; eauto.\nintros EQ; rewrite EQ; auto.\ninv H; unfold do_ef_volatile_store.\nexploit do_volatile_store_complete; eauto.\nintros EQ; rewrite EQ; auto.\ninv H; unfold do_ef_malloc.\ninv H0.\nerewrite SIZE by eauto.\nrewrite H1, H2.\nauto.\ninv H; unfold do_ef_free.\ninv H0.\nrewrite H1.\nerewrite SIZE by eauto.\nrewrite H2.\nauto.\ninv H0.\nunfold Vnullptr; destruct Archi.ptr64; auto.\ninv H; unfold do_ef_memcpy.\ninv H0.\nrewrite Decidable_complete.\nrewrite H7; rewrite H8; auto.\nred.\ntauto.\ninv H; unfold do_ef_annot.\ninv H0.\ninv H6.\ninv H4.\nrewrite (list_eventval_of_val_complete _ _ _ H1).\nauto.\ninv H; unfold do_ef_annot_val.\ninv H0.\ninv H6.\ninv H4.\nrewrite (eventval_of_val_complete _ _ _ H1).\nauto.\neapply do_inline_assembly_complete; eauto.\ninv H.\ninv H0.\nreflexivity."},{"statement":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_functions_sem name sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name0 : string) (sg0 : signature),\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m')) : do_external_function name sg ge w vargs m = Some (w', t, vres, m').","conclusion":"do_external_function name sg ge w vargs m = Some (w', t, vres, m')","hypotheses":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : external_functions_sem name sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name0 : string) (sg0 : signature),\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m'))","proofString":"eapply do_external_function_complete; eauto."},{"statement":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : builtin_or_external_sem name sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name0 : string) (sg0 : signature),\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m')) : do_builtin_or_external name sg w vargs m = Some (w', t, vres, m').","conclusion":"do_builtin_or_external name sg w vargs m = Some (w', t, vres, m')","hypotheses":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : builtin_or_external_sem name sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name0 : string) (sg0 : signature),\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m'))","proofString":"eapply BF_EX; eauto."},{"statement":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : builtin_or_external_sem name sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name0 : string) (sg0 : signature),\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m')) : do_builtin_or_external name sg w vargs m = Some (w', t, vres, m').","conclusion":"do_builtin_or_external name sg w vargs m = Some (w', t, vres, m')","hypotheses":"(name : string) (sg : signature) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : builtin_or_external_sem name sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name0 : string) (sg0 : signature),\nbuiltin_or_external_sem name0 sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name0 sg0 w vargs m = Some (w', t, vres, m'))","proofString":"eapply BF_EX; eauto."},{"statement":"(chunk : memory_chunk) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : volatile_load_sem chunk ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_volatile_load chunk w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_volatile_load chunk w vargs m = Some (w', t, vres, m')","hypotheses":"(chunk : memory_chunk) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : volatile_load_sem chunk ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H; unfold do_ef_volatile_load.\nexploit do_volatile_load_complete; eauto.\nintros EQ; rewrite EQ; auto."},{"statement":"(chunk : memory_chunk) (w w' : world) (t : trace) (vres : val) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: nil) m' t vres m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: nil) m' =\nSome (w', t, vres, m')) (H1 : volatile_load ge chunk m' b ofs t vres) : (do w'0, t0, v <- do_volatile_load w chunk m' b ofs; Some (w'0, t0, v, m')) =\nSome (w', t, vres, m').","conclusion":"(do w'0, t0, v <- do_volatile_load w chunk m' b ofs; Some (w'0, t0, v, m')) =\nSome (w', t, vres, m')","hypotheses":"(chunk : memory_chunk) (w w' : world) (t : trace) (vres : val) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: nil) m' t vres m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: nil) m' =\nSome (w', t, vres, m')) (H1 : volatile_load ge chunk m' b ofs t vres)","proofString":"exploit do_volatile_load_complete; eauto.\nintros EQ; rewrite EQ; auto."},{"statement":"(chunk : memory_chunk) (w w' : world) (t : trace) (vres : val) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: nil) m' t vres m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: nil) m' =\nSome (w', t, vres, m')) (H1 : volatile_load ge chunk m' b ofs t vres) : do_volatile_load w chunk m' b ofs = Some (w', t, vres) ->\n(do w'0, t0, v <- do_volatile_load w chunk m' b ofs; Some (w'0, t0, v, m')) =\nSome (w', t, vres, m').","conclusion":"do_volatile_load w chunk m' b ofs = Some (w', t, vres) ->\n(do w'0, t0, v <- do_volatile_load w chunk m' b ofs; Some (w'0, t0, v, m')) =\nSome (w', t, vres, m')","hypotheses":"(chunk : memory_chunk) (w w' : world) (t : trace) (vres : val) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: nil) m' t vres m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: nil) m' =\nSome (w', t, vres, m')) (H1 : volatile_load ge chunk m' b ofs t vres)","proofString":"intros EQ; rewrite EQ; auto."},{"statement":"(chunk : memory_chunk) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : volatile_store_sem chunk ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_volatile_store chunk w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_volatile_store chunk w vargs m = Some (w', t, vres, m')","hypotheses":"(chunk : memory_chunk) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : volatile_store_sem chunk ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H; unfold do_ef_volatile_store.\nexploit do_volatile_store_complete; eauto.\nintros EQ; rewrite EQ; auto."},{"statement":"(chunk : memory_chunk) (w : world) (m : mem) (w' : world) (t : trace) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (v : val) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: v :: nil) m t Vundef m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: v :: nil) m =\nSome (w', t, Vundef, m')) (H1 : volatile_store ge chunk m b ofs v t m') : (do w'0, t0, m'0, _ <- do_volatile_store w chunk m b ofs v;\n Some (w'0, t0, Vundef, m'0)) = Some (w', t, Vundef, m').","conclusion":"(do w'0, t0, m'0, _ <- do_volatile_store w chunk m b ofs v;\n Some (w'0, t0, Vundef, m'0)) = Some (w', t, Vundef, m')","hypotheses":"(chunk : memory_chunk) (w : world) (m : mem) (w' : world) (t : trace) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (v : val) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: v :: nil) m t Vundef m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: v :: nil) m =\nSome (w', t, Vundef, m')) (H1 : volatile_store ge chunk m b ofs v t m')","proofString":"exploit do_volatile_store_complete; eauto.\nintros EQ; rewrite EQ; auto."},{"statement":"(chunk : memory_chunk) (w : world) (m : mem) (w' : world) (t : trace) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (v : val) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: v :: nil) m t Vundef m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: v :: nil) m =\nSome (w', t, Vundef, m')) (H1 : volatile_store ge chunk m b ofs v t m') : do_volatile_store w chunk m b ofs v = Some (w', t, m', v) ->\n(do w'0, t0, m'0, _ <- do_volatile_store w chunk m b ofs v;\n Some (w'0, t0, Vundef, m'0)) = Some (w', t, Vundef, m').","conclusion":"do_volatile_store w chunk m b ofs v = Some (w', t, m', v) ->\n(do w'0, t0, m'0, _ <- do_volatile_store w chunk m b ofs v;\n Some (w'0, t0, Vundef, m'0)) = Some (w', t, Vundef, m')","hypotheses":"(chunk : memory_chunk) (w : world) (m : mem) (w' : world) (t : trace) (m' : mem) (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (ofs : ptrofs) (v : val) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b ofs :: v :: nil) m t Vundef m' ->\ndo_builtin_or_external name sg w (Vptr b ofs :: v :: nil) m =\nSome (w', t, Vundef, m')) (H1 : volatile_store ge chunk m b ofs v t m')","proofString":"intros EQ; rewrite EQ; auto."},{"statement":"(w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_malloc_sem ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_malloc w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_malloc w vargs m = Some (w', t, vres, m')","hypotheses":"(w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_malloc_sem ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H; unfold do_ef_malloc.\ninv H0.\nerewrite SIZE by eauto.\nrewrite H1, H2.\nauto."},{"statement":"(w : world) (m : mem) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m') : (do sz0 <- do_alloc_size (Vptrofs sz);\n let (m'1, b0) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz0) in\n do m'' <- Mem.store Mptr m'1 b0 (- size_chunk Mptr) (Vptrofs sz);\n Some (w, E0, Vptr b0 Ptrofs.zero, m'')) =\nSome (w', E0, Vptr b Ptrofs.zero, m').","conclusion":"(do sz0 <- do_alloc_size (Vptrofs sz);\n let (m'1, b0) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz0) in\n do m'' <- Mem.store Mptr m'1 b0 (- size_chunk Mptr) (Vptrofs sz);\n Some (w, E0, Vptr b0 Ptrofs.zero, m'')) =\nSome (w', E0, Vptr b Ptrofs.zero, m')","hypotheses":"(w : world) (m : mem) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m')","proofString":"inv H0.\nerewrite SIZE by eauto.\nrewrite H1, H2.\nauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w' (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m') : (do sz0 <- do_alloc_size (Vptrofs sz);\n let (m'1, b0) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz0) in\n do m'' <- Mem.store Mptr m'1 b0 (- size_chunk Mptr) (Vptrofs sz);\n Some (w', E0, Vptr b0 Ptrofs.zero, m'')) =\nSome (w', E0, Vptr b Ptrofs.zero, m').","conclusion":"(do sz0 <- do_alloc_size (Vptrofs sz);\n let (m'1, b0) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz0) in\n do m'' <- Mem.store Mptr m'1 b0 (- size_chunk Mptr) (Vptrofs sz);\n Some (w', E0, Vptr b0 Ptrofs.zero, m'')) =\nSome (w', E0, Vptr b Ptrofs.zero, m')","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w' (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m')","proofString":"erewrite SIZE by eauto.\nrewrite H1, H2.\nauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w' (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m') : (let (m'1, b0) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) in\n do m'' <- Mem.store Mptr m'1 b0 (- size_chunk Mptr) (Vptrofs sz);\n Some (w', E0, Vptr b0 Ptrofs.zero, m'')) =\nSome (w', E0, Vptr b Ptrofs.zero, m').","conclusion":"(let (m'1, b0) := Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) in\n do m'' <- Mem.store Mptr m'1 b0 (- size_chunk Mptr) (Vptrofs sz);\n Some (w', E0, Vptr b0 Ptrofs.zero, m'')) =\nSome (w', E0, Vptr b Ptrofs.zero, m')","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w' (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m')","proofString":"rewrite H1, H2.\nauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w' (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m') : Some (w', E0, Vptr b Ptrofs.zero, m') = Some (w', E0, Vptr b Ptrofs.zero, m').","conclusion":"Some (w', E0, Vptr b Ptrofs.zero, m') = Some (w', E0, Vptr b Ptrofs.zero, m')","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (sz : ptrofs) (b : block) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptrofs sz :: nil) m E0\n  (Vptr b Ptrofs.zero) m' ->\ndo_builtin_or_external name sg w' (Vptrofs sz :: nil) m =\nSome (w', E0, Vptr b Ptrofs.zero, m')) (m'0 : Mem.mem') (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b)) (H2 : Mem.store Mptr m'0 b (- size_chunk Mptr) (Vptrofs sz) = Some m')","proofString":"auto."},{"statement":"(w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_free_sem ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_free w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_free w vargs m = Some (w', t, vres, m')","hypotheses":"(w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_free_sem ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H; unfold do_ef_free.\ninv H0.\nrewrite H1.\nerewrite SIZE by eauto.\nrewrite H2.\nauto.\ninv H0.\nunfold Vnullptr; destruct Archi.ptr64; auto."},{"statement":"(w : world) (m : mem) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m') : (do vsz <- Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr);\n do sz0 <- do_alloc_size vsz;\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz0); Some (w, E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m').","conclusion":"(do vsz <- Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr);\n do sz0 <- do_alloc_size vsz;\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz0); Some (w, E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m')","hypotheses":"(w : world) (m : mem) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m')","proofString":"inv H0.\nrewrite H1.\nerewrite SIZE by eauto.\nrewrite H2.\nauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m') : (do vsz <- Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr);\n do sz0 <- do_alloc_size vsz;\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz0); Some (w', E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m').","conclusion":"(do vsz <- Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr);\n do sz0 <- do_alloc_size vsz;\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz0); Some (w', E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m')","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m')","proofString":"rewrite H1.\nerewrite SIZE by eauto.\nrewrite H2.\nauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m') : (do sz0 <- do_alloc_size (Vptrofs sz);\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz0); Some (w', E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m').","conclusion":"(do sz0 <- do_alloc_size (Vptrofs sz);\n do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz0); Some (w', E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m')","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m')","proofString":"erewrite SIZE by eauto.\nrewrite H2.\nauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m') : (do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz); Some (w', E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m').","conclusion":"(do m'0 <-\n Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n   (Ptrofs.unsigned lo + Ptrofs.unsigned sz); Some (w', E0, Vundef, m'0)) =\nSome (w', E0, Vundef, m')","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m')","proofString":"rewrite H2.\nauto."},{"statement":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m') : Some (w', E0, Vundef, m') = Some (w', E0, Vundef, m').","conclusion":"Some (w', E0, Vundef, m') = Some (w', E0, Vundef, m')","hypotheses":"(m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (b : block) (lo : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr b lo :: nil) m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr b lo :: nil) m =\nSome (w', E0, Vundef, m')) (sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m')","proofString":"auto."},{"statement":"(w w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vnullptr :: nil) m' E0 Vundef m' ->\ndo_builtin_or_external name sg w (Vnullptr :: nil) m' =\nSome (w', E0, Vundef, m')) : match Vnullptr with\n| Vint n =>\n    check Int.eq_dec n Int.zero && negb Archi.ptr64; Some (w, E0, Vundef, m')\n| Vlong n =>\n    check Int64.eq_dec n Int64.zero && Archi.ptr64; Some (w, E0, Vundef, m')\n| Vptr b lo =>\n    do vsz <- Mem.load Mptr m' b (Ptrofs.unsigned lo - size_chunk Mptr);\n    do sz <- do_alloc_size vsz;\n    do m'0 <-\n    Mem.free m' b (Ptrofs.unsigned lo - size_chunk Mptr)\n      (Ptrofs.unsigned lo + Ptrofs.unsigned sz); Some (w, E0, Vundef, m'0)\n| _ => None\nend = Some (w', E0, Vundef, m').","conclusion":"match Vnullptr with\n| Vint n =>\n    check Int.eq_dec n Int.zero && negb Archi.ptr64; Some (w, E0, Vundef, m')\n| Vlong n =>\n    check Int64.eq_dec n Int64.zero && Archi.ptr64; Some (w, E0, Vundef, m')\n| Vptr b lo =>\n    do vsz <- Mem.load Mptr m' b (Ptrofs.unsigned lo - size_chunk Mptr);\n    do sz <- do_alloc_size vsz;\n    do m'0 <-\n    Mem.free m' b (Ptrofs.unsigned lo - size_chunk Mptr)\n      (Ptrofs.unsigned lo + Ptrofs.unsigned sz); Some (w, E0, Vundef, m'0)\n| _ => None\nend = Some (w', E0, Vundef, m')","hypotheses":"(w w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vnullptr :: nil) m' E0 Vundef m' ->\ndo_builtin_or_external name sg w (Vnullptr :: nil) m' =\nSome (w', E0, Vundef, m'))","proofString":"inv H0.\nunfold Vnullptr; destruct Archi.ptr64; auto."},{"statement":"(w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vnullptr :: nil) m' E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vnullptr :: nil) m' =\nSome (w', E0, Vundef, m')) : match Vnullptr with\n| Vint n =>\n    check Int.eq_dec n Int.zero && negb Archi.ptr64;\n    Some (w', E0, Vundef, m')\n| Vlong n =>\n    check Int64.eq_dec n Int64.zero && Archi.ptr64; Some (w', E0, Vundef, m')\n| Vptr b lo =>\n    do vsz <- Mem.load Mptr m' b (Ptrofs.unsigned lo - size_chunk Mptr);\n    do sz <- do_alloc_size vsz;\n    do m'0 <-\n    Mem.free m' b (Ptrofs.unsigned lo - size_chunk Mptr)\n      (Ptrofs.unsigned lo + Ptrofs.unsigned sz); Some (w', E0, Vundef, m'0)\n| _ => None\nend = Some (w', E0, Vundef, m').","conclusion":"match Vnullptr with\n| Vint n =>\n    check Int.eq_dec n Int.zero && negb Archi.ptr64;\n    Some (w', E0, Vundef, m')\n| Vlong n =>\n    check Int64.eq_dec n Int64.zero && Archi.ptr64; Some (w', E0, Vundef, m')\n| Vptr b lo =>\n    do vsz <- Mem.load Mptr m' b (Ptrofs.unsigned lo - size_chunk Mptr);\n    do sz <- do_alloc_size vsz;\n    do m'0 <-\n    Mem.free m' b (Ptrofs.unsigned lo - size_chunk Mptr)\n      (Ptrofs.unsigned lo + Ptrofs.unsigned sz); Some (w', E0, Vundef, m'0)\n| _ => None\nend = Some (w', E0, Vundef, m')","hypotheses":"(w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vnullptr :: nil) m' E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vnullptr :: nil) m' =\nSome (w', E0, Vundef, m'))","proofString":"unfold Vnullptr; destruct Archi.ptr64; auto."},{"statement":"(sz al : Z) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_memcpy_sem sz al ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_memcpy sz al w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_memcpy sz al w vargs m = Some (w', t, vres, m')","hypotheses":"(sz al : Z) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_memcpy_sem sz al ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H; unfold do_ef_memcpy.\ninv H0.\nrewrite Decidable_complete.\nrewrite H7; rewrite H8; auto.\nred.\ntauto."},{"statement":"(sz al : Z) (w : world) (m : mem) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : (check decide\n         (memcpy_args_ok sz al bdst (Ptrofs.unsigned odst) bsrc\n            (Ptrofs.unsigned osrc));\n do bytes0 <- Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz;\n do m'0 <- Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0;\n Some (w, E0, Vundef, m'0)) = Some (w', E0, Vundef, m').","conclusion":"(check decide\n         (memcpy_args_ok sz al bdst (Ptrofs.unsigned odst) bsrc\n            (Ptrofs.unsigned osrc));\n do bytes0 <- Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz;\n do m'0 <- Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0;\n Some (w, E0, Vundef, m'0)) = Some (w', E0, Vundef, m')","hypotheses":"(sz al : Z) (w : world) (m : mem) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m')","proofString":"inv H0.\nrewrite Decidable_complete.\nrewrite H7; rewrite H8; auto.\nred.\ntauto."},{"statement":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : (check decide\n         (memcpy_args_ok sz al bdst (Ptrofs.unsigned odst) bsrc\n            (Ptrofs.unsigned osrc));\n do bytes0 <- Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz;\n do m'0 <- Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0;\n Some (w', E0, Vundef, m'0)) = Some (w', E0, Vundef, m').","conclusion":"(check decide\n         (memcpy_args_ok sz al bdst (Ptrofs.unsigned odst) bsrc\n            (Ptrofs.unsigned osrc));\n do bytes0 <- Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz;\n do m'0 <- Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0;\n Some (w', E0, Vundef, m'0)) = Some (w', E0, Vundef, m')","hypotheses":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m')","proofString":"rewrite Decidable_complete.\nrewrite H7; rewrite H8; auto.\nred.\ntauto."},{"statement":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : (do bytes0 <- Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz;\n do m'0 <- Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0;\n Some (w', E0, Vundef, m'0)) = Some (w', E0, Vundef, m').","conclusion":"(do bytes0 <- Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz;\n do m'0 <- Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0;\n Some (w', E0, Vundef, m'0)) = Some (w', E0, Vundef, m')","hypotheses":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m')","proofString":"rewrite H7; rewrite H8; auto."},{"statement":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : memcpy_args_ok sz al bdst (Ptrofs.unsigned odst) bsrc (Ptrofs.unsigned osrc).","conclusion":"memcpy_args_ok sz al bdst (Ptrofs.unsigned odst) bsrc (Ptrofs.unsigned osrc)","hypotheses":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m')","proofString":"red.\ntauto."},{"statement":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : (al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned osrc)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned odst)) /\\\n(bsrc <> bdst \\/\n Ptrofs.unsigned osrc = Ptrofs.unsigned odst \\/\n Ptrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\n Ptrofs.unsigned odst + sz <= Ptrofs.unsigned osrc).","conclusion":"(al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) /\\\nsz >= 0 /\\\n(al | sz) /\\\n(sz > 0 -> (al | Ptrofs.unsigned osrc)) /\\\n(sz > 0 -> (al | Ptrofs.unsigned odst)) /\\\n(bsrc <> bdst \\/\n Ptrofs.unsigned osrc = Ptrofs.unsigned odst \\/\n Ptrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\n Ptrofs.unsigned odst + sz <= Ptrofs.unsigned osrc)","hypotheses":"(sz al : Z) (m : mem) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (Vptr bdst odst :: Vptr bsrc osrc :: nil)\n  m E0 Vundef m' ->\ndo_builtin_or_external name sg w' (Vptr bdst odst :: Vptr bsrc osrc :: nil) m =\nSome (w', E0, Vundef, m')) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m')","proofString":"tauto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_sem text targs ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_annot text targs w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_annot text targs w vargs m = Some (w', t, vres, m')","hypotheses":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_sem text targs ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H; unfold do_ef_annot.\ninv H0.\ninv H6.\ninv H4.\nrewrite (list_eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (H0 : possible_trace w (Event_annot text args :: E0) w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs) : (do args0 <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m').","conclusion":"(do args0 <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m')","hypotheses":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (H0 : possible_trace w (Event_annot text args :: E0) w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs)","proofString":"inv H0.\ninv H6.\ninv H4.\nrewrite (list_eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs) (w2 : world) (H4 : possible_event w (Event_annot text args) w2) (H6 : possible_trace w2 E0 w') : (do args0 <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m').","conclusion":"(do args0 <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m')","hypotheses":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs) (w2 : world) (H4 : possible_event w (Event_annot text args) w2) (H6 : possible_trace w2 E0 w')","proofString":"inv H6.\ninv H4.\nrewrite (list_eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs) (H4 : possible_event w (Event_annot text args) w') : (do args0 <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m').","conclusion":"(do args0 <- list_eventval_of_val vargs targs;\n Some (w, Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m')","hypotheses":"(kind : positive) (text : string) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs) (H4 : possible_event w (Event_annot text args) w')","proofString":"inv H4.\nrewrite (list_eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs) : (do args0 <- list_eventval_of_val vargs targs;\n Some (w', Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m').","conclusion":"(do args0 <- list_eventval_of_val vargs targs;\n Some (w', Event_annot text args0 :: E0, Vundef, m')) =\nSome (w', Event_annot text args :: E0, Vundef, m')","hypotheses":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs)","proofString":"rewrite (list_eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs) : Some (w', Event_annot text args :: E0, Vundef, m') =\nSome (w', Event_annot text args :: E0, Vundef, m').","conclusion":"Some (w', Event_annot text args :: E0, Vundef, m') =\nSome (w', Event_annot text args :: E0, Vundef, m')","hypotheses":"(kind : positive) (text : string) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (args : list eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' (Event_annot text args :: E0)\n  Vundef m' ->\ndo_builtin_or_external name sg w' vargs m' =\nSome (w', Event_annot text args :: E0, Vundef, m')) (H1 : eventval_list_match ge args targs vargs)","proofString":"auto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_val_sem text targ ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_annot_val text targ w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_annot_val text targ w vargs m = Some (w', t, vres, m')","hypotheses":"(kind : positive) (text : string) (targ : typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_val_sem text targ ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H; unfold do_ef_annot_val.\ninv H0.\ninv H6.\ninv H4.\nrewrite (eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w w' : world) (vres : val) (m' : mem) (arg : eventval) (H0 : possible_trace w (Event_annot text (arg :: nil) :: E0) w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres) : (do arg0 <- eventval_of_val vres targ;\n Some (w, Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m').","conclusion":"(do arg0 <- eventval_of_val vres targ;\n Some (w, Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')","hypotheses":"(kind : positive) (text : string) (targ : typ) (w w' : world) (vres : val) (m' : mem) (arg : eventval) (H0 : possible_trace w (Event_annot text (arg :: nil) :: E0) w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres)","proofString":"inv H0.\ninv H6.\ninv H4.\nrewrite (eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres) (w2 : world) (H4 : possible_event w (Event_annot text (arg :: nil)) w2) (H6 : possible_trace w2 E0 w') : (do arg0 <- eventval_of_val vres targ;\n Some (w, Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m').","conclusion":"(do arg0 <- eventval_of_val vres targ;\n Some (w, Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')","hypotheses":"(kind : positive) (text : string) (targ : typ) (w w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres) (w2 : world) (H4 : possible_event w (Event_annot text (arg :: nil)) w2) (H6 : possible_trace w2 E0 w')","proofString":"inv H6.\ninv H4.\nrewrite (eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres) (H4 : possible_event w (Event_annot text (arg :: nil)) w') : (do arg0 <- eventval_of_val vres targ;\n Some (w, Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m').","conclusion":"(do arg0 <- eventval_of_val vres targ;\n Some (w, Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')","hypotheses":"(kind : positive) (text : string) (targ : typ) (w w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres) (H4 : possible_event w (Event_annot text (arg :: nil)) w')","proofString":"inv H4.\nrewrite (eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres) : (do arg0 <- eventval_of_val vres targ;\n Some (w', Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m').","conclusion":"(do arg0 <- eventval_of_val vres targ;\n Some (w', Event_annot text (arg0 :: nil) :: E0, vres, m')) =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')","hypotheses":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres)","proofString":"rewrite (eventval_of_val_complete _ _ _ H1).\nauto."},{"statement":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres) : Some (w', Event_annot text (arg :: nil) :: E0, vres, m') =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m').","conclusion":"Some (w', Event_annot text (arg :: nil) :: E0, vres, m') =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')","hypotheses":"(kind : positive) (text : string) (targ : typ) (w' : world) (vres : val) (m' : mem) (arg : eventval) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge (vres :: nil) m'\n  (Event_annot text (arg :: nil) :: E0) vres m' ->\ndo_builtin_or_external name sg w' (vres :: nil) m' =\nSome (w', Event_annot text (arg :: nil) :: E0, vres, m')) (H1 : eventval_match ge arg targ vres)","proofString":"auto."},{"statement":"(text : string) (sg : signature) (clobbers : list string) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : inline_assembly_sem text sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg0 : signature),\nbuiltin_or_external_sem name sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name sg0 w vargs m = Some (w', t, vres, m')) : do_inline_assembly text sg ge w vargs m = Some (w', t, vres, m').","conclusion":"do_inline_assembly text sg ge w vargs m = Some (w', t, vres, m')","hypotheses":"(text : string) (sg : signature) (clobbers : list string) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : inline_assembly_sem text sg ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg0 : signature),\nbuiltin_or_external_sem name sg0 ge vargs m t vres m' ->\ndo_builtin_or_external name sg0 w vargs m = Some (w', t, vres, m'))","proofString":"eapply do_inline_assembly_complete; eauto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_debug_sem ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m')) : do_ef_debug kind text targs w vargs m = Some (w', t, vres, m').","conclusion":"do_ef_debug kind text targs w vargs m = Some (w', t, vres, m')","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (m : mem) (w' : world) (t : trace) (vres : val) (m' : mem) (H : extcall_debug_sem ge vargs m t vres m') (H0 : possible_trace w t w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m t vres m' ->\ndo_builtin_or_external name sg w vargs m = Some (w', t, vres, m'))","proofString":"inv H.\ninv H0.\nreflexivity."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' E0 Vundef m' ->\ndo_builtin_or_external name sg w vargs m' = Some (w', E0, Vundef, m')) : do_ef_debug kind text targs w vargs m' = Some (w', E0, Vundef, m').","conclusion":"do_ef_debug kind text targs w vargs m' = Some (w', E0, Vundef, m')","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (w : world) (vargs : list val) (w' : world) (m' : mem) (H0 : possible_trace w E0 w') (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' E0 Vundef m' ->\ndo_builtin_or_external name sg w vargs m' = Some (w', E0, Vundef, m'))","proofString":"inv H0.\nreflexivity."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' E0 Vundef m' ->\ndo_builtin_or_external name sg w' vargs m' = Some (w', E0, Vundef, m')) : do_ef_debug kind text targs w' vargs m' = Some (w', E0, Vundef, m').","conclusion":"do_ef_debug kind text targs w' vargs m' = Some (w', E0, Vundef, m')","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (vargs : list val) (w' : world) (m' : mem) (SIZE : forall n : ptrofs, do_alloc_size (Vptrofs n) = Some n) (BF_EX : forall (name : string) (sg : signature),\nbuiltin_or_external_sem name sg ge vargs m' E0 Vundef m' ->\ndo_builtin_or_external name sg w' vargs m' = Some (w', E0, Vundef, m'))","proofString":"reflexivity."},{"statement":"(v : val) (ty : type) (m : mem) : imm_safe ge e RV (Eval v ty) m.","conclusion":"imm_safe ge e RV (Eval v ty) m","hypotheses":"(v : val) (ty : type) (m : mem)","proofString":"constructor."},{"statement":"(b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) : imm_safe ge e LV (Eloc b ofs bf ty) m.","conclusion":"imm_safe ge e LV (Eloc b ofs bf ty) m","hypotheses":"(b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem)","proofString":"constructor."},{"statement":"(to : kind) (C : expr -> expr) (l : expr) (m : mem) (l' : expr) (m' : mem) (H : lred ge e l m l' m') (H0 : context LV to C) : imm_safe ge e to (C l) m.","conclusion":"imm_safe ge e to (C l) m","hypotheses":"(to : kind) (C : expr -> expr) (l : expr) (m : mem) (l' : expr) (m' : mem) (H : lred ge e l m l' m') (H0 : context LV to C)","proofString":"eapply imm_safe_lred; eauto."},{"statement":"(to : kind) (C : expr -> expr) (r : expr) (m : mem) (t : trace) (r' : expr) (m' : mem) (w' : world) (H : rred ge r m t r' m') (H0 : possible_trace w t w') (H1 : context RV to C) : imm_safe ge e to (C r) m.","conclusion":"imm_safe ge e to (C r) m","hypotheses":"(to : kind) (C : expr -> expr) (r : expr) (m : mem) (t : trace) (r' : expr) (m' : mem) (w' : world) (H : rred ge r m t r' m') (H0 : possible_trace w t w') (H1 : context RV to C)","proofString":"eapply imm_safe_rred; eauto."},{"statement":"(to : kind) (C : expr -> expr) (r : expr) (m : mem) (fd : fundef) (args : list val) (ty : type) (H : callred ge r m fd args ty) (H0 : context RV to C) : imm_safe ge e to (C r) m.","conclusion":"imm_safe ge e to (C r) m","hypotheses":"(to : kind) (C : expr -> expr) (r : expr) (m : mem) (fd : fundef) (args : list val) (ty : type) (H : callred ge r m fd args ty) (H0 : context RV to C)","proofString":"eapply imm_safe_callred; eauto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty)) : exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0.","conclusion":"exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty))","proofString":"exists b; auto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b) : exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0.","conclusion":"exists b0 : block,\n  e ! x = Some (b0, ty) \\/ e ! x = None /\\ Genv.find_symbol ge x = Some b0","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b)","proofString":"exists b; auto."},{"statement":"(b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) : exists (b0 : block) (ofs0 : ptrofs), Vptr b ofs = Vptr b0 ofs0.","conclusion":"exists (b0 : block) (ofs0 : ptrofs), Vptr b ofs = Vptr b0 ofs0","hypotheses":"(b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem)","proofString":"exists b; exists ofs; auto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w') : ty = ty /\\\n(exists (t0 : trace) (v0 : val) (w'0 : world),\n   deref_loc ge ty m b ofs bf t0 v0 /\\ possible_trace w t0 w'0).","conclusion":"ty = ty /\\\n(exists (t0 : trace) (v0 : val) (w'0 : world),\n   deref_loc ge ty m b ofs bf t0 v0 /\\ possible_trace w t0 w'0)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w')","proofString":"split; auto; exists t; exists v; exists w'; auto."},{"statement":"(w' : world) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (H0 : possible_trace w E0 w') : exists v0 : val, sem_unary_operation op v1 ty1 m = Some v0.","conclusion":"exists v0 : val, sem_unary_operation op v1 ty1 m = Some v0","hypotheses":"(w' : world) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (H0 : possible_trace w E0 w')","proofString":"exists v; auto."},{"statement":"(w' : world) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (H0 : possible_trace w E0 w') : exists v0 : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v0.","conclusion":"exists v0 : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v0","hypotheses":"(w' : world) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (H0 : possible_trace w E0 w')","proofString":"exists v; auto."},{"statement":"(w' : world) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (H0 : possible_trace w E0 w') : exists v0 : val, sem_cast v1 ty1 ty m = Some v0.","conclusion":"exists v0 : val, sem_cast v1 ty1 ty m = Some v0","hypotheses":"(w' : world) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (H0 : possible_trace w E0 w')","proofString":"exists v; auto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w') : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w')","proofString":"exists true; auto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w') : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w')","proofString":"exists false; auto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w') : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w')","proofString":"exists true; auto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w') : exists b : bool, bool_val v1 ty1 m = Some b.","conclusion":"exists b : bool, bool_val v1 ty1 m = Some b","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w')","proofString":"exists false; auto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (H0 : possible_trace w E0 w') : exists b0 : bool, bool_val v1 ty1 m = Some b0.","conclusion":"exists b0 : bool, bool_val v1 ty1 m = Some b0","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (H0 : possible_trace w E0 w')","proofString":"exists b; auto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w') : exists (v0 : val) (m'0 : mem) (v'0 : val) (t0 : trace) \n(w'0 : world),\n  ty1 = ty1 /\\\n  sem_cast v2 ty2 ty1 m = Some v0 /\\\n  assign_loc ge ty1 m b ofs bf v0 t0 m'0 v'0 /\\ possible_trace w t0 w'0.","conclusion":"exists (v0 : val) (m'0 : mem) (v'0 : val) (t0 : trace) \n(w'0 : world),\n  ty1 = ty1 /\\\n  sem_cast v2 ty2 ty1 m = Some v0 /\\\n  assign_loc ge ty1 m b ofs bf v0 t0 m'0 v'0 /\\ possible_trace w t0 w'0","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w')","proofString":"exists v; exists m'; exists v'; exists t; exists w'; auto."},{"statement":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w') : exists (t0 : trace) (v0 : val) (w'0 : world),\n  ty1 = ty1 /\\ deref_loc ge ty1 m b ofs bf t0 v0 /\\ possible_trace w t0 w'0.","conclusion":"exists (t0 : trace) (v0 : val) (w'0 : world),\n  ty1 = ty1 /\\ deref_loc ge ty1 m b ofs bf t0 v0 /\\ possible_trace w t0 w'0","hypotheses":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w')","proofString":"exists t; exists v1; exists w'; auto."},{"statement":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (H1 : possible_trace w t w') : exists (t0 : trace) (v0 : val) (w'0 : world),\n  ty = ty /\\ deref_loc ge ty m b ofs bf t0 v0 /\\ possible_trace w t0 w'0.","conclusion":"exists (t0 : trace) (v0 : val) (w'0 : world),\n  ty = ty /\\ deref_loc ge ty m b ofs bf t0 v0 /\\ possible_trace w t0 w'0","hypotheses":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (H1 : possible_trace w t w')","proofString":"exists t; exists v1; exists w'; auto."},{"statement":"(w' : world) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (H0 : possible_trace w E0 w') : exists v0 : val, sem_cast v1 ty1 ty2 m = Some v0.","conclusion":"exists v0 : val, sem_cast v1 ty1 ty2 m = Some v0","hypotheses":"(w' : world) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (H0 : possible_trace w E0 w')","proofString":"exists v; auto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') : exprlist_all_values el ->\nexists\n  (vargs0 : list val) (t0 : trace) (vres0 : val) (m'0 : mem) \n(w'0 : world),\n  cast_arguments m el tyargs vargs0 /\\\n  external_call ef ge vargs0 m t0 vres0 m'0 /\\ possible_trace w t0 w'0.","conclusion":"exprlist_all_values el ->\nexists\n  (vargs0 : list val) (t0 : trace) (vres0 : val) (m'0 : mem) \n(w'0 : world),\n  cast_arguments m el tyargs vargs0 /\\\n  external_call ef ge vargs0 m t0 vres0 m'0 /\\ possible_trace w t0 w'0","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w')","proofString":"intros; exists vargs; exists t; exists vres; exists m'; exists w'; auto."},{"statement":"(r : expr) (fd : fundef) (args : list val) (ty : type) (m : mem) (H : callred ge r m fd args ty) : invert_expr_prop r m.","conclusion":"invert_expr_prop r m","hypotheses":"(r : expr) (fd : fundef) (args : list val) (ty : type) (m : mem) (H : callred ge r m fd args ty)","proofString":"inv H.\nsimpl.\nintros.\nexists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) : invert_expr_prop (Ecall (Eval vf tyf) el ty) m.","conclusion":"invert_expr_prop (Ecall (Eval vf tyf) el ty) m","hypotheses":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"simpl.\nintros.\nexists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) : exprlist_all_values el ->\nexists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0.","conclusion":"exprlist_all_values el ->\nexists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0","hypotheses":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"intros.\nexists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) (H : exprlist_all_values el) : exists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0.","conclusion":"exists\n  (tyargs0 : list type) (tyres0 : type) (cconv0 : calling_convention) \n(fd0 : fundef) (vl : list val),\n  classify_fun tyf = fun_case_f tyargs0 tyres0 cconv0 /\\\n  Genv.find_funct ge vf = Some fd0 /\\\n  cast_arguments m el tyargs0 vl /\\\n  type_of_fundef fd0 = Tfunction tyargs0 tyres0 cconv0","hypotheses":"(fd : fundef) (args : list val) (ty : type) (m : mem) (vf : val) (tyf : type) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (H0 : Genv.find_funct ge vf = Some fd) (H1 : cast_arguments m el tyargs args) (H2 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H3 : classify_fun tyf = fun_case_f tyargs tyres cconv) (H : exprlist_all_values el)","proofString":"exists tyargs, tyres, cconv, fd, args; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : invert_expr_prop a m) : invert_expr_prop a m.","conclusion":"invert_expr_prop a m","hypotheses":"(k : kind) (a : expr) (m : mem) (H : invert_expr_prop a m)","proofString":"auto."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v _ => exists (b : block) (ofs : ptrofs), v = Vptr b ofs\n| _ => True\nend.","conclusion":"match C a with\n| Eval v _ => exists (b : block) (ofs : ptrofs), v = Vptr b ofs\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty' =>\n    ty' = ty /\\\n    (exists (t : trace) (v : val) (w' : world),\n       deref_loc ge ty m b ofs bf t v /\\ possible_trace w t w')\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty' =>\n    ty' = ty /\\\n    (exists (t : trace) (v : val) (w' : world),\n       deref_loc ge ty m b ofs bf t v /\\ possible_trace w t w')\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc _ _ bf _ => bf = Full\n| _ => True\nend.","conclusion":"match C a with\n| Eloc _ _ bf _ => bf = Full\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : unary_operation) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists v : val, sem_unary_operation op v1 ty1 m = Some v\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists v : val, sem_unary_operation op v1 ty1 m = Some v\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : unary_operation) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match e1 with\n| Eval v1 ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match e1 with\n| Eval v1 ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists v : val, sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct e1; auto; destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 ty m = Some v\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 ty m = Some v\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists b : bool, bool_val v1 ty1 m = Some b\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace) \n        (w' : world),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v' /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace) \n        (w' : world),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v' /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace) \n        (w' : world),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v' /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval v2 ty2 =>\n        exists (v : val) (m' : mem) (v' : val) (t : trace) \n        (w' : world),\n          ty = ty1 /\\\n          sem_cast v2 ty2 ty1 m = Some v /\\\n          assign_loc ge ty1 m b ofs bf v t m' v' /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (e1 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct e1; auto; destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (tyres ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val) (w' : world),\n          ty = ty1 /\\\n          deref_loc ge ty1 m b ofs bf t v1 /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty1 =>\n    match e2 with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val) (w' : world),\n          ty = ty1 /\\\n          deref_loc ge ty1 m b ofs bf t v1 /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (tyres ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (tyres ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val) (w' : world),\n          ty = ty1 /\\\n          deref_loc ge ty1 m b ofs bf t v1 /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend.","conclusion":"match e1 with\n| Eloc b ofs bf ty1 =>\n    match C a with\n    | Eval _ _ =>\n        exists (t : trace) (v1 : val) (w' : world),\n          ty = ty1 /\\\n          deref_loc ge ty1 m b ofs bf t v1 /\\ possible_trace w t w'\n    | _ => True\n    end\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (tyres ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct e1; auto; destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (id : incr_or_decr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eloc b ofs bf ty1 =>\n    exists (t : trace) (v1 : val) (w' : world),\n      ty = ty1 /\\ deref_loc ge ty m b ofs bf t v1 /\\ possible_trace w t w'\n| _ => True\nend.","conclusion":"match C a with\n| Eloc b ofs bf ty1 =>\n    exists (t : trace) (v1 : val) (w' : world),\n      ty = ty1 /\\ deref_loc ge ty m b ofs bf t v1 /\\ possible_trace w t w'\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (id : incr_or_decr) (ty : type) (H : context k LV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval vf tyf =>\n    exprlist_all_values el ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m el tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend.","conclusion":"match C a with\n| Eval vf tyf =>\n    exprlist_all_values el ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m el tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : match e1 with\n| Eval vf tyf =>\n    exprlist_all_values (C a) ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m (C a) tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend.","conclusion":"match e1 with\n| Eval vf tyf =>\n    exprlist_all_values (C a) ->\n    exists\n      (tyargs : list type) (tyres : type) (cconv : calling_convention) \n    (fd : fundef) (vl : list val),\n      classify_fun tyf = fun_case_f tyargs tyres cconv /\\\n      Genv.find_funct ge vf = Some fd /\\\n      cast_arguments m (C a) tyargs vl /\\\n      type_of_fundef fd = Tfunction tyargs tyres cconv\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"destruct e1; auto.\nintros.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : exprlist_all_values (C a) ->\nexists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv.","conclusion":"exprlist_all_values (C a) ->\nexists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv","hypotheses":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"intros.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a)) : exists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv.","conclusion":"exists\n  (tyargs : list type) (tyres : type) (cconv : calling_convention) \n(fd : fundef) (vl : list val),\n  classify_fun ty0 = fun_case_f tyargs tyres cconv /\\\n  Genv.find_funct ge v = Some fd /\\\n  cast_arguments m (C a) tyargs vl /\\\n  type_of_fundef fd = Tfunction tyargs tyres cconv","hypotheses":"(k : kind) (C : expr -> exprlist) (v : val) (ty0 ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a))","proofString":"elim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : exprlist_all_values (C a) ->\nexists (vargs : list val) (t : trace) (vres : val) \n(m' : mem) (w' : world),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"exprlist_all_values (C a) ->\nexists (vargs : list val) (t : trace) (vres : val) \n(m' : mem) (w' : world),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"intros.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a)) : exists (vargs : list val) (t : trace) (vres : val) \n(m' : mem) (w' : world),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m' /\\ possible_trace w t w'.","conclusion":"exists (vargs : list val) (t : trace) (vres : val) \n(m' : mem) (w' : world),\n  cast_arguments m (C a) tyargs vargs /\\\n  external_call ef ge vargs m t vres m' /\\ possible_trace w t w'","hypotheses":"(k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a))","proofString":"elim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval _ _ => typeof e2 = ty\n| _ => True\nend.","conclusion":"match C a with\n| Eval _ _ => typeof e2 = ty\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (tycast ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 tycast m = Some v\n| _ => True\nend.","conclusion":"match C a with\n| Eval v1 ty1 => exists v : val, sem_cast v1 ty1 tycast m = Some v\n| _ => True\nend","hypotheses":"(k : kind) (C : expr -> expr) (tycast ty : type) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"destruct (C a); auto; contradiction."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) : ~ match C a with\n  | Eval _ _ => exprlist_all_values el\n  | _ => False\n  end.","conclusion":"~ match C a with\n  | Eval _ _ => exprlist_all_values el\n  | _ => False\n  end","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m)","proofString":"red; intros.\ndestruct (C a); auto."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) (H3 : match C a with\n| Eval _ _ => exprlist_all_values el\n| _ => False\nend) : False.","conclusion":"False","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : invert_expr_prop (C a) m) (H3 : match C a with\n| Eval _ _ => exprlist_all_values el\n| _ => False\nend)","proofString":"destruct (C a); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) : ~ match e1 with\n  | Eval _ _ => exprlist_all_values (C a)\n  | _ => False\n  end.","conclusion":"~ match e1 with\n  | Eval _ _ => exprlist_all_values (C a)\n  | _ => False\n  end","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m)","proofString":"red; intros.\ndestruct e1; auto.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : match e1 with\n| Eval _ _ => exprlist_all_values (C a)\n| _ => False\nend) : False.","conclusion":"False","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : match e1 with\n| Eval _ _ => exprlist_all_values (C a)\n| _ => False\nend)","proofString":"destruct e1; auto.\nelim (H0 a m); auto."},{"statement":"(k : kind) (C : expr -> exprlist) (v : val) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a)) : False.","conclusion":"False","hypotheses":"(k : kind) (C : expr -> exprlist) (v : val) (ty : type) (H : contextlist k C) (H0 : forall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (a : expr) (m : mem) (H1 : invert_expr_prop a m) (H2 : exprlist_all_values (C a))","proofString":"elim (H0 a m); auto."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m : mem), invert_expr_prop a m -> invert_expr_prop (C a) m) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m : mem),\ninvert_expr_prop a m -> ~ exprlist_all_values (C a)) : forall (k : kind) (a : expr) (m : mem),\nimm_safe_t k a m ->\nmatch a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend.","conclusion":"forall (k : kind) (a : expr) (m : mem),\nimm_safe_t k a m ->\nmatch a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m : mem), invert_expr_prop a m -> invert_expr_prop (C a) m) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m : mem),\ninvert_expr_prop a m -> ~ exprlist_all_values (C a))","proofString":"intros.\ninv H.\nauto.\nauto.\nassert (invert_expr_prop (C l) m).\neapply A; eauto.\neapply lred_invert; eauto.\nred in H.\ndestruct (C l); auto; contradiction.\nassert (invert_expr_prop (C r) m).\neapply A; eauto.\neapply rred_invert; eauto.\nred in H.\ndestruct (C r); auto; contradiction.\nassert (invert_expr_prop (C r) m).\neapply A; eauto.\neapply callred_invert; eauto.\nred in H.\ndestruct (C r); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (k : kind) (a : expr) (m : mem) (H : imm_safe_t k a m) : match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend.","conclusion":"match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> invert_expr_prop (C a0) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a0 : expr) (m0 : mem),\ninvert_expr_prop a0 m0 -> ~ exprlist_all_values (C a0)) (k : kind) (a : expr) (m : mem) (H : imm_safe_t k a m)","proofString":"inv H.\nauto.\nauto.\nassert (invert_expr_prop (C l) m).\neapply A; eauto.\neapply lred_invert; eauto.\nred in H.\ndestruct (C l); auto; contradiction.\nassert (invert_expr_prop (C r) m).\neapply A; eauto.\neapply rred_invert; eauto.\nred in H.\ndestruct (C r); auto; contradiction.\nassert (invert_expr_prop (C r) m).\neapply A; eauto.\neapply callred_invert; eauto.\nred in H.\ndestruct (C r); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (v : val) (ty : type) : True.","conclusion":"True","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (v : val) (ty : type)","proofString":"auto."},{"statement":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) : True.","conclusion":"True","hypotheses":"(A : forall (from to : kind) (C : expr -> expr),\ncontext from to C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C a) m0) (B : forall (from : kind) (C : expr -> exprlist),\ncontextlist from C ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C a)) (m : mem) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield)","proofString":"auto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C) : match C l with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C l) m\nend.","conclusion":"match C l with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C l) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C)","proofString":"assert (invert_expr_prop (C l) m).\neapply A; eauto.\neapply lred_invert; eauto.\nred in H.\ndestruct (C l); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C) : invert_expr_prop (C l) m.","conclusion":"invert_expr_prop (C l) m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C)","proofString":"eapply A; eauto.\neapply lred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C) : invert_expr_prop l m.","conclusion":"invert_expr_prop l m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C)","proofString":"eapply lred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C) (H : invert_expr_prop (C l) m) : match C l with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C l) m\nend.","conclusion":"match C l with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C l) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (l l' : expr) (m' : mem) (H0 : lred ge e l m l' m') (H1 : context LV k C) (H : invert_expr_prop (C l) m)","proofString":"red in H.\ndestruct (C l); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C) : match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend.","conclusion":"match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C)","proofString":"assert (invert_expr_prop (C r) m).\neapply A; eauto.\neapply rred_invert; eauto.\nred in H.\ndestruct (C r); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C) : invert_expr_prop (C r) m.","conclusion":"invert_expr_prop (C r) m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C)","proofString":"eapply A; eauto.\neapply rred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C) : invert_expr_prop r m.","conclusion":"invert_expr_prop r m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C)","proofString":"eapply rred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C) (H : invert_expr_prop (C r) m) : match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend.","conclusion":"match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (t : trace) (r' : expr) (m' : mem) (w' : world) (H0 : rred ge r m t r' m') (H1 : possible_trace w t w') (H2 : context RV k C) (H : invert_expr_prop (C r) m)","proofString":"red in H.\ndestruct (C r); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C) : match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend.","conclusion":"match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C)","proofString":"assert (invert_expr_prop (C r) m).\neapply A; eauto.\neapply callred_invert; eauto.\nred in H.\ndestruct (C r); auto; contradiction."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C) : invert_expr_prop (C r) m.","conclusion":"invert_expr_prop (C r) m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C)","proofString":"eapply A; eauto.\neapply callred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C) : invert_expr_prop r m.","conclusion":"invert_expr_prop r m","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C)","proofString":"eapply callred_invert; eauto."},{"statement":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C) (H : invert_expr_prop (C r) m) : match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend.","conclusion":"match C r with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop (C r) m\nend","hypotheses":"(A : forall (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> invert_expr_prop (C0 a) m0) (B : forall (from : kind) (C0 : expr -> exprlist),\ncontextlist from C0 ->\nforall (a : expr) (m0 : mem),\ninvert_expr_prop a m0 -> ~ exprlist_all_values (C0 a)) (k : kind) (m : mem) (C : expr -> expr) (r : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge r m fd args ty) (H1 : context RV k C) (H : invert_expr_prop (C r) m)","proofString":"red in H.\ndestruct (C r); auto; contradiction."},{"statement":"(m : mem) (vtl : list (val * type)) (tyargs : list type) (vargs : list val) (H : Some nil = Some vtl) (H0 : sem_cast_arguments vtl tyargs m = Some vargs) : cast_arguments m Enil tyargs vargs.","conclusion":"cast_arguments m Enil tyargs vargs","hypotheses":"(m : mem) (vtl : list (val * type)) (tyargs : list type) (vargs : list val) (H : Some nil = Some vtl) (H0 : sem_cast_arguments vtl tyargs m = Some vargs)","proofString":"inv H.\ndestruct tyargs; simpl in H0; inv H0.\nconstructor."},{"statement":"(m : mem) (tyargs : list type) (vargs : list val) (H0 : sem_cast_arguments nil tyargs m = Some vargs) : cast_arguments m Enil tyargs vargs.","conclusion":"cast_arguments m Enil tyargs vargs","hypotheses":"(m : mem) (tyargs : list type) (vargs : list val) (H0 : sem_cast_arguments nil tyargs m = Some vargs)","proofString":"destruct tyargs; simpl in H0; inv H0.\nconstructor."},{"statement":"(m : mem) : cast_arguments m Enil nil nil.","conclusion":"cast_arguments m Enil nil nil","hypotheses":"(m : mem)","proofString":"constructor."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (IHrargs : forall (vtl0 : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nis_val_list rargs = Some vtl0 ->\nsem_cast_arguments vtl0 tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (vtl : list (val * type)) (tyargs : list type) (vargs : list val) (H : match is_val r1 with\n| Some vt1 =>\n    match is_val_list rargs with\n    | Some vtl0 => Some (vt1 :: vtl0)\n    | None => None\n    end\n| None => None\nend = Some vtl) (H0 : sem_cast_arguments vtl tyargs m = Some vargs) : cast_arguments m (Econs r1 rargs) tyargs vargs.","conclusion":"cast_arguments m (Econs r1 rargs) tyargs vargs","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (IHrargs : forall (vtl0 : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nis_val_list rargs = Some vtl0 ->\nsem_cast_arguments vtl0 tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (vtl : list (val * type)) (tyargs : list type) (vargs : list val) (H : match is_val r1 with\n| Some vt1 =>\n    match is_val_list rargs with\n    | Some vtl0 => Some (vt1 :: vtl0)\n    | None => None\n    end\n| None => None\nend = Some vtl) (H0 : sem_cast_arguments vtl tyargs m = Some vargs)","proofString":"monadInv.\ninv H.\nsimpl in H0.\ndestruct p as [v1 t1].\ndestruct tyargs; try congruence.\nmonadInv.\ninv H0.\nrewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl0 : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl0 ->\nsem_cast_arguments vtl0 tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (vtl : list (val * type)) (tyargs : list type) (vargs : list val) (p : val * type) (Heqo : is_val r1 = Some p) (H : Some (p :: l) = Some vtl) (H0 : sem_cast_arguments vtl tyargs m = Some vargs) : cast_arguments m (Econs r1 rargs) tyargs vargs.","conclusion":"cast_arguments m (Econs r1 rargs) tyargs vargs","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl0 : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl0 ->\nsem_cast_arguments vtl0 tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (vtl : list (val * type)) (tyargs : list type) (vargs : list val) (p : val * type) (Heqo : is_val r1 = Some p) (H : Some (p :: l) = Some vtl) (H0 : sem_cast_arguments vtl tyargs m = Some vargs)","proofString":"inv H.\nsimpl in H0.\ndestruct p as [v1 t1].\ndestruct tyargs; try congruence.\nmonadInv.\ninv H0.\nrewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (tyargs : list type) (vargs : list val) (p : val * type) (Heqo : is_val r1 = Some p) (H0 : sem_cast_arguments (p :: l) tyargs m = Some vargs) : cast_arguments m (Econs r1 rargs) tyargs vargs.","conclusion":"cast_arguments m (Econs r1 rargs) tyargs vargs","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (tyargs : list type) (vargs : list val) (p : val * type) (Heqo : is_val r1 = Some p) (H0 : sem_cast_arguments (p :: l) tyargs m = Some vargs)","proofString":"simpl in H0.\ndestruct p as [v1 t1].\ndestruct tyargs; try congruence.\nmonadInv.\ninv H0.\nrewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (tyargs : list type) (vargs : list val) (p : val * type) (Heqo : is_val r1 = Some p) (H0 : (let (v1, t1) := p in\n match tyargs with\n | nil => None\n | t1' :: tl =>\n     match sem_cast v1 t1 t1' m with\n     | Some v =>\n         match sem_cast_arguments l tl m with\n         | Some vl => Some (v :: vl)\n         | None => None\n         end\n     | None => None\n     end\n end) = Some vargs) : cast_arguments m (Econs r1 rargs) tyargs vargs.","conclusion":"cast_arguments m (Econs r1 rargs) tyargs vargs","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (tyargs : list type) (vargs : list val) (p : val * type) (Heqo : is_val r1 = Some p) (H0 : (let (v1, t1) := p in\n match tyargs with\n | nil => None\n | t1' :: tl =>\n     match sem_cast v1 t1 t1' m with\n     | Some v =>\n         match sem_cast_arguments l tl m with\n         | Some vl => Some (v :: vl)\n         | None => None\n         end\n     | None => None\n     end\n end) = Some vargs)","proofString":"destruct p as [v1 t1].\ndestruct tyargs; try congruence.\nmonadInv.\ninv H0.\nrewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (tyargs : list type) (vargs : list val) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (H0 : match tyargs with\n| nil => None\n| t1' :: tl =>\n    match sem_cast v1 t1 t1' m with\n    | Some v =>\n        match sem_cast_arguments l tl m with\n        | Some vl => Some (v :: vl)\n        | None => None\n        end\n    | None => None\n    end\nend = Some vargs) : cast_arguments m (Econs r1 rargs) tyargs vargs.","conclusion":"cast_arguments m (Econs r1 rargs) tyargs vargs","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (tyargs : list type) (vargs : list val) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (H0 : match tyargs with\n| nil => None\n| t1' :: tl =>\n    match sem_cast v1 t1 t1' m with\n    | Some v =>\n        match sem_cast_arguments l tl m with\n        | Some vl => Some (v :: vl)\n        | None => None\n        end\n    | None => None\n    end\nend = Some vargs)","proofString":"destruct tyargs; try congruence.\nmonadInv.\ninv H0.\nrewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (t : type) (tyargs : list type) (vargs : list val) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (H0 : match sem_cast v1 t1 t m with\n| Some v =>\n    match sem_cast_arguments l tyargs m with\n    | Some vl => Some (v :: vl)\n    | None => None\n    end\n| None => None\nend = Some vargs) : cast_arguments m (Econs r1 rargs) (t :: tyargs) vargs.","conclusion":"cast_arguments m (Econs r1 rargs) (t :: tyargs) vargs","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (t : type) (tyargs : list type) (vargs : list val) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (H0 : match sem_cast v1 t1 t m with\n| Some v =>\n    match sem_cast_arguments l tyargs m with\n    | Some vl => Some (v :: vl)\n    | None => None\n    end\n| None => None\nend = Some vargs)","proofString":"monadInv.\ninv H0.\nrewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (t : type) (tyargs : list type) (vargs : list val) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0) (H0 : Some (v :: l0) = Some vargs) : cast_arguments m (Econs r1 rargs) (t :: tyargs) vargs.","conclusion":"cast_arguments m (Econs r1 rargs) (t :: tyargs) vargs","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs0 : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs0 ->\ncast_arguments m rargs tyargs0 vargs0) (t : type) (tyargs : list type) (vargs : list val) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0) (H0 : Some (v :: l0) = Some vargs)","proofString":"inv H0.\nrewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0) : cast_arguments m (Econs r1 rargs) (t :: tyargs) (v :: l0).","conclusion":"cast_arguments m (Econs r1 rargs) (t :: tyargs) (v :: l0)","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0)","proofString":"rewrite (is_val_inv _ _ _ Heqo).\nconstructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0) : cast_arguments m (Econs (Eval v1 t1) rargs) (t :: tyargs) (v :: l0).","conclusion":"cast_arguments m (Econs (Eval v1 t1) rargs) (t :: tyargs) (v :: l0)","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0)","proofString":"constructor.\nauto.\neauto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0) : sem_cast v1 t1 t m = Some v.","conclusion":"sem_cast v1 t1 t m = Some v","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0)","proofString":"auto."},{"statement":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0) : cast_arguments m rargs tyargs l0.","conclusion":"cast_arguments m rargs tyargs l0","hypotheses":"(m : mem) (r1 : expr) (rargs : exprlist) (l : list (val * type)) (Heqo0 : is_val_list rargs = Some l) (IHrargs : forall (vtl : list (val * type)) (tyargs0 : list type) (vargs : list val),\nSome l = Some vtl ->\nsem_cast_arguments vtl tyargs0 m = Some vargs ->\ncast_arguments m rargs tyargs0 vargs) (t : type) (tyargs : list type) (v1 : val) (t1 : type) (Heqo : is_val r1 = Some (v1, t1)) (v : val) (Heqo1 : sem_cast v1 t1 t m = Some v) (l0 : list val) (Heqo2 : sem_cast_arguments l tyargs m = Some l0)","proofString":"eauto."},{"statement":"(m : mem) : exists vtl : list (val * type),\n  is_val_list Enil = Some vtl /\\ sem_cast_arguments vtl nil m = Some nil.","conclusion":"exists vtl : list (val * type),\n  is_val_list Enil = Some vtl /\\ sem_cast_arguments vtl nil m = Some nil","hypotheses":"(m : mem)","proofString":"exists (@nil (val * type)); auto."},{"statement":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (IHcast_arguments : exists vtl : list (val * type),\n  is_val_list el = Some vtl /\\ sem_cast_arguments vtl targs m = Some vl) : exists vtl : list (val * type),\n  is_val_list (Econs (Eval v ty) el) = Some vtl /\\\n  sem_cast_arguments vtl (targ1 :: targs) m = Some (v1 :: vl).","conclusion":"exists vtl : list (val * type),\n  is_val_list (Econs (Eval v ty) el) = Some vtl /\\\n  sem_cast_arguments vtl (targ1 :: targs) m = Some (v1 :: vl)","hypotheses":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (IHcast_arguments : exists vtl : list (val * type),\n  is_val_list el = Some vtl /\\ sem_cast_arguments vtl targs m = Some vl)","proofString":"destruct IHcast_arguments as [vtl [A B]].\nexists ((v, ty) :: vtl); simpl.\nrewrite A; rewrite B; rewrite H.\nauto."},{"statement":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl targs m = Some vl) : exists vtl0 : list (val * type),\n  is_val_list (Econs (Eval v ty) el) = Some vtl0 /\\\n  sem_cast_arguments vtl0 (targ1 :: targs) m = Some (v1 :: vl).","conclusion":"exists vtl0 : list (val * type),\n  is_val_list (Econs (Eval v ty) el) = Some vtl0 /\\\n  sem_cast_arguments vtl0 (targ1 :: targs) m = Some (v1 :: vl)","hypotheses":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl targs m = Some vl)","proofString":"exists ((v, ty) :: vtl); simpl.\nrewrite A; rewrite B; rewrite H.\nauto."},{"statement":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl targs m = Some vl) : match is_val_list el with\n| Some vtl0 => Some ((v, ty) :: vtl0)\n| None => None\nend = Some ((v, ty) :: vtl) /\\\nmatch sem_cast v ty targ1 m with\n| Some v0 =>\n    match sem_cast_arguments vtl targs m with\n    | Some vl0 => Some (v0 :: vl0)\n    | None => None\n    end\n| None => None\nend = Some (v1 :: vl).","conclusion":"match is_val_list el with\n| Some vtl0 => Some ((v, ty) :: vtl0)\n| None => None\nend = Some ((v, ty) :: vtl) /\\\nmatch sem_cast v ty targ1 m with\n| Some v0 =>\n    match sem_cast_arguments vtl targs m with\n    | Some vl0 => Some (v0 :: vl0)\n    | None => None\n    end\n| None => None\nend = Some (v1 :: vl)","hypotheses":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl targs m = Some vl)","proofString":"rewrite A; rewrite B; rewrite H.\nauto."},{"statement":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl targs m = Some vl) : Some ((v, ty) :: vtl) = Some ((v, ty) :: vtl) /\\\nSome (v1 :: vl) = Some (v1 :: vl).","conclusion":"Some ((v, ty) :: vtl) = Some ((v, ty) :: vtl) /\\\nSome (v1 :: vl) = Some (v1 :: vl)","hypotheses":"(m : mem) (v : val) (ty : type) (el : exprlist) (targ1 : type) (targs : list type) (v1 : val) (vl : list val) (H : sem_cast v ty targ1 m = Some v1) (H0 : cast_arguments m el targs vl) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl targs m = Some vl)","proofString":"auto."},{"statement":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd) : reducts_ok k a m (topred rd).","conclusion":"reducts_ok k a m (topred rd)","hypotheses":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd)","proofString":"unfold topred; split; simpl; intros.\ndestruct H0; try contradiction.\ninv H0.\nexists a; exists k; auto.\ncongruence."},{"statement":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd) (C : expr -> expr) (rd0 : reduction) (H0 : (fun x : expr => x, rd) = (C, rd0) \\/ False) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd0.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd0","hypotheses":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd) (C : expr -> expr) (rd0 : reduction) (H0 : (fun x : expr => x, rd) = (C, rd0) \\/ False)","proofString":"destruct H0; try contradiction.\ninv H0.\nexists a; exists k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd) (C : expr -> expr) (rd0 : reduction) (H0 : (fun x : expr => x, rd) = (C, rd0)) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd0.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd0","hypotheses":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd) (C : expr -> expr) (rd0 : reduction) (H0 : (fun x : expr => x, rd) = (C, rd0))","proofString":"inv H0.\nexists a; exists k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (rd0 : reduction) (H : reduction_ok k a m rd0) : exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => x) /\\ a = a' /\\ reduction_ok k' a' m rd0.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => x) /\\ a = a' /\\ reduction_ok k' a' m rd0","hypotheses":"(k : kind) (a : expr) (m : mem) (rd0 : reduction) (H : reduction_ok k a m rd0)","proofString":"exists a; exists k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd) (H0 : (fun x : expr => x, rd) :: nil = nil) : match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend.","conclusion":"match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend","hypotheses":"(k : kind) (a : expr) (m : mem) (rd : reduction) (H : reduction_ok k a m rd) (H0 : (fun x : expr => x, rd) :: nil = nil)","proofString":"congruence."},{"statement":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) : reducts_ok k a m stuck.","conclusion":"reducts_ok k a m stuck","hypotheses":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m)","proofString":"unfold stuck; split; simpl; intros.\ndestruct H0; try contradiction.\ninv H0.\nexists a; exists k; intuition.\nred.\ndestruct k; auto.\ncongruence."},{"statement":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) (C : expr -> expr) (rd : reduction) (H0 : (fun x : expr => x, Stuckred) = (C, rd) \\/ False) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) (C : expr -> expr) (rd : reduction) (H0 : (fun x : expr => x, Stuckred) = (C, rd) \\/ False)","proofString":"destruct H0; try contradiction.\ninv H0.\nexists a; exists k; intuition.\nred.\ndestruct k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) (C : expr -> expr) (rd : reduction) (H0 : (fun x : expr => x, Stuckred) = (C, rd)) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) (C : expr -> expr) (rd : reduction) (H0 : (fun x : expr => x, Stuckred) = (C, rd))","proofString":"inv H0.\nexists a; exists k; intuition.\nred.\ndestruct k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) : exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => x) /\\ a = a' /\\ reduction_ok k' a' m Stuckred.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => x) /\\ a = a' /\\ reduction_ok k' a' m Stuckred","hypotheses":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m)","proofString":"exists a; exists k; intuition.\nred.\ndestruct k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : imm_safe_t k a m -> False) : reduction_ok k a m Stuckred.","conclusion":"reduction_ok k a m Stuckred","hypotheses":"(k : kind) (a : expr) (m : mem) (H : imm_safe_t k a m -> False)","proofString":"red.\ndestruct k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : imm_safe_t k a m -> False) : match k with\n| LV | _ => ~ imm_safe_t k a m\nend.","conclusion":"match k with\n| LV | _ => ~ imm_safe_t k a m\nend","hypotheses":"(k : kind) (a : expr) (m : mem) (H : imm_safe_t k a m -> False)","proofString":"destruct k; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) (H0 : (fun x : expr => x, Stuckred) :: nil = nil) : match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend.","conclusion":"match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend","hypotheses":"(k : kind) (a : expr) (m : mem) (H : ~ imm_safe_t k a m) (H0 : (fun x : expr => x, Stuckred) :: nil = nil)","proofString":"congruence."},{"statement":"(k : kind) (a : expr) (m : mem) (H : k <> Cstrategy.expr_kind a) : reducts_ok k a m stuck.","conclusion":"reducts_ok k a m stuck","hypotheses":"(k : kind) (a : expr) (m : mem) (H : k <> Cstrategy.expr_kind a)","proofString":"apply stuck_ok.\nred; intros.\nexploit Cstrategy.imm_safe_kind; eauto.\neapply imm_safe_t_imm_safe; eauto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : k <> Cstrategy.expr_kind a) : ~ imm_safe_t k a m.","conclusion":"~ imm_safe_t k a m","hypotheses":"(k : kind) (a : expr) (m : mem) (H : k <> Cstrategy.expr_kind a)","proofString":"red; intros.\nexploit Cstrategy.imm_safe_kind; eauto.\neapply imm_safe_t_imm_safe; eauto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : k <> Cstrategy.expr_kind a) (H0 : imm_safe_t k a m) : False.","conclusion":"False","hypotheses":"(k : kind) (a : expr) (m : mem) (H : k <> Cstrategy.expr_kind a) (H0 : imm_safe_t k a m)","proofString":"exploit Cstrategy.imm_safe_kind; eauto.\neapply imm_safe_t_imm_safe; eauto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend) : reducts_ok k a m stuck.","conclusion":"reducts_ok k a m stuck","hypotheses":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend)","proofString":"apply stuck_ok.\nred; intros.\nexploit imm_safe_t_inv; eauto.\ndestruct a; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend) : ~ imm_safe_t k a m.","conclusion":"~ imm_safe_t k a m","hypotheses":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend)","proofString":"red; intros.\nexploit imm_safe_t_inv; eauto.\ndestruct a; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend) (H0 : imm_safe_t k a m) : False.","conclusion":"False","hypotheses":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend) (H0 : imm_safe_t k a m)","proofString":"exploit imm_safe_t_inv; eauto.\ndestruct a; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend) (H0 : imm_safe_t k a m) : match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend -> False.","conclusion":"match a with\n| Eval _ _ | Eloc _ _ _ _ => True\n| _ => invert_expr_prop a m\nend -> False","hypotheses":"(k : kind) (a : expr) (m : mem) (H : match a with\n| Eval _ _ | Eloc _ _ _ _ => False\n| _ => invert_expr_prop a m -> False\nend) (H0 : imm_safe_t k a m)","proofString":"destruct a; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : (forall (C0 : expr -> expr) (rd : reduction),\n In (C0, rd) res ->\n exists (a'0 : expr) (k'0 : kind),\n   context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) /\\\n(res = nil ->\n match k' with\n | LV => is_loc a' <> None\n | RV => is_val a' <> None\n end)) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) : (forall (C0 : expr -> expr) (rd : reduction),\n In (C0, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C (fst z x), snd z)) res) ->\n exists (a'0 : expr) (k'0 : kind),\n   context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C (fst z x), snd z)) res = nil ->\n match k with\n | LV => is_loc a <> None\n | RV => is_val a <> None\n end).","conclusion":"(forall (C0 : expr -> expr) (rd : reduction),\n In (C0, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C (fst z x), snd z)) res) ->\n exists (a'0 : expr) (k'0 : kind),\n   context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C (fst z x), snd z)) res = nil ->\n match k with\n | LV => is_loc a <> None\n | RV => is_val a <> None\n end)","hypotheses":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : (forall (C0 : expr -> expr) (rd : reduction),\n In (C0, rd) res ->\n exists (a'0 : expr) (k'0 : kind),\n   context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) /\\\n(res = nil ->\n match k' with\n | LV => is_loc a' <> None\n | RV => is_val a' <> None\n end)) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend)","proofString":"destruct H.\nsplit; intros.\nexploit list_in_map_inv; eauto.\nintros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto.\ndestruct res; simpl in H4; try congruence.\ndestruct k'; intuition congruence."},{"statement":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) : (forall (C0 : expr -> expr) (rd : reduction),\n In (C0, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C (fst z x), snd z)) res) ->\n exists (a'0 : expr) (k'0 : kind),\n   context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C (fst z x), snd z)) res = nil ->\n match k with\n | LV => is_loc a <> None\n | RV => is_val a <> None\n end).","conclusion":"(forall (C0 : expr -> expr) (rd : reduction),\n In (C0, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C (fst z x), snd z)) res) ->\n exists (a'0 : expr) (k'0 : kind),\n   context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C (fst z x), snd z)) res = nil ->\n match k with\n | LV => is_loc a <> None\n | RV => is_val a <> None\n end)","hypotheses":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend)","proofString":"split; intros.\nexploit list_in_map_inv; eauto.\nintros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto.\ndestruct res; simpl in H4; try congruence.\ndestruct k'; intuition congruence."},{"statement":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C1 : expr -> expr) (rd0 : reduction),\nIn (C1, rd0) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C1 /\\ a' = C1 a'0 /\\ reduction_ok k'0 a'0 m rd0) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C0 : expr -> expr) (rd : reduction) (H4 : In (C0, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) : exists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd.","conclusion":"exists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C1 : expr -> expr) (rd0 : reduction),\nIn (C1, rd0) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C1 /\\ a' = C1 a'0 /\\ reduction_ok k'0 a'0 m rd0) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C0 : expr -> expr) (rd : reduction) (H4 : In (C0, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C1 : expr -> expr) (rd0 : reduction),\nIn (C1, rd0) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C1 /\\ a' = C1 a'0 /\\ reduction_ok k'0 a'0 m rd0) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C0 : expr -> expr) (rd : reduction) (H4 : In (C0, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) : (exists x : (expr -> expr) * reduction,\n   (C0, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => C (fst z x0), snd z)) x /\\ In x res) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd.","conclusion":"(exists x : (expr -> expr) * reduction,\n   (C0, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => C (fst z x0), snd z)) x /\\ In x res) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C1 : expr -> expr) (rd0 : reduction),\nIn (C1, rd0) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C1 /\\ a' = C1 a'0 /\\ reduction_ok k'0 a'0 m rd0) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C0 : expr -> expr) (rd : reduction) (H4 : In (C0, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res))","proofString":"intros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C2 : expr -> expr) (rd0 : reduction),\nIn (C2, rd0) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C2 /\\ a' = C2 a'0 /\\ reduction_ok k'0 a'0 m rd0) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C0 : expr -> expr) (rd : reduction) (H4 : In (C0, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (C1 : expr -> expr) (rd1 : reduction) (P : (C0, rd) = (fun x : expr => C (fst (C1, rd1) x), snd (C1, rd1))) (Q : In (C1, rd1) res) : exists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd.","conclusion":"exists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C2 : expr -> expr) (rd0 : reduction),\nIn (C2, rd0) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C2 /\\ a' = C2 a'0 /\\ reduction_ok k'0 a'0 m rd0) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C0 : expr -> expr) (rd : reduction) (H4 : In (C0, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (C1 : expr -> expr) (rd1 : reduction) (P : (C0, rd) = (fun x : expr => C (fst (C1, rd1) x), snd (C1, rd1))) (Q : In (C1, rd1) res)","proofString":"inv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) : exists (a'0 : expr) (k'0 : kind),\n  context k'0 k (fun x : expr => C (C1 x)) /\\\n  C a' = C (C1 a'0) /\\ reduction_ok k'0 a'0 m rd1.","conclusion":"exists (a'0 : expr) (k'0 : kind),\n  context k'0 k (fun x : expr => C (C1 x)) /\\\n  C a' = C (C1 a'0) /\\ reduction_ok k'0 a'0 m rd1","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res)","proofString":"exploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) : (exists (a'0 : expr) (k'0 : kind),\n   context k'0 k' C1 /\\ a' = C1 a'0 /\\ reduction_ok k'0 a'0 m rd1) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k (fun x : expr => C (C1 x)) /\\\n  C a' = C (C1 a'0) /\\ reduction_ok k'0 a'0 m rd1.","conclusion":"(exists (a'0 : expr) (k'0 : kind),\n   context k'0 k' C1 /\\ a' = C1 a'0 /\\ reduction_ok k'0 a'0 m rd1) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k (fun x : expr => C (C1 x)) /\\\n  C a' = C (C1 a'0) /\\ reduction_ok k'0 a'0 m rd1","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1) : exists (a'0 : expr) (k'0 : kind),\n  context k'0 k (fun x : expr => C (C1 x)) /\\\n  C a' = C (C1 a'0) /\\ reduction_ok k'0 a'0 m rd1.","conclusion":"exists (a'0 : expr) (k'0 : kind),\n  context k'0 k (fun x : expr => C (C1 x)) /\\\n  C a' = C (C1 a'0) /\\ reduction_ok k'0 a'0 m rd1","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"exists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1) : context k'' k (fun x : expr => C (C1 x)) /\\\nC a' = C (C1 a'') /\\ reduction_ok k'' a'' m rd1.","conclusion":"context k'' k (fun x : expr => C (C1 x)) /\\\nC a' = C (C1 a'') /\\ reduction_ok k'' a'' m rd1","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"split.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1) : context k'' k (fun x : expr => C (C1 x)).","conclusion":"context k'' k (fun x : expr => C (C1 x))","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"eapply context_compose; eauto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1) : C a' = C (C1 a'') /\\ reduction_ok k'' a'' m rd1.","conclusion":"C a' = C (C1 a'') /\\ reduction_ok k'' a'' m rd1","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (C1 : expr -> expr) (rd1 : reduction) (H4 : In (fun x : expr => C (C1 x), rd1)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C (fst z x), snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : context k'' k' C1) (V : a' = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"rewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (H4 : map\n  (fun z : (expr -> expr) * reduction => (fun x : expr => C (fst z x), snd z))\n  res = nil) : match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend.","conclusion":"match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend","hypotheses":"(k : kind) (a : expr) (m : mem) (C : expr -> expr) (res : reducts expr) (k' : kind) (a' : expr) (H : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) res ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k' C0 /\\ a' = C0 a'0 /\\ reduction_ok k'0 a'0 m rd) (H3 : res = nil ->\nmatch k' with\n| LV => is_loc a' <> None\n| RV => is_val a' <> None\nend) (H0 : a = C a') (H1 : context k' k C) (H2 : match k' with\n| LV => is_loc a' = None\n| RV => is_val a' = None\nend) (H4 : map\n  (fun z : (expr -> expr) * reduction => (fun x : expr => C (fst z x), snd z))\n  res = nil)","proofString":"destruct res; simpl in H4; try congruence.\ndestruct k'; intuition congruence."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res1 ->\n exists (a' : expr) (k' : kind),\n   context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res1 = nil ->\n match k1 with\n | LV => is_loc a1 <> None\n | RV => is_val a1 <> None\n end)) (H0 : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res2 ->\n exists (a' : expr) (k' : kind),\n   context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res2 = nil ->\n match k2 with\n | LV => is_loc a2 <> None\n | RV => is_val a2 <> None\n end)) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C1 (fst z x), snd z)) res1 ++\n    map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C2 (fst z x), snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C1 (fst z x), snd z)) res1 ++\n map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C2 (fst z x), snd z)) res2 = nil ->\n match k with\n | LV => is_loc a <> None\n | RV => is_val a <> None\n end).","conclusion":"(forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C1 (fst z x), snd z)) res1 ++\n    map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => C2 (fst z x), snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C1 (fst z x), snd z)) res1 ++\n map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => C2 (fst z x), snd z)) res2 = nil ->\n match k with\n | LV => is_loc a <> None\n | RV => is_val a <> None\n end)","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res1 ->\n exists (a' : expr) (k' : kind),\n   context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res1 = nil ->\n match k1 with\n | LV => is_loc a1 <> None\n | RV => is_val a1 <> None\n end)) (H0 : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res2 ->\n exists (a' : expr) (k' : kind),\n   context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res2 = nil ->\n match k2 with\n | LV => is_loc a2 <> None\n | RV => is_val a2 <> None\n end)) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end)","proofString":"destruct H; destruct H0; split; intros.\ndestruct (in_app_or _ _ _ H8).\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto.\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto.\ndestruct res1; simpl in H8; try congruence.\ndestruct res2; simpl in H8; try congruence.\ndestruct H5.\ndestruct k1; intuition congruence.\ndestruct k2; intuition congruence."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2))","proofString":"destruct (in_app_or _ _ _ H8).\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto.\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) : (exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => C1 (fst z x0), snd z)) x /\\ \n   In x res1) ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"(exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => C1 (fst z x0), snd z)) x /\\ \n   In x res1) ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1))","proofString":"intros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => C1 (fst (C', rd') x), snd (C', rd'))) (Q : In (C', rd') res1) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => C1 (fst (C', rd') x), snd (C', rd'))) (Q : In (C', rd') res1)","proofString":"inv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) : exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C1 (C' x)) /\\\n  C1 a1 = C1 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C1 (C' x)) /\\\n  C1 a1 = C1 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1)","proofString":"exploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) : (exists (a' : expr) (k' : kind),\n   context k' k1 C' /\\ a1 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C1 (C' x)) /\\\n  C1 a1 = C1 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"(exists (a' : expr) (k' : kind),\n   context k' k1 C' /\\ a1 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C1 (C' x)) /\\\n  C1 a1 = C1 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C1 (C' x)) /\\\n  C1 a1 = C1 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C1 (C' x)) /\\\n  C1 a1 = C1 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"exists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' k (fun x : expr => C1 (C' x)) /\\\nC1 a1 = C1 (C' a'') /\\ reduction_ok k'' a'' m rd'.","conclusion":"context k'' k (fun x : expr => C1 (C' x)) /\\\nC1 a1 = C1 (C' a'') /\\ reduction_ok k'' a'' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"split.\neapply context_compose; eauto.\nrewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' k (fun x : expr => C1 (C' x)).","conclusion":"context k'' k (fun x : expr => C1 (C' x))","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"eapply context_compose; eauto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : C1 a1 = C1 (C' a'') /\\ reduction_ok k'' a'' m rd'.","conclusion":"C1 a1 = C1 (C' a'') /\\ reduction_ok k'' a'' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' k1 C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"rewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) : (exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => C2 (fst z x0), snd z)) x /\\ \n   In x res2) ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"(exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => C2 (fst z x0), snd z)) x /\\ \n   In x res2) ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2))","proofString":"intros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => C2 (fst (C', rd') x), snd (C', rd'))) (Q : In (C', rd') res2) : exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C : expr -> expr) (rd : reduction) (H8 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => C2 (fst (C', rd') x), snd (C', rd'))) (Q : In (C', rd') res2)","proofString":"inv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) : exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C2 (C' x)) /\\\n  C1 a1 = C2 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C2 (C' x)) /\\\n  C1 a1 = C2 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2)","proofString":"exploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) : (exists (a' : expr) (k' : kind),\n   context k' k2 C' /\\ a2 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C2 (C' x)) /\\\n  C1 a1 = C2 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"(exists (a' : expr) (k' : kind),\n   context k' k2 C' /\\ a2 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C2 (C' x)) /\\\n  C1 a1 = C2 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C2 (C' x)) /\\\n  C1 a1 = C2 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' k (fun x : expr => C2 (C' x)) /\\\n  C1 a1 = C2 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"exists a''; exists k''.\nsplit.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' k (fun x : expr => C2 (C' x)) /\\\nC1 a1 = C2 (C' a'') /\\ reduction_ok k'' a'' m rd'.","conclusion":"context k'' k (fun x : expr => C2 (C' x)) /\\\nC1 a1 = C2 (C' a'') /\\ reduction_ok k'' a'' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"split.\neapply context_compose; eauto.\nrewrite H2; rewrite V; auto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' k (fun x : expr => C2 (C' x)).","conclusion":"context k'' k (fun x : expr => C2 (C' x))","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"eapply context_compose; eauto."},{"statement":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : C1 a1 = C2 (C' a'') /\\ reduction_ok k'' a'' m rd'.","conclusion":"C1 a1 = C2 (C' a'') /\\ reduction_ok k'' a'' m rd'","hypotheses":"(k : kind) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H2 : C1 a1 = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (C' : expr -> expr) (rd' : reduction) (H8 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (H9 : In (fun x : expr => C2 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : context k'' k2 C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"rewrite H2; rewrite V; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (H8 : map\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => C1 (fst z x), snd z)) res1 ++\nmap\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => C2 (fst z x), snd z)) res2 = nil) : match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend.","conclusion":"match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend","hypotheses":"(k : kind) (a : expr) (m : mem) (k1 : kind) (a1 : expr) (res1 : reducts expr) (k2 : kind) (a2 : expr) (res2 : reducts expr) (C1 C2 : expr -> expr) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' k1 C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H6 : res1 = nil ->\nmatch k1 with\n| LV => is_loc a1 <> None\n| RV => is_val a1 <> None\nend) (H0 : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  context k' k2 C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H7 : res2 = nil ->\nmatch k2 with\n| LV => is_loc a2 <> None\n| RV => is_val a2 <> None\nend) (H1 : a = C1 a1) (H2 : a = C2 a2) (H3 : context k1 k C1) (H4 : context k2 k C2) (H5 : match k1 with\n| LV => is_loc a1 = None\n| RV => is_val a1 = None\nend \\/ match k2 with\n       | LV => is_loc a2 = None\n       | RV => is_val a2 = None\n       end) (H8 : map\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => C1 (fst z x), snd z)) res1 ++\nmap\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => C2 (fst z x), snd z)) res2 = nil)","proofString":"destruct res1; simpl in H8; try congruence.\ndestruct res2; simpl in H8; try congruence.\ndestruct H5.\ndestruct k1; intuition congruence.\ndestruct k2; intuition congruence."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : list_reducts_ok al m res) (H0 : is_val_list al = None) : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\\n   Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil ->\n is_val (Ebuiltin ef tyargs al ty) <> None).","conclusion":"(forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\\n   Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil ->\n is_val (Ebuiltin ef tyargs al ty) <> None)","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : list_reducts_ok al m res) (H0 : is_val_list al = None)","proofString":"destruct H.\nsplit; intros.\nexploit list_in_map_inv; eauto.\nintros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\ndestruct res; simpl in H2.\nelim H1; auto.\ncongruence."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\\n   Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil ->\n is_val (Ebuiltin ef tyargs al ty) <> None).","conclusion":"(forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\\n   Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil ->\n is_val (Ebuiltin ef tyargs al ty) <> None)","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None)","proofString":"split; intros.\nexploit list_in_map_inv; eauto.\nintros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\ndestruct res; simpl in H2.\nelim H1; auto.\ncongruence."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ al = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C : expr -> expr) (rd : reduction) (H2 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) : exists (a' : expr) (k' : kind),\n  context k' RV C /\\\n  Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV C /\\\n  Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ al = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C : expr -> expr) (rd : reduction) (H2 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ al = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C : expr -> expr) (rd : reduction) (H2 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) : (exists x : (expr -> exprlist) * reduction,\n   (C, rd) =\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x0 : expr => Ebuiltin ef tyargs (fst z x0) ty, snd z)) x /\\ \n   In x res) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\\n  Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"(exists x : (expr -> exprlist) * reduction,\n   (C, rd) =\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x0 : expr => Ebuiltin ef tyargs (fst z x0) ty, snd z)) x /\\ \n   In x res) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\\n  Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ al = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C : expr -> expr) (rd : reduction) (H2 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res))","proofString":"intros [[C1 rd1] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ al = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C : expr -> expr) (rd : reduction) (H2 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (C1 : expr -> exprlist) (rd1 : reduction) (P : (C, rd) =\n(fun x : expr => Ebuiltin ef tyargs (fst (C1, rd1) x) ty, snd (C1, rd1))) (Q : In (C1, rd1) res) : exists (a' : expr) (k' : kind),\n  context k' RV C /\\\n  Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV C /\\\n  Ebuiltin ef tyargs al ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ al = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C : expr -> expr) (rd : reduction) (H2 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (C1 : expr -> exprlist) (rd1 : reduction) (P : (C, rd) =\n(fun x : expr => Ebuiltin ef tyargs (fst (C1, rd1) x) ty, snd (C1, rd1))) (Q : In (C1, rd1) res)","proofString":"inv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) : exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\n  Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a') ty /\\\n  reduction_ok k' a' m rd1.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\n  Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a') ty /\\\n  reduction_ok k' a' m rd1","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res)","proofString":"exploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) : (exists (a' : expr) (k' : kind),\n   contextlist k' C1 /\\ al = C1 a' /\\ reduction_ok k' a' m rd1) ->\nexists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\n  Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a') ty /\\\n  reduction_ok k' a' m rd1.","conclusion":"(exists (a' : expr) (k' : kind),\n   contextlist k' C1 /\\ al = C1 a' /\\ reduction_ok k' a' m rd1) ->\nexists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\n  Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a') ty /\\\n  reduction_ok k' a' m rd1","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1) : exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\n  Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a') ty /\\\n  reduction_ok k' a' m rd1.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\n  Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a') ty /\\\n  reduction_ok k' a' m rd1","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"exists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1) : context k'' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\nEbuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a'') ty /\\\nreduction_ok k'' a'' m rd1.","conclusion":"context k'' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty) /\\\nEbuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a'') ty /\\\nreduction_ok k'' a'' m rd1","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"split.\neauto.\nrewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1) : context k'' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty).","conclusion":"context k'' RV (fun x : expr => Ebuiltin ef tyargs (C1 x) ty)","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"eauto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1) : Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a'') ty /\\\nreduction_ok k'' a'' m rd1.","conclusion":"Ebuiltin ef tyargs al ty = Ebuiltin ef tyargs (C1 a'') ty /\\\nreduction_ok k'' a'' m rd1","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (C1 : expr -> exprlist) (rd1 : reduction) (H2 : In (fun x : expr => Ebuiltin ef tyargs (C1 x) ty, rd1)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res)) (Q : In (C1, rd1) res) (a'' : expr) (k'' : kind) (U : contextlist k'' C1) (V : al = C1 a'') (W : reduction_ok k'' a'' m rd1)","proofString":"rewrite V; auto."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (H2 : map\n  (fun z : (expr -> exprlist) * reduction =>\n   (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil) : is_val (Ebuiltin ef tyargs al ty) <> None.","conclusion":"is_val (Ebuiltin ef tyargs al ty) <> None","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (res : reducts exprlist) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (H2 : map\n  (fun z : (expr -> exprlist) * reduction =>\n   (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil)","proofString":"destruct res; simpl in H2.\nelim H1; auto.\ncongruence."},{"statement":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (p : (expr -> exprlist) * reduction) (res : list ((expr -> exprlist) * reduction)) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) (p :: res) ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : p :: res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (H2 : (fun x : expr => Ebuiltin ef tyargs (fst p x) ty, snd p)\n:: map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil) : is_val (Ebuiltin ef tyargs al ty) <> None.","conclusion":"is_val (Ebuiltin ef tyargs al ty) <> None","hypotheses":"(ef : external_function) (tyargs : list type) (al : exprlist) (ty : type) (m : mem) (p : (expr -> exprlist) * reduction) (res : list ((expr -> exprlist) * reduction)) (H : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) (p :: res) ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ al = C a' /\\ reduction_ok k' a' m rd) (H1 : p :: res = nil -> is_val_list al <> None) (H0 : is_val_list al = None) (H2 : (fun x : expr => Ebuiltin ef tyargs (fst p x) ty, snd p)\n:: map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ebuiltin ef tyargs (fst z x) ty, snd z)) res = nil)","proofString":"congruence."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res1 ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res1 = nil -> is_val a1 <> None)) (H0 : list_reducts_ok a2 m res2) (H1 : is_val a1 = None \\/ is_val_list a2 = None) : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n    map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2 = nil ->\n is_val (Ecall a1 a2 ty) <> None).","conclusion":"(forall (C : expr -> expr) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n    map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2 = nil ->\n is_val (Ecall a1 a2 ty) <> None)","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res1 ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res1 = nil -> is_val a1 <> None)) (H0 : list_reducts_ok a2 m res2) (H1 : is_val a1 = None \\/ is_val_list a2 = None)","proofString":"destruct H; destruct H0; split; intros.\ndestruct (in_app_or _ _ _ H4).\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\ndestruct res1; simpl in H4; try congruence.\ndestruct res2; simpl in H4; try congruence.\ntauto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) : exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2))","proofString":"destruct (in_app_or _ _ _ H4).\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) : exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) : (exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => Ecall (fst z x0) a2 ty, snd z)) x /\\ \n   In x res1) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"(exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => Ecall (fst z x0) a2 ty, snd z)) x /\\ \n   In x res1) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1))","proofString":"intros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => Ecall (fst (C', rd') x) a2 ty, snd (C', rd'))) (Q : In (C', rd') res1) : exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => Ecall (fst (C', rd') x) a2 ty, snd (C', rd'))) (Q : In (C', rd') res1)","proofString":"inv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) : exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\n  Ecall a1 a2 ty = Ecall (C' a') a2 ty /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\n  Ecall a1 a2 ty = Ecall (C' a') a2 ty /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1)","proofString":"exploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) : (exists (a' : expr) (k' : kind),\n   context k' RV C' /\\ a1 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\n  Ecall a1 a2 ty = Ecall (C' a') a2 ty /\\ reduction_ok k' a' m rd'.","conclusion":"(exists (a' : expr) (k' : kind),\n   context k' RV C' /\\ a1 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\n  Ecall a1 a2 ty = Ecall (C' a') a2 ty /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\n  Ecall a1 a2 ty = Ecall (C' a') a2 ty /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\n  Ecall a1 a2 ty = Ecall (C' a') a2 ty /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"exists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\nEcall a1 a2 ty = Ecall (C' a'') a2 ty /\\ reduction_ok k'' a'' m rd'.","conclusion":"context k'' RV (fun x : expr => Ecall (C' x) a2 ty) /\\\nEcall a1 a2 ty = Ecall (C' a'') a2 ty /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"split.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' RV (fun x : expr => Ecall (C' x) a2 ty).","conclusion":"context k'' RV (fun x : expr => Ecall (C' x) a2 ty)","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"eauto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : Ecall a1 a2 ty = Ecall (C' a'') a2 ty /\\ reduction_ok k'' a'' m rd'.","conclusion":"Ecall a1 a2 ty = Ecall (C' a'') a2 ty /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> expr) (rd' : reduction) (H4 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall (C' x) a2 ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"rewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) : exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) : (exists x : (expr -> exprlist) * reduction,\n   (C, rd) =\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x0 : expr => Ecall a1 (fst z x0) ty, snd z)) x /\\ \n   In x res2) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"(exists x : (expr -> exprlist) * reduction,\n   (C, rd) =\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x0 : expr => Ecall a1 (fst z x0) ty, snd z)) x /\\ \n   In x res2) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2))","proofString":"intros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (C' : expr -> exprlist) (rd' : reduction) (P : (C, rd) = (fun x : expr => Ecall a1 (fst (C', rd') x) ty, snd (C', rd'))) (Q : In (C', rd') res2) : exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV C /\\ Ecall a1 a2 ty = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C : expr -> expr) (rd : reduction) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (C' : expr -> exprlist) (rd' : reduction) (P : (C, rd) = (fun x : expr => Ecall a1 (fst (C', rd') x) ty, snd (C', rd'))) (Q : In (C', rd') res2)","proofString":"inv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) : exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\n  Ecall a1 a2 ty = Ecall a1 (C' a') ty /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\n  Ecall a1 a2 ty = Ecall a1 (C' a') ty /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2)","proofString":"exploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) : (exists (a' : expr) (k' : kind),\n   contextlist k' C' /\\ a2 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\n  Ecall a1 a2 ty = Ecall a1 (C' a') ty /\\ reduction_ok k' a' m rd'.","conclusion":"(exists (a' : expr) (k' : kind),\n   contextlist k' C' /\\ a2 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\n  Ecall a1 a2 ty = Ecall a1 (C' a') ty /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\n  Ecall a1 a2 ty = Ecall a1 (C' a') ty /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  context k' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\n  Ecall a1 a2 ty = Ecall a1 (C' a') ty /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"exists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\nEcall a1 a2 ty = Ecall a1 (C' a'') ty /\\ reduction_ok k'' a'' m rd'.","conclusion":"context k'' RV (fun x : expr => Ecall a1 (C' x) ty) /\\\nEcall a1 a2 ty = Ecall a1 (C' a'') ty /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"split.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : context k'' RV (fun x : expr => Ecall a1 (C' x) ty).","conclusion":"context k'' RV (fun x : expr => Ecall a1 (C' x) ty)","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"eauto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : Ecall a1 a2 ty = Ecall a1 (C' a'') ty /\\ reduction_ok k'' a'' m rd'.","conclusion":"Ecall a1 a2 ty = Ecall a1 (C' a'') ty /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (C' : expr -> exprlist) (rd' : reduction) (H4 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (H5 : In (fun x : expr => Ecall a1 (C' x) ty, rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"rewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (H4 : map\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\nmap\n  (fun z : (expr -> exprlist) * reduction =>\n   (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2 = nil) : is_val (Ecall a1 a2 ty) <> None.","conclusion":"is_val (Ecall a1 a2 ty) <> None","hypotheses":"(a1 : expr) (a2 : exprlist) (ty : type) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H2 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H3 : res2 = nil -> is_val_list a2 <> None) (H1 : is_val a1 = None \\/ is_val_list a2 = None) (H4 : map\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => Ecall (fst z x) a2 ty, snd z)) res1 ++\nmap\n  (fun z : (expr -> exprlist) * reduction =>\n   (fun x : expr => Ecall a1 (fst z x) ty, snd z)) res2 = nil)","proofString":"destruct res1; simpl in H4; try congruence.\ndestruct res2; simpl in H4; try congruence.\ntauto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res1 ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res1 = nil -> is_val a1 <> None)) (H0 : (forall (C : expr -> exprlist) (rd : reduction),\n In (C, rd) res2 ->\n exists (a' : expr) (k' : kind),\n   contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res2 = nil -> is_val_list a2 <> None)) : (forall (C : expr -> exprlist) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n    map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Econs a1 (fst z x), snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Econs a1 (fst z x), snd z)) res2 = nil ->\n is_val_list (Econs a1 a2) <> None).","conclusion":"(forall (C : expr -> exprlist) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n    map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Econs a1 (fst z x), snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Econs a1 (fst z x), snd z)) res2 = nil ->\n is_val_list (Econs a1 a2) <> None)","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : (forall (C : expr -> expr) (rd : reduction),\n In (C, rd) res1 ->\n exists (a' : expr) (k' : kind),\n   context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res1 = nil -> is_val a1 <> None)) (H0 : (forall (C : expr -> exprlist) (rd : reduction),\n In (C, rd) res2 ->\n exists (a' : expr) (k' : kind),\n   contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(res2 = nil -> is_val_list a2 <> None))","proofString":"destruct H; destruct H0.\nsplit; intros.\ndestruct (in_app_or _ _ _ H3).\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\ndestruct res1; simpl in H3; try congruence.\ndestruct res2; simpl in H3; try congruence.\nsimpl.\ndestruct (is_val a1).\ndestruct (is_val_list a2).\ncongruence.\nintuition congruence.\nintuition congruence."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) : (forall (C : expr -> exprlist) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n    map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Econs a1 (fst z x), snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Econs a1 (fst z x), snd z)) res2 = nil ->\n is_val_list (Econs a1 a2) <> None).","conclusion":"(forall (C : expr -> exprlist) (rd : reduction),\n In (C, rd)\n   (map\n      (fun z : (expr -> expr) * reduction =>\n       (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n    map\n      (fun z : (expr -> exprlist) * reduction =>\n       (fun x : expr => Econs a1 (fst z x), snd z)) res2) ->\n exists (a' : expr) (k' : kind),\n   contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd) /\\\n(map\n   (fun z : (expr -> expr) * reduction =>\n    (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n map\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x : expr => Econs a1 (fst z x), snd z)) res2 = nil ->\n is_val_list (Econs a1 a2) <> None)","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None)","proofString":"split; intros.\ndestruct (in_app_or _ _ _ H3).\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\ndestruct res1; simpl in H3; try congruence.\ndestruct res2; simpl in H3; try congruence.\nsimpl.\ndestruct (is_val a1).\ndestruct (is_val_list a2).\ncongruence.\nintuition congruence.\nintuition congruence."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) : exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2))","proofString":"destruct (in_app_or _ _ _ H3).\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto.\nexploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) : exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) : (exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => Econs (fst z x0) a2, snd z)) x /\\ \n   In x res1) ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd.","conclusion":"(exists x : (expr -> expr) * reduction,\n   (C, rd) =\n   (fun z : (expr -> expr) * reduction =>\n    (fun x0 : expr => Econs (fst z x0) a2, snd z)) x /\\ \n   In x res1) ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1))","proofString":"intros [[C' rd'] [P Q]].\ninv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => Econs (fst (C', rd') x) a2, snd (C', rd'))) (Q : In (C', rd') res1) : exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (C' : expr -> expr) (rd' : reduction) (P : (C, rd) = (fun x : expr => Econs (fst (C', rd') x) a2, snd (C', rd'))) (Q : In (C', rd') res1)","proofString":"inv P.\nexploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) : exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs (C' x) a2) /\\\n  Econs a1 a2 = Econs (C' a') a2 /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs (C' x) a2) /\\\n  Econs a1 a2 = Econs (C' a') a2 /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1)","proofString":"exploit H; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) : (exists (a' : expr) (k' : kind),\n   context k' RV C' /\\ a1 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs (C' x) a2) /\\\n  Econs a1 a2 = Econs (C' a') a2 /\\ reduction_ok k' a' m rd'.","conclusion":"(exists (a' : expr) (k' : kind),\n   context k' RV C' /\\ a1 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs (C' x) a2) /\\\n  Econs a1 a2 = Econs (C' a') a2 /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs (C' x) a2) /\\\n  Econs a1 a2 = Econs (C' a') a2 /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs (C' x) a2) /\\\n  Econs a1 a2 = Econs (C' a') a2 /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"exists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : contextlist k'' (fun x : expr => Econs (C' x) a2) /\\\nEcons a1 a2 = Econs (C' a'') a2 /\\ reduction_ok k'' a'' m rd'.","conclusion":"contextlist k'' (fun x : expr => Econs (C' x) a2) /\\\nEcons a1 a2 = Econs (C' a'') a2 /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"split.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : contextlist k'' (fun x : expr => Econs (C' x) a2).","conclusion":"contextlist k'' (fun x : expr => Econs (C' x) a2)","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"eauto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd') : Econs a1 a2 = Econs (C' a'') a2 /\\ reduction_ok k'' a'' m rd'.","conclusion":"Econs a1 a2 = Econs (C' a'') a2 /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> expr) (rd' : reduction) (H3 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs (C' x) a2, rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1)) (Q : In (C', rd') res1) (a'' : expr) (k'' : kind) (U : context k'' RV C') (V : a1 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"rewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) : exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) : (exists x : (expr -> exprlist) * reduction,\n   (C, rd) =\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x0 : expr => Econs a1 (fst z x0), snd z)) x /\\ \n   In x res2) ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd.","conclusion":"(exists x : (expr -> exprlist) * reduction,\n   (C, rd) =\n   (fun z : (expr -> exprlist) * reduction =>\n    (fun x0 : expr => Econs a1 (fst z x0), snd z)) x /\\ \n   In x res2) ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2))","proofString":"intros [[C' rd'] [P Q]].\ninv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (C' : expr -> exprlist) (rd' : reduction) (P : (C, rd) = (fun x : expr => Econs a1 (fst (C', rd') x), snd (C', rd'))) (Q : In (C', rd') res2) : exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' C /\\ Econs a1 a2 = C a' /\\ reduction_ok k' a' m rd","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ a1 = C0 a' /\\ reduction_ok k' a' m rd0) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C0 : expr -> exprlist) (rd0 : reduction),\nIn (C0, rd0) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C0 /\\ a2 = C0 a' /\\ reduction_ok k' a' m rd0) (H2 : res2 = nil -> is_val_list a2 <> None) (C : expr -> exprlist) (rd : reduction) (H3 : In (C, rd)\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (C, rd)\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (C' : expr -> exprlist) (rd' : reduction) (P : (C, rd) = (fun x : expr => Econs a1 (fst (C', rd') x), snd (C', rd'))) (Q : In (C', rd') res2)","proofString":"inv P.\nexploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) : exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs a1 (C' x)) /\\\n  Econs a1 a2 = Econs a1 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs a1 (C' x)) /\\\n  Econs a1 a2 = Econs a1 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2)","proofString":"exploit H0; eauto.\nintros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) : (exists (a' : expr) (k' : kind),\n   contextlist k' C' /\\ a2 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs a1 (C' x)) /\\\n  Econs a1 a2 = Econs a1 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"(exists (a' : expr) (k' : kind),\n   contextlist k' C' /\\ a2 = C' a' /\\ reduction_ok k' a' m rd') ->\nexists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs a1 (C' x)) /\\\n  Econs a1 a2 = Econs a1 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2)","proofString":"intros [a'' [k'' [U [V W]]]].\nexists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs a1 (C' x)) /\\\n  Econs a1 a2 = Econs a1 (C' a') /\\ reduction_ok k' a' m rd'.","conclusion":"exists (a' : expr) (k' : kind),\n  contextlist k' (fun x : expr => Econs a1 (C' x)) /\\\n  Econs a1 a2 = Econs a1 (C' a') /\\ reduction_ok k' a' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"exists a''; exists k''.\nsplit.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : contextlist k'' (fun x : expr => Econs a1 (C' x)) /\\\nEcons a1 a2 = Econs a1 (C' a'') /\\ reduction_ok k'' a'' m rd'.","conclusion":"contextlist k'' (fun x : expr => Econs a1 (C' x)) /\\\nEcons a1 a2 = Econs a1 (C' a'') /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"split.\neauto.\nrewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : contextlist k'' (fun x : expr => Econs a1 (C' x)).","conclusion":"contextlist k'' (fun x : expr => Econs a1 (C' x))","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"eauto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd') : Econs a1 a2 = Econs a1 (C' a'') /\\ reduction_ok k'' a'' m rd'.","conclusion":"Econs a1 a2 = Econs a1 (C' a'') /\\ reduction_ok k'' a'' m rd'","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (C' : expr -> exprlist) (rd' : reduction) (H3 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> expr) * reduction =>\n      (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\n   map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (H4 : In (fun x : expr => Econs a1 (C' x), rd')\n  (map\n     (fun z : (expr -> exprlist) * reduction =>\n      (fun x : expr => Econs a1 (fst z x), snd z)) res2)) (Q : In (C', rd') res2) (a'' : expr) (k'' : kind) (U : contextlist k'' C') (V : a2 = C' a'') (W : reduction_ok k'' a'' m rd')","proofString":"rewrite V; auto."},{"statement":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (H3 : map\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\nmap\n  (fun z : (expr -> exprlist) * reduction =>\n   (fun x : expr => Econs a1 (fst z x), snd z)) res2 = nil) : is_val_list (Econs a1 a2) <> None.","conclusion":"is_val_list (Econs a1 a2) <> None","hypotheses":"(a1 : expr) (a2 : exprlist) (m : mem) (res1 : reducts expr) (res2 : reducts exprlist) (H : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) res1 ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a1 = C a' /\\ reduction_ok k' a' m rd) (H1 : res1 = nil -> is_val a1 <> None) (H0 : forall (C : expr -> exprlist) (rd : reduction),\nIn (C, rd) res2 ->\nexists (a' : expr) (k' : kind),\n  contextlist k' C /\\ a2 = C a' /\\ reduction_ok k' a' m rd) (H2 : res2 = nil -> is_val_list a2 <> None) (H3 : map\n  (fun z : (expr -> expr) * reduction =>\n   (fun x : expr => Econs (fst z x) a2, snd z)) res1 ++\nmap\n  (fun z : (expr -> exprlist) * reduction =>\n   (fun x : expr => Econs a1 (fst z x), snd z)) res2 = nil)","proofString":"destruct res1; simpl in H3; try congruence.\ndestruct res2; simpl in H3; try congruence.\nsimpl.\ndestruct (is_val a1).\ndestruct (is_val_list a2).\ncongruence.\nintuition congruence.\nintuition congruence."},{"statement":"(vtl : list (val * type)) (H : Some nil = Some vtl) : True.","conclusion":"True","hypotheses":"(vtl : list (val * type)) (H : Some nil = Some vtl)","proofString":"auto."},{"statement":"(r1 : expr) (al : exprlist) (IHal : forall vtl0 : list (val * type),\nis_val_list al = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (H : match is_val r1 with\n| Some vt1 =>\n    match is_val_list al with\n    | Some vtl0 => Some (vt1 :: vtl0)\n    | None => None\n    end\n| None => None\nend = Some vtl) : match r1 with\n| Eval _ _ => exprlist_all_values al\n| _ => False\nend.","conclusion":"match r1 with\n| Eval _ _ => exprlist_all_values al\n| _ => False\nend","hypotheses":"(r1 : expr) (al : exprlist) (IHal : forall vtl0 : list (val * type),\nis_val_list al = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (H : match is_val r1 with\n| Some vt1 =>\n    match is_val_list al with\n    | Some vtl0 => Some (vt1 :: vtl0)\n    | None => None\n    end\n| None => None\nend = Some vtl)","proofString":"destruct (is_val r1) as [[v ty]|] eqn:?; try discriminate.\ndestruct (is_val_list al) as [vtl'|] eqn:?; try discriminate.\nrewrite (is_val_inv _ _ _ Heqo).\neauto."},{"statement":"(r1 : expr) (al : exprlist) (IHal : forall vtl0 : list (val * type),\nis_val_list al = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (v : val) (ty : type) (Heqo : is_val r1 = Some (v, ty)) (H : match is_val_list al with\n| Some vtl0 => Some ((v, ty) :: vtl0)\n| None => None\nend = Some vtl) : match r1 with\n| Eval _ _ => exprlist_all_values al\n| _ => False\nend.","conclusion":"match r1 with\n| Eval _ _ => exprlist_all_values al\n| _ => False\nend","hypotheses":"(r1 : expr) (al : exprlist) (IHal : forall vtl0 : list (val * type),\nis_val_list al = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (v : val) (ty : type) (Heqo : is_val r1 = Some (v, ty)) (H : match is_val_list al with\n| Some vtl0 => Some ((v, ty) :: vtl0)\n| None => None\nend = Some vtl)","proofString":"destruct (is_val_list al) as [vtl'|] eqn:?; try discriminate.\nrewrite (is_val_inv _ _ _ Heqo).\neauto."},{"statement":"(r1 : expr) (al : exprlist) (vtl' : list (val * type)) (Heqo0 : is_val_list al = Some vtl') (IHal : forall vtl0 : list (val * type),\nSome vtl' = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (v : val) (ty : type) (Heqo : is_val r1 = Some (v, ty)) (H : Some ((v, ty) :: vtl') = Some vtl) : match r1 with\n| Eval _ _ => exprlist_all_values al\n| _ => False\nend.","conclusion":"match r1 with\n| Eval _ _ => exprlist_all_values al\n| _ => False\nend","hypotheses":"(r1 : expr) (al : exprlist) (vtl' : list (val * type)) (Heqo0 : is_val_list al = Some vtl') (IHal : forall vtl0 : list (val * type),\nSome vtl' = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (v : val) (ty : type) (Heqo : is_val r1 = Some (v, ty)) (H : Some ((v, ty) :: vtl') = Some vtl)","proofString":"rewrite (is_val_inv _ _ _ Heqo).\neauto."},{"statement":"(r1 : expr) (al : exprlist) (vtl' : list (val * type)) (Heqo0 : is_val_list al = Some vtl') (IHal : forall vtl0 : list (val * type),\nSome vtl' = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (v : val) (ty : type) (Heqo : is_val r1 = Some (v, ty)) (H : Some ((v, ty) :: vtl') = Some vtl) : exprlist_all_values al.","conclusion":"exprlist_all_values al","hypotheses":"(r1 : expr) (al : exprlist) (vtl' : list (val * type)) (Heqo0 : is_val_list al = Some vtl') (IHal : forall vtl0 : list (val * type),\nSome vtl' = Some vtl0 -> exprlist_all_values al) (vtl : list (val * type)) (v : val) (ty : type) (Heqo : is_val r1 = Some (v, ty)) (H : Some ((v, ty) :: vtl') = Some vtl)","proofString":"eauto."},{"statement":"(m : mem) (r1 : expr) (al : exprlist) (IHal : is_val_list al <> None -> step_exprlist al m = nil) (H : match is_val r1 with\n| Some vt1 =>\n    match is_val_list al with\n    | Some vtl => Some (vt1 :: vtl)\n    | None => None\n    end\n| None => None\nend <> None) : incontext2 (fun x : expr => Econs x al) (step_expr RV r1 m)\n  (fun x : exprlist => Econs r1 x) (step_exprlist al m) = nil.","conclusion":"incontext2 (fun x : expr => Econs x al) (step_expr RV r1 m)\n  (fun x : exprlist => Econs r1 x) (step_exprlist al m) = nil","hypotheses":"(m : mem) (r1 : expr) (al : exprlist) (IHal : is_val_list al <> None -> step_exprlist al m = nil) (H : match is_val r1 with\n| Some vt1 =>\n    match is_val_list al with\n    | Some vtl => Some (vt1 :: vtl)\n    | None => None\n    end\n| None => None\nend <> None)","proofString":"destruct (is_val r1) as [[v1 ty1]|] eqn:?; try congruence.\ndestruct (is_val_list al) eqn:?; try congruence.\nrewrite (is_val_inv _ _ _ Heqo).\nrewrite IHal.\nauto.\ncongruence."},{"statement":"(m : mem) (r1 : expr) (al : exprlist) (IHal : is_val_list al <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : match is_val_list al with\n| Some vtl => Some ((v1, ty1) :: vtl)\n| None => None\nend <> None) : incontext2 (fun x : expr => Econs x al) (step_expr RV r1 m)\n  (fun x : exprlist => Econs r1 x) (step_exprlist al m) = nil.","conclusion":"incontext2 (fun x : expr => Econs x al) (step_expr RV r1 m)\n  (fun x : exprlist => Econs r1 x) (step_exprlist al m) = nil","hypotheses":"(m : mem) (r1 : expr) (al : exprlist) (IHal : is_val_list al <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : match is_val_list al with\n| Some vtl => Some ((v1, ty1) :: vtl)\n| None => None\nend <> None)","proofString":"destruct (is_val_list al) eqn:?; try congruence.\nrewrite (is_val_inv _ _ _ Heqo).\nrewrite IHal.\nauto.\ncongruence."},{"statement":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None) : incontext2 (fun x : expr => Econs x al) (step_expr RV r1 m)\n  (fun x : exprlist => Econs r1 x) (step_exprlist al m) = nil.","conclusion":"incontext2 (fun x : expr => Econs x al) (step_expr RV r1 m)\n  (fun x : exprlist => Econs r1 x) (step_exprlist al m) = nil","hypotheses":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None)","proofString":"rewrite (is_val_inv _ _ _ Heqo).\nrewrite IHal.\nauto.\ncongruence."},{"statement":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None) : incontext2 (fun x : expr => Econs x al) (step_expr RV (Eval v1 ty1) m)\n  (fun x : exprlist => Econs (Eval v1 ty1) x) (step_exprlist al m) = nil.","conclusion":"incontext2 (fun x : expr => Econs x al) (step_expr RV (Eval v1 ty1) m)\n  (fun x : exprlist => Econs (Eval v1 ty1) x) (step_exprlist al m) = nil","hypotheses":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None)","proofString":"rewrite IHal.\nauto.\ncongruence."},{"statement":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None) : incontext2 (fun x : expr => Econs x al) (step_expr RV (Eval v1 ty1) m)\n  (fun x : exprlist => Econs (Eval v1 ty1) x) nil = nil.","conclusion":"incontext2 (fun x : expr => Econs x al) (step_expr RV (Eval v1 ty1) m)\n  (fun x : exprlist => Econs (Eval v1 ty1) x) nil = nil","hypotheses":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None)","proofString":"auto."},{"statement":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None) : Some l <> None.","conclusion":"Some l <> None","hypotheses":"(m : mem) (r1 : expr) (al : exprlist) (l : list (val * type)) (Heqo0 : is_val_list al = Some l) (IHal : Some l <> None -> step_exprlist al m = nil) (v1 : val) (ty1 : type) (Heqo : is_val r1 = Some (v1, ty1)) (H : Some ((v1, ty1) :: l) <> None)","proofString":"congruence."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty)) : exists rule : string,\n  match e ! x with\n  | Some (b0, ty') =>\n      check type_eq ty ty';\n      topred (Lred \"red_var_local\" (Eloc b0 Ptrofs.zero Full ty) m)\n  | None =>\n      do b0 <- Genv.find_symbol ge x;\n      topred (Lred \"red_var_global\" (Eloc b0 Ptrofs.zero Full ty) m)\n  end = topred (Lred rule (Eloc b Ptrofs.zero Full ty) m).","conclusion":"exists rule : string,\n  match e ! x with\n  | Some (b0, ty') =>\n      check type_eq ty ty';\n      topred (Lred \"red_var_local\" (Eloc b0 Ptrofs.zero Full ty) m)\n  | None =>\n      do b0 <- Genv.find_symbol ge x;\n      topred (Lred \"red_var_global\" (Eloc b0 Ptrofs.zero Full ty) m)\n  end = topred (Lred rule (Eloc b Ptrofs.zero Full ty) m)","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty))","proofString":"rewrite H.\nrewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty)) : exists rule : string,\n  (check type_eq ty ty;\n   topred (Lred \"red_var_local\" (Eloc b Ptrofs.zero Full ty) m)) =\n  topred (Lred rule (Eloc b Ptrofs.zero Full ty) m).","conclusion":"exists rule : string,\n  (check type_eq ty ty;\n   topred (Lred \"red_var_local\" (Eloc b Ptrofs.zero Full ty) m)) =\n  topred (Lred rule (Eloc b Ptrofs.zero Full ty) m)","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty))","proofString":"rewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty)) : exists rule : string,\n  topred (Lred \"red_var_local\" (Eloc b Ptrofs.zero Full ty) m) =\n  topred (Lred rule (Eloc b Ptrofs.zero Full ty) m).","conclusion":"exists rule : string,\n  topred (Lred \"red_var_local\" (Eloc b Ptrofs.zero Full ty) m) =\n  topred (Lred rule (Eloc b Ptrofs.zero Full ty) m)","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = Some (b, ty))","proofString":"econstructor; eauto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b) : exists rule : string,\n  match e ! x with\n  | Some (b0, ty') =>\n      check type_eq ty ty';\n      topred (Lred \"red_var_local\" (Eloc b0 Ptrofs.zero Full ty) m)\n  | None =>\n      do b0 <- Genv.find_symbol ge x;\n      topred (Lred \"red_var_global\" (Eloc b0 Ptrofs.zero Full ty) m)\n  end = topred (Lred rule (Eloc b Ptrofs.zero Full ty) m).","conclusion":"exists rule : string,\n  match e ! x with\n  | Some (b0, ty') =>\n      check type_eq ty ty';\n      topred (Lred \"red_var_local\" (Eloc b0 Ptrofs.zero Full ty) m)\n  | None =>\n      do b0 <- Genv.find_symbol ge x;\n      topred (Lred \"red_var_global\" (Eloc b0 Ptrofs.zero Full ty) m)\n  end = topred (Lred rule (Eloc b Ptrofs.zero Full ty) m)","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b)","proofString":"rewrite H; rewrite H0.\neconstructor; eauto."},{"statement":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b) : exists rule : string,\n  topred (Lred \"red_var_global\" (Eloc b Ptrofs.zero Full ty) m) =\n  topred (Lred rule (Eloc b Ptrofs.zero Full ty) m).","conclusion":"exists rule : string,\n  topred (Lred \"red_var_global\" (Eloc b Ptrofs.zero Full ty) m) =\n  topred (Lred rule (Eloc b Ptrofs.zero Full ty) m)","hypotheses":"(x : positive) (ty : type) (m : mem) (b : block) (H : e ! x = None) (H0 : Genv.find_symbol ge x = Some b)","proofString":"econstructor; eauto."},{"statement":"(b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) : exists rule : string,\n  topred (Lred \"red_deref\" (Eloc b ofs Full ty) m) =\n  topred (Lred rule (Eloc b ofs Full ty) m).","conclusion":"exists rule : string,\n  topred (Lred \"red_deref\" (Eloc b ofs Full ty) m) =\n  topred (Lred rule (Eloc b ofs Full ty) m)","hypotheses":"(b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem)","proofString":"econstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w') : exists rule : string,\n  (check type_eq ty ty;\n   do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred (Rred \"red_rvalof\" (Eval v0 ty) m t0)) =\n  topred (Rred rule (Eval v ty) m t).","conclusion":"exists rule : string,\n  (check type_eq ty ty;\n   do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred (Rred \"red_rvalof\" (Eval v0 ty) m t0)) =\n  topred (Rred rule (Eval v ty) m t)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w')","proofString":"rewrite dec_eq_true.\nrewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ _ H H0).\neconstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w') : exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred (Rred \"red_rvalof\" (Eval v0 ty) m t0)) =\n  topred (Rred rule (Eval v ty) m t).","conclusion":"exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred (Rred \"red_rvalof\" (Eval v0 ty) m t0)) =\n  topred (Rred rule (Eval v ty) m t)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w')","proofString":"rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ _ H H0).\neconstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w') : exists rule : string,\n  topred (Rred \"red_rvalof\" (Eval v ty) m t) =\n  topred (Rred rule (Eval v ty) m t).","conclusion":"exists rule : string,\n  topred (Rred \"red_rvalof\" (Eval v ty) m t) =\n  topred (Rred rule (Eval v ty) m t)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (H0 : possible_trace w t w')","proofString":"econstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) (H : possible_trace w E0 w') : exists rule : string,\n  topred (Rred \"red_addrof\" (Eval (Vptr b ofs) ty) m E0) =\n  topred (Rred rule (Eval (Vptr b ofs) ty) m E0).","conclusion":"exists rule : string,\n  topred (Rred \"red_addrof\" (Eval (Vptr b ofs) ty) m E0) =\n  topred (Rred rule (Eval (Vptr b ofs) ty) m E0)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) (H : possible_trace w E0 w')","proofString":"inv H.\neconstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) : exists rule : string,\n  topred (Rred \"red_addrof\" (Eval (Vptr b ofs) ty) m E0) =\n  topred (Rred rule (Eval (Vptr b ofs) ty) m E0).","conclusion":"exists rule : string,\n  topred (Rred \"red_addrof\" (Eval (Vptr b ofs) ty) m E0) =\n  topred (Rred rule (Eval (Vptr b ofs) ty) m E0)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem)","proofString":"econstructor; eauto."},{"statement":"(w' : world) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (H0 : possible_trace w E0 w') : exists rule : string,\n  (do v0 <- sem_unary_operation op v1 ty1 m;\n   topred (Rred \"red_unop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_unary_operation op v1 ty1 m;\n   topred (Rred \"red_unop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) : exists rule : string,\n  (do v0 <- sem_unary_operation op v1 ty1 m;\n   topred (Rred \"red_unop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_unary_operation op v1 ty1 m;\n   topred (Rred \"red_unop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (H0 : possible_trace w E0 w') : exists rule : string,\n  (do v0 <- sem_binary_operation ge op v1 ty1 v2 ty2 m;\n   topred (Rred \"red_binop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_binary_operation ge op v1 ty1 v2 ty2 m;\n   topred (Rred \"red_binop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) : exists rule : string,\n  (do v0 <- sem_binary_operation ge op v1 ty1 v2 ty2 m;\n   topred (Rred \"red_binop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_binary_operation ge op v1 ty1 v2 ty2 m;\n   topred (Rred \"red_binop\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (H0 : possible_trace w E0 w') : exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty m; topred (Rred \"red_cast\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty m; topred (Rred \"red_cast\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) : exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty m; topred (Rred \"red_cast\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty m; topred (Rred \"red_cast\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w') : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w') : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.zero) ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.zero) ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.zero) ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true =>\n      topred (Rred \"red_seqand_true\" (Eparen r2 type_bool ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqand_false\" (Eval (Vint Int.zero) ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.zero) ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w') : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.one) ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.one) ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.one) ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eval (Vint Int.one) ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w') : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) : exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0).","conclusion":"exists rule : string,\n  match bool_val v1 ty1 m with\n  | Some true => topred (Rred \"red_seqor_true\" (Eval (Vint Int.one) ty) m E0)\n  | Some false =>\n      topred (Rred \"red_seqor_false\" (Eparen r2 type_bool ty) m E0)\n  | None => stuck\n  end = topred (Rred rule (Eparen r2 type_bool ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (H0 : possible_trace w E0 w') : exists rule : string,\n  (do b0 <- bool_val v1 ty1 m;\n   topred (Rred \"red_condition\" (Eparen (if b0 then r1 else r2) ty ty) m E0)) =\n  topred (Rred rule (Eparen (if b then r1 else r2) ty ty) m E0).","conclusion":"exists rule : string,\n  (do b0 <- bool_val v1 ty1 m;\n   topred (Rred \"red_condition\" (Eparen (if b0 then r1 else r2) ty ty) m E0)) =\n  topred (Rred rule (Eparen (if b then r1 else r2) ty ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) : exists rule : string,\n  (do b0 <- bool_val v1 ty1 m;\n   topred (Rred \"red_condition\" (Eparen (if b0 then r1 else r2) ty ty) m E0)) =\n  topred (Rred rule (Eparen (if b then r1 else r2) ty ty) m E0).","conclusion":"exists rule : string,\n  (do b0 <- bool_val v1 ty1 m;\n   topred (Rred \"red_condition\" (Eparen (if b0 then r1 else r2) ty ty) m E0)) =\n  topred (Rred rule (Eparen (if b then r1 else r2) ty ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (ty1 ty : type) (m : mem) (H : possible_trace w E0 w') : exists rule : string,\n  topred\n    (Rred \"red_sizeof\" (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0).","conclusion":"exists rule : string,\n  topred\n    (Rred \"red_sizeof\" (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0)","hypotheses":"(w' : world) (ty1 ty : type) (m : mem) (H : possible_trace w E0 w')","proofString":"inv H.\neconstructor; eauto."},{"statement":"(w' : world) (ty1 ty : type) (m : mem) : exists rule : string,\n  topred\n    (Rred \"red_sizeof\" (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0).","conclusion":"exists rule : string,\n  topred\n    (Rred \"red_sizeof\" (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) m E0)","hypotheses":"(w' : world) (ty1 ty : type) (m : mem)","proofString":"econstructor; eauto."},{"statement":"(w' : world) (ty1 ty : type) (m : mem) (H : possible_trace w E0 w') : exists rule : string,\n  topred\n    (Rred \"red_alignof\" (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m\n       E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m E0).","conclusion":"exists rule : string,\n  topred\n    (Rred \"red_alignof\" (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m\n       E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m E0)","hypotheses":"(w' : world) (ty1 ty : type) (m : mem) (H : possible_trace w E0 w')","proofString":"inv H.\neconstructor; eauto."},{"statement":"(w' : world) (ty1 ty : type) (m : mem) : exists rule : string,\n  topred\n    (Rred \"red_alignof\" (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m\n       E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m E0).","conclusion":"exists rule : string,\n  topred\n    (Rred \"red_alignof\" (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m\n       E0) =\n  topred (Rred rule (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) m E0)","hypotheses":"(w' : world) (ty1 ty : type) (m : mem)","proofString":"econstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w') : exists rule : string,\n  (check type_eq ty1 ty1;\n   do v0 <- sem_cast v2 ty2 ty1 m;\n   do _, t0, m'0, v'0 <- do_assign_loc w ty1 m b ofs bf v0;\n   topred (Rred \"red_assign\" (Eval v'0 ty1) m'0 t0)) =\n  topred (Rred rule (Eval v' ty1) m' t).","conclusion":"exists rule : string,\n  (check type_eq ty1 ty1;\n   do v0 <- sem_cast v2 ty2 ty1 m;\n   do _, t0, m'0, v'0 <- do_assign_loc w ty1 m b ofs bf v0;\n   topred (Rred \"red_assign\" (Eval v'0 ty1) m'0 t0)) =\n  topred (Rred rule (Eval v' ty1) m' t)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w')","proofString":"rewrite dec_eq_true.\nrewrite H.\nrewrite (do_assign_loc_complete _ _ _ _ _ _ _ _ _ _ _ H0 H1).\neconstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w') : exists rule : string,\n  (do v0 <- sem_cast v2 ty2 ty1 m;\n   do _, t0, m'0, v'0 <- do_assign_loc w ty1 m b ofs bf v0;\n   topred (Rred \"red_assign\" (Eval v'0 ty1) m'0 t0)) =\n  topred (Rred rule (Eval v' ty1) m' t).","conclusion":"exists rule : string,\n  (do v0 <- sem_cast v2 ty2 ty1 m;\n   do _, t0, m'0, v'0 <- do_assign_loc w ty1 m b ofs bf v0;\n   topred (Rred \"red_assign\" (Eval v'0 ty1) m'0 t0)) =\n  topred (Rred rule (Eval v' ty1) m' t)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w')","proofString":"rewrite H.\nrewrite (do_assign_loc_complete _ _ _ _ _ _ _ _ _ _ _ H0 H1).\neconstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w') : exists rule : string,\n  (do _, t0, m'0, v'0 <- do_assign_loc w ty1 m b ofs bf v;\n   topred (Rred \"red_assign\" (Eval v'0 ty1) m'0 t0)) =\n  topred (Rred rule (Eval v' ty1) m' t).","conclusion":"exists rule : string,\n  (do _, t0, m'0, v'0 <- do_assign_loc w ty1 m b ofs bf v;\n   topred (Rred \"red_assign\" (Eval v'0 ty1) m'0 t0)) =\n  topred (Rred rule (Eval v' ty1) m' t)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w')","proofString":"rewrite (do_assign_loc_complete _ _ _ _ _ _ _ _ _ _ _ H0 H1).\neconstructor; eauto."},{"statement":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w') : exists rule : string,\n  topred (Rred \"red_assign\" (Eval v' ty1) m' t) =\n  topred (Rred rule (Eval v' ty1) m' t).","conclusion":"exists rule : string,\n  topred (Rred \"red_assign\" (Eval v' ty1) m' t) =\n  topred (Rred rule (Eval v' ty1) m' t)","hypotheses":"(w' : world) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (H1 : possible_trace w t w')","proofString":"econstructor; eauto."},{"statement":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w') : exists rule : string,\n  (check type_eq ty1 ty1;\n   do _, t0, v0 <- do_deref_loc w ty1 m b ofs bf;\n   topred\n     (Rred \"red_assignop\"\n        (Eassign (Eloc b ofs bf ty1)\n           (Ebinop op (Eval v0 ty1) (Eval v2 ty2) tyres) ty1) m t0)) =\n  topred\n    (Rred rule\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t).","conclusion":"exists rule : string,\n  (check type_eq ty1 ty1;\n   do _, t0, v0 <- do_deref_loc w ty1 m b ofs bf;\n   topred\n     (Rred \"red_assignop\"\n        (Eassign (Eloc b ofs bf ty1)\n           (Ebinop op (Eval v0 ty1) (Eval v2 ty2) tyres) ty1) m t0)) =\n  topred\n    (Rred rule\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t)","hypotheses":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w')","proofString":"rewrite dec_eq_true.\nrewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ _ H H0).\neconstructor; eauto."},{"statement":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w') : exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty1 m b ofs bf;\n   topred\n     (Rred \"red_assignop\"\n        (Eassign (Eloc b ofs bf ty1)\n           (Ebinop op (Eval v0 ty1) (Eval v2 ty2) tyres) ty1) m t0)) =\n  topred\n    (Rred rule\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t).","conclusion":"exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty1 m b ofs bf;\n   topred\n     (Rred \"red_assignop\"\n        (Eassign (Eloc b ofs bf ty1)\n           (Ebinop op (Eval v0 ty1) (Eval v2 ty2) tyres) ty1) m t0)) =\n  topred\n    (Rred rule\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t)","hypotheses":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w')","proofString":"rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ _ H H0).\neconstructor; eauto."},{"statement":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w') : exists rule : string,\n  topred\n    (Rred \"red_assignop\"\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t) =\n  topred\n    (Rred rule\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t).","conclusion":"exists rule : string,\n  topred\n    (Rred \"red_assignop\"\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t) =\n  topred\n    (Rred rule\n       (Eassign (Eloc b ofs bf ty1)\n          (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres) ty1) m t)","hypotheses":"(w' : world) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (H0 : possible_trace w t w')","proofString":"econstructor; eauto."},{"statement":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (H1 : possible_trace w t w') : exists rule : string,\n  (check type_eq ty ty;\n   do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred\n     (Rred \"red_postincr\"\n        (Ecomma\n           (Eassign (Eloc b ofs bf ty)\n              (Ebinop match id with\n                      | Incr => Oadd\n                      | Decr => Osub\n                      end (Eval v0 ty) (Eval (Vint Int.one) type_int32s)\n                 (incrdecr_type ty)) ty) (Eval v0 ty) ty) m t0)) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t).","conclusion":"exists rule : string,\n  (check type_eq ty ty;\n   do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred\n     (Rred \"red_postincr\"\n        (Ecomma\n           (Eassign (Eloc b ofs bf ty)\n              (Ebinop match id with\n                      | Incr => Oadd\n                      | Decr => Osub\n                      end (Eval v0 ty) (Eval (Vint Int.one) type_int32s)\n                 (incrdecr_type ty)) ty) (Eval v0 ty) ty) m t0)) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t)","hypotheses":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (H1 : possible_trace w t w')","proofString":"rewrite dec_eq_true.\nsubst.\nrewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ _ H H1).\neconstructor; eauto."},{"statement":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (H1 : possible_trace w t w') : exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred\n     (Rred \"red_postincr\"\n        (Ecomma\n           (Eassign (Eloc b ofs bf ty)\n              (Ebinop match id with\n                      | Incr => Oadd\n                      | Decr => Osub\n                      end (Eval v0 ty) (Eval (Vint Int.one) type_int32s)\n                 (incrdecr_type ty)) ty) (Eval v0 ty) ty) m t0)) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t).","conclusion":"exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred\n     (Rred \"red_postincr\"\n        (Ecomma\n           (Eassign (Eloc b ofs bf ty)\n              (Ebinop match id with\n                      | Incr => Oadd\n                      | Decr => Osub\n                      end (Eval v0 ty) (Eval (Vint Int.one) type_int32s)\n                 (incrdecr_type ty)) ty) (Eval v0 ty) ty) m t0)) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t)","hypotheses":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (H1 : possible_trace w t w')","proofString":"subst.\nrewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ _ H H1).\neconstructor; eauto."},{"statement":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (H1 : possible_trace w t w') : exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred\n     (Rred \"red_postincr\"\n        (Ecomma\n           (Eassign (Eloc b ofs bf ty)\n              (Ebinop match id with\n                      | Incr => Oadd\n                      | Decr => Osub\n                      end (Eval v0 ty) (Eval (Vint Int.one) type_int32s)\n                 (incrdecr_type ty)) ty) (Eval v0 ty) ty) m t0)) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop match id with\n                     | Incr => Oadd\n                     | Decr => Osub\n                     end (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t).","conclusion":"exists rule : string,\n  (do _, t0, v0 <- do_deref_loc w ty m b ofs bf;\n   topred\n     (Rred \"red_postincr\"\n        (Ecomma\n           (Eassign (Eloc b ofs bf ty)\n              (Ebinop match id with\n                      | Incr => Oadd\n                      | Decr => Osub\n                      end (Eval v0 ty) (Eval (Vint Int.one) type_int32s)\n                 (incrdecr_type ty)) ty) (Eval v0 ty) ty) m t0)) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop match id with\n                     | Incr => Oadd\n                     | Decr => Osub\n                     end (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t)","hypotheses":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (H1 : possible_trace w t w')","proofString":"rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ _ H H1).\neconstructor; eauto."},{"statement":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (H1 : possible_trace w t w') : exists rule : string,\n  topred\n    (Rred \"red_postincr\"\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop match id with\n                     | Incr => Oadd\n                     | Decr => Osub\n                     end (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop match id with\n                     | Incr => Oadd\n                     | Decr => Osub\n                     end (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t).","conclusion":"exists rule : string,\n  topred\n    (Rred \"red_postincr\"\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop match id with\n                     | Incr => Oadd\n                     | Decr => Osub\n                     end (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t) =\n  topred\n    (Rred rule\n       (Ecomma\n          (Eassign (Eloc b ofs bf ty)\n             (Ebinop match id with\n                     | Incr => Oadd\n                     | Decr => Osub\n                     end (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n                (incrdecr_type ty)) ty) (Eval v1 ty) ty) m t)","hypotheses":"(w' : world) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (H1 : possible_trace w t w')","proofString":"econstructor; eauto."},{"statement":"(w' : world) (v : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : typeof r2 = ty) (H0 : possible_trace w E0 w') : exists rule : string,\n  (check type_eq (typeof r2) ty; topred (Rred \"red_comma\" r2 m E0)) =\n  topred (Rred rule r2 m E0).","conclusion":"exists rule : string,\n  (check type_eq (typeof r2) ty; topred (Rred \"red_comma\" r2 m E0)) =\n  topred (Rred rule r2 m E0)","hypotheses":"(w' : world) (v : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : typeof r2 = ty) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(w' : world) (v : val) (ty1 : type) (r2 : expr) (m : mem) : exists rule : string,\n  (check type_eq (typeof r2) (typeof r2); topred (Rred \"red_comma\" r2 m E0)) =\n  topred (Rred rule r2 m E0).","conclusion":"exists rule : string,\n  (check type_eq (typeof r2) (typeof r2); topred (Rred \"red_comma\" r2 m E0)) =\n  topred (Rred rule r2 m E0)","hypotheses":"(w' : world) (v : val) (ty1 : type) (r2 : expr) (m : mem)","proofString":"rewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(w' : world) (v : val) (ty1 : type) (r2 : expr) (m : mem) : exists rule : string,\n  topred (Rred \"red_comma\" r2 m E0) = topred (Rred rule r2 m E0).","conclusion":"exists rule : string,\n  topred (Rred \"red_comma\" r2 m E0) = topred (Rred rule r2 m E0)","hypotheses":"(w' : world) (v : val) (ty1 : type) (r2 : expr) (m : mem)","proofString":"econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (H0 : possible_trace w E0 w') : exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty2 m;\n   topred (Rred \"red_paren\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty2 m;\n   topred (Rred \"red_paren\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (H0 : possible_trace w E0 w')","proofString":"inv H0.\nrewrite H; econstructor; eauto."},{"statement":"(w' : world) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) : exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty2 m;\n   topred (Rred \"red_paren\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0).","conclusion":"exists rule : string,\n  (do v0 <- sem_cast v1 ty1 ty2 m;\n   topred (Rred \"red_paren\" (Eval v0 ty) m E0)) =\n  topred (Rred rule (Eval v ty) m E0)","hypotheses":"(w' : world) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v)","proofString":"rewrite H; econstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') : exists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t).","conclusion":"exists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w')","proofString":"exploit sem_cast_arguments_complete; eauto.\nintros [vtl [A B]].\nexploit do_ef_external_complete; eauto.\nintros C.\nrewrite A.\nrewrite B.\nrewrite C.\neconstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') : (exists vtl : list (val * type),\n   is_val_list el = Some vtl /\\ sem_cast_arguments vtl tyargs m = Some vargs) ->\nexists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t).","conclusion":"(exists vtl : list (val * type),\n   is_val_list el = Some vtl /\\ sem_cast_arguments vtl tyargs m = Some vargs) ->\nexists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w')","proofString":"intros [vtl [A B]].\nexploit do_ef_external_complete; eauto.\nintros C.\nrewrite A.\nrewrite B.\nrewrite C.\neconstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) : exists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t).","conclusion":"exists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs)","proofString":"exploit do_ef_external_complete; eauto.\nintros C.\nrewrite A.\nrewrite B.\nrewrite C.\neconstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) : do_external ef w vargs m = Some (w', t, vres, m') ->\nexists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t).","conclusion":"do_external ef w vargs m = Some (w', t, vres, m') ->\nexists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs)","proofString":"intros C.\nrewrite A.\nrewrite B.\nrewrite C.\neconstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m')) : exists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t).","conclusion":"exists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      do _, t0, v, m'0 <- do_external ef w vargs0 m;\n      topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)\n  | None =>\n      incontext (fun x : exprlist => Ebuiltin ef tyargs x ty)\n        (step_exprlist el m)\n  end = topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m'))","proofString":"rewrite A.\nrewrite B.\nrewrite C.\neconstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m')) : exists rule : string,\n  (do vargs0 <- sem_cast_arguments vtl tyargs m;\n   do _, t0, v, m'0 <- do_external ef w vargs0 m;\n   topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)) =\n  topred (Rred rule (Eval vres ty) m' t).","conclusion":"exists rule : string,\n  (do vargs0 <- sem_cast_arguments vtl tyargs m;\n   do _, t0, v, m'0 <- do_external ef w vargs0 m;\n   topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)) =\n  topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m'))","proofString":"rewrite B.\nrewrite C.\neconstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m')) : exists rule : string,\n  (do _, t0, v, m'0 <- do_external ef w vargs m;\n   topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)) =\n  topred (Rred rule (Eval vres ty) m' t).","conclusion":"exists rule : string,\n  (do _, t0, v, m'0 <- do_external ef w vargs m;\n   topred (Rred \"red_builtin\" (Eval v ty) m'0 t0)) =\n  topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m'))","proofString":"rewrite C.\neconstructor; eauto."},{"statement":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m')) : exists rule : string,\n  topred (Rred \"red_builtin\" (Eval vres ty) m' t) =\n  topred (Rred rule (Eval vres ty) m' t).","conclusion":"exists rule : string,\n  topred (Rred \"red_builtin\" (Eval vres ty) m' t) =\n  topred (Rred rule (Eval vres ty) m' t)","hypotheses":"(w' : world) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : possible_trace w t w') (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) (C : do_external ef w vargs m = Some (w', t, vres, m'))","proofString":"econstructor; eauto."},{"statement":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv) : exists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      match classify_fun tyf with\n      | fun_case_f tyargs0 tyres0 cconv0 =>\n          do fd0 <- Genv.find_funct ge vf;\n          do vargs0 <- sem_cast_arguments vtl tyargs0 m;\n          check type_eq (type_of_fundef fd0)\n                  (Tfunction tyargs0 tyres0 cconv0);\n          topred (Callred \"red_call\" fd0 vargs0 ty m)\n      | fun_default => stuck\n      end\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m).","conclusion":"exists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      match classify_fun tyf with\n      | fun_case_f tyargs0 tyres0 cconv0 =>\n          do fd0 <- Genv.find_funct ge vf;\n          do vargs0 <- sem_cast_arguments vtl tyargs0 m;\n          check type_eq (type_of_fundef fd0)\n                  (Tfunction tyargs0 tyres0 cconv0);\n          topred (Callred \"red_call\" fd0 vargs0 ty m)\n      | fun_default => stuck\n      end\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m)","hypotheses":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"rewrite H2.\nexploit sem_cast_arguments_complete; eauto.\nintros [vtl [A B]].\nrewrite A; rewrite H; rewrite B; rewrite H1; rewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv) : exists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do fd0 <- Genv.find_funct ge vf;\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      check type_eq (type_of_fundef fd0) (Tfunction tyargs tyres cconv);\n      topred (Callred \"red_call\" fd0 vargs0 ty m)\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m).","conclusion":"exists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do fd0 <- Genv.find_funct ge vf;\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      check type_eq (type_of_fundef fd0) (Tfunction tyargs tyres cconv);\n      topred (Callred \"red_call\" fd0 vargs0 ty m)\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m)","hypotheses":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"exploit sem_cast_arguments_complete; eauto.\nintros [vtl [A B]].\nrewrite A; rewrite H; rewrite B; rewrite H1; rewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv) : (exists vtl : list (val * type),\n   is_val_list el = Some vtl /\\ sem_cast_arguments vtl tyargs m = Some vargs) ->\nexists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do fd0 <- Genv.find_funct ge vf;\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      check type_eq (type_of_fundef fd0) (Tfunction tyargs tyres cconv);\n      topred (Callred \"red_call\" fd0 vargs0 ty m)\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m).","conclusion":"(exists vtl : list (val * type),\n   is_val_list el = Some vtl /\\ sem_cast_arguments vtl tyargs m = Some vargs) ->\nexists rule : string,\n  match is_val_list el with\n  | Some vtl =>\n      do fd0 <- Genv.find_funct ge vf;\n      do vargs0 <- sem_cast_arguments vtl tyargs m;\n      check type_eq (type_of_fundef fd0) (Tfunction tyargs tyres cconv);\n      topred (Callred \"red_call\" fd0 vargs0 ty m)\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m)","hypotheses":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"intros [vtl [A B]].\nrewrite A; rewrite H; rewrite B; rewrite H1; rewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) : exists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do fd0 <- Genv.find_funct ge vf;\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      check type_eq (type_of_fundef fd0) (Tfunction tyargs tyres cconv);\n      topred (Callred \"red_call\" fd0 vargs0 ty m)\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m).","conclusion":"exists rule : string,\n  match is_val_list el with\n  | Some vtl0 =>\n      do fd0 <- Genv.find_funct ge vf;\n      do vargs0 <- sem_cast_arguments vtl0 tyargs m;\n      check type_eq (type_of_fundef fd0) (Tfunction tyargs tyres cconv);\n      topred (Callred \"red_call\" fd0 vargs0 ty m)\n  | None =>\n      incontext2 (fun x : expr => Ecall x el ty) nil\n        (fun x : exprlist => Ecall (Eval vf tyf) x ty) \n        (step_exprlist el m)\n  end = topred (Callred rule fd vargs ty m)","hypotheses":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs)","proofString":"rewrite A; rewrite H; rewrite B; rewrite H1; rewrite dec_eq_true.\neconstructor; eauto."},{"statement":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs) : exists rule : string,\n  topred (Callred \"red_call\" fd vargs ty m) =\n  topred (Callred rule fd vargs ty m).","conclusion":"exists rule : string,\n  topred (Callred \"red_call\" fd vargs ty m) =\n  topred (Callred rule fd vargs ty m)","hypotheses":"(vf : val) (tyf : type) (m : mem) (tyargs : list type) (tyres : type) (cconv : calling_convention) (el : exprlist) (ty : type) (fd : fundef) (vargs : list val) (H : Genv.find_funct ge vf = Some fd) (H0 : cast_arguments m el tyargs vargs) (H1 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H2 : classify_fun tyf = fun_case_f tyargs tyres cconv) (vtl : list (val * type)) (A : is_val_list el = Some vtl) (B : sem_cast_arguments vtl tyargs m = Some vargs)","proofString":"econstructor; eauto."},{"statement":"(A1 : Type) (A2 : Type) (C : A1 -> A2) (res1 : reducts A1) (res2 : reducts A2) (H : forall (C0 : expr -> A1) (rd0 : reduction),\nIn (C0, rd0) res1 -> In (fun x : expr => C (C0 x), rd0) res2) (A3 : Type) (C' : A2 -> A3) (res3 : reducts A3) (H0 : forall (C0 : expr -> A2) (rd0 : reduction),\nIn (C0, rd0) res2 -> In (fun x : expr => C' (C0 x), rd0) res3) (C1 : expr -> A1) (rd : reduction) (H1 : In (C1, rd) res1) : In (fun x : expr => C' (C (C1 x)), rd) res3.","conclusion":"In (fun x : expr => C' (C (C1 x)), rd) res3","hypotheses":"(A1 : Type) (A2 : Type) (C : A1 -> A2) (res1 : reducts A1) (res2 : reducts A2) (H : forall (C0 : expr -> A1) (rd0 : reduction),\nIn (C0, rd0) res1 -> In (fun x : expr => C (C0 x), rd0) res2) (A3 : Type) (C' : A2 -> A3) (res3 : reducts A3) (H0 : forall (C0 : expr -> A2) (rd0 : reduction),\nIn (C0, rd0) res2 -> In (fun x : expr => C' (C0 x), rd0) res3) (C1 : expr -> A1) (rd : reduction) (H1 : In (C1, rd) res1)","proofString":"auto."},{"statement":"(A : Type) (B : Type) (C : A -> B) (res : reducts B) : forall (C1 : expr -> A) (rd : reduction),\nIn (C1, rd) nil -> In (fun x : expr => C (C1 x), rd) res.","conclusion":"forall (C1 : expr -> A) (rd : reduction),\nIn (C1, rd) nil -> In (fun x : expr => C (C1 x), rd) res","hypotheses":"(A : Type) (B : Type) (C : A -> B) (res : reducts B)","proofString":"intros; contradiction."},{"statement":"(A : Type) (a : expr) (m : mem) (v : val) (ty : type) (C : expr -> A) (res : reducts A) (H : is_val a = Some (v, ty)) : reducts_incl C (step_expr RV a m) res.","conclusion":"reducts_incl C (step_expr RV a m) res","hypotheses":"(A : Type) (a : expr) (m : mem) (v : val) (ty : type) (C : expr -> A) (res : reducts A) (H : is_val a = Some (v, ty))","proofString":"rewrite (is_val_inv _ _ _ H).\napply reducts_incl_nil."},{"statement":"(A : Type) (a : expr) (m : mem) (v : val) (ty : type) (C : expr -> A) (res : reducts A) (H : is_val a = Some (v, ty)) : reducts_incl C (step_expr RV (Eval v ty) m) res.","conclusion":"reducts_incl C (step_expr RV (Eval v ty) m) res","hypotheses":"(A : Type) (a : expr) (m : mem) (v : val) (ty : type) (C : expr -> A) (res : reducts A) (H : is_val a = Some (v, ty))","proofString":"apply reducts_incl_nil."},{"statement":"(A : Type) (a : expr) (m : mem) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (C : expr -> A) (res : reducts A) (H : is_loc a = Some (b, ofs, bf, ty)) : reducts_incl C (step_expr LV a m) res.","conclusion":"reducts_incl C (step_expr LV a m) res","hypotheses":"(A : Type) (a : expr) (m : mem) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (C : expr -> A) (res : reducts A) (H : is_loc a = Some (b, ofs, bf, ty))","proofString":"rewrite (is_loc_inv _ _ _ _ _ H).\napply reducts_incl_nil."},{"statement":"(A : Type) (a : expr) (m : mem) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (C : expr -> A) (res : reducts A) (H : is_loc a = Some (b, ofs, bf, ty)) : reducts_incl C (step_expr LV (Eloc b ofs bf ty) m) res.","conclusion":"reducts_incl C (step_expr LV (Eloc b ofs bf ty) m) res","hypotheses":"(A : Type) (a : expr) (m : mem) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (C : expr -> A) (res : reducts A) (H : is_loc a = Some (b, ofs, bf, ty))","proofString":"apply reducts_incl_nil."},{"statement":"(A : Type) (a : exprlist) (m : mem) (vtl : list (val * type)) (C : exprlist -> A) (res : reducts A) (H : is_val_list a = Some vtl) : reducts_incl C (step_exprlist a m) res.","conclusion":"reducts_incl C (step_exprlist a m) res","hypotheses":"(A : Type) (a : exprlist) (m : mem) (vtl : list (val * type)) (C : exprlist -> A) (res : reducts A) (H : is_val_list a = Some vtl)","proofString":"rewrite step_exprlist_val_list.\napply reducts_incl_nil.\ncongruence."},{"statement":"(A : Type) (a : exprlist) (m : mem) (vtl : list (val * type)) (C : exprlist -> A) (res : reducts A) (H : is_val_list a = Some vtl) : reducts_incl C nil res.","conclusion":"reducts_incl C nil res","hypotheses":"(A : Type) (a : exprlist) (m : mem) (vtl : list (val * type)) (C : exprlist -> A) (res : reducts A) (H : is_val_list a = Some vtl)","proofString":"apply reducts_incl_nil."},{"statement":"(A : Type) (a : exprlist) (m : mem) (vtl : list (val * type)) (C : exprlist -> A) (res : reducts A) (H : is_val_list a = Some vtl) : is_val_list a <> None.","conclusion":"is_val_list a <> None","hypotheses":"(A : Type) (a : exprlist) (m : mem) (vtl : list (val * type)) (C : exprlist -> A) (res : reducts A) (H : is_val_list a = Some vtl)","proofString":"congruence."},{"statement":"forall (A B : Type) (C : A -> B) (res : reducts A) \n  (C1 : expr -> A) (rd : reduction),\nIn (C1, rd) res ->\nIn (fun x : expr => C (C1 x), rd)\n  (map\n     (fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z))\n     res).","conclusion":"forall (A B : Type) (C : A -> B) (res : reducts A) \n  (C1 : expr -> A) (rd : reduction),\nIn (C1, rd) res ->\nIn (fun x : expr => C (C1 x), rd)\n  (map\n     (fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z))\n     res)","hypotheses":"","proofString":"intros.\nset (f := fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z)).\nchange (In (f (C1, rd)) (map f res)).\napply in_map.\nauto."},{"statement":"(A : Type) (B : Type) (C : A -> B) (res : reducts A) (C1 : expr -> A) (rd : reduction) (H : In (C1, rd) res) : In (fun x : expr => C (C1 x), rd)\n  (map\n     (fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z))\n     res).","conclusion":"In (fun x : expr => C (C1 x), rd)\n  (map\n     (fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z))\n     res)","hypotheses":"(A : Type) (B : Type) (C : A -> B) (res : reducts A) (C1 : expr -> A) (rd : reduction) (H : In (C1, rd) res)","proofString":"set (f := fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z)).\nchange (In (f (C1, rd)) (map f res)).\napply in_map.\nauto."},{"statement":"(A : Type) (B : Type) (C : A -> B) (res : reducts A) (C1 : expr -> A) (rd : reduction) (H : In (C1, rd) res) (f : (expr -> A) * reduction -> (expr -> B) * reduction) : In (f (C1, rd)) (map f res).","conclusion":"In (f (C1, rd)) (map f res)","hypotheses":"(A : Type) (B : Type) (C : A -> B) (res : reducts A) (C1 : expr -> A) (rd : reduction) (H : In (C1, rd) res) (f : (expr -> A) * reduction -> (expr -> B) * reduction)","proofString":"apply in_map.\nauto."},{"statement":"(A : Type) (B : Type) (C : A -> B) (res : reducts A) (C1 : expr -> A) (rd : reduction) (H : In (C1, rd) res) (f : (expr -> A) * reduction -> (expr -> B) * reduction) : In (C1, rd) res.","conclusion":"In (C1, rd) res","hypotheses":"(A : Type) (B : Type) (C : A -> B) (res : reducts A) (C1 : expr -> A) (rd : reduction) (H : In (C1, rd) res) (f : (expr -> A) * reduction -> (expr -> B) * reduction)","proofString":"auto."},{"statement":"forall (A1 A2 B : Type) (C1 : A1 -> B) (res1 : reducts A1) \n  (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) \n  (rd : reduction),\nIn (C0, rd) res1 ->\nIn (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2).","conclusion":"forall (A1 A2 B : Type) (C1 : A1 -> B) (res1 : reducts A1) \n  (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) \n  (rd : reduction),\nIn (C0, rd) res1 ->\nIn (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)","hypotheses":"","proofString":"intros.\nrewrite in_app_iff.\nleft.\nset (f := fun z : (expr -> A1) * reduction => (fun x : expr => C1 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res1)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1) : In (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2).","conclusion":"In (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1)","proofString":"rewrite in_app_iff.\nleft.\nset (f := fun z : (expr -> A1) * reduction => (fun x : expr => C1 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res1)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1) : In (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1) \\/\nIn (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2).","conclusion":"In (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1) \\/\nIn (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1)","proofString":"left.\nset (f := fun z : (expr -> A1) * reduction => (fun x : expr => C1 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res1)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1) : In (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1).","conclusion":"In (fun x : expr => C1 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1)","proofString":"set (f := fun z : (expr -> A1) * reduction => (fun x : expr => C1 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res1)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1) (f : (expr -> A1) * reduction -> (expr -> B) * reduction) : In (f (C0, rd)) (map f res1).","conclusion":"In (f (C0, rd)) (map f res1)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A1) (rd : reduction) (H : In (C0, rd) res1) (f : (expr -> A1) * reduction -> (expr -> B) * reduction)","proofString":"apply in_map; auto."},{"statement":"forall (A1 A2 B : Type) (C1 : A1 -> B) (res1 : reducts A1) \n  (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) \n  (rd : reduction),\nIn (C0, rd) res2 ->\nIn (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2).","conclusion":"forall (A1 A2 B : Type) (C1 : A1 -> B) (res1 : reducts A1) \n  (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) \n  (rd : reduction),\nIn (C0, rd) res2 ->\nIn (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)","hypotheses":"","proofString":"intros.\nrewrite in_app_iff.\nright.\nset (f := fun z : (expr -> A2) * reduction => (fun x : expr => C2 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res2)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2) : In (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2).","conclusion":"In (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1 ++\n   map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2)","proofString":"rewrite in_app_iff.\nright.\nset (f := fun z : (expr -> A2) * reduction => (fun x : expr => C2 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res2)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2) : In (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1) \\/\nIn (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2).","conclusion":"In (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A1) * reduction =>\n      (fun x : expr => C1 (fst z x), snd z)) res1) \\/\nIn (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2)","proofString":"right.\nset (f := fun z : (expr -> A2) * reduction => (fun x : expr => C2 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res2)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2) : In (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2).","conclusion":"In (fun x : expr => C2 (C0 x), rd)\n  (map\n     (fun z : (expr -> A2) * reduction =>\n      (fun x : expr => C2 (fst z x), snd z)) res2)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2)","proofString":"set (f := fun z : (expr -> A2) * reduction => (fun x : expr => C2 (fst z x), snd z)).\nchange (In (f (C0, rd)) (map f res2)).\napply in_map; auto."},{"statement":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2) (f : (expr -> A2) * reduction -> (expr -> B) * reduction) : In (f (C0, rd)) (map f res2).","conclusion":"In (f (C0, rd)) (map f res2)","hypotheses":"(A1 : Type) (A2 : Type) (B : Type) (C1 : A1 -> B) (res1 : reducts A1) (C2 : A2 -> B) (res2 : reducts A2) (C0 : expr -> A2) (rd : reduction) (H : In (C0, rd) res2) (f : (expr -> A2) * reduction -> (expr -> B) * reduction)","proofString":"apply in_map; auto."},{"statement":"(m : mem) (a : expr) (k : kind) (H : forall C : expr -> expr, ~ In (C, Stuckred) (step_expr k a m)) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (H : forall C : expr -> expr, ~ In (C, Stuckred) (step_expr k a m))","proofString":"generalize (step_expr_sound a k m).\nintros [A B].\ndestruct (step_expr k a m) as [|[C rd] res] eqn:?.\nspecialize (B (eq_refl _)).\ndestruct k.\ndestruct a; simpl in B; try congruence.\nconstructor.\ndestruct a; simpl in B; try congruence.\nconstructor.\nassert (NOTSTUCK: rd <> Stuckred).\nred; intros.\nelim (H C); subst rd; auto with coqlib.\nexploit A.\neauto with coqlib.\nintros [a' [k' [P [Q R]]]].\ndestruct k'; destruct rd; simpl in R; intuition.\nsubst a.\neapply imm_safe_t_lred; eauto.\nsubst a.\ndestruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto.\nsubst.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (H : forall C : expr -> expr, ~ In (C, Stuckred) (step_expr k a m)) : reducts_ok k a m (step_expr k a m) -> imm_safe_t k a m.","conclusion":"reducts_ok k a m (step_expr k a m) -> imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (H : forall C : expr -> expr, ~ In (C, Stuckred) (step_expr k a m))","proofString":"intros [A B].\ndestruct (step_expr k a m) as [|[C rd] res] eqn:?.\nspecialize (B (eq_refl _)).\ndestruct k.\ndestruct a; simpl in B; try congruence.\nconstructor.\ndestruct a; simpl in B; try congruence.\nconstructor.\nassert (NOTSTUCK: rd <> Stuckred).\nred; intros.\nelim (H C); subst rd; auto with coqlib.\nexploit A.\neauto with coqlib.\nintros [a' [k' [P [Q R]]]].\ndestruct k'; destruct rd; simpl in R; intuition.\nsubst a.\neapply imm_safe_t_lred; eauto.\nsubst a.\ndestruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto.\nsubst.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (H : forall C : expr -> expr, ~ In (C, Stuckred) (step_expr k a m)) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) (step_expr k a m) ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : step_expr k a m = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (H : forall C : expr -> expr, ~ In (C, Stuckred) (step_expr k a m)) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) (step_expr k a m) ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : step_expr k a m = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend)","proofString":"destruct (step_expr k a m) as [|[C rd] res] eqn:?.\nspecialize (B (eq_refl _)).\ndestruct k.\ndestruct a; simpl in B; try congruence.\nconstructor.\ndestruct a; simpl in B; try congruence.\nconstructor.\nassert (NOTSTUCK: rd <> Stuckred).\nred; intros.\nelim (H C); subst rd; auto with coqlib.\nexploit A.\neauto with coqlib.\nintros [a' [k' [P [Q R]]]].\ndestruct k'; destruct rd; simpl in R; intuition.\nsubst a.\neapply imm_safe_t_lred; eauto.\nsubst a.\ndestruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto.\nsubst.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (Heqr : step_expr k a m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (Heqr : step_expr k a m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' k C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : match k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend)","proofString":"destruct k.\ndestruct a; simpl in B; try congruence.\nconstructor.\ndestruct a; simpl in B; try congruence.\nconstructor."},{"statement":"(m : mem) (a : expr) (Heqr : step_expr LV a m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' LV C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : is_loc a <> None) : imm_safe_t LV a m.","conclusion":"imm_safe_t LV a m","hypotheses":"(m : mem) (a : expr) (Heqr : step_expr LV a m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' LV C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : is_loc a <> None)","proofString":"destruct a; simpl in B; try congruence.\nconstructor."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (Heqr : step_expr LV (Eloc b ofs bf ty) m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' LV C /\\ Eloc b ofs bf ty = C a' /\\ reduction_ok k' a' m rd) (B : Some (b, ofs, bf, ty) <> None) : imm_safe_t LV (Eloc b ofs bf ty) m.","conclusion":"imm_safe_t LV (Eloc b ofs bf ty) m","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (Heqr : step_expr LV (Eloc b ofs bf ty) m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' LV C /\\ Eloc b ofs bf ty = C a' /\\ reduction_ok k' a' m rd) (B : Some (b, ofs, bf, ty) <> None)","proofString":"constructor."},{"statement":"(m : mem) (a : expr) (Heqr : step_expr RV a m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : is_val a <> None) : imm_safe_t RV a m.","conclusion":"imm_safe_t RV a m","hypotheses":"(m : mem) (a : expr) (Heqr : step_expr RV a m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ a = C a' /\\ reduction_ok k' a' m rd) (B : is_val a <> None)","proofString":"destruct a; simpl in B; try congruence.\nconstructor."},{"statement":"(m : mem) (v : val) (ty : type) (Heqr : step_expr RV (Eval v ty) m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ Eval v ty = C a' /\\ reduction_ok k' a' m rd) (B : Some (v, ty) <> None) : imm_safe_t RV (Eval v ty) m.","conclusion":"imm_safe_t RV (Eval v ty) m","hypotheses":"(m : mem) (v : val) (ty : type) (Heqr : step_expr RV (Eval v ty) m = nil) (H : forall C : expr -> expr, ~ In (C, Stuckred) nil) (A : forall (C : expr -> expr) (rd : reduction),\nIn (C, rd) nil ->\nexists (a' : expr) (k' : kind),\n  context k' RV C /\\ Eval v ty = C a' /\\ reduction_ok k' a' m rd) (B : Some (v, ty) <> None)","proofString":"constructor."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend)","proofString":"assert (NOTSTUCK: rd <> Stuckred).\nred; intros.\nelim (H C); subst rd; auto with coqlib.\nexploit A.\neauto with coqlib.\nintros [a' [k' [P [Q R]]]].\ndestruct k'; destruct rd; simpl in R; intuition.\nsubst a.\neapply imm_safe_t_lred; eauto.\nsubst a.\ndestruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto.\nsubst.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) : rd <> Stuckred.","conclusion":"rd <> Stuckred","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend)","proofString":"red; intros.\nelim (H C); subst rd; auto with coqlib."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) (H0 : rd = Stuckred) : False.","conclusion":"False","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) (H0 : rd = Stuckred)","proofString":"elim (H C); subst rd; auto with coqlib."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) (NOTSTUCK : rd <> Stuckred) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a' : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a' /\\ reduction_ok k' a' m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) (NOTSTUCK : rd <> Stuckred)","proofString":"exploit A.\neauto with coqlib.\nintros [a' [k' [P [Q R]]]].\ndestruct k'; destruct rd; simpl in R; intuition.\nsubst a.\neapply imm_safe_t_lred; eauto.\nsubst a.\ndestruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto.\nsubst.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) (NOTSTUCK : rd <> Stuckred) (a' : expr) (k' : kind) (P : context k' k C) (Q : a = C a') (R : reduction_ok k' a' m rd) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rd : reduction) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, rd) :: res) (H : forall C0 : expr -> expr, ~ In (C0, Stuckred) ((C, rd) :: res)) (A : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) ((C, rd) :: res) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 k C0 /\\ a = C0 a'0 /\\ reduction_ok k'0 a'0 m rd0) (B : (C, rd) :: res = nil ->\nmatch k with\n| LV => is_loc a <> None\n| RV => is_val a <> None\nend) (NOTSTUCK : rd <> Stuckred) (a' : expr) (k' : kind) (P : context k' k C) (Q : a = C a') (R : reduction_ok k' a' m rd)","proofString":"destruct k'; destruct rd; simpl in R; intuition.\nsubst a.\neapply imm_safe_t_lred; eauto.\nsubst a.\ndestruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto.\nsubst.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rule : string) (l' : expr) (m' : mem) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, Lred rule l' m') :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Lred rule l' m') :: res) -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Lred rule l' m') :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Lred rule l' m') :: res = nil ->\nmatch k with\n| LV => is_loc a = None -> False\n| RV => is_val a = None -> False\nend) (NOTSTUCK : Lred rule l' m' = Stuckred -> False) (a' : expr) (P : context LV k C) (Q : a = C a') (R : lred ge e a' m l' m') : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rule : string) (l' : expr) (m' : mem) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, Lred rule l' m') :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Lred rule l' m') :: res) -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Lred rule l' m') :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Lred rule l' m') :: res = nil ->\nmatch k with\n| LV => is_loc a = None -> False\n| RV => is_val a = None -> False\nend) (NOTSTUCK : Lred rule l' m' = Stuckred -> False) (a' : expr) (P : context LV k C) (Q : a = C a') (R : lred ge e a' m l' m')","proofString":"subst a.\neapply imm_safe_t_lred; eauto."},{"statement":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (l' : expr) (m' : mem) (res : list ((expr -> expr) * reduction)) (a' : expr) (Heqr : step_expr k (C a') m = (C, Lred rule l' m') :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Lred rule l' m') :: res) -> False) (B : (C, Lred rule l' m') :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Lred rule l' m') :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (NOTSTUCK : Lred rule l' m' = Stuckred -> False) (P : context LV k C) (R : lred ge e a' m l' m') : imm_safe_t k (C a') m.","conclusion":"imm_safe_t k (C a') m","hypotheses":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (l' : expr) (m' : mem) (res : list ((expr -> expr) * reduction)) (a' : expr) (Heqr : step_expr k (C a') m = (C, Lred rule l' m') :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Lred rule l' m') :: res) -> False) (B : (C, Lred rule l' m') :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Lred rule l' m') :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (NOTSTUCK : Lred rule l' m' = Stuckred -> False) (P : context LV k C) (R : lred ge e a' m l' m')","proofString":"eapply imm_safe_t_lred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rule : string) (r' : expr) (m' : mem) (t : trace) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, Rred rule r' m' t) :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Rred rule r' m' t) :: res) -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Rred rule r' m' t) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Rred rule r' m' t) :: res = nil ->\nmatch k with\n| LV => is_loc a = None -> False\n| RV => is_val a = None -> False\nend) (NOTSTUCK : Rred rule r' m' t = Stuckred -> False) (a' : expr) (P : context RV k C) (Q : a = C a') (H0 : rred ge a' m t r' m') (H1 : exists w' : world, possible_trace w t w') : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rule : string) (r' : expr) (m' : mem) (t : trace) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, Rred rule r' m' t) :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Rred rule r' m' t) :: res) -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Rred rule r' m' t) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Rred rule r' m' t) :: res = nil ->\nmatch k with\n| LV => is_loc a = None -> False\n| RV => is_val a = None -> False\nend) (NOTSTUCK : Rred rule r' m' t = Stuckred -> False) (a' : expr) (P : context RV k C) (Q : a = C a') (H0 : rred ge a' m t r' m') (H1 : exists w' : world, possible_trace w t w')","proofString":"subst a.\ndestruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto."},{"statement":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (r' : expr) (m' : mem) (t : trace) (res : list ((expr -> expr) * reduction)) (a' : expr) (Heqr : step_expr k (C a') m = (C, Rred rule r' m' t) :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Rred rule r' m' t) :: res) -> False) (B : (C, Rred rule r' m' t) :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Rred rule r' m' t) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (NOTSTUCK : Rred rule r' m' t = Stuckred -> False) (P : context RV k C) (H0 : rred ge a' m t r' m') (H1 : exists w' : world, possible_trace w t w') : imm_safe_t k (C a') m.","conclusion":"imm_safe_t k (C a') m","hypotheses":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (r' : expr) (m' : mem) (t : trace) (res : list ((expr -> expr) * reduction)) (a' : expr) (Heqr : step_expr k (C a') m = (C, Rred rule r' m' t) :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Rred rule r' m' t) :: res) -> False) (B : (C, Rred rule r' m' t) :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Rred rule r' m' t) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (NOTSTUCK : Rred rule r' m' t = Stuckred -> False) (P : context RV k C) (H0 : rred ge a' m t r' m') (H1 : exists w' : world, possible_trace w t w')","proofString":"destruct H1 as [w' PT].\neapply imm_safe_t_rred; eauto."},{"statement":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (r' : expr) (m' : mem) (t : trace) (res : list ((expr -> expr) * reduction)) (a' : expr) (Heqr : step_expr k (C a') m = (C, Rred rule r' m' t) :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Rred rule r' m' t) :: res) -> False) (B : (C, Rred rule r' m' t) :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Rred rule r' m' t) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (NOTSTUCK : Rred rule r' m' t = Stuckred -> False) (P : context RV k C) (H0 : rred ge a' m t r' m') (w' : world) (PT : possible_trace w t w') : imm_safe_t k (C a') m.","conclusion":"imm_safe_t k (C a') m","hypotheses":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (r' : expr) (m' : mem) (t : trace) (res : list ((expr -> expr) * reduction)) (a' : expr) (Heqr : step_expr k (C a') m = (C, Rred rule r' m' t) :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Rred rule r' m' t) :: res) -> False) (B : (C, Rred rule r' m' t) :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Rred rule r' m' t) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (NOTSTUCK : Rred rule r' m' t = Stuckred -> False) (P : context RV k C) (H0 : rred ge a' m t r' m') (w' : world) (PT : possible_trace w t w')","proofString":"eapply imm_safe_t_rred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rule : string) (fd : fundef) (args : list val) (tyres : type) (m' : mem) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, Callred rule fd args tyres m') :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Callred rule fd args tyres m') :: res) -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Callred rule fd args tyres m') :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Callred rule fd args tyres m') :: res = nil ->\nmatch k with\n| LV => is_loc a = None -> False\n| RV => is_val a = None -> False\nend) (NOTSTUCK : Callred rule fd args tyres m' = Stuckred -> False) (a' : expr) (P : context RV k C) (Q : a = C a') (H0 : callred ge a' m fd args tyres) (H1 : m' = m) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (rule : string) (fd : fundef) (args : list val) (tyres : type) (m' : mem) (res : list ((expr -> expr) * reduction)) (Heqr : step_expr k a m = (C, Callred rule fd args tyres m') :: res) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Callred rule fd args tyres m') :: res) -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Callred rule fd args tyres m') :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ a = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Callred rule fd args tyres m') :: res = nil ->\nmatch k with\n| LV => is_loc a = None -> False\n| RV => is_val a = None -> False\nend) (NOTSTUCK : Callred rule fd args tyres m' = Stuckred -> False) (a' : expr) (P : context RV k C) (Q : a = C a') (H0 : callred ge a' m fd args tyres) (H1 : m' = m)","proofString":"subst.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (fd : fundef) (args : list val) (tyres : type) (res : list ((expr -> expr) * reduction)) (a' : expr) (NOTSTUCK : Callred rule fd args tyres m = Stuckred -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Callred rule fd args tyres m) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Callred rule fd args tyres m) :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Callred rule fd args tyres m) :: res) -> False) (Heqr : step_expr k (C a') m = (C, Callred rule fd args tyres m) :: res) (P : context RV k C) (H0 : callred ge a' m fd args tyres) : imm_safe_t k (C a') m.","conclusion":"imm_safe_t k (C a') m","hypotheses":"(m : mem) (k : kind) (C : expr -> expr) (rule : string) (fd : fundef) (args : list val) (tyres : type) (res : list ((expr -> expr) * reduction)) (a' : expr) (NOTSTUCK : Callred rule fd args tyres m = Stuckred -> False) (A : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) ((C, Callred rule fd args tyres m) :: res) ->\nexists (a'0 : expr) (k' : kind),\n  context k' k C0 /\\ C a' = C0 a'0 /\\ reduction_ok k' a'0 m rd) (B : (C, Callred rule fd args tyres m) :: res = nil ->\nmatch k with\n| LV => is_loc (C a') = None -> False\n| RV => is_val (C a') = None -> False\nend) (H : forall C0 : expr -> expr,\nIn (C0, Stuckred) ((C, Callred rule fd args tyres m) :: res) -> False) (Heqr : step_expr k (C a') m = (C, Callred rule fd args tyres m) :: res) (P : context RV k C) (H0 : callred ge a' m fd args tyres)","proofString":"eapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) : exists C' : expr -> expr, In (C', Stuckred) (step_expr RV (C a) m).","conclusion":"exists C' : expr -> expr, In (C', Stuckred) (step_expr RV (C a) m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m)","proofString":"assert (exists C', In (C', Stuckred) (step_expr k a m)).\ndestruct (classic (exists C', In (C', Stuckred) (step_expr k a m))); auto.\nelim H0.\napply not_stuckred_imm_safe.\napply not_ex_all_not.\nauto.\ndestruct H1 as [C' IN].\nspecialize (step_expr_context _ _ _ H a m).\nunfold reducts_incl.\nintro.\nexists (fun x => (C (C' x))).\napply H1; auto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) : exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m).","conclusion":"exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m)","proofString":"destruct (classic (exists C', In (C', Stuckred) (step_expr k a m))); auto.\nelim H0.\napply not_stuckred_imm_safe.\napply not_ex_all_not.\nauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m))) : exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m).","conclusion":"exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m)))","proofString":"elim H0.\napply not_stuckred_imm_safe.\napply not_ex_all_not.\nauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m))) : imm_safe_t k a m.","conclusion":"imm_safe_t k a m","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m)))","proofString":"apply not_stuckred_imm_safe.\napply not_ex_all_not.\nauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m))) : forall C0 : expr -> expr, ~ In (C0, Stuckred) (step_expr k a m).","conclusion":"forall C0 : expr -> expr, ~ In (C0, Stuckred) (step_expr k a m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m)))","proofString":"apply not_ex_all_not.\nauto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m))) : ~ (exists n : expr -> expr, In (n, Stuckred) (step_expr k a m)).","conclusion":"~ (exists n : expr -> expr, In (n, Stuckred) (step_expr k a m))","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : ~ (exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m)))","proofString":"auto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m)) : exists C' : expr -> expr, In (C', Stuckred) (step_expr RV (C a) m).","conclusion":"exists C' : expr -> expr, In (C', Stuckred) (step_expr RV (C a) m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (H1 : exists C' : expr -> expr, In (C', Stuckred) (step_expr k a m))","proofString":"destruct H1 as [C' IN].\nspecialize (step_expr_context _ _ _ H a m).\nunfold reducts_incl.\nintro.\nexists (fun x => (C (C' x))).\napply H1; auto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m)) : exists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m).","conclusion":"exists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m))","proofString":"specialize (step_expr_context _ _ _ H a m).\nunfold reducts_incl.\nintro.\nexists (fun x => (C (C' x))).\napply H1; auto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m)) : reducts_incl C (step_expr k a m) (step_expr RV (C a) m) ->\nexists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m).","conclusion":"reducts_incl C (step_expr k a m) (step_expr RV (C a) m) ->\nexists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m))","proofString":"unfold reducts_incl.\nintro.\nexists (fun x => (C (C' x))).\napply H1; auto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m)) : (forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr k a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr RV (C a) m)) ->\nexists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m).","conclusion":"(forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr k a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr RV (C a) m)) ->\nexists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m))","proofString":"intro.\nexists (fun x => (C (C' x))).\napply H1; auto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m)) (H1 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr k a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr RV (C a) m)) : exists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m).","conclusion":"exists C'0 : expr -> expr, In (C'0, Stuckred) (step_expr RV (C a) m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m)) (H1 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr k a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr RV (C a) m))","proofString":"exists (fun x => (C (C' x))).\napply H1; auto."},{"statement":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m)) (H1 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr k a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr RV (C a) m)) : In (fun x : expr => C (C' x), Stuckred) (step_expr RV (C a) m).","conclusion":"In (fun x : expr => C (C' x), Stuckred) (step_expr RV (C a) m)","hypotheses":"(m : mem) (a : expr) (k : kind) (C : expr -> expr) (H : context k RV C) (H0 : ~ imm_safe_t k a m) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr k a m)) (H1 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr k a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr RV (C a) m))","proofString":"apply H1; auto."},{"statement":"(k : kind) (a : expr) (m : mem) (H : imm_safe ge e k a m) : imm_safe_t k a m \\/\n(exists (C : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV k C /\\\n   a = C a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w')).","conclusion":"imm_safe_t k a m \\/\n(exists (C : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV k C /\\\n   a = C a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w'))","hypotheses":"(k : kind) (a : expr) (m : mem) (H : imm_safe ge e k a m)","proofString":"inv H.\nleft.\napply imm_safe_t_val.\nleft.\napply imm_safe_t_loc.\nleft.\neapply imm_safe_t_lred; eauto.\ndestruct (classic (exists w', possible_trace w t w')) as [[w' A] | A].\nleft.\neapply imm_safe_t_rred; eauto.\nright.\nexists C; exists e0; exists t; exists e'; exists m'; intuition.\napply A; exists w'; auto.\nleft.\neapply imm_safe_t_callred; eauto."},{"statement":"(m : mem) (v : val) (ty : type) : imm_safe_t RV (Eval v ty) m \\/\n(exists (C : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV RV C /\\\n   Eval v ty = C a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w')).","conclusion":"imm_safe_t RV (Eval v ty) m \\/\n(exists (C : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV RV C /\\\n   Eval v ty = C a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w'))","hypotheses":"(m : mem) (v : val) (ty : type)","proofString":"left.\napply imm_safe_t_val."},{"statement":"(m : mem) (v : val) (ty : type) : imm_safe_t RV (Eval v ty) m.","conclusion":"imm_safe_t RV (Eval v ty) m","hypotheses":"(m : mem) (v : val) (ty : type)","proofString":"apply imm_safe_t_val."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) : imm_safe_t LV (Eloc b ofs bf ty) m \\/\n(exists (C : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV LV C /\\\n   Eloc b ofs bf ty = C a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w')).","conclusion":"imm_safe_t LV (Eloc b ofs bf ty) m \\/\n(exists (C : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV LV C /\\\n   Eloc b ofs bf ty = C a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w'))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type)","proofString":"left.\napply imm_safe_t_loc."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) : imm_safe_t LV (Eloc b ofs bf ty) m.","conclusion":"imm_safe_t LV (Eloc b ofs bf ty) m","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type)","proofString":"apply imm_safe_t_loc."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C) : imm_safe_t k (C e0) m \\/\n(exists (C0 : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t a1' m'0 /\\ (forall w' : world, ~ possible_trace w t w')).","conclusion":"imm_safe_t k (C e0) m \\/\n(exists (C0 : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t a1' m'0 /\\ (forall w' : world, ~ possible_trace w t w'))","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C)","proofString":"left.\neapply imm_safe_t_lred; eauto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C) : imm_safe_t k (C e0) m.","conclusion":"imm_safe_t k (C e0) m","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 e' : expr) (m' : mem) (H0 : lred ge e e0 m e' m') (H1 : context LV k C)","proofString":"eapply imm_safe_t_lred; eauto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) : imm_safe_t k (C e0) m \\/\n(exists\n   (C0 : expr -> expr) (a1 : expr) (t0 : trace) (a1' : expr) \n (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t0 a1' m'0 /\\ (forall w' : world, ~ possible_trace w t0 w')).","conclusion":"imm_safe_t k (C e0) m \\/\n(exists\n   (C0 : expr -> expr) (a1 : expr) (t0 : trace) (a1' : expr) \n (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t0 a1' m'0 /\\ (forall w' : world, ~ possible_trace w t0 w'))","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C)","proofString":"destruct (classic (exists w', possible_trace w t w')) as [[w' A] | A].\nleft.\neapply imm_safe_t_rred; eauto.\nright.\nexists C; exists e0; exists t; exists e'; exists m'; intuition.\napply A; exists w'; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (w' : world) (A : possible_trace w t w') : imm_safe_t k (C e0) m \\/\n(exists\n   (C0 : expr -> expr) (a1 : expr) (t0 : trace) (a1' : expr) \n (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t0 a1' m'0 /\\ (forall w'0 : world, ~ possible_trace w t0 w'0)).","conclusion":"imm_safe_t k (C e0) m \\/\n(exists\n   (C0 : expr -> expr) (a1 : expr) (t0 : trace) (a1' : expr) \n (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t0 a1' m'0 /\\ (forall w'0 : world, ~ possible_trace w t0 w'0))","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (w' : world) (A : possible_trace w t w')","proofString":"left.\neapply imm_safe_t_rred; eauto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (w' : world) (A : possible_trace w t w') : imm_safe_t k (C e0) m.","conclusion":"imm_safe_t k (C e0) m","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (w' : world) (A : possible_trace w t w')","proofString":"eapply imm_safe_t_rred; eauto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (A : ~ (exists w' : world, possible_trace w t w')) : imm_safe_t k (C e0) m \\/\n(exists\n   (C0 : expr -> expr) (a1 : expr) (t0 : trace) (a1' : expr) \n (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t0 a1' m'0 /\\ (forall w' : world, ~ possible_trace w t0 w')).","conclusion":"imm_safe_t k (C e0) m \\/\n(exists\n   (C0 : expr -> expr) (a1 : expr) (t0 : trace) (a1' : expr) \n (m'0 : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t0 a1' m'0 /\\ (forall w' : world, ~ possible_trace w t0 w'))","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (A : ~ (exists w' : world, possible_trace w t w'))","proofString":"right.\nexists C; exists e0; exists t; exists e'; exists m'; intuition.\napply A; exists w'; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (A : ~ (exists w' : world, possible_trace w t w')) : exists (C0 : expr -> expr) (a1 : expr) (t0 : trace) \n(a1' : expr) (m'0 : mem),\n  context RV k C0 /\\\n  C e0 = C0 a1 /\\\n  rred ge a1 m t0 a1' m'0 /\\ (forall w' : world, ~ possible_trace w t0 w').","conclusion":"exists (C0 : expr -> expr) (a1 : expr) (t0 : trace) \n(a1' : expr) (m'0 : mem),\n  context RV k C0 /\\\n  C e0 = C0 a1 /\\\n  rred ge a1 m t0 a1' m'0 /\\ (forall w' : world, ~ possible_trace w t0 w')","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (A : ~ (exists w' : world, possible_trace w t w'))","proofString":"exists C; exists e0; exists t; exists e'; exists m'; intuition.\napply A; exists w'; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (A : (exists w'0 : world, possible_trace w t w'0) -> False) (w' : world) (H : possible_trace w t w') : False.","conclusion":"False","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (t : trace) (e' : expr) (m' : mem) (H0 : rred ge e0 m t e' m') (H1 : context RV k C) (A : (exists w'0 : world, possible_trace w t w'0) -> False) (w' : world) (H : possible_trace w t w')","proofString":"apply A; exists w'; auto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C) : imm_safe_t k (C e0) m \\/\n(exists (C0 : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w')).","conclusion":"imm_safe_t k (C e0) m \\/\n(exists (C0 : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV k C0 /\\\n   C e0 = C0 a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w'))","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C)","proofString":"left.\neapply imm_safe_t_callred; eauto."},{"statement":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C) : imm_safe_t k (C e0) m.","conclusion":"imm_safe_t k (C e0) m","hypotheses":"(k : kind) (m : mem) (C : expr -> expr) (e0 : expr) (fd : fundef) (args : list val) (ty : type) (H0 : callred ge e0 m fd args ty) (H1 : context RV k C)","proofString":"eapply imm_safe_t_callred; eauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) : step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m).","conclusion":"step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m)","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m)","proofString":"destruct (classic (imm_safe ge e K a m)).\nexploit imm_safe_imm_safe_t; eauto.\nintros [A | [C1 [a1 [t [a1' [m' [A [B [D E]]]]]]]]].\ncontradiction.\nright.\nred.\nexists t; econstructor; split; auto.\nleft.\nrewrite B.\neapply step_rred with (C := fun x => C(C1 x)).\neauto.\neauto.\nleft.\nleft.\neapply step_stuck; eauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) : step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m).","conclusion":"step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m)","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m)","proofString":"exploit imm_safe_imm_safe_t; eauto.\nintros [A | [C1 [a1 [t [a1' [m' [A [B [D E]]]]]]]]].\ncontradiction.\nright.\nred.\nexists t; econstructor; split; auto.\nleft.\nrewrite B.\neapply step_rred with (C := fun x => C(C1 x)).\neauto.\neauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) : imm_safe_t K a m \\/\n(exists (C0 : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV K C0 /\\\n   a = C0 a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w')) ->\nstep ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m).","conclusion":"imm_safe_t K a m \\/\n(exists (C0 : expr -> expr) (a1 : expr) (t : trace) \n (a1' : expr) (m' : mem),\n   context RV K C0 /\\\n   a = C0 a1 /\\\n   rred ge a1 m t a1' m' /\\ (forall w' : world, ~ possible_trace w t w')) ->\nstep ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m)","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m)","proofString":"intros [A | [C1 [a1 [t [a1' [m' [A [B [D E]]]]]]]]].\ncontradiction.\nright.\nred.\nexists t; econstructor; split; auto.\nleft.\nrewrite B.\neapply step_rred with (C := fun x => C(C1 x)).\neauto.\neauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (A : imm_safe_t K a m) : step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m).","conclusion":"step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m)","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (A : imm_safe_t K a m)","proofString":"contradiction."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w') : step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m).","conclusion":"step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m)","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w')","proofString":"right.\nred.\nexists t; econstructor; split; auto.\nleft.\nrewrite B.\neapply step_rred with (C := fun x => C(C1 x)).\neauto.\neauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w') : can_crash_world w (ExprState f (C a) k e m).","conclusion":"can_crash_world w (ExprState f (C a) k e m)","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w')","proofString":"red.\nexists t; econstructor; split; auto.\nleft.\nrewrite B.\neapply step_rred with (C := fun x => C(C1 x)).\neauto.\neauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w') : exists (t0 : trace) (S' : state),\n  step ge (ExprState f (C a) k e m) t0 S' /\\\n  (forall w' : world, ~ possible_trace w t0 w').","conclusion":"exists (t0 : trace) (S' : state),\n  step ge (ExprState f (C a) k e m) t0 S' /\\\n  (forall w' : world, ~ possible_trace w t0 w')","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w')","proofString":"exists t; econstructor; split; auto.\nleft.\nrewrite B.\neapply step_rred with (C := fun x => C(C1 x)).\neauto.\neauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w') : context RV RV (fun x : expr => C (C1 x)).","conclusion":"context RV RV (fun x : expr => C (C1 x))","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : imm_safe ge e K a m) (C1 : expr -> expr) (a1 : expr) (t : trace) (a1' : expr) (m' : mem) (A : context RV K C1) (B : a = C1 a1) (D : rred ge a1 m t a1' m') (E : forall w' : world, ~ possible_trace w t w')","proofString":"eauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : ~ imm_safe ge e K a m) : step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m).","conclusion":"step ge (ExprState f (C a) k e m) E0 Stuckstate \\/\ncan_crash_world w (ExprState f (C a) k e m)","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : ~ imm_safe ge e K a m)","proofString":"left.\nleft.\neapply step_stuck; eauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : ~ imm_safe ge e K a m) : step ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"step ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : ~ imm_safe ge e K a m)","proofString":"left.\neapply step_stuck; eauto."},{"statement":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : ~ imm_safe ge e K a m) : estep ge (ExprState f (C a) k e m) E0 Stuckstate.","conclusion":"estep ge (ExprState f (C a) k e m) E0 Stuckstate","hypotheses":"(K : kind) (C : expr -> expr) (a : expr) (m : mem) (f : function) (k : cont) (H : context K RV C) (H0 : ~ imm_safe_t K a m) (H1 : ~ imm_safe ge e K a m)","proofString":"eapply step_stuck; eauto."},{"statement":"(e : env) (m : mem) : alloc_variables ge e m nil e m.","conclusion":"alloc_variables ge e m nil e m","hypotheses":"(e : env) (m : mem)","proofString":"constructor."},{"statement":"(a : ident * type) (l : list (ident * type)) (IHl : forall (e0 : env) (m0 : mem),\nalloc_variables ge e0 m0 l (fst (do_alloc_variables e0 m0 l))\n  (snd (do_alloc_variables e0 m0 l))) (e : env) (m : mem) : alloc_variables ge e m (a :: l)\n  (fst\n     (let (id, ty) := a in\n      let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l))\n  (snd\n     (let (id, ty) := a in\n      let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l)).","conclusion":"alloc_variables ge e m (a :: l)\n  (fst\n     (let (id, ty) := a in\n      let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l))\n  (snd\n     (let (id, ty) := a in\n      let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l))","hypotheses":"(a : ident * type) (l : list (ident * type)) (IHl : forall (e0 : env) (m0 : mem),\nalloc_variables ge e0 m0 l (fst (do_alloc_variables e0 m0 l))\n  (snd (do_alloc_variables e0 m0 l))) (e : env) (m : mem)","proofString":"destruct a as [id ty].\ndestruct (Mem.alloc m 0 (sizeof ge ty)) as [m1 b1] eqn:?; simpl.\neconstructor; eauto."},{"statement":"(id : ident) (ty : type) (l : list (ident * type)) (IHl : forall (e0 : env) (m0 : mem),\nalloc_variables ge e0 m0 l (fst (do_alloc_variables e0 m0 l))\n  (snd (do_alloc_variables e0 m0 l))) (e : env) (m : mem) : alloc_variables ge e m ((id, ty) :: l)\n  (fst\n     (let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l))\n  (snd\n     (let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l)).","conclusion":"alloc_variables ge e m ((id, ty) :: l)\n  (fst\n     (let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l))\n  (snd\n     (let (m1, b1) := Mem.alloc m 0 (sizeof ge ty) in\n      do_alloc_variables (PTree.set id (b1, ty) e) m1 l))","hypotheses":"(id : ident) (ty : type) (l : list (ident * type)) (IHl : forall (e0 : env) (m0 : mem),\nalloc_variables ge e0 m0 l (fst (do_alloc_variables e0 m0 l))\n  (snd (do_alloc_variables e0 m0 l))) (e : env) (m : mem)","proofString":"destruct (Mem.alloc m 0 (sizeof ge ty)) as [m1 b1] eqn:?; simpl.\neconstructor; eauto."},{"statement":"(id : ident) (ty : type) (l : list (ident * type)) (IHl : forall (e0 : env) (m0 : mem),\nalloc_variables ge e0 m0 l (fst (do_alloc_variables e0 m0 l))\n  (snd (do_alloc_variables e0 m0 l))) (e : env) (m : mem) (m1 : Mem.mem') (b1 : block) (Heqp : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) : alloc_variables ge e m ((id, ty) :: l)\n  (fst (do_alloc_variables (PTree.set id (b1, ty) e) m1 l))\n  (snd (do_alloc_variables (PTree.set id (b1, ty) e) m1 l)).","conclusion":"alloc_variables ge e m ((id, ty) :: l)\n  (fst (do_alloc_variables (PTree.set id (b1, ty) e) m1 l))\n  (snd (do_alloc_variables (PTree.set id (b1, ty) e) m1 l))","hypotheses":"(id : ident) (ty : type) (l : list (ident * type)) (IHl : forall (e0 : env) (m0 : mem),\nalloc_variables ge e0 m0 l (fst (do_alloc_variables e0 m0 l))\n  (snd (do_alloc_variables e0 m0 l))) (e : env) (m : mem) (m1 : Mem.mem') (b1 : block) (Heqp : Mem.alloc m 0 (sizeof ge ty) = (m1, b1))","proofString":"econstructor; eauto."},{"statement":"(e : env) (m : mem) : (e, m) = (e, m).","conclusion":"(e, m) = (e, m)","hypotheses":"(e : env) (m : mem)","proofString":"auto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : do_alloc_variables (PTree.set id (b1, ty) e) m1 vars = (e2, m2)) : (let (m0, b0) := Mem.alloc m 0 (sizeof ge ty) in\n do_alloc_variables (PTree.set id (b0, ty) e) m0 vars) = (\ne2, m2).","conclusion":"(let (m0, b0) := Mem.alloc m 0 (sizeof ge ty) in\n do_alloc_variables (PTree.set id (b0, ty) e) m0 vars) = (\ne2, m2)","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : do_alloc_variables (PTree.set id (b1, ty) e) m1 vars = (e2, m2))","proofString":"rewrite H; rewrite IHalloc_variables; auto."},{"statement":"(w : world) (e : env) (m' m : mem) (H : Some m = Some m') : bind_parameters ge e m nil nil m'.","conclusion":"bind_parameters ge e m nil nil m'","hypotheses":"(w : world) (e : env) (m' m : mem) (H : Some m = Some m')","proofString":"inversion H; constructor; auto."},{"statement":"(w : world) (e : env) (m' : mem) (params : list (ident * type)) (lv0 : list val) (m1 : mem) (H : sem_bind_parameters w e m1 params lv0 = Some m') (m : mem) (id : ident) (ty : type) (v1 : val) (b : block) (e2 : e ! id = Some (b, ty)) (e3 : type_eq ty ty = left eq_refl) (w' : world) (v' : val) (e4 : do_assign_loc w ty m b Ptrofs.zero Full v1 = Some (w', nil, m1, v')) (IHo : sem_bind_parameters w e m1 params lv0 = Some m' ->\nbind_parameters ge e m1 params lv0 m') : bind_parameters ge e m ((id, ty) :: params) (v1 :: lv0) m'.","conclusion":"bind_parameters ge e m ((id, ty) :: params) (v1 :: lv0) m'","hypotheses":"(w : world) (e : env) (m' : mem) (params : list (ident * type)) (lv0 : list val) (m1 : mem) (H : sem_bind_parameters w e m1 params lv0 = Some m') (m : mem) (id : ident) (ty : type) (v1 : val) (b : block) (e2 : e ! id = Some (b, ty)) (e3 : type_eq ty ty = left eq_refl) (w' : world) (v' : val) (e4 : do_assign_loc w ty m b Ptrofs.zero Full v1 = Some (w', nil, m1, v')) (IHo : sem_bind_parameters w e m1 params lv0 = Some m' ->\nbind_parameters ge e m1 params lv0 m')","proofString":"exploit do_assign_loc_sound; eauto.\nintros [A B].\neconstructor; eauto."},{"statement":"(w : world) (e : env) (m' : mem) (params : list (ident * type)) (lv0 : list val) (m1 : mem) (H : sem_bind_parameters w e m1 params lv0 = Some m') (m : mem) (id : ident) (ty : type) (v1 : val) (b : block) (e2 : e ! id = Some (b, ty)) (e3 : type_eq ty ty = left eq_refl) (w' : world) (v' : val) (e4 : do_assign_loc w ty m b Ptrofs.zero Full v1 = Some (w', nil, m1, v')) (IHo : sem_bind_parameters w e m1 params lv0 = Some m' ->\nbind_parameters ge e m1 params lv0 m') : assign_loc ge ty m b Ptrofs.zero Full v1 nil m1 v' /\\ possible_trace w nil w' ->\nbind_parameters ge e m ((id, ty) :: params) (v1 :: lv0) m'.","conclusion":"assign_loc ge ty m b Ptrofs.zero Full v1 nil m1 v' /\\ possible_trace w nil w' ->\nbind_parameters ge e m ((id, ty) :: params) (v1 :: lv0) m'","hypotheses":"(w : world) (e : env) (m' : mem) (params : list (ident * type)) (lv0 : list val) (m1 : mem) (H : sem_bind_parameters w e m1 params lv0 = Some m') (m : mem) (id : ident) (ty : type) (v1 : val) (b : block) (e2 : e ! id = Some (b, ty)) (e3 : type_eq ty ty = left eq_refl) (w' : world) (v' : val) (e4 : do_assign_loc w ty m b Ptrofs.zero Full v1 = Some (w', nil, m1, v')) (IHo : sem_bind_parameters w e m1 params lv0 = Some m' ->\nbind_parameters ge e m1 params lv0 m')","proofString":"intros [A B].\neconstructor; eauto."},{"statement":"(w : world) (e : env) (m' : mem) (params : list (ident * type)) (lv0 : list val) (m1 : mem) (H : sem_bind_parameters w e m1 params lv0 = Some m') (m : mem) (id : ident) (ty : type) (v1 : val) (b : block) (e2 : e ! id = Some (b, ty)) (e3 : type_eq ty ty = left eq_refl) (w' : world) (v' : val) (e4 : do_assign_loc w ty m b Ptrofs.zero Full v1 = Some (w', nil, m1, v')) (IHo : sem_bind_parameters w e m1 params lv0 = Some m' ->\nbind_parameters ge e m1 params lv0 m') (A : assign_loc ge ty m b Ptrofs.zero Full v1 nil m1 v') (B : possible_trace w nil w') : bind_parameters ge e m ((id, ty) :: params) (v1 :: lv0) m'.","conclusion":"bind_parameters ge e m ((id, ty) :: params) (v1 :: lv0) m'","hypotheses":"(w : world) (e : env) (m' : mem) (params : list (ident * type)) (lv0 : list val) (m1 : mem) (H : sem_bind_parameters w e m1 params lv0 = Some m') (m : mem) (id : ident) (ty : type) (v1 : val) (b : block) (e2 : e ! id = Some (b, ty)) (e3 : type_eq ty ty = left eq_refl) (w' : world) (v' : val) (e4 : do_assign_loc w ty m b Ptrofs.zero Full v1 = Some (w', nil, m1, v')) (IHo : sem_bind_parameters w e m1 params lv0 = Some m' ->\nbind_parameters ge e m1 params lv0 m') (A : assign_loc ge ty m b Ptrofs.zero Full v1 nil m1 v') (B : possible_trace w nil w')","proofString":"econstructor; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m)) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m)) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None)","proofString":"intros.\nexploit list_in_map_inv; eauto.\nintros [[C rd] [A B]].\ngeneralize (step_expr_sound e w r RV m).\nunfold reducts_ok.\nintros [P Q].\nexploit P; eauto.\nintros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) : step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m)))","proofString":"exploit list_in_map_inv; eauto.\nintros [[C rd] [A B]].\ngeneralize (step_expr_sound e w r RV m).\nunfold reducts_ok.\nintros [P Q].\nexploit P; eauto.\nintros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) : (exists x : (expr -> expr) * reduction,\n   TR rule t S' = expr_final_state f k e x /\\ In x (step_expr e w RV r m)) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"(exists x : (expr -> expr) * reduction,\n   TR rule t S' = expr_final_state f k e x /\\ In x (step_expr e w RV r m)) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m)))","proofString":"intros [[C rd] [A B]].\ngeneralize (step_expr_sound e w r RV m).\nunfold reducts_ok.\nintros [P Q].\nexploit P; eauto.\nintros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) : step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m))","proofString":"generalize (step_expr_sound e w r RV m).\nunfold reducts_ok.\nintros [P Q].\nexploit P; eauto.\nintros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) : reducts_ok e w RV r m (step_expr e w RV r m) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"reducts_ok e w RV r m (step_expr e w RV r m) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m))","proofString":"unfold reducts_ok.\nintros [P Q].\nexploit P; eauto.\nintros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) : (forall (C0 : expr -> expr) (rd0 : reduction),\n In (C0, rd0) (step_expr e w RV r m) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C0 /\\ r = C0 a' /\\ reduction_ok e w k' a' m rd0) /\\\n(step_expr e w RV r m = nil -> is_val r <> None) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"(forall (C0 : expr -> expr) (rd0 : reduction),\n In (C0, rd0) (step_expr e w RV r m) ->\n exists (a' : expr) (k' : kind),\n   context k' RV C0 /\\ r = C0 a' /\\ reduction_ok e w k' a' m rd0) /\\\n(step_expr e w RV r m = nil -> is_val r <> None) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m))","proofString":"intros [P Q].\nexploit P; eauto.\nintros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ r = C0 a' /\\ reduction_ok e w k' a' m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) : step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ r = C0 a' /\\ reduction_ok e w k' a' m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None)","proofString":"exploit P; eauto.\nintros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ r = C0 a' /\\ reduction_ok e w k' a' m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) : (exists (a' : expr) (k' : kind),\n   context k' RV C /\\ r = C a' /\\ reduction_ok e w k' a' m rd) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"(exists (a' : expr) (k' : kind),\n   context k' RV C /\\ r = C a' /\\ reduction_ok e w k' a' m rd) ->\nstep ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a' : expr) (k' : kind),\n  context k' RV C0 /\\ r = C0 a' /\\ reduction_ok e w k' a' m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None)","proofString":"intros [a' [k' [CTX [EQ RD]]]].\nunfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 RV C0 /\\ r = C0 a'0 /\\ reduction_ok e w k'0 a'0 m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) (a' : expr) (k' : kind) (CTX : context k' RV C) (EQ : r = C a') (RD : reduction_ok e w k' a' m rd) : step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' = expr_final_state f k e (C, rd)) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 RV C0 /\\ r = C0 a'0 /\\ reduction_ok e w k'0 a'0 m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) (a' : expr) (k' : kind) (CTX : context k' RV C) (EQ : r = C a') (RD : reduction_ok e w k' a' m rd)","proofString":"unfold expr_final_state in A.\nsimpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' =\nmatch snd (C, rd) with\n| Lred rule0 a m0 => TR rule0 E0 (ExprState f (fst (C, rd) a) k e m0)\n| Rred rule0 a m0 t0 => TR rule0 t0 (ExprState f (fst (C, rd) a) k e m0)\n| Callred rule0 fd vargs ty m0 =>\n    TR rule0 E0 (Callstate fd vargs (Kcall f e (fst (C, rd)) ty k) m0)\n| Stuckred => TR \"step_stuck\" E0 Stuckstate\nend) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 RV C0 /\\ r = C0 a'0 /\\ reduction_ok e w k'0 a'0 m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) (a' : expr) (k' : kind) (CTX : context k' RV C) (EQ : r = C a') (RD : reduction_ok e w k' a' m rd) : step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' =\nmatch snd (C, rd) with\n| Lred rule0 a m0 => TR rule0 E0 (ExprState f (fst (C, rd) a) k e m0)\n| Rred rule0 a m0 t0 => TR rule0 t0 (ExprState f (fst (C, rd) a) k e m0)\n| Callred rule0 fd vargs ty m0 =>\n    TR rule0 E0 (Callstate fd vargs (Kcall f e (fst (C, rd)) ty k) m0)\n| Stuckred => TR \"step_stuck\" E0 Stuckstate\nend) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 RV C0 /\\ r = C0 a'0 /\\ reduction_ok e w k'0 a'0 m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) (a' : expr) (k' : kind) (CTX : context k' RV C) (EQ : r = C a') (RD : reduction_ok e w k' a' m rd)","proofString":"simpl in A.\ndestruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' =\nmatch rd with\n| Lred rule0 a m0 => TR rule0 E0 (ExprState f (C a) k e m0)\n| Rred rule0 a m0 t0 => TR rule0 t0 (ExprState f (C a) k e m0)\n| Callred rule0 fd vargs ty m0 =>\n    TR rule0 E0 (Callstate fd vargs (Kcall f e C ty k) m0)\n| Stuckred => TR \"step_stuck\" E0 Stuckstate\nend) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 RV C0 /\\ r = C0 a'0 /\\ reduction_ok e w k'0 a'0 m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) (a' : expr) (k' : kind) (CTX : context k' RV C) (EQ : r = C a') (RD : reduction_ok e w k' a' m rd) : step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m).","conclusion":"step ge (ExprState f r k e m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (ExprState f r k e m)","hypotheses":"(w : world) (f : function) (r : expr) (k : cont) (e : env) (m : mem) (rule : string) (t : trace) (S' : state) (Heqo : is_val r = None) (H : In (TR rule t S') (map (expr_final_state f k e) (step_expr e w RV r m))) (C : expr -> expr) (rd : reduction) (A : TR rule t S' =\nmatch rd with\n| Lred rule0 a m0 => TR rule0 E0 (ExprState f (C a) k e m0)\n| Rred rule0 a m0 t0 => TR rule0 t0 (ExprState f (C a) k e m0)\n| Callred rule0 fd vargs ty m0 =>\n    TR rule0 E0 (Callstate fd vargs (Kcall f e C ty k) m0)\n| Stuckred => TR \"step_stuck\" E0 Stuckstate\nend) (B : In (C, rd) (step_expr e w RV r m)) (P : forall (C0 : expr -> expr) (rd0 : reduction),\nIn (C0, rd0) (step_expr e w RV r m) ->\nexists (a'0 : expr) (k'0 : kind),\n  context k'0 RV C0 /\\ r = C0 a'0 /\\ reduction_ok e w k'0 a'0 m rd0) (Q : step_expr e w RV r m = nil -> is_val r <> None) (a' : expr) (k' : kind) (CTX : context k' RV C) (EQ : r = C a') (RD : reduction_ok e w k' a' m rd)","proofString":"destruct k'; destruct rd; inv A; simpl in RD; try contradiction.\nleft; left; apply step_lred; auto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto.\ndestruct RD.\nleft; left; apply step_rred; auto.\ndestruct RD; subst m'.\nleft; left; apply step_call; eauto.\nexploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (l' : expr) (m' : mem) (H : In (TR rule0 E0 (ExprState f (C l') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Lred rule0 l' m') (step_expr e w RV (C a') m)) (CTX : context LV RV C) (RD : lred ge e a' m l' m') : step ge (ExprState f (C a') k e m) E0 (ExprState f (C l') k e m') \\/\nE0 = E0 /\\\nExprState f (C l') k e m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m).","conclusion":"step ge (ExprState f (C a') k e m) E0 (ExprState f (C l') k e m') \\/\nE0 = E0 /\\\nExprState f (C l') k e m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m)","hypotheses":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (l' : expr) (m' : mem) (H : In (TR rule0 E0 (ExprState f (C l') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Lred rule0 l' m') (step_expr e w RV (C a') m)) (CTX : context LV RV C) (RD : lred ge e a' m l' m')","proofString":"left; left; apply step_lred; auto."},{"statement":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Stuckred) (step_expr e w RV (C a') m)) (H : In (TR \"step_stuck\" E0 Stuckstate)\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (CTX : context LV RV C) (RD : ~ imm_safe_t e w LV a' m) : step ge (ExprState f (C a') k e m) E0 Stuckstate \\/\nE0 = E0 /\\\nStuckstate = Stuckstate /\\ can_crash_world w (ExprState f (C a') k e m).","conclusion":"step ge (ExprState f (C a') k e m) E0 Stuckstate \\/\nE0 = E0 /\\\nStuckstate = Stuckstate /\\ can_crash_world w (ExprState f (C a') k e m)","hypotheses":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Stuckred) (step_expr e w RV (C a') m)) (H : In (TR \"step_stuck\" E0 Stuckstate)\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (CTX : context LV RV C) (RD : ~ imm_safe_t e w LV a' m)","proofString":"exploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (t0 : trace) (r' : expr) (m' : mem) (H : In (TR rule0 t0 (ExprState f (C r') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Rred rule0 r' m' t0) (step_expr e w RV (C a') m)) (CTX : context RV RV C) (RD : rred ge a' m t0 r' m' /\\ (exists w' : world, possible_trace w t0 w')) : step ge (ExprState f (C a') k e m) t0 (ExprState f (C r') k e m') \\/\nt0 = E0 /\\\nExprState f (C r') k e m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m).","conclusion":"step ge (ExprState f (C a') k e m) t0 (ExprState f (C r') k e m') \\/\nt0 = E0 /\\\nExprState f (C r') k e m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m)","hypotheses":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (t0 : trace) (r' : expr) (m' : mem) (H : In (TR rule0 t0 (ExprState f (C r') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Rred rule0 r' m' t0) (step_expr e w RV (C a') m)) (CTX : context RV RV C) (RD : rred ge a' m t0 r' m' /\\ (exists w' : world, possible_trace w t0 w'))","proofString":"destruct RD.\nleft; left; apply step_rred; auto."},{"statement":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (t0 : trace) (r' : expr) (m' : mem) (H : In (TR rule0 t0 (ExprState f (C r') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Rred rule0 r' m' t0) (step_expr e w RV (C a') m)) (CTX : context RV RV C) (H0 : rred ge a' m t0 r' m') (H1 : exists w' : world, possible_trace w t0 w') : step ge (ExprState f (C a') k e m) t0 (ExprState f (C r') k e m') \\/\nt0 = E0 /\\\nExprState f (C r') k e m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m).","conclusion":"step ge (ExprState f (C a') k e m) t0 (ExprState f (C r') k e m') \\/\nt0 = E0 /\\\nExprState f (C r') k e m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m)","hypotheses":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (t0 : trace) (r' : expr) (m' : mem) (H : In (TR rule0 t0 (ExprState f (C r') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Rred rule0 r' m' t0) (step_expr e w RV (C a') m)) (CTX : context RV RV C) (H0 : rred ge a' m t0 r' m') (H1 : exists w' : world, possible_trace w t0 w')","proofString":"left; left; apply step_rred; auto."},{"statement":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (fd : fundef) (args : list val) (tyres : type) (m' : mem) (H : In (TR rule0 E0 (Callstate fd args (Kcall f e C tyres k) m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Callred rule0 fd args tyres m') (step_expr e w RV (C a') m)) (CTX : context RV RV C) (RD : callred ge a' m fd args tyres /\\ m' = m) : step ge (ExprState f (C a') k e m) E0\n  (Callstate fd args (Kcall f e C tyres k) m') \\/\nE0 = E0 /\\\nCallstate fd args (Kcall f e C tyres k) m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m).","conclusion":"step ge (ExprState f (C a') k e m) E0\n  (Callstate fd args (Kcall f e C tyres k) m') \\/\nE0 = E0 /\\\nCallstate fd args (Kcall f e C tyres k) m' = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m)","hypotheses":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (fd : fundef) (args : list val) (tyres : type) (m' : mem) (H : In (TR rule0 E0 (Callstate fd args (Kcall f e C tyres k) m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Callred rule0 fd args tyres m') (step_expr e w RV (C a') m)) (CTX : context RV RV C) (RD : callred ge a' m fd args tyres /\\ m' = m)","proofString":"destruct RD; subst m'.\nleft; left; apply step_call; eauto."},{"statement":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (fd : fundef) (args : list val) (tyres : type) (H : In (TR rule0 E0 (Callstate fd args (Kcall f e C tyres k) m))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Callred rule0 fd args tyres m) (step_expr e w RV (C a') m)) (CTX : context RV RV C) (H0 : callred ge a' m fd args tyres) : step ge (ExprState f (C a') k e m) E0\n  (Callstate fd args (Kcall f e C tyres k) m) \\/\nE0 = E0 /\\\nCallstate fd args (Kcall f e C tyres k) m = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m).","conclusion":"step ge (ExprState f (C a') k e m) E0\n  (Callstate fd args (Kcall f e C tyres k) m) \\/\nE0 = E0 /\\\nCallstate fd args (Kcall f e C tyres k) m = Stuckstate /\\\ncan_crash_world w (ExprState f (C a') k e m)","hypotheses":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (rule0 : string) (fd : fundef) (args : list val) (tyres : type) (H : In (TR rule0 E0 (Callstate fd args (Kcall f e C tyres k) m))\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Callred rule0 fd args tyres m) (step_expr e w RV (C a') m)) (CTX : context RV RV C) (H0 : callred ge a' m fd args tyres)","proofString":"left; left; apply step_call; eauto."},{"statement":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Stuckred) (step_expr e w RV (C a') m)) (H : In (TR \"step_stuck\" E0 Stuckstate)\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (CTX : context RV RV C) (RD : ~ imm_safe_t e w RV a' m) : step ge (ExprState f (C a') k e m) E0 Stuckstate \\/\nE0 = E0 /\\\nStuckstate = Stuckstate /\\ can_crash_world w (ExprState f (C a') k e m).","conclusion":"step ge (ExprState f (C a') k e m) E0 Stuckstate \\/\nE0 = E0 /\\\nStuckstate = Stuckstate /\\ can_crash_world w (ExprState f (C a') k e m)","hypotheses":"(w : world) (f : function) (k : cont) (e : env) (m : mem) (C : expr -> expr) (a' : expr) (Q : step_expr e w RV (C a') m = nil -> is_val (C a') <> None) (P : forall (C0 : expr -> expr) (rd : reduction),\nIn (C0, rd) (step_expr e w RV (C a') m) ->\nexists (a'0 : expr) (k' : kind),\n  context k' RV C0 /\\ C a' = C0 a'0 /\\ reduction_ok e w k' a'0 m rd) (B : In (C, Stuckred) (step_expr e w RV (C a') m)) (H : In (TR \"step_stuck\" E0 Stuckstate)\n  (map (expr_final_state f k e) (step_expr e w RV (C a') m))) (Heqo : is_val (C a') = None) (CTX : context RV RV C) (RD : ~ imm_safe_t e w RV a' m)","proofString":"exploit not_imm_safe_t; eauto.\nintros [R | R]; eauto."},{"statement":"(w : world) (fd : fundef) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) : In (TR rule t S')\n  match fd with\n  | Internal f =>\n      check list_norepet_dec ident_eq\n              (var_names (fn_params f) ++ var_names (fn_vars f));\n      let (e, m1) :=\n        do_alloc_variables empty_env m (fn_params f ++ fn_vars f) in\n      do m2 <- sem_bind_parameters w e m1 (fn_params f) args;\n      ret \"step_internal_function\" (State f (fn_body f) k e m2)\n  | External ef _ _ _ =>\n      match do_external ef w args m with\n      | Some (_, t1, v, m') =>\n          TR \"step_external_function\" t1 (Returnstate v k m') :: nil\n      | None => nil\n      end\n  end ->\nstep ge (Callstate fd args k m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (Callstate fd args k m).","conclusion":"In (TR rule t S')\n  match fd with\n  | Internal f =>\n      check list_norepet_dec ident_eq\n              (var_names (fn_params f) ++ var_names (fn_vars f));\n      let (e, m1) :=\n        do_alloc_variables empty_env m (fn_params f ++ fn_vars f) in\n      do m2 <- sem_bind_parameters w e m1 (fn_params f) args;\n      ret \"step_internal_function\" (State f (fn_body f) k e m2)\n  | External ef _ _ _ =>\n      match do_external ef w args m with\n      | Some (_, t1, v, m') =>\n          TR \"step_external_function\" t1 (Returnstate v k m') :: nil\n      | None => nil\n      end\n  end ->\nstep ge (Callstate fd args k m) t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w (Callstate fd args k m)","hypotheses":"(w : world) (fd : fundef) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state)","proofString":"destruct fd; myinv.\ndestruct (do_alloc_variables empty_env m (fn_params f ++ fn_vars f)) as [e m1] eqn:?.\nmyinv.\nleft; right; apply step_internal_function with m1.\nauto.\nchange e with (fst (e,m1)).\nchange m1 with (snd (e,m1)) at 2.\nrewrite <- Heqp.\napply do_alloc_variables_sound.\neapply sem_bind_parameters_sound; eauto.\ndestruct p as [[[w' tr] v] m'].\nmyinv.\nleft; right; constructor.\neapply do_ef_external_sound; eauto."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) : In (TR rule t S')\n  (let (e, m1) :=\n     do_alloc_variables empty_env m (fn_params f ++ fn_vars f) in\n   do m2 <- sem_bind_parameters w e m1 (fn_params f) args;\n   ret \"step_internal_function\" (State f (fn_body f) k e m2)) ->\nstep ge (Callstate (Internal f) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (Internal f) args k m).","conclusion":"In (TR rule t S')\n  (let (e, m1) :=\n     do_alloc_variables empty_env m (fn_params f ++ fn_vars f) in\n   do m2 <- sem_bind_parameters w e m1 (fn_params f) args;\n   ret \"step_internal_function\" (State f (fn_body f) k e m2)) ->\nstep ge (Callstate (Internal f) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (Internal f) args k m)","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f)))","proofString":"destruct (do_alloc_variables empty_env m (fn_params f ++ fn_vars f)) as [e m1] eqn:?.\nmyinv.\nleft; right; apply step_internal_function with m1.\nauto.\nchange e with (fst (e,m1)).\nchange m1 with (snd (e,m1)) at 2.\nrewrite <- Heqp.\napply do_alloc_variables_sound.\neapply sem_bind_parameters_sound; eauto."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) : In (TR rule t S')\n  (do m2 <- sem_bind_parameters w e m1 (fn_params f) args;\n   ret \"step_internal_function\" (State f (fn_body f) k e m2)) ->\nstep ge (Callstate (Internal f) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (Internal f) args k m).","conclusion":"In (TR rule t S')\n  (do m2 <- sem_bind_parameters w e m1 (fn_params f) args;\n   ret \"step_internal_function\" (State f (fn_body f) k e m2)) ->\nstep ge (Callstate (Internal f) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (Internal f) args k m)","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1))","proofString":"myinv.\nleft; right; apply step_internal_function with m1.\nauto.\nchange e with (fst (e,m1)).\nchange m1 with (snd (e,m1)) at 2.\nrewrite <- Heqp.\napply do_alloc_variables_sound.\neapply sem_bind_parameters_sound; eauto."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0) : step ge (Callstate (Internal f) args k m) E0 (State f (fn_body f) k e m0) \\/\nE0 = E0 /\\\nState f (fn_body f) k e m0 = Stuckstate /\\\ncan_crash_world w (Callstate (Internal f) args k m).","conclusion":"step ge (Callstate (Internal f) args k m) E0 (State f (fn_body f) k e m0) \\/\nE0 = E0 /\\\nState f (fn_body f) k e m0 = Stuckstate /\\\ncan_crash_world w (Callstate (Internal f) args k m)","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0)","proofString":"left; right; apply step_internal_function with m1.\nauto.\nchange e with (fst (e,m1)).\nchange m1 with (snd (e,m1)) at 2.\nrewrite <- Heqp.\napply do_alloc_variables_sound.\neapply sem_bind_parameters_sound; eauto."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0) : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f)).","conclusion":"list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0)","proofString":"auto."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0) : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1.","conclusion":"alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0)","proofString":"change e with (fst (e,m1)).\nchange m1 with (snd (e,m1)) at 2.\nrewrite <- Heqp.\napply do_alloc_variables_sound."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0) : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) (fst (e, m1)) m1.","conclusion":"alloc_variables ge empty_env m (fn_params f ++ fn_vars f) (fst (e, m1)) m1","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0)","proofString":"change m1 with (snd (e,m1)) at 2.\nrewrite <- Heqp.\napply do_alloc_variables_sound."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0) : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) \n  (fst (e, m1)) (snd (e, m1)).","conclusion":"alloc_variables ge empty_env m (fn_params f ++ fn_vars f) \n  (fst (e, m1)) (snd (e, m1))","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0)","proofString":"rewrite <- Heqp.\napply do_alloc_variables_sound."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0) : alloc_variables ge empty_env m (fn_params f ++ fn_vars f)\n  (fst (do_alloc_variables empty_env m (fn_params f ++ fn_vars f)))\n  (snd (do_alloc_variables empty_env m (fn_params f ++ fn_vars f))).","conclusion":"alloc_variables ge empty_env m (fn_params f ++ fn_vars f)\n  (fst (do_alloc_variables empty_env m (fn_params f ++ fn_vars f)))\n  (snd (do_alloc_variables empty_env m (fn_params f ++ fn_vars f)))","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0)","proofString":"apply do_alloc_variables_sound."},{"statement":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0) : bind_parameters ge e m1 (fn_params f) args m0.","conclusion":"bind_parameters ge e m1 (fn_params f) args m0","hypotheses":"(w : world) (f : function) (args : list val) (k : cont) (m : mem) (l : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (e : env) (m1 : mem) (Heqp : do_alloc_variables empty_env m (fn_params f ++ fn_vars f) = (e, m1)) (m0 : mem) (Heqo : sem_bind_parameters w e m1 (fn_params f) args = Some m0)","proofString":"eapply sem_bind_parameters_sound; eauto."},{"statement":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (p : world * trace * val * mem) (Heqo : do_external e w args m = Some p) : In (TR rule t S')\n  (let (p0, m') := p in\n   let (p1, v) := p0 in\n   let (_, t1) := p1 in\n   TR \"step_external_function\" t1 (Returnstate v k m') :: nil) ->\nstep ge (Callstate (External e l t0 c) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (External e l t0 c) args k m).","conclusion":"In (TR rule t S')\n  (let (p0, m') := p in\n   let (p1, v) := p0 in\n   let (_, t1) := p1 in\n   TR \"step_external_function\" t1 (Returnstate v k m') :: nil) ->\nstep ge (Callstate (External e l t0 c) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (External e l t0 c) args k m)","hypotheses":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (p : world * trace * val * mem) (Heqo : do_external e w args m = Some p)","proofString":"destruct p as [[[w' tr] v] m'].\nmyinv.\nleft; right; constructor.\neapply do_ef_external_sound; eauto."},{"statement":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (w' : world) (tr : trace) (v : val) (m' : mem) (Heqo : do_external e w args m = Some (w', tr, v, m')) : In (TR rule t S')\n  (TR \"step_external_function\" tr (Returnstate v k m') :: nil) ->\nstep ge (Callstate (External e l t0 c) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (External e l t0 c) args k m).","conclusion":"In (TR rule t S')\n  (TR \"step_external_function\" tr (Returnstate v k m') :: nil) ->\nstep ge (Callstate (External e l t0 c) args k m) t S' \\/\nt = E0 /\\\nS' = Stuckstate /\\ can_crash_world w (Callstate (External e l t0 c) args k m)","hypotheses":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (rule : string) (t : trace) (S' : state) (w' : world) (tr : trace) (v : val) (m' : mem) (Heqo : do_external e w args m = Some (w', tr, v, m'))","proofString":"myinv.\nleft; right; constructor.\neapply do_ef_external_sound; eauto."},{"statement":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (t : trace) (w' : world) (v : val) (m' : mem) (Heqo : do_external e w args m = Some (w', t, v, m')) : step ge (Callstate (External e l t0 c) args k m) t (Returnstate v k m') \\/\nt = E0 /\\\nReturnstate v k m' = Stuckstate /\\\ncan_crash_world w (Callstate (External e l t0 c) args k m).","conclusion":"step ge (Callstate (External e l t0 c) args k m) t (Returnstate v k m') \\/\nt = E0 /\\\nReturnstate v k m' = Stuckstate /\\\ncan_crash_world w (Callstate (External e l t0 c) args k m)","hypotheses":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (t : trace) (w' : world) (v : val) (m' : mem) (Heqo : do_external e w args m = Some (w', t, v, m'))","proofString":"left; right; constructor.\neapply do_ef_external_sound; eauto."},{"statement":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (t : trace) (w' : world) (v : val) (m' : mem) (Heqo : do_external e w args m = Some (w', t, v, m')) : external_call e ge args m t v m'.","conclusion":"external_call e ge args m t v m'","hypotheses":"(w : world) (e : external_function) (l : list type) (t0 : type) (c : calling_convention) (args : list val) (k : cont) (m : mem) (t : trace) (w' : world) (v : val) (m' : mem) (Heqo : do_external e w args m = Some (w', t, v, m'))","proofString":"eapply do_ef_external_sound; eauto."},{"statement":"(w : world) (rule : string) (t : trace) (S' : state) : False ->\nstep ge Stuckstate t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w Stuckstate.","conclusion":"False ->\nstep ge Stuckstate t S' \\/\nt = E0 /\\ S' = Stuckstate /\\ can_crash_world w Stuckstate","hypotheses":"(w : world) (rule : string) (t : trace) (S' : state)","proofString":"contradiction."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (S : state) (H : estep ge (ExprState f a k e m) t S) : is_val a = None.","conclusion":"is_val a = None","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (S : state) (H : estep ge (ExprState f a k e m) t S)","proofString":"assert (forall b from to C, context from to C -> (from = to /\\ C = fun x => x) \\/ is_val (C b) = None).\ninduction 1; simpl; auto.\ninv H.\ndestruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto.\ndestruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto.\ndestruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto.\ndestruct (H0 a0 _ _ _ H8) as [[A B] | A].\nsubst.\ndestruct a0; auto.\nelim H9.\nconstructor.\nauto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (S : state) (H : estep ge (ExprState f a k e m) t S) : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None.","conclusion":"forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (S : state) (H : estep ge (ExprState f a k e m) t S)","proofString":"induction 1; simpl; auto."},{"statement":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (S : state) (H : estep ge (ExprState f a k e m) t S) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) : is_val a = None.","conclusion":"is_val a = None","hypotheses":"(f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (S : state) (H : estep ge (ExprState f a k e m) t S) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None)","proofString":"inv H.\ndestruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto.\ndestruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto.\ndestruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto.\ndestruct (H0 a0 _ _ _ H8) as [[A B] | A].\nsubst.\ndestruct a0; auto.\nelim H9.\nconstructor.\nauto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV C) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV C)","proofString":"destruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV C) (A : LV = RV) (B : C = (fun x : expr => x)) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV C) (A : LV = RV) (B : C = (fun x : expr => x))","proofString":"subst.\ninv H8; auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV (fun x : expr => x)) (A : LV = RV) : is_val a0 = None.","conclusion":"is_val a0 = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV (fun x : expr => x)) (A : LV = RV)","proofString":"inv H8; auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV C) (A : is_val (C a0) = None) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : lred ge e a0 m a' m') (H9 : context LV RV C) (A : is_val (C a0) = None)","proofString":"auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV C) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV C)","proofString":"destruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV C) (A : RV = RV) (B : C = (fun x : expr => x)) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV C) (A : RV = RV) (B : C = (fun x : expr => x))","proofString":"subst.\ninv H8; auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV (fun x : expr => x)) (A : RV = RV) : is_val a0 = None.","conclusion":"is_val a0 = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV (fun x : expr => x)) (A : RV = RV)","proofString":"inv H8; auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV C) (A : is_val (C a0) = None) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (t : trace) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 a' : expr) (m' : mem) (H8 : rred ge a0 m t a' m') (H9 : context RV RV C) (A : is_val (C a0) = None)","proofString":"auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV C) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV C)","proofString":"destruct (H0 a0 _ _ _ H9) as [[A B] | A].\nsubst.\ninv H8; auto.\nauto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV C) (A : RV = RV) (B : C = (fun x : expr => x)) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV C) (A : RV = RV) (B : C = (fun x : expr => x))","proofString":"subst.\ninv H8; auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV (fun x : expr => x)) (A : RV = RV) : is_val a0 = None.","conclusion":"is_val a0 = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV (fun x : expr => x)) (A : RV = RV)","proofString":"inv H8; auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV C) (A : is_val (C a0) = None) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (fd : fundef) (vargs : list val) (ty : type) (H8 : callred ge a0 m fd vargs ty) (H9 : context RV RV C) (A : is_val (C a0) = None)","proofString":"auto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a0 m) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a0 m)","proofString":"destruct (H0 a0 _ _ _ H8) as [[A B] | A].\nsubst.\ndestruct a0; auto.\nelim H9.\nconstructor.\nauto."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a0 m) (A : K = RV) (B : C = (fun x : expr => x)) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a0 m) (A : K = RV) (B : C = (fun x : expr => x))","proofString":"subst.\ndestruct a0; auto.\nelim H9.\nconstructor."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 : expr) (H9 : ~ imm_safe ge e RV a0 m) (H8 : context RV RV (fun x : expr => x)) : is_val a0 = None.","conclusion":"is_val a0 = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (a0 : expr) (H9 : ~ imm_safe ge e RV a0 m) (H8 : context RV RV (fun x : expr => x))","proofString":"destruct a0; auto.\nelim H9.\nconstructor."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (v : val) (ty : type) (H9 : ~ imm_safe ge e RV (Eval v ty) m) (H8 : context RV RV (fun x : expr => x)) : is_val (Eval v ty) = None.","conclusion":"is_val (Eval v ty) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (v : val) (ty : type) (H9 : ~ imm_safe ge e RV (Eval v ty) m) (H8 : context RV RV (fun x : expr => x))","proofString":"elim H9.\nconstructor."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (v : val) (ty : type) (H9 : ~ imm_safe ge e RV (Eval v ty) m) (H8 : context RV RV (fun x : expr => x)) : imm_safe ge e RV (Eval v ty) m.","conclusion":"imm_safe ge e RV (Eval v ty) m","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C : expr -> expr),\ncontext from to C ->\nfrom = to /\\ C = (fun x : expr => x) \\/ is_val (C b) = None) (v : val) (ty : type) (H9 : ~ imm_safe ge e RV (Eval v ty) m) (H8 : context RV RV (fun x : expr => x))","proofString":"constructor."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a0 m) (A : is_val (C a0) = None) : is_val (C a0) = None.","conclusion":"is_val (C a0) = None","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (H0 : forall (b : expr) (from to : kind) (C0 : expr -> expr),\ncontext from to C0 ->\nfrom = to /\\ C0 = (fun x : expr => x) \\/ is_val (C0 b) = None) (C : expr -> expr) (a0 : expr) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a0 m) (A : is_val (C a0) = None)","proofString":"auto."},{"statement":"(w : world) (S : state) (t : trace) (S' : state) (w' : world) (PT : possible_trace w t w') (H : estep ge S t S') : exists rule : string, In (TR rule t S') (do_step w S).","conclusion":"exists rule : string, In (TR rule t S') (do_step w S)","hypotheses":"(w : world) (S : state) (t : trace) (S' : state) (w' : world) (PT : possible_trace w t w') (H : estep ge S t S')","proofString":"inversion H; subst; exploit estep_not_val; eauto; intro NOTVAL.\nunfold do_step; rewrite NOTVAL.\nexploit lred_topred; eauto.\ninstantiate (1 := w).\nintros (rule & STEP).\nexists rule.\nchange (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto.\nunfold do_step; rewrite NOTVAL.\nexploit rred_topred; eauto.\ninstantiate (1 := e).\nintros (rule & STEP).\nexists rule.\nchange (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto.\nunfold do_step; rewrite NOTVAL.\nexploit callred_topred; eauto.\ninstantiate (1 := w).\ninstantiate (1 := e).\nintros (rule & STEP).\nexists rule.\nchange (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto.\nexploit not_imm_safe_stuck_red.\neauto.\nred; intros; elim H1.\neapply imm_safe_t_imm_safe.\neauto.\ninstantiate (1 := w).\nintros [C' IN].\nsimpl do_step.\nrewrite NOTVAL.\nexists \"step_stuck\".\nchange (TR \"step_stuck\" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).\napply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) : exists rule : string,\n  In (TR rule E0 (ExprState f (C a') k e m'))\n    (do_step w (ExprState f (C a) k e m)).","conclusion":"exists rule : string,\n  In (TR rule E0 (ExprState f (C a') k e m'))\n    (do_step w (ExprState f (C a) k e m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None)","proofString":"unfold do_step; rewrite NOTVAL.\nexploit lred_topred; eauto.\ninstantiate (1 := w).\nintros (rule & STEP).\nexists rule.\nchange (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) : exists rule : string,\n  In (TR rule E0 (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"exists rule : string,\n  In (TR rule E0 (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None)","proofString":"exploit lred_topred; eauto.\ninstantiate (1 := w).\nintros (rule & STEP).\nexists rule.\nchange (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) : (exists rule : string, step_expr e w LV a m = topred (Lred rule a' m')) ->\nexists rule : string,\n  In (TR rule E0 (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"(exists rule : string, step_expr e w LV a m = topred (Lred rule a' m')) ->\nexists rule : string,\n  In (TR rule E0 (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None)","proofString":"intros (rule & STEP).\nexists rule.\nchange (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) : exists rule0 : string,\n  In (TR rule0 E0 (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"exists rule0 : string,\n  In (TR rule0 E0 (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m'))","proofString":"exists rule.\nchange (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) : In (TR rule E0 (ExprState f (C a') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (TR rule E0 (ExprState f (C a') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m'))","proofString":"change (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) : In (expr_final_state f k e (C, Lred rule a' m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (expr_final_state f k e (C, Lred rule a' m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m'))","proofString":"apply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) : In (C, Lred rule a' m') (step_expr e w RV (C a) m).","conclusion":"In (C, Lred rule a' m') (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m'))","proofString":"generalize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) : reducts_incl C (step_expr e w LV a m) (step_expr e w RV (C a) m) ->\nIn (C, Lred rule a' m') (step_expr e w RV (C a) m).","conclusion":"reducts_incl C (step_expr e w LV a m) (step_expr e w RV (C a) m) ->\nIn (C, Lred rule a' m') (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m'))","proofString":"unfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) : (forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr e w LV a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) ->\nIn (C, Lred rule a' m') (step_expr e w RV (C a) m).","conclusion":"(forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr e w LV a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) ->\nIn (C, Lred rule a' m') (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m'))","proofString":"intro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (C, Lred rule a' m') (step_expr e w RV (C a) m).","conclusion":"In (C, Lred rule a' m') (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"replace C with (fun x => C x).\napply H2.\nrewrite STEP.\nunfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (fun x : expr => C x, Lred rule a' m') (step_expr e w RV (C a) m).","conclusion":"In (fun x : expr => C x, Lred rule a' m') (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"apply H2.\nrewrite STEP.\nunfold topred; auto with coqlib."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (fun x : expr => x, Lred rule a' m') (step_expr e w LV a m).","conclusion":"In (fun x : expr => x, Lred rule a' m') (step_expr e w LV a m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"rewrite STEP.\nunfold topred; auto with coqlib."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (fun x : expr => x, Lred rule a' m') (topred (Lred rule a' m')).","conclusion":"In (fun x : expr => x, Lred rule a' m') (topred (Lred rule a' m'))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"unfold topred; auto with coqlib."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : (fun x : expr => C x) = C.","conclusion":"(fun x : expr => C x) = C","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) E0 (ExprState f (C a') k e m')) (H0 : lred ge e a m a' m') (H1 : context LV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w LV a m = topred (Lred rule a' m')) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w LV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"apply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) : exists rule : string,\n  In (TR rule t (ExprState f (C a') k e m'))\n    (do_step w (ExprState f (C a) k e m)).","conclusion":"exists rule : string,\n  In (TR rule t (ExprState f (C a') k e m'))\n    (do_step w (ExprState f (C a) k e m))","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None)","proofString":"unfold do_step; rewrite NOTVAL.\nexploit rred_topred; eauto.\ninstantiate (1 := e).\nintros (rule & STEP).\nexists rule.\nchange (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) : exists rule : string,\n  In (TR rule t (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"exists rule : string,\n  In (TR rule t (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None)","proofString":"exploit rred_topred; eauto.\ninstantiate (1 := e).\nintros (rule & STEP).\nexists rule.\nchange (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) : (exists rule : string, step_expr e w RV a m = topred (Rred rule a' m' t)) ->\nexists rule : string,\n  In (TR rule t (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"(exists rule : string, step_expr e w RV a m = topred (Rred rule a' m' t)) ->\nexists rule : string,\n  In (TR rule t (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None)","proofString":"intros (rule & STEP).\nexists rule.\nchange (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) : exists rule0 : string,\n  In (TR rule0 t (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"exists rule0 : string,\n  In (TR rule0 t (ExprState f (C a') k e m'))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t))","proofString":"exists rule.\nchange (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) : In (TR rule t (ExprState f (C a') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (TR rule t (ExprState f (C a') k e m'))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t))","proofString":"change (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) : In (expr_final_state f k e (C, Rred rule a' m' t))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (expr_final_state f k e (C, Rred rule a' m' t))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t))","proofString":"apply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) : In (C, Rred rule a' m' t) (step_expr e w RV (C a) m).","conclusion":"In (C, Rred rule a' m' t) (step_expr e w RV (C a) m)","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t))","proofString":"generalize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) : reducts_incl C (step_expr e w RV a m) (step_expr e w RV (C a) m) ->\nIn (C, Rred rule a' m' t) (step_expr e w RV (C a) m).","conclusion":"reducts_incl C (step_expr e w RV a m) (step_expr e w RV (C a) m) ->\nIn (C, Rred rule a' m' t) (step_expr e w RV (C a) m)","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t))","proofString":"unfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) : (forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr e w RV a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) ->\nIn (C, Rred rule a' m' t) (step_expr e w RV (C a) m).","conclusion":"(forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr e w RV a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) ->\nIn (C, Rred rule a' m' t) (step_expr e w RV (C a) m)","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t))","proofString":"intro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (C, Rred rule a' m' t) (step_expr e w RV (C a) m).","conclusion":"In (C, Rred rule a' m' t) (step_expr e w RV (C a) m)","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"replace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (fun x : expr => C x, Rred rule a' m' t) (step_expr e w RV (C a) m).","conclusion":"In (fun x : expr => C x, Rred rule a' m' t) (step_expr e w RV (C a) m)","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"apply H2.\nrewrite STEP; unfold topred; auto with coqlib."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (fun x : expr => x, Rred rule a' m' t) (step_expr e w RV a m).","conclusion":"In (fun x : expr => x, Rred rule a' m' t) (step_expr e w RV a m)","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"rewrite STEP; unfold topred; auto with coqlib."},{"statement":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : (fun x : expr => C x) = C.","conclusion":"(fun x : expr => C x) = C","hypotheses":"(w : world) (t : trace) (w' : world) (PT : possible_trace w t w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : estep ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) (H0 : rred ge a m t a' m') (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Rred rule a' m' t)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"apply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) : exists rule : string,\n  In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (do_step w (ExprState f (C a) k e m)).","conclusion":"exists rule : string,\n  In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (do_step w (ExprState f (C a) k e m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None)","proofString":"unfold do_step; rewrite NOTVAL.\nexploit callred_topred; eauto.\ninstantiate (1 := w).\ninstantiate (1 := e).\nintros (rule & STEP).\nexists rule.\nchange (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) : exists rule : string,\n  In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"exists rule : string,\n  In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None)","proofString":"exploit callred_topred; eauto.\ninstantiate (1 := w).\ninstantiate (1 := e).\nintros (rule & STEP).\nexists rule.\nchange (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) : (exists rule : string,\n   step_expr e w RV a m = topred (Callred rule fd vargs ty m)) ->\nexists rule : string,\n  In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"(exists rule : string,\n   step_expr e w RV a m = topred (Callred rule fd vargs ty m)) ->\nexists rule : string,\n  In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None)","proofString":"intros (rule & STEP).\nexists rule.\nchange (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) : exists rule0 : string,\n  In (TR rule0 E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"exists rule0 : string,\n  In (TR rule0 E0 (Callstate fd vargs (Kcall f e C ty k) m))\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m))","proofString":"exists rule.\nchange (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) : In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m))","proofString":"change (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)).\napply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) : In (expr_final_state f k e (C, Callred rule fd vargs ty m))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (expr_final_state f k e (C, Callred rule fd vargs ty m))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m))","proofString":"apply in_map.\ngeneralize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) : In (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m).","conclusion":"In (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m))","proofString":"generalize (step_expr_context e w _ _ _ H1 a m).\nunfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) : reducts_incl C (step_expr e w RV a m) (step_expr e w RV (C a) m) ->\nIn (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m).","conclusion":"reducts_incl C (step_expr e w RV a m) (step_expr e w RV (C a) m) ->\nIn (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m))","proofString":"unfold reducts_incl.\nintro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) : (forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr e w RV a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) ->\nIn (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m).","conclusion":"(forall (C1 : expr -> expr) (rd : reduction),\n In (C1, rd) (step_expr e w RV a m) ->\n In (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) ->\nIn (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m))","proofString":"intro.\nreplace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m).","conclusion":"In (C, Callred rule fd vargs ty m) (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"replace C with (fun x => C x).\napply H2.\nrewrite STEP; unfold topred; auto with coqlib.\napply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (fun x : expr => C x, Callred rule fd vargs ty m)\n  (step_expr e w RV (C a) m).","conclusion":"In (fun x : expr => C x, Callred rule fd vargs ty m)\n  (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"apply H2.\nrewrite STEP; unfold topred; auto with coqlib."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : In (fun x : expr => x, Callred rule fd vargs ty m) (step_expr e w RV a m).","conclusion":"In (fun x : expr => x, Callred rule fd vargs ty m) (step_expr e w RV a m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"rewrite STEP; unfold topred; auto with coqlib."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m)) : (fun x : expr => C x) = C.","conclusion":"(fun x : expr => C x) = C","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : estep ge (ExprState f (C a) k e m) E0\n  (Callstate fd vargs (Kcall f e C ty k) m)) (H0 : callred ge a m fd vargs ty) (H1 : context RV RV C) (NOTVAL : is_val (C a) = None) (rule : string) (STEP : step_expr e w RV a m = topred (Callred rule fd vargs ty m)) (H2 : forall (C1 : expr -> expr) (rd : reduction),\nIn (C1, rd) (step_expr e w RV a m) ->\nIn (fun x : expr => C (C1 x), rd) (step_expr e w RV (C a) m))","proofString":"apply extensionality; auto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) : exists rule : string,\n  In (TR rule E0 Stuckstate) (do_step w (ExprState f (C a) k e m)).","conclusion":"exists rule : string,\n  In (TR rule E0 Stuckstate) (do_step w (ExprState f (C a) k e m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None)","proofString":"exploit not_imm_safe_stuck_red.\neauto.\nred; intros; elim H1.\neapply imm_safe_t_imm_safe.\neauto.\ninstantiate (1 := w).\nintros [C' IN].\nsimpl do_step.\nrewrite NOTVAL.\nexists \"step_stuck\".\nchange (TR \"step_stuck\" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).\napply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) : (exists C' : expr -> expr, In (C', Stuckred) (step_expr e w RV (C a) m)) ->\nexists rule : string,\n  In (TR rule E0 Stuckstate) (do_step w (ExprState f (C a) k e m)).","conclusion":"(exists C' : expr -> expr, In (C', Stuckred) (step_expr e w RV (C a) m)) ->\nexists rule : string,\n  In (TR rule E0 Stuckstate) (do_step w (ExprState f (C a) k e m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None)","proofString":"intros [C' IN].\nsimpl do_step.\nrewrite NOTVAL.\nexists \"step_stuck\".\nchange (TR \"step_stuck\" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).\napply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m)) : exists rule : string,\n  In (TR rule E0 Stuckstate) (do_step w (ExprState f (C a) k e m)).","conclusion":"exists rule : string,\n  In (TR rule E0 Stuckstate) (do_step w (ExprState f (C a) k e m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m))","proofString":"simpl do_step.\nrewrite NOTVAL.\nexists \"step_stuck\".\nchange (TR \"step_stuck\" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).\napply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m)) : exists rule : string,\n  In (TR rule E0 Stuckstate)\n    match is_val (C a) with\n    | Some (v, ty) =>\n        match k with\n        | Kdo k0 => ret \"step_do_2\" (State f Sskip k0 e m)\n        | Kifthenelse s1 s2 k0 =>\n            do b <- bool_val v ty m;\n            ret \"step_ifthenelse_2\" (State f (if b then s1 else s2) k0 e m)\n        | Kwhile1 x s k0 =>\n            match bool_val v ty m with\n            | Some true =>\n                ret \"step_while_true\" (State f s (Kwhile2 x s k0) e m)\n            | Some false => ret \"step_while_false\" (State f Sskip k0 e m)\n            | None => nil\n            end\n        | Kdowhile2 x s k0 =>\n            match bool_val v ty m with\n            | Some true =>\n                ret \"step_dowhile_true\" (State f (Sdowhile x s) k0 e m)\n            | Some false => ret \"step_dowhile_false\" (State f Sskip k0 e m)\n            | None => nil\n            end\n        | Kfor2 a2 a3 s k0 =>\n            match bool_val v ty m with\n            | Some true =>\n                ret \"step_for_true\" (State f s (Kfor3 a2 a3 s k0) e m)\n            | Some false => ret \"step_for_false\" (State f Sskip k0 e m)\n            | None => nil\n            end\n        | Kswitch1 sl k0 =>\n            do n <- sem_switch_arg v ty;\n            ret \"step_expr_switch\"\n              (State f (seq_of_labeled_statement (select_switch n sl))\n                 (Kswitch2 k0) e m)\n        | Kreturn k0 =>\n            do v' <- sem_cast v ty (fn_return f) m;\n            do m' <- Mem.free_list m (blocks_of_env ge e);\n            ret \"step_return_2\" (Returnstate v' (call_cont k0) m')\n        | _ => nil\n        end\n    | None => map (expr_final_state f k e) (step_expr e w RV (C a) m)\n    end.","conclusion":"exists rule : string,\n  In (TR rule E0 Stuckstate)\n    match is_val (C a) with\n    | Some (v, ty) =>\n        match k with\n        | Kdo k0 => ret \"step_do_2\" (State f Sskip k0 e m)\n        | Kifthenelse s1 s2 k0 =>\n            do b <- bool_val v ty m;\n            ret \"step_ifthenelse_2\" (State f (if b then s1 else s2) k0 e m)\n        | Kwhile1 x s k0 =>\n            match bool_val v ty m with\n            | Some true =>\n                ret \"step_while_true\" (State f s (Kwhile2 x s k0) e m)\n            | Some false => ret \"step_while_false\" (State f Sskip k0 e m)\n            | None => nil\n            end\n        | Kdowhile2 x s k0 =>\n            match bool_val v ty m with\n            | Some true =>\n                ret \"step_dowhile_true\" (State f (Sdowhile x s) k0 e m)\n            | Some false => ret \"step_dowhile_false\" (State f Sskip k0 e m)\n            | None => nil\n            end\n        | Kfor2 a2 a3 s k0 =>\n            match bool_val v ty m with\n            | Some true =>\n                ret \"step_for_true\" (State f s (Kfor3 a2 a3 s k0) e m)\n            | Some false => ret \"step_for_false\" (State f Sskip k0 e m)\n            | None => nil\n            end\n        | Kswitch1 sl k0 =>\n            do n <- sem_switch_arg v ty;\n            ret \"step_expr_switch\"\n              (State f (seq_of_labeled_statement (select_switch n sl))\n                 (Kswitch2 k0) e m)\n        | Kreturn k0 =>\n            do v' <- sem_cast v ty (fn_return f) m;\n            do m' <- Mem.free_list m (blocks_of_env ge e);\n            ret \"step_return_2\" (Returnstate v' (call_cont k0) m')\n        | _ => nil\n        end\n    | None => map (expr_final_state f k e) (step_expr e w RV (C a) m)\n    end","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m))","proofString":"rewrite NOTVAL.\nexists \"step_stuck\".\nchange (TR \"step_stuck\" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).\napply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m)) : exists rule : string,\n  In (TR rule E0 Stuckstate)\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"exists rule : string,\n  In (TR rule E0 Stuckstate)\n    (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m))","proofString":"exists \"step_stuck\".\nchange (TR \"step_stuck\" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).\napply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m)) : In (TR \"step_stuck\" E0 Stuckstate)\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (TR \"step_stuck\" E0 Stuckstate)\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m))","proofString":"change (TR \"step_stuck\" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).\napply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m)) : In (expr_final_state f k e (C', Stuckred))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m)).","conclusion":"In (expr_final_state f k e (C', Stuckred))\n  (map (expr_final_state f k e) (step_expr e w RV (C a) m))","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m))","proofString":"apply in_map.\nauto."},{"statement":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m)) : In (C', Stuckred) (step_expr e w RV (C a) m).","conclusion":"In (C', Stuckred) (step_expr e w RV (C a) m)","hypotheses":"(w w' : world) (PT : possible_trace w E0 w') (C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (H : estep ge (ExprState f (C a) k e m) E0 Stuckstate) (K : kind) (H0 : context K RV C) (H1 : ~ imm_safe ge e K a m) (NOTVAL : is_val (C a) = None) (C' : expr -> expr) (IN : In (C', Stuckred) (step_expr e w RV (C a) m))","proofString":"auto."}]}