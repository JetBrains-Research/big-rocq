{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/simulation/SimulationRelProperties.v","fileSamples":[{"statement":"(rel : View.t_) (b : actid) (from : Time.t) (v : value) (ISS : I b) (VAL : Some v = val lab b) (FROM : Time.lt from (f_to b) \\/ is_init b /\\ from = Time.bot /\\ f_to b = Time.bot) (SIMMSG : sim_msg G sc f_to b rel) : sim_msg G sc f_to' b rel.","proofString":"eapply sim_msg_f_issued; eauto."},{"statement":"(thread : thread_id) (threads : Local.t) (memory : Memory.t) (SIMMEM : forall (l0 : location) (b0 : actid),\nS b0 ->\n~ I b0 ->\nloc lab b0 = Some l0 ->\nMemory.get l0 (f_to b0) memory = Some (f_from b0, Message.reserve) /\\\n(tid b0 = thread ->\n Memory.get l0 (f_to b0) (Local.promises threads) =\n Some (f_from b0, Message.reserve))) (l : location) (b : actid) (RESB : S b) (NISSB : ~ I b) (LOC : loc lab b = Some l) : Memory.get l (f_to' b) memory = Some (f_from' b, Message.reserve) /\\\n(tid b = thread ->\n Memory.get l (f_to' b) (Local.promises threads) =\n Some (f_from' b, Message.reserve)).","proofString":"rewrite (REQ_TO RESB); rewrite (REQ_FROM RESB).\nby apply SIMMEM."},{"statement":"(thread : thread_id) (threads : Local.t) (memory : Memory.t) (SIMMEM : forall (l0 : location) (b0 : actid),\nS b0 ->\n~ I b0 ->\nloc lab b0 = Some l0 ->\nMemory.get l0 (f_to b0) memory = Some (f_from b0, Message.reserve) /\\\n(tid b0 = thread ->\n Memory.get l0 (f_to b0) (Local.promises threads) =\n Some (f_from b0, Message.reserve))) (l : location) (b : actid) (RESB : S b) (NISSB : ~ I b) (LOC : loc lab b = Some l) : Memory.get l (f_to b) memory = Some (f_from b, Message.reserve) /\\\n(tid b = thread ->\n Memory.get l (f_to b) (Local.promises threads) =\n Some (f_from b, Message.reserve)).","proofString":"by apply SIMMEM."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) : message_to_event G TLS f_to' f_from' memory.","proofString":"red; ins.\nspecialize (MEM l to from v rel MSG).\ndestruct MEM as [MEM|MEM]; [by left; apply MEM|right].\ndestruct MEM as [b H]; desc.\nexists b; splits; auto.\nrewrite REQ_FROM; auto.\nby apply (rcoh_I_in_S RCOH).\nrewrite REQ_TO; auto.\nby apply (rcoh_I_in_S RCOH)."},{"statement":"(memory : Memory.t) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (ISS : I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) (v : Const.t) (rel : option View.t) (MSG : Memory.get l to memory = Some (from, Message.full v rel)) : f_from' b = from.","proofString":"rewrite REQ_FROM; auto.\nby apply (rcoh_I_in_S RCOH)."},{"statement":"(memory : Memory.t) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (ISS : I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) (v : Const.t) (rel : option View.t) (MSG : Memory.get l to memory = Some (from, Message.full v rel)) : S b.","proofString":"by apply (rcoh_I_in_S RCOH)."},{"statement":"(memory : Memory.t) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (ISS : I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) (v : Const.t) (rel : option View.t) (MSG : Memory.get l to memory = Some (from, Message.full v rel)) : f_to' b = to.","proofString":"rewrite REQ_TO; auto.\nby apply (rcoh_I_in_S RCOH)."},{"statement":"(memory : Memory.t) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (ISS : I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) (v : Const.t) (rel : option View.t) (MSG : Memory.get l to memory = Some (from, Message.full v rel)) : S b.","proofString":"by apply (rcoh_I_in_S RCOH)."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) : half_message_to_event G TLS f_to' f_from' memory.","proofString":"red.\nins.\nspecialize (HMEM l to from MSG).\ndesc.\nexists b.\nsplits; auto.\nerewrite REQ_FROM; eauto.\nerewrite REQ_TO; eauto."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (RES : S b) (NOISS : ~ I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) (MSG : Memory.get l to memory = Some (from, Message.reserve)) : f_from' b = from.","proofString":"erewrite REQ_FROM; eauto."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (RES : S b) (NOISS : ~ I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) (MSG : Memory.get l to memory = Some (from, Message.reserve)) : f_to' b = to.","proofString":"erewrite REQ_TO; eauto."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x y : actid,\nS x -> S y -> co x y -> f_to x = f_from y -> (rf ⨾ rmw) x y) : forall x y : actid,\nS x -> S y -> co x y -> f_to' x = f_from' y -> (rf ⨾ rmw) x y.","proofString":"intros x y SX SY COXY H.\napply TFRMW; auto.\nrewrite <- (REQ_FROM SY).\nrewrite <- (REQ_TO   SX).\ndone."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x0 y0 : actid,\nS x0 -> S y0 -> co x0 y0 -> f_to x0 = f_from y0 -> (rf ⨾ rmw) x0 y0) (x y : actid) (SX : S x) (SY : S y) (COXY : co x y) (H : f_to' x = f_from' y) : (rf ⨾ rmw) x y.","proofString":"apply TFRMW; auto.\nrewrite <- (REQ_FROM SY).\nrewrite <- (REQ_TO   SX).\ndone."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x0 y0 : actid,\nS x0 -> S y0 -> co x0 y0 -> f_to x0 = f_from y0 -> (rf ⨾ rmw) x0 y0) (x y : actid) (SX : S x) (SY : S y) (COXY : co x y) (H : f_to' x = f_from' y) : f_to x = f_from y.","proofString":"rewrite <- (REQ_FROM SY).\nrewrite <- (REQ_TO   SX).\ndone."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x0 y0 : actid,\nS x0 -> S y0 -> co x0 y0 -> f_to x0 = f_from y0 -> (rf ⨾ rmw) x0 y0) (x y : actid) (SX : S x) (SY : S y) (COXY : co x y) (H : f_to' x = f_from' y) : f_to x = f_from' y.","proofString":"rewrite <- (REQ_TO   SX).\ndone."},{"statement":"(memory : Memory.t) (MEM : message_to_event G TLS f_to f_from memory) (HMEM : half_message_to_event G TLS f_to f_from memory) (TFRMW : forall x0 y0 : actid,\nS x0 -> S y0 -> co x0 y0 -> f_to x0 = f_from y0 -> (rf ⨾ rmw) x0 y0) (x y : actid) (SX : S x) (SY : S y) (COXY : co x y) (H : f_to' x = f_from' y) : f_to' x = f_from' y.","proofString":"done."},{"statement":"(thread : thread_id) (promises : Memory.t) (SIMPROM : sim_prom G sc TLS f_to f_from thread promises) (l : Loc.t) (to from : Time.t) (v : Const.t) (rel : option View.t) (PROM : Memory.get l to promises = Some (from, Message.full v rel)) (b : actid) (ACTS : E b) (TID : tid b = thread) (ISS : I b) (NCOV : ~ C b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (HELPER : sim_mem_helper G sc f_to b from v (View.unwrap rel)) : f_from' b = from.","proofString":"by rewrite ISSEQ_FROM."},{"statement":"(thread : thread_id) (promises : Memory.t) (SIMPROM : sim_prom G sc TLS f_to f_from thread promises) (l : Loc.t) (to from : Time.t) (v : Const.t) (rel : option View.t) (PROM : Memory.get l to promises = Some (from, Message.full v rel)) (b : actid) (ACTS : E b) (TID : tid b = thread) (ISS : I b) (NCOV : ~ C b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (HELPER : sim_mem_helper G sc f_to b from v (View.unwrap rel)) : f_to' b = to.","proofString":"by rewrite ISSEQ_TO."},{"statement":"(thread : thread_id) (promises : Memory.t) (SIMPROM : sim_prom G sc TLS f_to f_from thread promises) (l : Loc.t) (to from : Time.t) (v : Const.t) (rel : option View.t) (PROM : Memory.get l to promises = Some (from, Message.full v rel)) (b : actid) (ACTS : E b) (TID : tid b = thread) (ISS : I b) (NCOV : ~ C b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) (HELPER : sim_mem_helper G sc f_to b from v (View.unwrap rel)) : sim_mem_helper G sc f_to' b from v (View.unwrap rel).","proofString":"eapply sim_mem_helper_f_issued; eauto."},{"statement":"(thread : thread_id) (promises : Memory.t) (SIMRESPROM : sim_res_prom G TLS f_to f_from thread promises) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (TID : tid b = thread) (RES : S b) (NOISS : ~ I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) : f_from' b = from.","proofString":"erewrite REQ_FROM; eauto."},{"statement":"(thread : thread_id) (promises : Memory.t) (SIMRESPROM : sim_res_prom G TLS f_to f_from thread promises) (l : Loc.t) (to from : Time.t) (b : actid) (ACTS : E b) (TID : tid b = thread) (RES : S b) (NOISS : ~ I b) (LOC : loc lab b = Some l) (FROM : f_from b = from) (TO : f_to b = to) : f_to' b = to.","proofString":"erewrite REQ_TO; eauto."},{"statement":"(sc_view : LocFun.t Time.t) (l : location) (SC_REQ : max_value f_to (S_tm G l C) (LocFun.find l sc_view)) : max_value f_to' (S_tm G l C) (LocFun.find l sc_view).","proofString":"eapply max_value_new_f; eauto.\nintros x H; apply ISSEQ_TO.\nred in H.\neapply S_tm_covered; eauto."},{"statement":"(sc_view : LocFun.t Time.t) (l : location) (SC_REQ : max_value f_to (S_tm G l C) (LocFun.find l sc_view)) : forall x : actid, S_tm G l C x -> f_to' x = f_to x.","proofString":"intros x H; apply ISSEQ_TO.\nred in H.\neapply S_tm_covered; eauto."},{"statement":"(sc_view : LocFun.t Time.t) (l : location) (SC_REQ : max_value f_to (S_tm G l C) (LocFun.find l sc_view)) (x : actid) (H : S_tm G l C x) : I x.","proofString":"red in H.\neapply S_tm_covered; eauto."},{"statement":"(sc_view : LocFun.t Time.t) (l : location) (SC_REQ : max_value f_to (S_tm G l C) (LocFun.find l sc_view)) (x : actid) (H : dom_rel (S_tmr G l C) x) : I x.","proofString":"eapply S_tm_covered; eauto."},{"statement":"(PC : Configuration.t) (smode : sim_mode) (SIMREL : simrel_common G sc PC TLS f_to f_from smode) (ALLRLX : E \\₁ (fun a : actid => is_init a) ⊆₁ (fun a : actid => Rlx a)) (FRELACQ : E ∩₁ F ⊆₁ (fun a : actid => is_ra lab a)) (TLSCOH0 : tls_coherent G TLS) (IORDCOH0 : iord_coherent G sc TLS) (RCOH0 : reserve_coherent G TLS) (RELCOV0 : W ∩₁ (fun a : actid => Rel a) ∩₁ I ⊆₁ C) (RMWCOV : forall r w : actid, rmw r w -> C r <-> C w) (THREAD : forall t : thread_id,\n(threads_set G \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH0 : f_to_coherent G S f_to f_from) (SC_COV : smode = sim_certification -> E ∩₁ F ∩₁ Sc ⊆₁ C) (SC_REQ : smode = sim_normal ->\nforall l : location,\nmax_value f_to (S_tm G l C) (LocFun.find l (Configuration.sc PC))) (RMWREX : dom_rel rmw ⊆₁ (fun a : actid => R_ex lab a)) (RESERVED_TIME : reserved_time G TLS f_to f_from smode (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC)) : simrel_common G sc PC TLS f_to' f_from' smode.","proofString":"red; splits; auto.\neapply f_to_coherent_fS; eauto.\nins.\neapply sc_view_f_issued; eauto.\neapply rintervals_fS; eauto."},{"statement":"(PC : Configuration.t) (smode : sim_mode) (SIMREL : simrel_common G sc PC TLS f_to f_from smode) (ALLRLX : E \\₁ (fun a : actid => is_init a) ⊆₁ (fun a : actid => Rlx a)) (FRELACQ : E ∩₁ F ⊆₁ (fun a : actid => is_ra lab a)) (TLSCOH0 : tls_coherent G TLS) (IORDCOH0 : iord_coherent G sc TLS) (RCOH0 : reserve_coherent G TLS) (RELCOV0 : W ∩₁ (fun a : actid => Rel a) ∩₁ I ⊆₁ C) (RMWCOV : forall r w : actid, rmw r w -> C r <-> C w) (THREAD : forall t : thread_id,\n(threads_set G \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH0 : f_to_coherent G S f_to f_from) (SC_COV : smode = sim_certification -> E ∩₁ F ∩₁ Sc ⊆₁ C) (SC_REQ : smode = sim_normal ->\nforall l : location,\nmax_value f_to (S_tm G l C) (LocFun.find l (Configuration.sc PC))) (RMWREX : dom_rel rmw ⊆₁ (fun a : actid => R_ex lab a)) (RESERVED_TIME : reserved_time G TLS f_to f_from smode (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC)) : f_to_coherent G S f_to' f_from'.","proofString":"eapply f_to_coherent_fS; eauto."},{"statement":"(PC : Configuration.t) (smode : sim_mode) (SIMREL : simrel_common G sc PC TLS f_to f_from smode) (ALLRLX : E \\₁ (fun a : actid => is_init a) ⊆₁ (fun a : actid => Rlx a)) (FRELACQ : E ∩₁ F ⊆₁ (fun a : actid => is_ra lab a)) (TLSCOH0 : tls_coherent G TLS) (IORDCOH0 : iord_coherent G sc TLS) (RCOH0 : reserve_coherent G TLS) (RELCOV0 : W ∩₁ (fun a : actid => Rel a) ∩₁ I ⊆₁ C) (RMWCOV : forall r w : actid, rmw r w -> C r <-> C w) (THREAD : forall t : thread_id,\n(threads_set G \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH0 : f_to_coherent G S f_to f_from) (SC_COV : smode = sim_certification -> E ∩₁ F ∩₁ Sc ⊆₁ C) (SC_REQ : smode = sim_normal ->\nforall l : location,\nmax_value f_to (S_tm G l C) (LocFun.find l (Configuration.sc PC))) (RMWREX : dom_rel rmw ⊆₁ (fun a : actid => R_ex lab a)) (RESERVED_TIME : reserved_time G TLS f_to f_from smode (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC)) : smode = sim_normal ->\nforall l : location,\nmax_value f_to' (S_tm G l C) (LocFun.find l (Configuration.sc PC)).","proofString":"ins.\neapply sc_view_f_issued; eauto."},{"statement":"(PC : Configuration.t) (smode : sim_mode) (SIMREL : simrel_common G sc PC TLS f_to f_from smode) (ALLRLX : E \\₁ (fun a : actid => is_init a) ⊆₁ (fun a : actid => Rlx a)) (FRELACQ : E ∩₁ F ⊆₁ (fun a : actid => is_ra lab a)) (TLSCOH0 : tls_coherent G TLS) (IORDCOH0 : iord_coherent G sc TLS) (RCOH0 : reserve_coherent G TLS) (RELCOV0 : W ∩₁ (fun a : actid => Rel a) ∩₁ I ⊆₁ C) (RMWCOV : forall r w : actid, rmw r w -> C r <-> C w) (THREAD : forall t : thread_id,\n(threads_set G \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH0 : f_to_coherent G S f_to f_from) (SC_COV : smode = sim_certification -> E ∩₁ F ∩₁ Sc ⊆₁ C) (SC_REQ : smode = sim_normal ->\nforall l0 : location,\nmax_value f_to (S_tm G l0 C) (LocFun.find l0 (Configuration.sc PC))) (RMWREX : dom_rel rmw ⊆₁ (fun a : actid => R_ex lab a)) (RESERVED_TIME : reserved_time G TLS f_to f_from smode (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC)) (H : smode = sim_normal) (l : location) : max_value f_to' (S_tm G l C) (LocFun.find l (Configuration.sc PC)).","proofString":"eapply sc_view_f_issued; eauto."},{"statement":"(PC : Configuration.t) (smode : sim_mode) (SIMREL : simrel_common G sc PC TLS f_to f_from smode) (ALLRLX : E \\₁ (fun a : actid => is_init a) ⊆₁ (fun a : actid => Rlx a)) (FRELACQ : E ∩₁ F ⊆₁ (fun a : actid => is_ra lab a)) (TLSCOH0 : tls_coherent G TLS) (IORDCOH0 : iord_coherent G sc TLS) (RCOH0 : reserve_coherent G TLS) (RELCOV0 : W ∩₁ (fun a : actid => Rel a) ∩₁ I ⊆₁ C) (RMWCOV : forall r w : actid, rmw r w -> C r <-> C w) (THREAD : forall t : thread_id,\n(threads_set G \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH0 : f_to_coherent G S f_to f_from) (SC_COV : smode = sim_certification -> E ∩₁ F ∩₁ Sc ⊆₁ C) (SC_REQ : smode = sim_normal ->\nforall l : location,\nmax_value f_to (S_tm G l C) (LocFun.find l (Configuration.sc PC))) (RMWREX : dom_rel rmw ⊆₁ (fun a : actid => R_ex lab a)) (RESERVED_TIME : reserved_time G TLS f_to f_from smode (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC)) : reserved_time G TLS f_to' f_from' smode (Configuration.memory PC).","proofString":"eapply rintervals_fS; eauto."},{"statement":"(thread : thread_id) (PC : Configuration.t) (smode : sim_mode) (SIMREL : simrel_thread G sc PC TLS f_to f_from thread smode) (COMMON : simrel_common G sc PC TLS f_to f_from smode) (LOCAL : simrel_thread_local G sc PC TLS f_to f_from thread smode) : simrel_thread G sc PC TLS f_to' f_from' thread smode.","proofString":"cdes COMMON.\ncdes LOCAL.\nred; splits; auto.\neapply simrel_common_fS; eauto.\neapply simrel_thread_local_fS; eauto."},{"statement":"(thread : thread_id) (PC : Configuration.t) (smode : sim_mode) (SIMREL : simrel_thread G sc PC TLS f_to f_from thread smode) (COMMON : simrel_common G sc PC TLS f_to f_from smode) (LOCAL : simrel_thread_local G sc PC TLS f_to f_from thread smode) (ALLRLX : E \\₁ (fun a : actid => is_init a) ⊆₁ (fun a : actid => Rlx a)) (FRELACQ : E ∩₁ F ⊆₁ (fun a : actid => is_ra lab a)) (TLSCOH0 : tls_coherent G TLS) (IORDCOH0 : iord_coherent G sc TLS) (RCOH0 : reserve_coherent G TLS) (RELCOV0 : W ∩₁ (fun a : actid => Rel a) ∩₁ I ⊆₁ C) (RMWCOV : forall r w : actid, rmw r w -> C r <-> C w) (THREAD : forall t : thread_id,\n(threads_set G \\₁ eq tid_init) t -> IdentMap.In t (Configuration.threads PC)) (PROM_IN_MEM : forall (thread' : IdentMap.key)\n  (langst : {lang : language & Language.state lang}) \n  (local : Local.t),\nIdentMap.find thread' (Configuration.threads PC) = Some (langst, local) ->\nMemory.le (Local.promises local) (Configuration.memory PC)) (FCOH0 : f_to_coherent G S f_to f_from) (SC_COV : smode = sim_certification -> E ∩₁ F ∩₁ Sc ⊆₁ C) (SC_REQ : smode = sim_normal ->\nforall l : location,\nmax_value f_to (S_tm G l C) (LocFun.find l (Configuration.sc PC))) (RMWREX : dom_rel rmw ⊆₁ (fun a : actid => R_ex lab a)) (RESERVED_TIME : reserved_time G TLS f_to f_from smode (Configuration.memory PC)) (CLOSED_SC : Memory.closed_timemap (Configuration.sc PC) (Configuration.memory PC)) (INHAB : Memory.inhabited (Configuration.memory PC)) (CLOSED_MEM : Memory.closed (Configuration.memory PC)) : simrel_thread G sc PC TLS f_to' f_from' thread smode.","proofString":"cdes LOCAL.\nred; splits; auto.\neapply simrel_common_fS; eauto.\neapply simrel_thread_local_fS; eauto."},{"statement":"(PC : Configuration.t) (SIMREL : simrel G sc PC TLS f_to f_from) (COMMON : simrel_common G sc PC TLS f_to f_from sim_normal) (THREADS : forall thread : IdentMap.key,\nIdentMap.In thread (Configuration.threads PC) ->\nsimrel_thread_local G sc PC TLS f_to f_from thread sim_normal) : simrel G sc PC TLS f_to' f_from'.","proofString":"red; splits.\neapply simrel_common_fS; eauto.\nins.\neapply simrel_thread_local_fS; eauto."},{"statement":"(PC : Configuration.t) (SIMREL : simrel G sc PC TLS f_to f_from) (COMMON : simrel_common G sc PC TLS f_to f_from sim_normal) (THREADS : forall thread : IdentMap.key,\nIdentMap.In thread (Configuration.threads PC) ->\nsimrel_thread_local G sc PC TLS f_to f_from thread sim_normal) : simrel_common G sc PC TLS f_to' f_from' sim_normal.","proofString":"eapply simrel_common_fS; eauto."},{"statement":"(PC : Configuration.t) (SIMREL : simrel G sc PC TLS f_to f_from) (COMMON : simrel_common G sc PC TLS f_to f_from sim_normal) (THREADS : forall thread : IdentMap.key,\nIdentMap.In thread (Configuration.threads PC) ->\nsimrel_thread_local G sc PC TLS f_to f_from thread sim_normal) : forall thread : IdentMap.key,\nIdentMap.In thread (Configuration.threads PC) ->\nsimrel_thread_local G sc PC TLS f_to' f_from' thread sim_normal.","proofString":"ins.\neapply simrel_thread_local_fS; eauto."},{"statement":"(PC : Configuration.t) (SIMREL : simrel G sc PC TLS f_to f_from) (COMMON : simrel_common G sc PC TLS f_to f_from sim_normal) (THREADS : forall thread0 : IdentMap.key,\nIdentMap.In thread0 (Configuration.threads PC) ->\nsimrel_thread_local G sc PC TLS f_to f_from thread0 sim_normal) (thread : IdentMap.key) (TP : IdentMap.In thread (Configuration.threads PC)) : simrel_thread_local G sc PC TLS f_to' f_from' thread sim_normal.","proofString":"eapply simrel_thread_local_fS; eauto."},{"statement":"(thread : thread_id) (local : Local.t) (memory : Memory.t) (SIMMEM : sim_mem G sc TLS f_to f_from thread local memory) (SIMRESMEM : sim_res_mem G TLS f_to f_from thread local memory) (l : location) (b : actid) (RESB : S b) (LOC : loc lab b = Some l) (AA : I b) : exists v : value, val lab b = Some v.","proofString":"apply is_w_val.\neapply issuedW; eauto."},{"statement":"(thread : thread_id) (local : Local.t) (memory : Memory.t) (SIMMEM : sim_mem G sc TLS f_to f_from thread local memory) (SIMRESMEM : sim_res_mem G TLS f_to f_from thread local memory) (l : location) (b : actid) (RESB : S b) (LOC : loc lab b = Some l) (AA : I b) : is_w lab b.","proofString":"eapply issuedW; eauto."},{"statement":"(thread : thread_id) (local : Local.t) (memory : Memory.t) (SIMMEM : sim_mem G sc TLS f_to f_from thread local memory) (SIMRESMEM : sim_res_mem G TLS f_to f_from thread local memory) (l : location) (b : actid) (RESB : S b) (LOC : loc lab b = Some l) (AA : I b) (v : value) (BB : val lab b = Some v) : exists msg : Message.t,\n  Memory.get l (f_to b) memory = Some (f_from b, msg) /\\\n  (tid b = thread ->\n   ~ C b ->\n   Memory.get l (f_to b) (Local.promises local) = Some (f_from b, msg)).","proofString":"edestruct SIMMEM as [msg CC]; eauto.\nsimpls.\ndesf.\neexists.\nsplits; eauto.\nins.\nby apply CC1."},{"statement":"(memory : Memory.t) (MTE : message_to_event G TLS f_to f_from memory) (HMTE : half_message_to_event G TLS f_to f_from memory) (l : Loc.t) (val : Const.t) (released : option View.t) (b : actid) (ACTS : E b) (ISS : I b) (LOC : loc lab b = Some l) : S b.","proofString":"eapply rcoh_I_in_S; eauto."},{"statement":"(locw : location) (memory : Memory.t) (local : Local.t) (thread : thread_id) (x : actid) (XLOC : loc lab x = Some locw) (SIMMEM : sim_mem G sc TLS f_to f_from thread local memory) (SIMRESMEM : sim_res_mem G TLS f_to f_from thread local memory) (SX : exists msg : Message.t,\n  Memory.get locw (f_to x) memory = Some (f_from x, msg) /\\\n  (tid x = thread ->\n   ~ C x ->\n   Memory.get locw (f_to x) (Local.promises local) = Some (f_from x, msg))) : Time.le (f_to x) (Memory.max_ts locw memory).","proofString":"desf.\neapply Memory.max_ts_spec; eauto."},{"statement":"(locw : location) (memory : Memory.t) (local : Local.t) (thread : thread_id) (x : actid) (XLOC : loc lab x = Some locw) (SIMMEM : sim_mem G sc TLS f_to f_from thread local memory) (SIMRESMEM : sim_res_mem G TLS f_to f_from thread local memory) (msg : Message.t) (SX : Memory.get locw (f_to x) memory = Some (f_from x, msg)) (SX0 : tid x = thread ->\n~ C x ->\nMemory.get locw (f_to x) (Local.promises local) = Some (f_from x, msg)) : Time.le (f_to x) (Memory.max_ts locw memory).","proofString":"eapply Memory.max_ts_spec; eauto."},{"statement":"(T T' : trav_label -> Prop) (b : actid) : ~ issued T b -> issued T' ≡₁ issued T -> ~ issued T' b.","proofString":"basic_solver 10."}]}