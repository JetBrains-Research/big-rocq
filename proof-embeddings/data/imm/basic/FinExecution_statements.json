{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/basic/FinExecution.v","fileSamples":[{"statement":"(G : execution) : set_finite (acts_set G) <->\nset_finite (acts_set G \\₁ (fun a : actid => is_init a)) /\\\nset_finite (acts_set G ∩₁ (fun a : actid => is_init a)).","proofString":"rewrite <- set_finite_union.\napply set_finite_more.\nrewrite set_minusE, set_unionC, <- set_inter_union_r, <- set_full_split.\nbasic_solver."},{"statement":"(G : execution) : set_finite (acts_set G) <->\nset_finite\n  (acts_set G \\₁ (fun a : actid => is_init a)\n   ∪₁ acts_set G ∩₁ (fun a : actid => is_init a)).","proofString":"apply set_finite_more.\nrewrite set_minusE, set_unionC, <- set_inter_union_r, <- set_full_split.\nbasic_solver."},{"statement":"(G : execution) : acts_set G\n≡₁ acts_set G \\₁ (fun a : actid => is_init a)\n   ∪₁ acts_set G ∩₁ (fun a : actid => is_init a).","proofString":"rewrite set_minusE, set_unionC, <- set_inter_union_r, <- set_full_split.\nbasic_solver."},{"statement":"(G : execution) : acts_set G ≡₁ acts_set G ∩₁ ⊤₁.","proofString":"basic_solver."},{"statement":"(thread : thread_id) (AA : fin_exec_full G) (n m : nat) (EQ : ThreadEvent thread n = ThreadEvent thread m) : n = m.","proofString":"desf."},{"statement":"(thread : thread_id) (AA : fin_exec_full G) : forall x y : actid, {x = y} + {x <> y}.","proofString":"apply eq_dec_actid."},{"statement":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m)) : exists n0 : nat, ~ acts_set G (ThreadEvent thread n0).","proofString":"exists (1 + n).\napply AA.\nlia."},{"statement":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m)) : ~ acts_set G (ThreadEvent thread (1 + n)).","proofString":"apply AA.\nlia."},{"statement":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m)) : n < 1 + n.","proofString":"lia."},{"statement":"(G G' : execution) (SAME : acts_set G ≡₁ acts_set G') (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) : set_finite (acts_set G' \\₁ (fun a : actid => is_init a)).","proofString":"by rewrite <- SAME."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite\n  (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)\n   ∪₁ S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","proofString":"apply set_finite_union.\nsplit.\neapply set_finite_mori; [| by apply set_finite_empty].\nred.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x.\neapply set_finite_mori; [| by apply FIN].\nred.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)) /\\\nset_finite (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","proofString":"split.\neapply set_finite_mori; [| by apply set_finite_empty].\nred.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x.\neapply set_finite_mori; [| by apply FIN].\nred.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)).","proofString":"eapply set_finite_mori; [| by apply set_finite_empty].\nred.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : Basics.flip set_subset ∅ (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)).","proofString":"red.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a) ⊆₁ ∅.","proofString":"unfolder.\nins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : forall x : actid, (S x /\\ tid x = thread) /\\ is_init x -> False.","proofString":"ins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (x : actid) (H : (S x /\\ tid x = thread) /\\ is_init x) : False.","proofString":"desc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (x : actid) (H : S x) (H1 : tid x = thread) (H0 : is_init x) : False.","proofString":"vauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (x : actid) (NT : tid x <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (H : S x) (H0 : is_init x) : False.","proofString":"by destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","proofString":"eapply set_finite_mori; [| by apply FIN].\nred.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : Basics.flip set_subset (S \\₁ (fun a : actid => is_init a))\n  (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","proofString":"red.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ S \\₁ (fun a : actid => is_init a).","proofString":"basic_solver."}]}