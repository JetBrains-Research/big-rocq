{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Cshmgenproof.v","fileSamples":[{"statement":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp)","proofString":"eapply match_transform_partial_program2.\neexact H.\nintros.\ndestruct f; simpl in H0.\nmonadInv H0.\nconstructor; auto.\ndestruct signature_eq; inv H0.\nconstructor; auto.\nintros; red; auto."},{"statement":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (f : Clight.fundef) (tf : fundef) (H0 : transl_fundef (prog_comp_env p) i f = OK tf) : match_fundef p f tf.","conclusion":"match_fundef p f tf","hypotheses":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (f : Clight.fundef) (tf : fundef) (H0 : transl_fundef (prog_comp_env p) i f = OK tf)","proofString":"destruct f; simpl in H0.\nmonadInv H0.\nconstructor; auto.\ndestruct signature_eq; inv H0.\nconstructor; auto."},{"statement":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (f : Clight.function) (tf : fundef) (H0 : bind (transl_function (prog_comp_env p) f)\n  (fun tg : function => OK (AST.Internal tg)) = OK tf) : match_fundef p (Internal f) tf.","conclusion":"match_fundef p (Internal f) tf","hypotheses":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (f : Clight.function) (tf : fundef) (H0 : bind (transl_function (prog_comp_env p) f)\n  (fun tg : function => OK (AST.Internal tg)) = OK tf)","proofString":"monadInv H0.\nconstructor; auto."},{"statement":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (f : Clight.function) (x : function) (EQ : transl_function (prog_comp_env p) f = OK x) : match_fundef p (Internal f) (AST.Internal x).","conclusion":"match_fundef p (Internal f) (AST.Internal x)","hypotheses":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (f : Clight.function) (x : function) (EQ : transl_function (prog_comp_env p) f = OK x)","proofString":"constructor; auto."},{"statement":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (e : external_function) (l : list type) (t : type) (c : calling_convention) (tf : fundef) (H0 : (if signature_eq (ef_sig e) (signature_of_type l t c)\n then OK (AST.External e)\n else Error (msg \"Cshmgen.transl_fundef: wrong external signature\")) = \nOK tf) : match_fundef p (External e l t c) tf.","conclusion":"match_fundef p (External e l t c) tf","hypotheses":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (e : external_function) (l : list type) (t : type) (c : calling_convention) (tf : fundef) (H0 : (if signature_eq (ef_sig e) (signature_of_type l t c)\n then OK (AST.External e)\n else Error (msg \"Cshmgen.transl_fundef: wrong external signature\")) = \nOK tf)","proofString":"destruct signature_eq; inv H0.\nconstructor; auto."},{"statement":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (e : external_function) (l : list type) (t : type) (c : calling_convention) (e0 : ef_sig e = signature_of_type l t c) : match_fundef p (External e l t c) (AST.External e).","conclusion":"match_fundef p (External e l t c) (AST.External e)","hypotheses":"(p : Clight.program) (tp : program) (H : transform_partial_program2 (transl_fundef (prog_comp_env p)) transl_globvar p =\nOK tp) (i : ident) (e : external_function) (l : list type) (t : type) (c : calling_convention) (e0 : ef_sig e = signature_of_type l t c)","proofString":"constructor; auto."},{"statement":"(ce : Clight.program) (f : Clight.fundef) (tf : fundef) (args : list type) (res : type) (cc : calling_convention) (H : match_fundef ce f tf) (H0 : classify_fun (type_of_fundef f) = fun_case_f args res cc) : funsig tf = signature_of_type args res cc.","conclusion":"funsig tf = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (f : Clight.fundef) (tf : fundef) (args : list type) (res : type) (cc : calling_convention) (H : match_fundef ce f tf) (H0 : classify_fun (type_of_fundef f) = fun_case_f args res cc)","proofString":"inv H.\nmonadInv H1.\nsimpl.\ninversion H0.\nreflexivity.\nsimpl in H0.\nunfold funsig.\ncongruence."},{"statement":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (tf0 : function) (H1 : transl_function (prog_comp_env ce) f0 = OK tf0) : funsig (AST.Internal tf0) = signature_of_type args res cc.","conclusion":"funsig (AST.Internal tf0) = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (tf0 : function) (H1 : transl_function (prog_comp_env ce) f0 = OK tf0)","proofString":"monadInv H1.\nsimpl.\ninversion H0.\nreflexivity."},{"statement":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (x : stmt) (EQ : transl_statement (prog_comp_env ce) (fn_return f0) 1 0 (Clight.fn_body f0) =\nOK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env ce)) (Clight.fn_vars f0) = OK x0) : funsig\n  (AST.Internal\n     {|\n       fn_sig := signature_of_function f0;\n       fn_params := map fst (Clight.fn_params f0);\n       fn_vars := x0;\n       fn_temps := map fst (Clight.fn_temps f0);\n       fn_body := x\n     |}) = signature_of_type args res cc.","conclusion":"funsig\n  (AST.Internal\n     {|\n       fn_sig := signature_of_function f0;\n       fn_params := map fst (Clight.fn_params f0);\n       fn_vars := x0;\n       fn_temps := map fst (Clight.fn_temps f0);\n       fn_body := x\n     |}) = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (x : stmt) (EQ : transl_statement (prog_comp_env ce) (fn_return f0) 1 0 (Clight.fn_body f0) =\nOK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env ce)) (Clight.fn_vars f0) = OK x0)","proofString":"simpl.\ninversion H0.\nreflexivity."},{"statement":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (x : stmt) (EQ : transl_statement (prog_comp_env ce) (fn_return f0) 1 0 (Clight.fn_body f0) =\nOK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env ce)) (Clight.fn_vars f0) = OK x0) : signature_of_function f0 = signature_of_type args res cc.","conclusion":"signature_of_function f0 = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (x : stmt) (EQ : transl_statement (prog_comp_env ce) (fn_return f0) 1 0 (Clight.fn_body f0) =\nOK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env ce)) (Clight.fn_vars f0) = OK x0)","proofString":"inversion H0.\nreflexivity."},{"statement":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (x : stmt) (EQ : transl_statement (prog_comp_env ce) (fn_return f0) 1 0 (Clight.fn_body f0) =\nOK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env ce)) (Clight.fn_vars f0) = OK x0) (H1 : type_of_params (Clight.fn_params f0) = args) (H2 : fn_return f0 = res) (H3 : fn_callconv f0 = cc) : signature_of_function f0 =\nsignature_of_type (type_of_params (Clight.fn_params f0)) \n  (fn_return f0) (fn_callconv f0).","conclusion":"signature_of_function f0 =\nsignature_of_type (type_of_params (Clight.fn_params f0)) \n  (fn_return f0) (fn_callconv f0)","hypotheses":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (f0 : Clight.function) (H0 : classify_fun (type_of_fundef (Internal f0)) = fun_case_f args res cc) (x : stmt) (EQ : transl_statement (prog_comp_env ce) (fn_return f0) 1 0 (Clight.fn_body f0) =\nOK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env ce)) (Clight.fn_vars f0) = OK x0) (H1 : type_of_params (Clight.fn_params f0) = args) (H2 : fn_return f0 = res) (H3 : fn_callconv f0 = cc)","proofString":"reflexivity."},{"statement":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (ef : external_function) (args0 : list type) (res0 : type) (cc0 : calling_convention) (H0 : classify_fun (type_of_fundef (External ef args0 res0 cc0)) =\nfun_case_f args res cc) (H1 : ef_sig ef = signature_of_type args0 res0 cc0) : funsig (AST.External ef) = signature_of_type args res cc.","conclusion":"funsig (AST.External ef) = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (ef : external_function) (args0 : list type) (res0 : type) (cc0 : calling_convention) (H0 : classify_fun (type_of_fundef (External ef args0 res0 cc0)) =\nfun_case_f args res cc) (H1 : ef_sig ef = signature_of_type args0 res0 cc0)","proofString":"simpl in H0.\nunfold funsig.\ncongruence."},{"statement":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (ef : external_function) (args0 : list type) (res0 : type) (cc0 : calling_convention) (H0 : fun_case_f args0 res0 cc0 = fun_case_f args res cc) (H1 : ef_sig ef = signature_of_type args0 res0 cc0) : funsig (AST.External ef) = signature_of_type args res cc.","conclusion":"funsig (AST.External ef) = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (ef : external_function) (args0 : list type) (res0 : type) (cc0 : calling_convention) (H0 : fun_case_f args0 res0 cc0 = fun_case_f args res cc) (H1 : ef_sig ef = signature_of_type args0 res0 cc0)","proofString":"unfold funsig.\ncongruence."},{"statement":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (ef : external_function) (args0 : list type) (res0 : type) (cc0 : calling_convention) (H0 : fun_case_f args0 res0 cc0 = fun_case_f args res cc) (H1 : ef_sig ef = signature_of_type args0 res0 cc0) : ef_sig ef = signature_of_type args res cc.","conclusion":"ef_sig ef = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (args : list type) (res : type) (cc : calling_convention) (ef : external_function) (args0 : list type) (res0 : type) (cc0 : calling_convention) (H0 : fun_case_f args0 res0 cc0 = fun_case_f args res cc) (H1 : ef_sig ef = signature_of_type args0 res0 cc0)","proofString":"congruence."},{"statement":"(ce : Clight.program) (f : Clight.fundef) (tf : fundef) (args : list type) (res : type) (cc : calling_convention) (H : match_fundef ce f tf) (H0 : type_of_fundef f = Tfunction args res cc) : funsig tf = signature_of_type args res cc.","conclusion":"funsig tf = signature_of_type args res cc","hypotheses":"(ce : Clight.program) (f : Clight.fundef) (tf : fundef) (args : list type) (res : type) (cc : calling_convention) (H : match_fundef ce f tf) (H0 : type_of_fundef f = Tfunction args res cc)","proofString":"eapply transl_fundef_sig1; eauto.\nrewrite H0; reflexivity."},{"statement":"(ce : Clight.program) (f : Clight.fundef) (tf : fundef) (args : list type) (res : type) (cc : calling_convention) (H : match_fundef ce f tf) (H0 : type_of_fundef f = Tfunction args res cc) : classify_fun (type_of_fundef f) = fun_case_f args res cc.","conclusion":"classify_fun (type_of_fundef f) = fun_case_f args res cc","hypotheses":"(ce : Clight.program) (f : Clight.fundef) (tf : fundef) (args : list type) (res : type) (cc : calling_convention) (H : match_fundef ce f tf) (H0 : type_of_fundef f = Tfunction args res cc)","proofString":"rewrite H0; reflexivity."},{"statement":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H0 : sizeof (prog_comp_env cunit) t = OK sz) : sz = Ctypes.sizeof (prog_comp_env prog) t.","conclusion":"sz = Ctypes.sizeof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H0 : sizeof (prog_comp_env cunit) t = OK sz)","proofString":"destruct H.\nunfold sizeof in H0.\ndestruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsymmetry.\napply Ctypes.sizeof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : sizeof (prog_comp_env cunit) t = OK sz) : sz = Ctypes.sizeof (prog_comp_env prog) t.","conclusion":"sz = Ctypes.sizeof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : sizeof (prog_comp_env cunit) t = OK sz)","proofString":"unfold sizeof in H0.\ndestruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsymmetry.\napply Ctypes.sizeof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : (if complete_type (prog_comp_env cunit) t\n then OK (Ctypes.sizeof (prog_comp_env cunit) t)\n else Error (msg \"incomplete type\")) = OK sz) : sz = Ctypes.sizeof (prog_comp_env prog) t.","conclusion":"sz = Ctypes.sizeof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : (if complete_type (prog_comp_env cunit) t\n then OK (Ctypes.sizeof (prog_comp_env cunit) t)\n else Error (msg \"incomplete type\")) = OK sz)","proofString":"destruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsymmetry.\napply Ctypes.sizeof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : Ctypes.sizeof (prog_comp_env cunit) t = Ctypes.sizeof (prog_comp_env prog) t.","conclusion":"Ctypes.sizeof (prog_comp_env cunit) t = Ctypes.sizeof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"symmetry.\napply Ctypes.sizeof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : Ctypes.sizeof (prog_comp_env prog) t = Ctypes.sizeof (prog_comp_env cunit) t.","conclusion":"Ctypes.sizeof (prog_comp_env prog) t = Ctypes.sizeof (prog_comp_env cunit) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"apply Ctypes.sizeof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (al : Z) (H : linkorder cunit prog) (H0 : alignof (prog_comp_env cunit) t = OK al) : al = Ctypes.alignof (prog_comp_env prog) t.","conclusion":"al = Ctypes.alignof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (al : Z) (H : linkorder cunit prog) (H0 : alignof (prog_comp_env cunit) t = OK al)","proofString":"destruct H.\nunfold alignof in H0.\ndestruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsymmetry.\napply Ctypes.alignof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (al : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : alignof (prog_comp_env cunit) t = OK al) : al = Ctypes.alignof (prog_comp_env prog) t.","conclusion":"al = Ctypes.alignof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (al : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : alignof (prog_comp_env cunit) t = OK al)","proofString":"unfold alignof in H0.\ndestruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsymmetry.\napply Ctypes.alignof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (al : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : (if complete_type (prog_comp_env cunit) t\n then OK (Ctypes.alignof (prog_comp_env cunit) t)\n else Error (msg \"incomplete type\")) = OK al) : al = Ctypes.alignof (prog_comp_env prog) t.","conclusion":"al = Ctypes.alignof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (al : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : (if complete_type (prog_comp_env cunit) t\n then OK (Ctypes.alignof (prog_comp_env cunit) t)\n else Error (msg \"incomplete type\")) = OK al)","proofString":"destruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsymmetry.\napply Ctypes.alignof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : Ctypes.alignof (prog_comp_env cunit) t =\nCtypes.alignof (prog_comp_env prog) t.","conclusion":"Ctypes.alignof (prog_comp_env cunit) t =\nCtypes.alignof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"symmetry.\napply Ctypes.alignof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : Ctypes.alignof (prog_comp_env prog) t =\nCtypes.alignof (prog_comp_env cunit) t.","conclusion":"Ctypes.alignof (prog_comp_env prog) t =\nCtypes.alignof (prog_comp_env cunit) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"apply Ctypes.alignof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H0 : sizeof (prog_comp_env cunit) t = OK sz) : sz = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t.","conclusion":"sz = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H0 : sizeof (prog_comp_env cunit) t = OK sz)","proofString":"destruct H.\nunfold sizeof in H0.\ndestruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsplit.\nsymmetry.\napply Ctypes.sizeof_stable; auto.\nrevert C.\ninduction t; simpl; auto;  destruct (prog_comp_env cunit)!i as [co|] eqn:X; try discriminate; erewrite H1 by eauto; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : sizeof (prog_comp_env cunit) t = OK sz) : sz = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t.","conclusion":"sz = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : sizeof (prog_comp_env cunit) t = OK sz)","proofString":"unfold sizeof in H0.\ndestruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsplit.\nsymmetry.\napply Ctypes.sizeof_stable; auto.\nrevert C.\ninduction t; simpl; auto;  destruct (prog_comp_env cunit)!i as [co|] eqn:X; try discriminate; erewrite H1 by eauto; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : (if complete_type (prog_comp_env cunit) t\n then OK (Ctypes.sizeof (prog_comp_env cunit) t)\n else Error (msg \"incomplete type\")) = OK sz) : sz = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t.","conclusion":"sz = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (sz : Z) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (H0 : (if complete_type (prog_comp_env cunit) t\n then OK (Ctypes.sizeof (prog_comp_env cunit) t)\n else Error (msg \"incomplete type\")) = OK sz)","proofString":"destruct (complete_type (prog_comp_env cunit) t) eqn:C; inv H0.\nsplit.\nsymmetry.\napply Ctypes.sizeof_stable; auto.\nrevert C.\ninduction t; simpl; auto;  destruct (prog_comp_env cunit)!i as [co|] eqn:X; try discriminate; erewrite H1 by eauto; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : Ctypes.sizeof (prog_comp_env cunit) t = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t.","conclusion":"Ctypes.sizeof (prog_comp_env cunit) t = Ctypes.sizeof (prog_comp_env prog) t /\\\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"split.\nsymmetry.\napply Ctypes.sizeof_stable; auto.\nrevert C.\ninduction t; simpl; auto;  destruct (prog_comp_env cunit)!i as [co|] eqn:X; try discriminate; erewrite H1 by eauto; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : Ctypes.sizeof (prog_comp_env cunit) t = Ctypes.sizeof (prog_comp_env prog) t.","conclusion":"Ctypes.sizeof (prog_comp_env cunit) t = Ctypes.sizeof (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"symmetry.\napply Ctypes.sizeof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : Ctypes.sizeof (prog_comp_env prog) t = Ctypes.sizeof (prog_comp_env cunit) t.","conclusion":"Ctypes.sizeof (prog_comp_env prog) t = Ctypes.sizeof (prog_comp_env cunit) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"apply Ctypes.sizeof_stable; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true) : alignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t.","conclusion":"alignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) (C : complete_type (prog_comp_env cunit) t = true)","proofString":"revert C.\ninduction t; simpl; auto;  destruct (prog_comp_env cunit)!i as [co|] eqn:X; try discriminate; erewrite H1 by eauto; auto."},{"statement":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co) : complete_type (prog_comp_env cunit) t = true ->\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t.","conclusion":"complete_type (prog_comp_env cunit) t = true ->\nalignof_blockcopy (prog_comp_env cunit) t =\nalignof_blockcopy (prog_comp_env prog) t","hypotheses":"(cunit prog : Clight.program) (t : type) (H : linkorder cunit prog) (H1 : forall (id : positive) (co : composite),\n(prog_comp_env cunit) ! id = Some co -> (prog_comp_env prog) ! id = Some co)","proofString":"induction t; simpl; auto;  destruct (prog_comp_env cunit)!i as [co|] eqn:X; try discriminate; erewrite H1 by eauto; auto."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) : (prog_comp_env prog) ! id = Some co /\\\nunion_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co).","conclusion":"(prog_comp_env prog) ! id = Some co /\\\nunion_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co)","proofString":"assert (C: composite_consistent cunit.(prog_comp_env) co).\napply build_composite_env_consistent with cunit.(prog_types) id; auto.\napply prog_comp_env_eq.\ndestruct H as [_ A].\nsplit.\nauto.\napply Ctypes.union_field_offset_stable; eauto using co_consistent_complete."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) : composite_consistent (prog_comp_env cunit) co.","conclusion":"composite_consistent (prog_comp_env cunit) co","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co)","proofString":"apply build_composite_env_consistent with cunit.(prog_types) id; auto.\napply prog_comp_env_eq."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) : build_composite_env (prog_types cunit) = OK (prog_comp_env cunit).","conclusion":"build_composite_env (prog_types cunit) = OK (prog_comp_env cunit)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co)","proofString":"apply prog_comp_env_eq."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : (prog_comp_env prog) ! id = Some co /\\\nunion_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co).","conclusion":"(prog_comp_env prog) ! id = Some co /\\\nunion_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"destruct H as [_ A].\nsplit.\nauto.\napply Ctypes.union_field_offset_stable; eauto using co_consistent_complete."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : (prog_comp_env prog) ! id = Some co /\\\nunion_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co).","conclusion":"(prog_comp_env prog) ! id = Some co /\\\nunion_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"split.\nauto.\napply Ctypes.union_field_offset_stable; eauto using co_consistent_complete."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : (prog_comp_env prog) ! id = Some co.","conclusion":"(prog_comp_env prog) ! id = Some co","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"auto."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : union_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co).","conclusion":"union_field_offset (prog_comp_env prog) f (co_members co) =\nunion_field_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"apply Ctypes.union_field_offset_stable; eauto using co_consistent_complete."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) : (prog_comp_env prog) ! id = Some co /\\\nfield_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co).","conclusion":"(prog_comp_env prog) ! id = Some co /\\\nfield_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co)","proofString":"assert (C: composite_consistent cunit.(prog_comp_env) co).\napply build_composite_env_consistent with cunit.(prog_types) id; auto.\napply prog_comp_env_eq.\ndestruct H as [_ A].\nsplit.\nauto.\napply Ctypes.field_offset_stable; eauto using co_consistent_complete."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) : composite_consistent (prog_comp_env cunit) co.","conclusion":"composite_consistent (prog_comp_env cunit) co","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co)","proofString":"apply build_composite_env_consistent with cunit.(prog_types) id; auto.\napply prog_comp_env_eq."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) : build_composite_env (prog_types cunit) = OK (prog_comp_env cunit).","conclusion":"build_composite_env (prog_types cunit) = OK (prog_comp_env cunit)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co)","proofString":"apply prog_comp_env_eq."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : (prog_comp_env prog) ! id = Some co /\\\nfield_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co).","conclusion":"(prog_comp_env prog) ! id = Some co /\\\nfield_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (H : linkorder cunit prog) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"destruct H as [_ A].\nsplit.\nauto.\napply Ctypes.field_offset_stable; eauto using co_consistent_complete."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : (prog_comp_env prog) ! id = Some co /\\\nfield_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co).","conclusion":"(prog_comp_env prog) ! id = Some co /\\\nfield_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"split.\nauto.\napply Ctypes.field_offset_stable; eauto using co_consistent_complete."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : (prog_comp_env prog) ! id = Some co.","conclusion":"(prog_comp_env prog) ! id = Some co","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"auto."},{"statement":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co) : field_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co).","conclusion":"field_offset (prog_comp_env prog) f (co_members co) =\nfield_offset (prog_comp_env cunit) f (co_members co)","hypotheses":"(cunit prog : Clight.program) (id : positive) (co : composite) (f : ident) (A : forall (id0 : positive) (co0 : composite),\n(prog_comp_env cunit) ! id0 = Some co0 ->\n(prog_comp_env prog) ! id0 = Some co0) (H0 : (prog_comp_env cunit) ! id = Some co) (C : composite_consistent (prog_comp_env cunit) co)","proofString":"apply Ctypes.field_offset_stable; eauto using co_consistent_complete."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl).","conclusion":"forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z)","proofString":"assert (DFL: forall sl tsl,    transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->    transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) = OK (select_switch_default tsl)).\ninduction sl; simpl; intros.\ninv H; auto.\nmonadInv H.\nsimpl.\ndestruct o; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto.\nassert (CASE: forall sl tsl,    transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->    match Clight.select_switch_case n sl with    | None =>        select_switch_case n tsl = None    | Some sl' =>        exists tsl',           select_switch_case n tsl = Some tsl'        /\\ transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'    end).\ninduction sl; simpl; intros.\ninv H; auto.\nmonadInv H; simpl.\ndestruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto.\napply IHsl; auto.\napply IHsl; auto.\nintros.\nspecialize (CASE _ _ H).\nunfold Clight.select_switch, select_switch.\ndestruct (Clight.select_switch_case n sl) as [sl'|].\ndestruct CASE as [tsl' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl).","conclusion":"forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z)","proofString":"induction sl; simpl; intros.\ninv H; auto.\nmonadInv H.\nsimpl.\ndestruct o; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (tsl : lbl_stmt) (H : OK LSnil = OK tsl) : OK LSnil = OK (select_switch_default tsl).","conclusion":"OK LSnil = OK (select_switch_default tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (tsl : lbl_stmt) (H : OK LSnil = OK tsl)","proofString":"inv H; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl0 : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl0)) (tsl : lbl_stmt) (H : bind (transl_statement ce tyret nbrk ncnt s)\n  (fun ts : stmt =>\n   bind (transl_lbl_stmt ce tyret nbrk ncnt sl)\n     (fun tsl' : lbl_stmt => OK (LScons o ts tsl'))) = \nOK tsl) : transl_lbl_stmt ce tyret nbrk ncnt\n  match o with\n  | Some _ => Clight.select_switch_default sl\n  | None => Clight.LScons o s sl\n  end = OK (select_switch_default tsl).","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt\n  match o with\n  | Some _ => Clight.select_switch_default sl\n  | None => Clight.LScons o s sl\n  end = OK (select_switch_default tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl0 : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl0)) (tsl : lbl_stmt) (H : bind (transl_statement ce tyret nbrk ncnt s)\n  (fun ts : stmt =>\n   bind (transl_lbl_stmt ce tyret nbrk ncnt sl)\n     (fun tsl' : lbl_stmt => OK (LScons o ts tsl'))) = \nOK tsl)","proofString":"monadInv H.\nsimpl.\ndestruct o; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : transl_lbl_stmt ce tyret nbrk ncnt\n  match o with\n  | Some _ => Clight.select_switch_default sl\n  | None => Clight.LScons o s sl\n  end = OK (select_switch_default (LScons o x x0)).","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt\n  match o with\n  | Some _ => Clight.select_switch_default sl\n  | None => Clight.LScons o s sl\n  end = OK (select_switch_default (LScons o x x0))","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"simpl.\ndestruct o; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : transl_lbl_stmt ce tyret nbrk ncnt\n  match o with\n  | Some _ => Clight.select_switch_default sl\n  | None => Clight.LScons o s sl\n  end =\nOK\n  match o with\n  | Some _ => select_switch_default x0\n  | None => LScons o x x0\n  end.","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt\n  match o with\n  | Some _ => Clight.select_switch_default sl\n  | None => Clight.LScons o s sl\n  end =\nOK\n  match o with\n  | Some _ => select_switch_default x0\n  | None => LScons o x x0\n  end","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"destruct o; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons None s sl) =\nOK (LScons None x x0).","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons None s sl) =\nOK (LScons None x x0)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"simpl; rewrite EQ; simpl; rewrite EQ1; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl).","conclusion":"forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl))","proofString":"assert (CASE: forall sl tsl,    transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->    match Clight.select_switch_case n sl with    | None =>        select_switch_case n tsl = None    | Some sl' =>        exists tsl',           select_switch_case n tsl = Some tsl'        /\\ transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'    end).\ninduction sl; simpl; intros.\ninv H; auto.\nmonadInv H; simpl.\ndestruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto.\napply IHsl; auto.\napply IHsl; auto.\nintros.\nspecialize (CASE _ _ H).\nunfold Clight.select_switch, select_switch.\ndestruct (Clight.select_switch_case n sl) as [sl'|].\ndestruct CASE as [tsl' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend.","conclusion":"forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl))","proofString":"induction sl; simpl; intros.\ninv H; auto.\nmonadInv H; simpl.\ndestruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto.\napply IHsl; auto.\napply IHsl; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl0)) (tsl : lbl_stmt) (H : OK LSnil = OK tsl) : select_switch_case n tsl = None.","conclusion":"select_switch_case n tsl = None","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl0)) (tsl : lbl_stmt) (H : OK LSnil = OK tsl)","proofString":"inv H; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl0 : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl0 = None\nend) (tsl : lbl_stmt) (H : bind (transl_statement ce tyret nbrk ncnt s)\n  (fun ts : stmt =>\n   bind (transl_lbl_stmt ce tyret nbrk ncnt sl)\n     (fun tsl' : lbl_stmt => OK (LScons o ts tsl'))) = \nOK tsl) : match\n  match o with\n  | Some c =>\n      if zeq c n\n      then Some (Clight.LScons o s sl)\n      else Clight.select_switch_case n sl\n  | None => Clight.select_switch_case n sl\n  end\nwith\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend.","conclusion":"match\n  match o with\n  | Some c =>\n      if zeq c n\n      then Some (Clight.LScons o s sl)\n      else Clight.select_switch_case n sl\n  | None => Clight.select_switch_case n sl\n  end\nwith\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl0 : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl0 = None\nend) (tsl : lbl_stmt) (H : bind (transl_statement ce tyret nbrk ncnt s)\n  (fun ts : stmt =>\n   bind (transl_lbl_stmt ce tyret nbrk ncnt sl)\n     (fun tsl' : lbl_stmt => OK (LScons o ts tsl'))) = \nOK tsl)","proofString":"monadInv H; simpl.\ndestruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto.\napply IHsl; auto.\napply IHsl; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : match\n  match o with\n  | Some c =>\n      if zeq c n\n      then Some (Clight.LScons o s sl)\n      else Clight.select_switch_case n sl\n  | None => Clight.select_switch_case n sl\n  end\nwith\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      match o with\n      | Some c =>\n          if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n      | None => select_switch_case n x0\n      end = Some tsl' /\\ transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None =>\n    match o with\n    | Some c =>\n        if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n    | None => select_switch_case n x0\n    end = None\nend.","conclusion":"match\n  match o with\n  | Some c =>\n      if zeq c n\n      then Some (Clight.LScons o s sl)\n      else Clight.select_switch_case n sl\n  | None => Clight.select_switch_case n sl\n  end\nwith\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      match o with\n      | Some c =>\n          if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n      | None => select_switch_case n x0\n      end = Some tsl' /\\ transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None =>\n    match o with\n    | Some c =>\n        if zeq c n then Some (LScons o x x0) else select_switch_case n x0\n    | None => select_switch_case n x0\n    end = None\nend","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"destruct o.\ndestruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto.\napply IHsl; auto.\napply IHsl; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : match\n  (if zeq z n\n   then Some (Clight.LScons (Some z) s sl)\n   else Clight.select_switch_case n sl)\nwith\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      (if zeq z n\n       then Some (LScons (Some z) x x0)\n       else select_switch_case n x0) = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None =>\n    (if zeq z n then Some (LScons (Some z) x x0) else select_switch_case n x0) =\n    None\nend.","conclusion":"match\n  (if zeq z n\n   then Some (Clight.LScons (Some z) s sl)\n   else Clight.select_switch_case n sl)\nwith\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      (if zeq z n\n       then Some (LScons (Some z) x x0)\n       else select_switch_case n x0) = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None =>\n    (if zeq z n then Some (LScons (Some z) x x0) else select_switch_case n x0) =\n    None\nend","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"destruct (zeq z n).\neconstructor; split; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto.\napply IHsl; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) (e : z = n) : exists tsl' : lbl_stmt,\n  Some (LScons (Some z) x x0) = Some tsl' /\\\n  transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons (Some z) s sl) = OK tsl'.","conclusion":"exists tsl' : lbl_stmt,\n  Some (LScons (Some z) x x0) = Some tsl' /\\\n  transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons (Some z) s sl) = OK tsl'","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) (e : z = n)","proofString":"econstructor; split; eauto.\nsimpl; rewrite EQ; simpl; rewrite EQ1; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) (e : z = n) : transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons (Some z) s sl) =\nOK (LScons (Some z) x x0).","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons (Some z) s sl) =\nOK (LScons (Some z) x x0)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) (e : z = n)","proofString":"simpl; rewrite EQ; simpl; rewrite EQ1; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) (n0 : z <> n) : match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n x0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n x0 = None\nend.","conclusion":"match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n x0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n x0 = None\nend","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (z : Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) (n0 : z <> n)","proofString":"apply IHsl; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n x0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n x0 = None\nend.","conclusion":"match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n x0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n x0 = None\nend","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl)) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"apply IHsl; auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (CASE : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl).","conclusion":"forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)) (CASE : forall (sl : labeled_statements) (tsl : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\nmatch Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend)","proofString":"intros.\nspecialize (CASE _ _ H).\nunfold Clight.select_switch, select_switch.\ndestruct (Clight.select_switch_case n sl) as [sl'|].\ndestruct CASE as [tsl' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (CASE : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\nmatch Clight.select_switch_case n sl0 with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl0 = None\nend) (sl : labeled_statements) (tsl : lbl_stmt) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl).","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (CASE : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\nmatch Clight.select_switch_case n sl0 with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl0 = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl0 = None\nend) (sl : labeled_statements) (tsl : lbl_stmt) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"specialize (CASE _ _ H).\nunfold Clight.select_switch, select_switch.\ndestruct (Clight.select_switch_case n sl) as [sl'|].\ndestruct CASE as [tsl' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl).","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch n sl) =\nOK (select_switch n tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"unfold Clight.select_switch, select_switch.\ndestruct (Clight.select_switch_case n sl) as [sl'|].\ndestruct CASE as [tsl' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : transl_lbl_stmt ce tyret nbrk ncnt\n  match Clight.select_switch_case n sl with\n  | Some sl' => sl'\n  | None => Clight.select_switch_default sl\n  end =\nOK\n  match select_switch_case n tsl with\n  | Some sl' => sl'\n  | None => select_switch_default tsl\n  end.","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt\n  match Clight.select_switch_case n sl with\n  | Some sl' => sl'\n  | None => Clight.select_switch_default sl\n  end =\nOK\n  match select_switch_case n tsl with\n  | Some sl' => sl'\n  | None => select_switch_default tsl\n  end","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : match Clight.select_switch_case n sl with\n| Some sl' =>\n    exists tsl' : lbl_stmt,\n      select_switch_case n tsl = Some tsl' /\\\n      transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl'\n| None => select_switch_case n tsl = None\nend) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"destruct (Clight.select_switch_case n sl) as [sl'|].\ndestruct CASE as [tsl' [P Q]].\nrewrite P, Q.\nauto.\nrewrite CASE.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (sl' : labeled_statements) (CASE : exists tsl' : lbl_stmt,\n  select_switch_case n tsl = Some tsl' /\\\n  transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl') (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : transl_lbl_stmt ce tyret nbrk ncnt sl' =\nOK\n  match select_switch_case n tsl with\n  | Some sl'0 => sl'0\n  | None => select_switch_default tsl\n  end.","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt sl' =\nOK\n  match select_switch_case n tsl with\n  | Some sl'0 => sl'0\n  | None => select_switch_default tsl\n  end","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (sl' : labeled_statements) (CASE : exists tsl' : lbl_stmt,\n  select_switch_case n tsl = Some tsl' /\\\n  transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl') (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"destruct CASE as [tsl' [P Q]].\nrewrite P, Q.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (sl' : labeled_statements) (tsl' : lbl_stmt) (P : select_switch_case n tsl = Some tsl') (Q : transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl') (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : transl_lbl_stmt ce tyret nbrk ncnt sl' =\nOK\n  match select_switch_case n tsl with\n  | Some sl'0 => sl'0\n  | None => select_switch_default tsl\n  end.","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt sl' =\nOK\n  match select_switch_case n tsl with\n  | Some sl'0 => sl'0\n  | None => select_switch_default tsl\n  end","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (sl' : labeled_statements) (tsl' : lbl_stmt) (P : select_switch_case n tsl = Some tsl') (Q : transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl') (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"rewrite P, Q.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (sl' : labeled_statements) (tsl' : lbl_stmt) (P : select_switch_case n tsl = Some tsl') (Q : transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl') (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : OK tsl' = OK tsl'.","conclusion":"OK tsl' = OK tsl'","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (sl' : labeled_statements) (tsl' : lbl_stmt) (P : select_switch_case n tsl = Some tsl') (Q : transl_lbl_stmt ce tyret nbrk ncnt sl' = OK tsl') (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : select_switch_case n tsl = None) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK\n  match select_switch_case n tsl with\n  | Some sl' => sl'\n  | None => select_switch_default tsl\n  end.","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK\n  match select_switch_case n tsl with\n  | Some sl' => sl'\n  | None => select_switch_default tsl\n  end","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : select_switch_case n tsl = None) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"rewrite CASE.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : select_switch_case n tsl = None) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl) : transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl).","conclusion":"transl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl) =\nOK (select_switch_default tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (n : Z) (DFL : forall (sl0 : labeled_statements) (tsl0 : lbl_stmt),\ntransl_lbl_stmt ce tyret nbrk ncnt sl0 = OK tsl0 ->\ntransl_lbl_stmt ce tyret nbrk ncnt (Clight.select_switch_default sl0) =\nOK (select_switch_default tsl0)) (sl : labeled_statements) (tsl : lbl_stmt) (CASE : select_switch_case n tsl = None) (H : transl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl)","proofString":"auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (tsl : lbl_stmt) (H : transl_lbl_stmt ce tyret nbrk ncnt Clight.LSnil = OK tsl) : transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement Clight.LSnil) =\nOK (seq_of_lbl_stmt tsl).","conclusion":"transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement Clight.LSnil) =\nOK (seq_of_lbl_stmt tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (tsl : lbl_stmt) (H : transl_lbl_stmt ce tyret nbrk ncnt Clight.LSnil = OK tsl)","proofString":"monadInv H.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) : transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement Clight.LSnil) =\nOK (seq_of_lbl_stmt LSnil).","conclusion":"transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement Clight.LSnil) =\nOK (seq_of_lbl_stmt LSnil)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat)","proofString":"auto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl0 : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl0)) (tsl : lbl_stmt) (H : transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons o s sl) = OK tsl) : transl_statement ce tyret nbrk ncnt\n  (seq_of_labeled_statement (Clight.LScons o s sl)) =\nOK (seq_of_lbl_stmt tsl).","conclusion":"transl_statement ce tyret nbrk ncnt\n  (seq_of_labeled_statement (Clight.LScons o s sl)) =\nOK (seq_of_lbl_stmt tsl)","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl0 : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl0 ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl0)) (tsl : lbl_stmt) (H : transl_lbl_stmt ce tyret nbrk ncnt (Clight.LScons o s sl) = OK tsl)","proofString":"monadInv H.\nsimpl.\nrewrite EQ; simpl.\nrewrite (IHsl _ EQ1).\nsimpl.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : transl_statement ce tyret nbrk ncnt\n  (seq_of_labeled_statement (Clight.LScons o s sl)) =\nOK (seq_of_lbl_stmt (LScons o x x0)).","conclusion":"transl_statement ce tyret nbrk ncnt\n  (seq_of_labeled_statement (Clight.LScons o s sl)) =\nOK (seq_of_lbl_stmt (LScons o x x0))","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"simpl.\nrewrite EQ; simpl.\nrewrite (IHsl _ EQ1).\nsimpl.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : bind (transl_statement ce tyret nbrk ncnt s)\n  (fun ts1 : stmt =>\n   bind (transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl))\n     (fun ts2 : stmt => OK (Sseq ts1 ts2))) =\nOK (Sseq x (seq_of_lbl_stmt x0)).","conclusion":"bind (transl_statement ce tyret nbrk ncnt s)\n  (fun ts1 : stmt =>\n   bind (transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl))\n     (fun ts2 : stmt => OK (Sseq ts1 ts2))) =\nOK (Sseq x (seq_of_lbl_stmt x0))","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"rewrite EQ; simpl.\nrewrite (IHsl _ EQ1).\nsimpl.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : bind (transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl))\n  (fun ts2 : stmt => OK (Sseq x ts2)) = OK (Sseq x (seq_of_lbl_stmt x0)).","conclusion":"bind (transl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl))\n  (fun ts2 : stmt => OK (Sseq x ts2)) = OK (Sseq x (seq_of_lbl_stmt x0))","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"rewrite (IHsl _ EQ1).\nsimpl.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : bind (OK (seq_of_lbl_stmt x0)) (fun ts2 : stmt => OK (Sseq x ts2)) =\nOK (Sseq x (seq_of_lbl_stmt x0)).","conclusion":"bind (OK (seq_of_lbl_stmt x0)) (fun ts2 : stmt => OK (Sseq x ts2)) =\nOK (Sseq x (seq_of_lbl_stmt x0))","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"simpl.\nauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0) : OK (Sseq x (seq_of_lbl_stmt x0)) = OK (Sseq x (seq_of_lbl_stmt x0)).","conclusion":"OK (Sseq x (seq_of_lbl_stmt x0)) = OK (Sseq x (seq_of_lbl_stmt x0))","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (o : option Z) (s : statement) (sl : labeled_statements) (IHsl : forall tsl : lbl_stmt,\ntransl_lbl_stmt ce tyret nbrk ncnt sl = OK tsl ->\ntransl_statement ce tyret nbrk ncnt (seq_of_labeled_statement sl) =\nOK (seq_of_lbl_stmt tsl)) (x : stmt) (EQ : transl_statement ce tyret nbrk ncnt s = OK x) (x0 : lbl_stmt) (EQ1 : transl_lbl_stmt ce tyret nbrk ncnt sl = OK x0)","proofString":"auto."},{"statement":"(n : int) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (make_intconst n) (Vint n).","conclusion":"eval_expr ge e le m (make_intconst n) (Vint n)","hypotheses":"(n : int) (e : env) (le : temp_env) (m : mem)","proofString":"unfold make_intconst.\neconstructor.\nreflexivity."},{"statement":"(n : int) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (Econst (Ointconst n)) (Vint n).","conclusion":"eval_expr ge e le m (Econst (Ointconst n)) (Vint n)","hypotheses":"(n : int) (e : env) (le : temp_env) (m : mem)","proofString":"econstructor.\nreflexivity."},{"statement":"(n : int) (e : env) (le : temp_env) (m : mem) : eval_constant (Ointconst n) = Some (Vint n).","conclusion":"eval_constant (Ointconst n) = Some (Vint n)","hypotheses":"(n : int) (e : env) (le : temp_env) (m : mem)","proofString":"reflexivity."},{"statement":"(n : float) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (make_floatconst n) (Vfloat n).","conclusion":"eval_expr ge e le m (make_floatconst n) (Vfloat n)","hypotheses":"(n : float) (e : env) (le : temp_env) (m : mem)","proofString":"unfold make_floatconst.\neconstructor.\nreflexivity."},{"statement":"(n : float) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (Econst (Ofloatconst n)) (Vfloat n).","conclusion":"eval_expr ge e le m (Econst (Ofloatconst n)) (Vfloat n)","hypotheses":"(n : float) (e : env) (le : temp_env) (m : mem)","proofString":"econstructor.\nreflexivity."},{"statement":"(n : float) (e : env) (le : temp_env) (m : mem) : eval_constant (Ofloatconst n) = Some (Vfloat n).","conclusion":"eval_constant (Ofloatconst n) = Some (Vfloat n)","hypotheses":"(n : float) (e : env) (le : temp_env) (m : mem)","proofString":"reflexivity."},{"statement":"(n : float32) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (make_singleconst n) (Vsingle n).","conclusion":"eval_expr ge e le m (make_singleconst n) (Vsingle n)","hypotheses":"(n : float32) (e : env) (le : temp_env) (m : mem)","proofString":"unfold make_singleconst.\neconstructor.\nreflexivity."},{"statement":"(n : float32) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (Econst (Osingleconst n)) (Vsingle n).","conclusion":"eval_expr ge e le m (Econst (Osingleconst n)) (Vsingle n)","hypotheses":"(n : float32) (e : env) (le : temp_env) (m : mem)","proofString":"econstructor.\nreflexivity."},{"statement":"(n : float32) (e : env) (le : temp_env) (m : mem) : eval_constant (Osingleconst n) = Some (Vsingle n).","conclusion":"eval_constant (Osingleconst n) = Some (Vsingle n)","hypotheses":"(n : float32) (e : env) (le : temp_env) (m : mem)","proofString":"reflexivity."},{"statement":"(n : int64) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (make_longconst n) (Vlong n).","conclusion":"eval_expr ge e le m (make_longconst n) (Vlong n)","hypotheses":"(n : int64) (e : env) (le : temp_env) (m : mem)","proofString":"unfold make_floatconst.\neconstructor.\nreflexivity."},{"statement":"(n : int64) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (make_longconst n) (Vlong n).","conclusion":"eval_expr ge e le m (make_longconst n) (Vlong n)","hypotheses":"(n : int64) (e : env) (le : temp_env) (m : mem)","proofString":"econstructor.\nreflexivity."},{"statement":"(n : int64) (e : env) (le : temp_env) (m : mem) : eval_constant (Olongconst n) = Some (Vlong n).","conclusion":"eval_constant (Olongconst n) = Some (Vlong n)","hypotheses":"(n : int64) (e : env) (le : temp_env) (m : mem)","proofString":"reflexivity."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m (make_ptrofsconst n) (Vptrofs (Ptrofs.repr n)).","conclusion":"eval_expr ge e le m (make_ptrofsconst n) (Vptrofs (Ptrofs.repr n))","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem)","proofString":"unfold Vptrofs, make_ptrofsconst.\ndestruct Archi.ptr64 eqn:SF.\nreplace (Ptrofs.to_int64 (Ptrofs.repr n)) with (Int64.repr n).\napply make_longconst_correct.\nsymmetry; auto with ptrofs.\nreplace (Ptrofs.to_int (Ptrofs.repr n)) with (Int.repr n).\napply make_intconst_correct.\nsymmetry; auto with ptrofs."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) : eval_expr ge e le m\n  (if Archi.ptr64\n   then make_longconst (Int64.repr n)\n   else make_intconst (Int.repr n))\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 (Ptrofs.repr n))\n   else Vint (Ptrofs.to_int (Ptrofs.repr n))).","conclusion":"eval_expr ge e le m\n  (if Archi.ptr64\n   then make_longconst (Int64.repr n)\n   else make_intconst (Int.repr n))\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 (Ptrofs.repr n))\n   else Vint (Ptrofs.to_int (Ptrofs.repr n)))","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem)","proofString":"destruct Archi.ptr64 eqn:SF.\nreplace (Ptrofs.to_int64 (Ptrofs.repr n)) with (Int64.repr n).\napply make_longconst_correct.\nsymmetry; auto with ptrofs.\nreplace (Ptrofs.to_int (Ptrofs.repr n)) with (Int.repr n).\napply make_intconst_correct.\nsymmetry; auto with ptrofs."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) : eval_expr ge e le m (make_longconst (Int64.repr n))\n  (Vlong (Ptrofs.to_int64 (Ptrofs.repr n))).","conclusion":"eval_expr ge e le m (make_longconst (Int64.repr n))\n  (Vlong (Ptrofs.to_int64 (Ptrofs.repr n)))","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true)","proofString":"replace (Ptrofs.to_int64 (Ptrofs.repr n)) with (Int64.repr n).\napply make_longconst_correct.\nsymmetry; auto with ptrofs."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) : eval_expr ge e le m (make_longconst (Int64.repr n)) (Vlong (Int64.repr n)).","conclusion":"eval_expr ge e le m (make_longconst (Int64.repr n)) (Vlong (Int64.repr n))","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true)","proofString":"apply make_longconst_correct."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) : Int64.repr n = Ptrofs.to_int64 (Ptrofs.repr n).","conclusion":"Int64.repr n = Ptrofs.to_int64 (Ptrofs.repr n)","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true)","proofString":"symmetry; auto with ptrofs."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) : eval_expr ge e le m (make_intconst (Int.repr n))\n  (Vint (Ptrofs.to_int (Ptrofs.repr n))).","conclusion":"eval_expr ge e le m (make_intconst (Int.repr n))\n  (Vint (Ptrofs.to_int (Ptrofs.repr n)))","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false)","proofString":"replace (Ptrofs.to_int (Ptrofs.repr n)) with (Int.repr n).\napply make_intconst_correct.\nsymmetry; auto with ptrofs."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) : eval_expr ge e le m (make_intconst (Int.repr n)) (Vint (Int.repr n)).","conclusion":"eval_expr ge e le m (make_intconst (Int.repr n)) (Vint (Int.repr n))","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false)","proofString":"apply make_intconst_correct."},{"statement":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) : Int.repr n = Ptrofs.to_int (Ptrofs.repr n).","conclusion":"Int.repr n = Ptrofs.to_int (Ptrofs.repr n)","hypotheses":"(n : Z) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false)","proofString":"symmetry; auto with ptrofs."},{"statement":"(a : expr) (n : float) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vfloat n)) : eval_expr ge e le m (make_singleoffloat a) (Vsingle (Float.to_single n)).","conclusion":"eval_expr ge e le m (make_singleoffloat a) (Vsingle (Float.to_single n))","hypotheses":"(a : expr) (n : float) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vfloat n))","proofString":"econstructor.\neauto.\nauto."},{"statement":"(a : expr) (n : float32) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vsingle n)) : eval_expr ge e le m (make_floatofsingle a) (Vfloat (Float.of_single n)).","conclusion":"eval_expr ge e le m (make_floatofsingle a) (Vfloat (Float.of_single n))","hypotheses":"(a : expr) (n : float32) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vsingle n))","proofString":"econstructor.\neauto.\nauto."},{"statement":"(a : expr) (n : int) (sg : signedness) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m (make_floatofint a sg) (Vfloat (cast_int_float sg n)).","conclusion":"eval_expr ge e le m (make_floatofint a sg) (Vfloat (cast_int_float sg n))","hypotheses":"(a : expr) (n : int) (sg : signedness) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vint n))","proofString":"unfold make_floatofint, cast_int_float.\ndestruct sg; econstructor; eauto."},{"statement":"(a : expr) (n : int) (sg : signedness) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m\n  match sg with\n  | Signed => Eunop Ofloatofint a\n  | Unsigned => Eunop Ofloatofintu a\n  end\n  (Vfloat\n     match sg with\n     | Signed => Float.of_int n\n     | Unsigned => Float.of_intu n\n     end).","conclusion":"eval_expr ge e le m\n  match sg with\n  | Signed => Eunop Ofloatofint a\n  | Unsigned => Eunop Ofloatofintu a\n  end\n  (Vfloat\n     match sg with\n     | Signed => Float.of_int n\n     | Unsigned => Float.of_intu n\n     end)","hypotheses":"(a : expr) (n : int) (sg : signedness) (e : env) (le : temp_env) (m : mem) (H : eval_expr ge e le m a (Vint n))","proofString":"destruct sg; econstructor; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n))","proofString":"assert (DEFAULT: eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))                                       (Vint (if Int.eq n Int.zero then Int.zero else Int.one))).\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Int.cmpu.\ndestruct (Int.eq n Int.zero); auto.\nassert (CMP: forall ob,               Val.of_optbool ob = Vint n ->               n = (if Int.eq n Int.zero then Int.zero else Int.one)).\nintros.\ndestruct ob; simpl in H0; inv H0.\ndestruct b; inv H2.\nrewrite Int.eq_false.\nauto.\napply Int.one_not_zero.\nrewrite Int.eq_true.\nauto.\ndestruct a; simpl; auto.\ndestruct b; auto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Int.cmpu.\ndestruct (Int.eq n Int.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) : eval_binop (Ocmpu Cne) (Vint n) (Vint Int.zero) m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmpu Cne) (Vint n) (Vint Int.zero) m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n))","proofString":"simpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Int.cmpu.\ndestruct (Int.eq n Int.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) : Some (Val.cmpu (Mem.valid_pointer m) Cne (Vint n) (Vint Int.zero)) =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Val.cmpu (Mem.valid_pointer m) Cne (Vint n) (Vint Int.zero)) =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n))","proofString":"unfold Val.cmpu, Val.cmpu_bool.\nunfold Int.cmpu.\ndestruct (Int.eq n Int.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) : Some (Val.of_optbool (Some (Int.cmpu Cne n Int.zero))) =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Val.of_optbool (Some (Int.cmpu Cne n Int.zero))) =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n))","proofString":"unfold Int.cmpu.\ndestruct (Int.eq n Int.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) : Some (Val.of_optbool (Some (negb (Int.eq n Int.zero)))) =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Val.of_optbool (Some (negb (Int.eq n Int.zero)))) =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n))","proofString":"destruct (Int.eq n Int.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) : eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)))","proofString":"assert (CMP: forall ob,               Val.of_optbool ob = Vint n ->               n = (if Int.eq n Int.zero then Int.zero else Int.one)).\nintros.\ndestruct ob; simpl in H0; inv H0.\ndestruct b; inv H2.\nrewrite Int.eq_false.\nauto.\napply Int.one_not_zero.\nrewrite Int.eq_true.\nauto.\ndestruct a; simpl; auto.\ndestruct b; auto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)))","proofString":"intros.\ndestruct ob; simpl in H0; inv H0.\ndestruct b; inv H2.\nrewrite Int.eq_false.\nauto.\napply Int.one_not_zero.\nrewrite Int.eq_true.\nauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (ob : option bool) (H0 : Val.of_optbool ob = Vint n) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (ob : option bool) (H0 : Val.of_optbool ob = Vint n)","proofString":"destruct ob; simpl in H0; inv H0.\ndestruct b; inv H2.\nrewrite Int.eq_false.\nauto.\napply Int.one_not_zero.\nrewrite Int.eq_true.\nauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (b : bool) (H2 : (if b then Vtrue else Vfalse) = Vint n) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (b : bool) (H2 : (if b then Vtrue else Vfalse) = Vint n)","proofString":"destruct b; inv H2.\nrewrite Int.eq_false.\nauto.\napply Int.one_not_zero.\nrewrite Int.eq_true.\nauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.one Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.one)) : Int.one = (if Int.eq Int.one Int.zero then Int.zero else Int.one).","conclusion":"Int.one = (if Int.eq Int.one Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.one Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.one))","proofString":"rewrite Int.eq_false.\nauto.\napply Int.one_not_zero."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.one Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.one)) : Int.one = Int.one.","conclusion":"Int.one = Int.one","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.one Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.one))","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.one Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.one)) : Int.one <> Int.zero.","conclusion":"Int.one <> Int.zero","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.one Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.one))","proofString":"apply Int.one_not_zero."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.zero Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.zero)) : Int.zero = (if Int.eq Int.zero Int.zero then Int.zero else Int.one).","conclusion":"Int.zero = (if Int.eq Int.zero Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.zero Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.zero))","proofString":"rewrite Int.eq_true.\nauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.zero Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.zero)) : Int.zero = Int.zero.","conclusion":"Int.zero = Int.zero","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq Int.zero Int.zero then Int.zero else Int.one))) (H : eval_expr ge e le m a (Vint Int.zero))","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (H : eval_expr ge e le m a (Vint n)) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"destruct a; simpl; auto.\ndestruct b; auto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (b : binary_operation) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop b a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop b a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m\n  match b with\n  | Ocmp _ | Ocmpu _ | Ocmpf _ | Ocmpfs _ | Ocmpl _ | Ocmplu _ =>\n      Ebinop b a1 a2\n  | _ => Ebinop (Ocmpu Cne) (Ebinop b a1 a2) (make_intconst Int.zero)\n  end (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m\n  match b with\n  | Ocmp _ | Ocmpu _ | Ocmpf _ | Ocmpfs _ | Ocmpl _ | Ocmplu _ =>\n      Ebinop b a1 a2\n  | _ => Ebinop (Ocmpu Cne) (Ebinop b a1 a2) (make_intconst Int.zero)\n  end (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (b : binary_operation) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop b a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop b a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"destruct b; auto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity.\ninv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmp c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m (Ebinop (Ocmp c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmp c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmp c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"inv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n)) : eval_expr ge e le m (Ebinop (Ocmp c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmp c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n))","proofString":"econstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n)) : eval_binop (Ocmp c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmp c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n))","proofString":"rewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n)) : Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n))","proofString":"decEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n)) : Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n))","proofString":"decEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmp c) v1 v2 m = Some (Vint n))","proofString":"simpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmp c v1 v2) = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmp c v1 v2) = Some (Vint n))","proofString":"inv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmp c v1 v2 = Vint n) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmp c v1 v2 = Vint n)","proofString":"eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"inv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n)) : eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n))","proofString":"econstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n)) : eval_binop (Ocmpu c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmpu c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n))","proofString":"rewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n)) : Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n))","proofString":"decEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n)) : Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n))","proofString":"decEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpu c) v1 v2 m = Some (Vint n))","proofString":"simpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmpu (Mem.valid_pointer m) c v1 v2) = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmpu (Mem.valid_pointer m) c v1 v2) = Some (Vint n))","proofString":"inv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmpu (Mem.valid_pointer m) c v1 v2 = Vint n) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmpu (Mem.valid_pointer m) c v1 v2 = Vint n)","proofString":"eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"inv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n)) : eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n))","proofString":"econstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n)) : eval_binop (Ocmpf c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmpf c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n))","proofString":"rewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n)) : Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n))","proofString":"decEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n)) : Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n))","proofString":"decEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpf c) v1 v2 m = Some (Vint n))","proofString":"simpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmpf c v1 v2) = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmpf c v1 v2) = Some (Vint n))","proofString":"inv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmpf c v1 v2 = Vint n) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmpf c v1 v2 = Vint n)","proofString":"eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"inv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n)) : eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n))","proofString":"econstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n)) : eval_binop (Ocmpfs c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmpfs c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n))","proofString":"rewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n)) : Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n))","proofString":"decEq.\ndecEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n)) : Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n))","proofString":"decEq.\nsimpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpfs c) v1 v2 m = Some (Vint n))","proofString":"simpl in H6.\ninv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmpfs c v1 v2) = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Some (Val.cmpfs c v1 v2) = Some (Vint n))","proofString":"inv H6.\neauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmpfs c v1 v2 = Vint n) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H0 : Val.cmpfs c v1 v2 = Vint n)","proofString":"eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"inv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n)) : eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n))","proofString":"econstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n)) : eval_binop (Ocmpl c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmpl c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n))","proofString":"rewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n)) : Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n))","proofString":"decEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n)) : Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n))","proofString":"decEq.\nsimpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmpl c) v1 v2 m = Some (Vint n))","proofString":"simpl in H6.\nunfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Val.cmpl c v1 v2 = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Val.cmpl c v1 v2 = Some (Vint n))","proofString":"unfold Val.cmpl in H6.\ndestruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : option_map Val.of_bool (Val.cmpl_bool c v1 v2) = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : option_map Val.of_bool (Val.cmpl_bool c v1 v2) = Some (Vint n))","proofString":"destruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) : eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (H : eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2) (Vint n)) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one))","proofString":"inv H.\neconstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n)) : eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n))","proofString":"econstructor; eauto.\nrewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n)) : eval_binop (Ocmplu c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmplu c) v1 v2 m =\nSome (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n))","proofString":"rewrite H6.\ndecEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n)) : Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"Some (Vint n) = Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n))","proofString":"decEq.\ndecEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n)) : Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"Vint n = Vint (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n))","proofString":"decEq.\nsimpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : eval_binop (Ocmplu c) v1 v2 m = Some (Vint n))","proofString":"simpl in H6.\nunfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some (Vint n))","proofString":"unfold Val.cmplu in H6.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) =\nSome (Vint n)) : n = (if Int.eq n Int.zero then Int.zero else Int.one).","conclusion":"n = (if Int.eq n Int.zero then Int.zero else Int.one)","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (n : int) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))) (CMP : forall ob : option bool,\nVal.of_optbool ob = Vint n ->\nn = (if Int.eq n Int.zero then Int.zero else Int.one)) (v1 v2 : val) (H3 : eval_expr ge e le m a1 v1) (H5 : eval_expr ge e le m a2 v2) (H6 : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) =\nSome (Vint n))","proofString":"destruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_expr ge e le m (make_cmpu_ne_zero a) Vone.","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"assert (DEFAULT: eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone).\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in H1.\nrewrite H0, H1.\nrewrite Int.eq_true; auto.\nassert (OF_OPTBOOL: forall ob, Some (Val.of_optbool ob) <> Some (Vptr b i)).\nintros.\ndestruct ob as [[]|]; discriminate.\nassert (OF_BOOL: forall ob, option_map Val.of_bool ob <> Some (Vptr b i)).\nintros.\ndestruct ob as [[]|]; discriminate.\ndestruct a; simpl; auto.\ndestruct b0; auto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_BOOL; eauto.\ninv H; eelim OF_BOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in H1.\nrewrite H0, H1.\nrewrite Int.eq_true; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_binop (Ocmpu Cne) (Vptr b i) (Vint Int.zero) m = Some Vone.","conclusion":"eval_binop (Ocmpu Cne) (Vptr b i) (Vint Int.zero) m = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"simpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in H1.\nrewrite H0, H1.\nrewrite Int.eq_true; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : Some (Val.cmpu (Mem.valid_pointer m) Cne (Vptr b i) (Vint Int.zero)) =\nSome Vone.","conclusion":"Some (Val.cmpu (Mem.valid_pointer m) Cne (Vptr b i) (Vint Int.zero)) =\nSome Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in H1.\nrewrite H0, H1.\nrewrite Int.eq_true; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Cne\n       else None)) = Some Vone.","conclusion":"Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Cne\n       else None)) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Mem.weak_valid_pointer in H1.\nrewrite H0, H1.\nrewrite Int.eq_true; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Cne\n       else None)) = Some Vone.","conclusion":"Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Cne\n       else None)) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"rewrite H0, H1.\nrewrite Int.eq_true; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : Some\n  (Val.of_optbool\n     (if Int.eq Int.zero Int.zero && true\n      then Val.cmp_different_blocks Cne\n      else None)) = Some Vone.","conclusion":"Some\n  (Val.of_optbool\n     (if Int.eq Int.zero Int.zero && true\n      then Val.cmp_different_blocks Cne\n      else None)) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"rewrite Int.eq_true; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) : eval_expr ge e le m (make_cmpu_ne_zero a) Vone.","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone)","proofString":"assert (OF_OPTBOOL: forall ob, Some (Val.of_optbool ob) <> Some (Vptr b i)).\nintros.\ndestruct ob as [[]|]; discriminate.\nassert (OF_BOOL: forall ob, option_map Val.of_bool ob <> Some (Vptr b i)).\nintros.\ndestruct ob as [[]|]; discriminate.\ndestruct a; simpl; auto.\ndestruct b0; auto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_BOOL; eauto.\ninv H; eelim OF_BOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i).","conclusion":"forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone)","proofString":"intros.\ndestruct ob as [[]|]; discriminate."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (ob : option bool) : Some (Val.of_optbool ob) <> Some (Vptr b i).","conclusion":"Some (Val.of_optbool ob) <> Some (Vptr b i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (ob : option bool)","proofString":"destruct ob as [[]|]; discriminate."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) : eval_expr ge e le m (make_cmpu_ne_zero a) Vone.","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i))","proofString":"assert (OF_BOOL: forall ob, option_map Val.of_bool ob <> Some (Vptr b i)).\nintros.\ndestruct ob as [[]|]; discriminate.\ndestruct a; simpl; auto.\ndestruct b0; auto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_BOOL; eauto.\ninv H; eelim OF_BOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i).","conclusion":"forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i))","proofString":"intros.\ndestruct ob as [[]|]; discriminate."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob0 : option bool, Some (Val.of_optbool ob0) <> Some (Vptr b i)) (ob : option bool) : option_map Val.of_bool ob <> Some (Vptr b i).","conclusion":"option_map Val.of_bool ob <> Some (Vptr b i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob0 : option bool, Some (Val.of_optbool ob0) <> Some (Vptr b i)) (ob : option bool)","proofString":"destruct ob as [[]|]; discriminate."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m (make_cmpu_ne_zero a) Vone.","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m a (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"destruct a; simpl; auto.\ndestruct b0; auto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_BOOL; eauto.\ninv H; eelim OF_BOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (b0 : binary_operation) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop b0 a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop b0 a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m\n  match b0 with\n  | Ocmp _ | Ocmpu _ | Ocmpf _ | Ocmpfs _ | Ocmpl _ | Ocmplu _ =>\n      Ebinop b0 a1 a2\n  | _ => Ebinop (Ocmpu Cne) (Ebinop b0 a1 a2) (make_intconst Int.zero)\n  end Vone.","conclusion":"eval_expr ge e le m\n  match b0 with\n  | Ocmp _ | Ocmpu _ | Ocmpf _ | Ocmpfs _ | Ocmpl _ | Ocmplu _ =>\n      Ebinop b0 a1 a2\n  | _ => Ebinop (Ocmpu Cne) (Ebinop b0 a1 a2) (make_intconst Int.zero)\n  end Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (b0 : binary_operation) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop b0 a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop b0 a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"destruct b0; auto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_OPTBOOL; eauto.\ninv H; eelim OF_BOOL; eauto.\ninv H; eelim OF_BOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmp c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmp c) a1 a2) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmp c) a1 a2) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmp c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmp c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"inv H; eelim OF_OPTBOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpu c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpu c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"inv H; eelim OF_OPTBOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpf c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpf c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"inv H; eelim OF_OPTBOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpfs c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpfs c) a1 a2) (make_intconst Int.zero))\n  Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"inv H; eelim OF_OPTBOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmpl c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmpl c) a1 a2) (make_intconst Int.zero)) Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"inv H; eelim OF_BOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (c : comparison) (a1 a2 : expr) (b : block) (i : ptrofs) (H : eval_expr ge e le m (Ebinop (Ocmplu c) a1 a2) (Vptr b i)) (H0 : Archi.ptr64 = false) (H1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) (DEFAULT : eval_expr ge e le m\n  (Ebinop (Ocmpu Cne) (Ebinop (Ocmplu c) a1 a2) (make_intconst Int.zero))\n  Vone) (OF_OPTBOOL : forall ob : option bool, Some (Val.of_optbool ob) <> Some (Vptr b i)) (OF_BOOL : forall ob : option bool, option_map Val.of_bool ob <> Some (Vptr b i))","proofString":"inv H; eelim OF_BOOL; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m (make_cast_int a sz si) (Vint (cast_int_int sz si n)).","conclusion":"eval_expr ge e le m (make_cast_int a sz si) (Vint (cast_int_int sz si n))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"unfold make_cast_int, cast_int_int.\ndestruct sz.\ndestruct si; eauto with cshm.\ndestruct si; eauto with cshm.\nauto.\napply make_cmpu_ne_zero_correct; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m\n  match sz with\n  | I8 =>\n      match si with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match si with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => make_cmpu_ne_zero a\n  end\n  (Vint\n     match sz with\n     | I8 =>\n         match si with\n         | Signed => Int.sign_ext 8 n\n         | Unsigned => Int.zero_ext 8 n\n         end\n     | I16 =>\n         match si with\n         | Signed => Int.sign_ext 16 n\n         | Unsigned => Int.zero_ext 16 n\n         end\n     | I32 => n\n     | IBool => if Int.eq n Int.zero then Int.zero else Int.one\n     end).","conclusion":"eval_expr ge e le m\n  match sz with\n  | I8 =>\n      match si with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match si with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => make_cmpu_ne_zero a\n  end\n  (Vint\n     match sz with\n     | I8 =>\n         match si with\n         | Signed => Int.sign_ext 8 n\n         | Unsigned => Int.zero_ext 8 n\n         end\n     | I16 =>\n         match si with\n         | Signed => Int.sign_ext 16 n\n         | Unsigned => Int.zero_ext 16 n\n         end\n     | I32 => n\n     | IBool => if Int.eq n Int.zero then Int.zero else Int.one\n     end)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"destruct sz.\ndestruct si; eauto with cshm.\ndestruct si; eauto with cshm.\nauto.\napply make_cmpu_ne_zero_correct; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m\n  match si with\n  | Signed => Eunop Ocast8signed a\n  | Unsigned => Eunop Ocast8unsigned a\n  end\n  (Vint\n     match si with\n     | Signed => Int.sign_ext 8 n\n     | Unsigned => Int.zero_ext 8 n\n     end).","conclusion":"eval_expr ge e le m\n  match si with\n  | Signed => Eunop Ocast8signed a\n  | Unsigned => Eunop Ocast8unsigned a\n  end\n  (Vint\n     match si with\n     | Signed => Int.sign_ext 8 n\n     | Unsigned => Int.zero_ext 8 n\n     end)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"destruct si; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m\n  match si with\n  | Signed => Eunop Ocast16signed a\n  | Unsigned => Eunop Ocast16unsigned a\n  end\n  (Vint\n     match si with\n     | Signed => Int.sign_ext 16 n\n     | Unsigned => Int.zero_ext 16 n\n     end).","conclusion":"eval_expr ge e le m\n  match si with\n  | Signed => Eunop Ocast16signed a\n  | Unsigned => Eunop Ocast16unsigned a\n  end\n  (Vint\n     match si with\n     | Signed => Int.sign_ext 16 n\n     | Unsigned => Int.zero_ext 16 n\n     end)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"destruct si; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m a (Vint n).","conclusion":"eval_expr ge e le m a (Vint n)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq n Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"apply make_cmpu_ne_zero_correct; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m (make_longofint a si) (Vlong (cast_int_long si n)).","conclusion":"eval_expr ge e le m (make_longofint a si) (Vlong (cast_int_long si n))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"unfold make_longofint, cast_int_long.\ndestruct si; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n)) : eval_expr ge e le m\n  match si with\n  | Signed => Eunop Olongofint a\n  | Unsigned => Eunop Olongofintu a\n  end\n  (Vlong\n     match si with\n     | Signed => Int64.repr (Int.signed n)\n     | Unsigned => Int64.repr (Int.unsigned n)\n     end).","conclusion":"eval_expr ge e le m\n  match si with\n  | Signed => Eunop Olongofint a\n  | Unsigned => Eunop Olongofintu a\n  end\n  (Vlong\n     match si with\n     | Signed => Int64.repr (Int.signed n)\n     | Unsigned => Int64.repr (Int.unsigned n)\n     end)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (si : signedness) (H : eval_expr ge e le m a (Vint n))","proofString":"destruct si; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a b : expr) (v : val) (ty1 ty2 : type) (v' : val) (H : make_cast ty1 ty2 a = OK b) (H0 : eval_expr ge e le m a v) (H1 : sem_cast v ty1 ty2 m = Some v') : eval_expr ge e le m b v'.","conclusion":"eval_expr ge e le m b v'","hypotheses":"(e : env) (le : temp_env) (m : mem) (a b : expr) (v : val) (ty1 ty2 : type) (v' : val) (H : make_cast ty1 ty2 a = OK b) (H0 : eval_expr ge e le m a v) (H1 : sem_cast v ty1 ty2 m = Some v')","proofString":"unfold make_cast, sem_cast in *;  destruct (classify_cast ty1 ty2); inv H; destruct v; InvEval; eauto with cshm.\nunfold make_singleofint, cast_int_float.\ndestruct si1; eauto with cshm.\napply make_cast_int_correct.\nunfold cast_float_int in Heqo.\nunfold make_intoffloat.\ndestruct si2; econstructor; eauto; simpl; rewrite Heqo; auto.\napply make_cast_int_correct.\nunfold cast_single_int in Heqo.\nunfold make_intofsingle.\ndestruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto.\nunfold make_floatoflong, cast_long_float.\ndestruct si1; eauto with cshm.\nunfold make_singleoflong, cast_long_single.\ndestruct si1; eauto with cshm.\nunfold cast_float_long in Heqo.\nunfold make_longoffloat.\ndestruct si2; econstructor; eauto; simpl; rewrite Heqo; auto.\nunfold cast_single_long in Heqo.\nunfold make_longofsingle.\ndestruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto.\napply make_cmpu_ne_zero_correct; auto.\neapply make_cmpu_ne_zero_correct_ptr; eauto.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb1.\nrewrite Heqb0, Heqb1.\nrewrite Int64.eq_true.\nreflexivity.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpf, Val.cmpf_bool.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f Float.zero); auto.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpfs, Val.cmpfs_bool.\nrewrite Float32.cmp_ne_eq.\ndestruct (Float32.cmp Ceq f Float32.zero); auto.\ndestruct (ident_eq id1 id2); inv H1; auto.\ndestruct (ident_eq id1 id2); inv H1; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vint i)) : eval_expr ge e le m (make_singleofint a si1)\n  (Vsingle (cast_int_single si1 i)).","conclusion":"eval_expr ge e le m (make_singleofint a si1)\n  (Vsingle (cast_int_single si1 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vint i))","proofString":"unfold make_singleofint, cast_int_float.\ndestruct si1; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vint i)) : eval_expr ge e le m\n  match si1 with\n  | Signed => Eunop Osingleofint a\n  | Unsigned => Eunop Osingleofintu a\n  end (Vsingle (cast_int_single si1 i)).","conclusion":"eval_expr ge e le m\n  match si1 with\n  | Signed => Eunop Osingleofint a\n  | Unsigned => Eunop Osingleofintu a\n  end (Vsingle (cast_int_single si1 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vint i))","proofString":"destruct si1; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : cast_float_int si2 f = Some i) : eval_expr ge e le m (make_cast_int (make_intoffloat a si2) sz2 si2)\n  (Vint (cast_int_int sz2 si2 i)).","conclusion":"eval_expr ge e le m (make_cast_int (make_intoffloat a si2) sz2 si2)\n  (Vint (cast_int_int sz2 si2 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : cast_float_int si2 f = Some i)","proofString":"apply make_cast_int_correct.\nunfold cast_float_int in Heqo.\nunfold make_intoffloat.\ndestruct si2; econstructor; eauto; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : cast_float_int si2 f = Some i) : eval_expr ge e le m (make_intoffloat a si2) (Vint i).","conclusion":"eval_expr ge e le m (make_intoffloat a si2) (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : cast_float_int si2 f = Some i)","proofString":"unfold cast_float_int in Heqo.\nunfold make_intoffloat.\ndestruct si2; econstructor; eauto; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : match si2 with\n| Signed => Float.to_int f\n| Unsigned => Float.to_intu f\nend = Some i) : eval_expr ge e le m (make_intoffloat a si2) (Vint i).","conclusion":"eval_expr ge e le m (make_intoffloat a si2) (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : match si2 with\n| Signed => Float.to_int f\n| Unsigned => Float.to_intu f\nend = Some i)","proofString":"unfold make_intoffloat.\ndestruct si2; econstructor; eauto; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : match si2 with\n| Signed => Float.to_int f\n| Unsigned => Float.to_intu f\nend = Some i) : eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Ointoffloat a\n  | Unsigned => Eunop Ointuoffloat a\n  end (Vint i).","conclusion":"eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Ointoffloat a\n  | Unsigned => Eunop Ointuoffloat a\n  end (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int) (Heqo : match si2 with\n| Signed => Float.to_int f\n| Unsigned => Float.to_intu f\nend = Some i)","proofString":"destruct si2; econstructor; eauto; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : cast_single_int si2 f = Some i) : eval_expr ge e le m (make_cast_int (make_intofsingle a si2) sz2 si2)\n  (Vint (cast_int_int sz2 si2 i)).","conclusion":"eval_expr ge e le m (make_cast_int (make_intofsingle a si2) sz2 si2)\n  (Vint (cast_int_int sz2 si2 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : cast_single_int si2 f = Some i)","proofString":"apply make_cast_int_correct.\nunfold cast_single_int in Heqo.\nunfold make_intofsingle.\ndestruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : cast_single_int si2 f = Some i) : eval_expr ge e le m (make_intofsingle a si2) (Vint i).","conclusion":"eval_expr ge e le m (make_intofsingle a si2) (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : cast_single_int si2 f = Some i)","proofString":"unfold cast_single_int in Heqo.\nunfold make_intofsingle.\ndestruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : match si2 with\n| Signed => Float32.to_int f\n| Unsigned => Float32.to_intu f\nend = Some i) : eval_expr ge e le m (make_intofsingle a si2) (Vint i).","conclusion":"eval_expr ge e le m (make_intofsingle a si2) (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : match si2 with\n| Signed => Float32.to_int f\n| Unsigned => Float32.to_intu f\nend = Some i)","proofString":"unfold make_intofsingle.\ndestruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : match si2 with\n| Signed => Float32.to_int f\n| Unsigned => Float32.to_intu f\nend = Some i) : eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Ointofsingle a\n  | Unsigned => Eunop Ointuofsingle a\n  end (Vint i).","conclusion":"eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Ointofsingle a\n  | Unsigned => Eunop Ointuofsingle a\n  end (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (sz2 : intsize) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int) (Heqo : match si2 with\n| Signed => Float32.to_int f\n| Unsigned => Float32.to_intu f\nend = Some i)","proofString":"destruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (make_floatoflong a si1) (Vfloat (cast_long_float si1 i)).","conclusion":"eval_expr ge e le m (make_floatoflong a si1) (Vfloat (cast_long_float si1 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"unfold make_floatoflong, cast_long_float.\ndestruct si1; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m\n  match si1 with\n  | Signed => Eunop Ofloatoflong a\n  | Unsigned => Eunop Ofloatoflongu a\n  end\n  (Vfloat\n     match si1 with\n     | Signed => Float.of_long i\n     | Unsigned => Float.of_longu i\n     end).","conclusion":"eval_expr ge e le m\n  match si1 with\n  | Signed => Eunop Ofloatoflong a\n  | Unsigned => Eunop Ofloatoflongu a\n  end\n  (Vfloat\n     match si1 with\n     | Signed => Float.of_long i\n     | Unsigned => Float.of_longu i\n     end)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"destruct si1; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (make_singleoflong a si1)\n  (Vsingle (cast_long_single si1 i)).","conclusion":"eval_expr ge e le m (make_singleoflong a si1)\n  (Vsingle (cast_long_single si1 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"unfold make_singleoflong, cast_long_single.\ndestruct si1; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m\n  match si1 with\n  | Signed => Eunop Osingleoflong a\n  | Unsigned => Eunop Osingleoflongu a\n  end\n  (Vsingle\n     match si1 with\n     | Signed => Float32.of_long i\n     | Unsigned => Float32.of_longu i\n     end).","conclusion":"eval_expr ge e le m\n  match si1 with\n  | Signed => Eunop Osingleoflong a\n  | Unsigned => Eunop Osingleoflongu a\n  end\n  (Vsingle\n     match si1 with\n     | Signed => Float32.of_long i\n     | Unsigned => Float32.of_longu i\n     end)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (si1 : signedness) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"destruct si1; eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int64) (Heqo : cast_float_long si2 f = Some i) : eval_expr ge e le m (make_longoffloat a si2) (Vlong i).","conclusion":"eval_expr ge e le m (make_longoffloat a si2) (Vlong i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int64) (Heqo : cast_float_long si2 f = Some i)","proofString":"unfold cast_float_long in Heqo.\nunfold make_longoffloat.\ndestruct si2; econstructor; eauto; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int64) (Heqo : match si2 with\n| Signed => Float.to_long f\n| Unsigned => Float.to_longu f\nend = Some i) : eval_expr ge e le m (make_longoffloat a si2) (Vlong i).","conclusion":"eval_expr ge e le m (make_longoffloat a si2) (Vlong i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int64) (Heqo : match si2 with\n| Signed => Float.to_long f\n| Unsigned => Float.to_longu f\nend = Some i)","proofString":"unfold make_longoffloat.\ndestruct si2; econstructor; eauto; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int64) (Heqo : match si2 with\n| Signed => Float.to_long f\n| Unsigned => Float.to_longu f\nend = Some i) : eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Olongoffloat a\n  | Unsigned => Eunop Olonguoffloat a\n  end (Vlong i).","conclusion":"eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Olongoffloat a\n  | Unsigned => Eunop Olonguoffloat a\n  end (Vlong i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vfloat f)) (i : int64) (Heqo : match si2 with\n| Signed => Float.to_long f\n| Unsigned => Float.to_longu f\nend = Some i)","proofString":"destruct si2; econstructor; eauto; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int64) (Heqo : cast_single_long si2 f = Some i) : eval_expr ge e le m (make_longofsingle a si2) (Vlong i).","conclusion":"eval_expr ge e le m (make_longofsingle a si2) (Vlong i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int64) (Heqo : cast_single_long si2 f = Some i)","proofString":"unfold cast_single_long in Heqo.\nunfold make_longofsingle.\ndestruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int64) (Heqo : match si2 with\n| Signed => Float32.to_long f\n| Unsigned => Float32.to_longu f\nend = Some i) : eval_expr ge e le m (make_longofsingle a si2) (Vlong i).","conclusion":"eval_expr ge e le m (make_longofsingle a si2) (Vlong i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int64) (Heqo : match si2 with\n| Signed => Float32.to_long f\n| Unsigned => Float32.to_longu f\nend = Some i)","proofString":"unfold make_longofsingle.\ndestruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int64) (Heqo : match si2 with\n| Signed => Float32.to_long f\n| Unsigned => Float32.to_longu f\nend = Some i) : eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Olongofsingle a\n  | Unsigned => Eunop Olonguofsingle a\n  end (Vlong i).","conclusion":"eval_expr ge e le m\n  match si2 with\n  | Signed => Eunop Olongofsingle a\n  | Unsigned => Eunop Olonguofsingle a\n  end (Vlong i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (si2 : signedness) (H0 : eval_expr ge e le m a (Vsingle f)) (i : int64) (Heqo : match si2 with\n| Signed => Float32.to_long f\n| Unsigned => Float32.to_longu f\nend = Some i)","proofString":"destruct si2; econstructor; eauto with cshm; simpl; rewrite Heqo; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vint i)) : eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq i Int.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a)\n  (Vint (if Int.eq i Int.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vint i))","proofString":"apply make_cmpu_ne_zero_correct; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_expr ge e le m (make_cmpu_ne_zero a) Vone.","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"eapply make_cmpu_ne_zero_correct_ptr; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero))\n  (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero))\n  (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i)) : eval_binop (Ocmplu Cne) (Vlong i) (Vlong Int64.zero) m =\nSome (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmplu Cne) (Vlong i) (Vlong Int64.zero) m =\nSome (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"simpl.\nunfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i)) : Val.cmplu (Mem.valid_pointer m) Cne (Vlong i) (Vlong Int64.zero) =\nSome (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one)).","conclusion":"Val.cmplu (Mem.valid_pointer m) Cne (Vlong i) (Vlong Int64.zero) =\nSome (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"unfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i)) : option_map Val.of_bool (Some (negb (Int64.eq i Int64.zero))) =\nSome (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one)).","conclusion":"option_map Val.of_bool (Some (negb (Int64.eq i Int64.zero))) =\nSome (Vint (if Int64.eq i Int64.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vlong i))","proofString":"destruct (Int64.eq i Int64.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb1.\nrewrite Heqb0, Heqb1.\nrewrite Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_binop (Ocmplu Cne) (Vptr b i) (Vlong Int64.zero) m = Some Vone.","conclusion":"eval_binop (Ocmplu Cne) (Vptr b i) (Vlong Int64.zero) m = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"simpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb1.\nrewrite Heqb0, Heqb1.\nrewrite Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : Val.cmplu (Mem.valid_pointer m) Cne (Vptr b i) (Vlong Int64.zero) = Some Vone.","conclusion":"Val.cmplu (Mem.valid_pointer m) Cne (Vptr b i) (Vlong Int64.zero) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb1.\nrewrite Heqb0, Heqb1.\nrewrite Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone.","conclusion":"option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Mem.weak_valid_pointer in Heqb1.\nrewrite Heqb0, Heqb1.\nrewrite Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone.","conclusion":"option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"rewrite Heqb0, Heqb1.\nrewrite Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : option_map Val.of_bool\n  (if Int64.eq Int64.zero Int64.zero && true\n   then Val.cmp_different_blocks Cne\n   else None) = Some Vone.","conclusion":"option_map Val.of_bool\n  (if Int64.eq Int64.zero Int64.zero && true\n   then Val.cmp_different_blocks Cne\n   else None) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"rewrite Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : option_map Val.of_bool\n  (if true && true then Val.cmp_different_blocks Cne else None) = \nSome Vone.","conclusion":"option_map Val.of_bool\n  (if true && true then Val.cmp_different_blocks Cne else None) = \nSome Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b : block) (i : ptrofs) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vptr b i)) (Heqb0 : negb Archi.ptr64 = false) (Heqb1 : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f)) : eval_expr ge e le m (Ebinop (Ocmpf Cne) a (make_floatconst Float.zero))\n  (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpf Cne) a (make_floatconst Float.zero))\n  (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpf, Val.cmpf_bool.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f)) : eval_binop (Ocmpf Cne) (Vfloat f) (Vfloat Float.zero) m =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmpf Cne) (Vfloat f) (Vfloat Float.zero) m =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f))","proofString":"simpl.\nunfold Val.cmpf, Val.cmpf_bool.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f)) : Some (Val.cmpf Cne (Vfloat f) (Vfloat Float.zero)) =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one)).","conclusion":"Some (Val.cmpf Cne (Vfloat f) (Vfloat Float.zero)) =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f))","proofString":"unfold Val.cmpf, Val.cmpf_bool.\nrewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f)) : Some (Val.of_optbool (Some (Float.cmp Cne f Float.zero))) =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one)).","conclusion":"Some (Val.of_optbool (Some (Float.cmp Cne f Float.zero))) =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f))","proofString":"rewrite Float.cmp_ne_eq.\ndestruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f)) : Some (Val.of_optbool (Some (negb (Float.cmp Ceq f Float.zero)))) =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one)).","conclusion":"Some (Val.of_optbool (Some (negb (Float.cmp Ceq f Float.zero)))) =\nSome (Vint (if Float.cmp Ceq f Float.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vfloat f))","proofString":"destruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f)) : eval_expr ge e le m (Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero))\n  (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one)).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero))\n  (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpfs, Val.cmpfs_bool.\nrewrite Float32.cmp_ne_eq.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f)) : eval_binop (Ocmpfs Cne) (Vsingle f) (Vsingle Float32.zero) m =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one)).","conclusion":"eval_binop (Ocmpfs Cne) (Vsingle f) (Vsingle Float32.zero) m =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f))","proofString":"simpl.\nunfold Val.cmpfs, Val.cmpfs_bool.\nrewrite Float32.cmp_ne_eq.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f)) : Some (Val.cmpfs Cne (Vsingle f) (Vsingle Float32.zero)) =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one)).","conclusion":"Some (Val.cmpfs Cne (Vsingle f) (Vsingle Float32.zero)) =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f))","proofString":"unfold Val.cmpfs, Val.cmpfs_bool.\nrewrite Float32.cmp_ne_eq.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f)) : Some (Val.of_optbool (Some (Float32.cmp Cne f Float32.zero))) =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one)).","conclusion":"Some (Val.of_optbool (Some (Float32.cmp Cne f Float32.zero))) =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f))","proofString":"rewrite Float32.cmp_ne_eq.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f)) : Some (Val.of_optbool (Some (negb (Float32.cmp Ceq f Float32.zero)))) =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one)).","conclusion":"Some (Val.of_optbool (Some (negb (Float32.cmp Ceq f Float32.zero)))) =\nSome (Vint (if Float32.cmp Ceq f Float32.zero then Int.zero else Int.one))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty1 ty2 : type) (H0 : eval_expr ge e le m a (Vsingle f))","proofString":"destruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (b : expr) (b0 : block) (i : ptrofs) (ty1 ty2 : type) (v' : val) (id1 id2 : ident) (H0 : eval_expr ge e le m b (Vptr b0 i)) (H1 : (if ident_eq id1 id2 then Some (Vptr b0 i) else None) = Some v') : eval_expr ge e le m b v'.","conclusion":"eval_expr ge e le m b v'","hypotheses":"(e : env) (le : temp_env) (m : mem) (b : expr) (b0 : block) (i : ptrofs) (ty1 ty2 : type) (v' : val) (id1 id2 : ident) (H0 : eval_expr ge e le m b (Vptr b0 i)) (H1 : (if ident_eq id1 id2 then Some (Vptr b0 i) else None) = Some v')","proofString":"destruct (ident_eq id1 id2); inv H1; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (b : expr) (b0 : block) (i : ptrofs) (ty1 ty2 : type) (v' : val) (id1 id2 : ident) (H0 : eval_expr ge e le m b (Vptr b0 i)) (H1 : (if ident_eq id1 id2 then Some (Vptr b0 i) else None) = Some v') : eval_expr ge e le m b v'.","conclusion":"eval_expr ge e le m b v'","hypotheses":"(e : env) (le : temp_env) (m : mem) (b : expr) (b0 : block) (i : ptrofs) (ty1 ty2 : type) (v' : val) (id1 id2 : ident) (H0 : eval_expr ge e le m b (Vptr b0 i)) (H1 : (if ident_eq id1 id2 then Some (Vptr b0 i) else None) = Some v')","proofString":"destruct (ident_eq id1 id2); inv H1; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (ty : type) (b : bool) (H : eval_expr ge e le m a v) (H0 : bool_val v ty m = Some b) : exists vb : val,\n  eval_expr ge e le m (make_boolean a ty) vb /\\ Val.bool_of_val vb b.","conclusion":"exists vb : val,\n  eval_expr ge e le m (make_boolean a ty) vb /\\ Val.bool_of_val vb b","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (ty : type) (b : bool) (H : eval_expr ge e le m a v) (H0 : bool_val v ty m = Some b)","proofString":"unfold make_boolean.\nunfold bool_val in H0.\ndestruct (classify_bool ty); destruct v; InvEval.\neconstructor; split.\napply make_cmpu_ne_zero_correct with (n := i); auto.\ndestruct (Int.eq i Int.zero); simpl; constructor.\nexists Vone; split.\neapply make_cmpu_ne_zero_correct_ptr; eauto.\nconstructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu.\nsimpl.\neauto.\ndestruct (Int64.eq i Int64.zero); simpl; constructor.\nexists Vone; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity.\nconstructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpf, Val.cmpf_bool.\nsimpl.\nrewrite <- Float.cmp_ne_eq.\ndestruct (Float.cmp Cne f Float.zero); constructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpfs, Val.cmpfs_bool.\nsimpl.\nrewrite <- Float32.cmp_ne_eq.\ndestruct (Float32.cmp Cne f Float32.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (ty : type) (b : bool) (H : eval_expr ge e le m a v) (H0 : bool_val v ty m = Some b) : exists vb : val,\n  eval_expr ge e le m\n    match classify_bool ty with\n    | bool_case_i => make_cmpu_ne_zero a\n    | bool_case_l => Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)\n    | bool_case_f => Ebinop (Ocmpf Cne) a (make_floatconst Float.zero)\n    | bool_case_s => Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero)\n    | bool_default => a\n    end vb /\\ Val.bool_of_val vb b.","conclusion":"exists vb : val,\n  eval_expr ge e le m\n    match classify_bool ty with\n    | bool_case_i => make_cmpu_ne_zero a\n    | bool_case_l => Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)\n    | bool_case_f => Ebinop (Ocmpf Cne) a (make_floatconst Float.zero)\n    | bool_case_s => Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero)\n    | bool_default => a\n    end vb /\\ Val.bool_of_val vb b","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (ty : type) (b : bool) (H : eval_expr ge e le m a v) (H0 : bool_val v ty m = Some b)","proofString":"unfold bool_val in H0.\ndestruct (classify_bool ty); destruct v; InvEval.\neconstructor; split.\napply make_cmpu_ne_zero_correct with (n := i); auto.\ndestruct (Int.eq i Int.zero); simpl; constructor.\nexists Vone; split.\neapply make_cmpu_ne_zero_correct_ptr; eauto.\nconstructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu.\nsimpl.\neauto.\ndestruct (Int64.eq i Int64.zero); simpl; constructor.\nexists Vone; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity.\nconstructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpf, Val.cmpf_bool.\nsimpl.\nrewrite <- Float.cmp_ne_eq.\ndestruct (Float.cmp Cne f Float.zero); constructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpfs, Val.cmpfs_bool.\nsimpl.\nrewrite <- Float32.cmp_ne_eq.\ndestruct (Float32.cmp Cne f Float32.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (ty : type) (b : bool) (H : eval_expr ge e le m a v) (H0 : match classify_bool ty with\n| bool_case_i =>\n    match v with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match v with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match v with\n    | Vfloat f => Some (negb (Float.cmp Ceq f Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match v with\n    | Vsingle f => Some (negb (Float32.cmp Ceq f Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b) : exists vb : val,\n  eval_expr ge e le m\n    match classify_bool ty with\n    | bool_case_i => make_cmpu_ne_zero a\n    | bool_case_l => Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)\n    | bool_case_f => Ebinop (Ocmpf Cne) a (make_floatconst Float.zero)\n    | bool_case_s => Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero)\n    | bool_default => a\n    end vb /\\ Val.bool_of_val vb b.","conclusion":"exists vb : val,\n  eval_expr ge e le m\n    match classify_bool ty with\n    | bool_case_i => make_cmpu_ne_zero a\n    | bool_case_l => Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)\n    | bool_case_f => Ebinop (Ocmpf Cne) a (make_floatconst Float.zero)\n    | bool_case_s => Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero)\n    | bool_default => a\n    end vb /\\ Val.bool_of_val vb b","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (ty : type) (b : bool) (H : eval_expr ge e le m a v) (H0 : match classify_bool ty with\n| bool_case_i =>\n    match v with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match v with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match v with\n    | Vfloat f => Some (negb (Float.cmp Ceq f Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match v with\n    | Vsingle f => Some (negb (Float32.cmp Ceq f Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b)","proofString":"destruct (classify_bool ty); destruct v; InvEval.\neconstructor; split.\napply make_cmpu_ne_zero_correct with (n := i); auto.\ndestruct (Int.eq i Int.zero); simpl; constructor.\nexists Vone; split.\neapply make_cmpu_ne_zero_correct_ptr; eauto.\nconstructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu.\nsimpl.\neauto.\ndestruct (Int64.eq i Int64.zero); simpl; constructor.\nexists Vone; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity.\nconstructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpf, Val.cmpf_bool.\nsimpl.\nrewrite <- Float.cmp_ne_eq.\ndestruct (Float.cmp Cne f Float.zero); constructor.\neconstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpfs, Val.cmpfs_bool.\nsimpl.\nrewrite <- Float32.cmp_ne_eq.\ndestruct (Float32.cmp Cne f Float32.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty : type) (H : eval_expr ge e le m a (Vint i)) : exists vb : val,\n  eval_expr ge e le m (make_cmpu_ne_zero a) vb /\\\n  Val.bool_of_val vb (negb (Int.eq i Int.zero)).","conclusion":"exists vb : val,\n  eval_expr ge e le m (make_cmpu_ne_zero a) vb /\\\n  Val.bool_of_val vb (negb (Int.eq i Int.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (ty : type) (H : eval_expr ge e le m a (Vint i))","proofString":"econstructor; split.\napply make_cmpu_ne_zero_correct with (n := i); auto.\ndestruct (Int.eq i Int.zero); simpl; constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : exists vb : val,\n  eval_expr ge e le m (make_cmpu_ne_zero a) vb /\\ Val.bool_of_val vb true.","conclusion":"exists vb : val,\n  eval_expr ge e le m (make_cmpu_ne_zero a) vb /\\ Val.bool_of_val vb true","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"exists Vone; split.\neapply make_cmpu_ne_zero_correct_ptr; eauto.\nconstructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : eval_expr ge e le m (make_cmpu_ne_zero a) Vone.","conclusion":"eval_expr ge e le m (make_cmpu_ne_zero a) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"eapply make_cmpu_ne_zero_correct_ptr; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : Val.bool_of_val Vone true.","conclusion":"Val.bool_of_val Vone true","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty : type) (H : eval_expr ge e le m a (Vlong i)) : exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) vb /\\\n  Val.bool_of_val vb (negb (Int64.eq i Int64.zero)).","conclusion":"exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) vb /\\\n  Val.bool_of_val vb (negb (Int64.eq i Int64.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (ty : type) (H : eval_expr ge e le m a (Vlong i))","proofString":"econstructor; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu.\nsimpl.\neauto.\ndestruct (Int64.eq i Int64.zero); simpl; constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) vb /\\\n  Val.bool_of_val vb true.","conclusion":"exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) vb /\\\n  Val.bool_of_val vb true","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"exists Vone; split.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity.\nconstructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) Vone.","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu Cne) a (make_longconst Int64.zero)) Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : eval_binop (Ocmplu Cne) (Vptr b0 i) (Vlong Int64.zero) m = Some Vone.","conclusion":"eval_binop (Ocmplu Cne) (Vptr b0 i) (Vlong Int64.zero) m = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"simpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : Val.cmplu (Mem.valid_pointer m) Cne (Vptr b0 i) (Vlong Int64.zero) =\nSome Vone.","conclusion":"Val.cmplu (Mem.valid_pointer m) Cne (Vptr b0 i) (Vlong Int64.zero) =\nSome Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"unfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone.","conclusion":"option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"unfold Mem.weak_valid_pointer in Heqb0.\nrewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1) = true) : option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone.","conclusion":"option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Cne\n    else None) = Some Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1) = true)","proofString":"rewrite Heqb0, Heqb1, Int64.eq_true.\nreflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1) = true) : option_map Val.of_bool\n  (if true && true then Val.cmp_different_blocks Cne else None) = \nSome Vone.","conclusion":"option_map Val.of_bool\n  (if true && true then Val.cmp_different_blocks Cne else None) = \nSome Vone","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1) = true)","proofString":"reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true) : Val.bool_of_val Vone true.","conclusion":"Val.bool_of_val Vone true","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (b0 : block) (i : ptrofs) (ty : type) (H : eval_expr ge e le m a (Vptr b0 i)) (Heqb1 : negb Archi.ptr64 = false) (Heqb0 : Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) = true)","proofString":"constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f)) : exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmpf Cne) a (make_floatconst Float.zero)) vb /\\\n  Val.bool_of_val vb (negb (Float.cmp Ceq f Float.zero)).","conclusion":"exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmpf Cne) a (make_floatconst Float.zero)) vb /\\\n  Val.bool_of_val vb (negb (Float.cmp Ceq f Float.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f))","proofString":"econstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpf, Val.cmpf_bool.\nsimpl.\nrewrite <- Float.cmp_ne_eq.\ndestruct (Float.cmp Cne f Float.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f)) : Val.bool_of_val (Val.of_optbool (Some (Float.cmp Cne f Float.zero)))\n  (negb (Float.cmp Ceq f Float.zero)).","conclusion":"Val.bool_of_val (Val.of_optbool (Some (Float.cmp Cne f Float.zero)))\n  (negb (Float.cmp Ceq f Float.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f))","proofString":"simpl.\nrewrite <- Float.cmp_ne_eq.\ndestruct (Float.cmp Cne f Float.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f)) : Val.bool_of_val (if Float.cmp Cne f Float.zero then Vtrue else Vfalse)\n  (negb (Float.cmp Ceq f Float.zero)).","conclusion":"Val.bool_of_val (if Float.cmp Cne f Float.zero then Vtrue else Vfalse)\n  (negb (Float.cmp Ceq f Float.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f))","proofString":"rewrite <- Float.cmp_ne_eq.\ndestruct (Float.cmp Cne f Float.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f)) : Val.bool_of_val (if Float.cmp Cne f Float.zero then Vtrue else Vfalse)\n  (Float.cmp Cne f Float.zero).","conclusion":"Val.bool_of_val (if Float.cmp Cne f Float.zero then Vtrue else Vfalse)\n  (Float.cmp Cne f Float.zero)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float) (ty : type) (H : eval_expr ge e le m a (Vfloat f))","proofString":"destruct (Float.cmp Cne f Float.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f)) : exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero))\n    vb /\\ Val.bool_of_val vb (negb (Float32.cmp Ceq f Float32.zero)).","conclusion":"exists vb : val,\n  eval_expr ge e le m (Ebinop (Ocmpfs Cne) a (make_singleconst Float32.zero))\n    vb /\\ Val.bool_of_val vb (negb (Float32.cmp Ceq f Float32.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f))","proofString":"econstructor; split.\neconstructor; eauto with cshm.\nsimpl.\neauto.\nunfold Val.cmpfs, Val.cmpfs_bool.\nsimpl.\nrewrite <- Float32.cmp_ne_eq.\ndestruct (Float32.cmp Cne f Float32.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f)) : Val.bool_of_val (Val.of_optbool (Some (Float32.cmp Cne f Float32.zero)))\n  (negb (Float32.cmp Ceq f Float32.zero)).","conclusion":"Val.bool_of_val (Val.of_optbool (Some (Float32.cmp Cne f Float32.zero)))\n  (negb (Float32.cmp Ceq f Float32.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f))","proofString":"simpl.\nrewrite <- Float32.cmp_ne_eq.\ndestruct (Float32.cmp Cne f Float32.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f)) : Val.bool_of_val (if Float32.cmp Cne f Float32.zero then Vtrue else Vfalse)\n  (negb (Float32.cmp Ceq f Float32.zero)).","conclusion":"Val.bool_of_val (if Float32.cmp Cne f Float32.zero then Vtrue else Vfalse)\n  (negb (Float32.cmp Ceq f Float32.zero))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f))","proofString":"rewrite <- Float32.cmp_ne_eq.\ndestruct (Float32.cmp Cne f Float32.zero); constructor."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f)) : Val.bool_of_val (if Float32.cmp Cne f Float32.zero then Vtrue else Vfalse)\n  (Float32.cmp Cne f Float32.zero).","conclusion":"Val.bool_of_val (if Float32.cmp Cne f Float32.zero then Vtrue else Vfalse)\n  (Float32.cmp Cne f Float32.zero)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (f : float32) (ty : type) (H : eval_expr ge e le m a (Vsingle f))","proofString":"destruct (Float32.cmp Cne f Float32.zero); constructor."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (EV1 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (Eunop Oabsf (make_floatoflong a s))\n  (Vfloat (Float.abs (cast_long_float s i))).","conclusion":"eval_expr ge e le m (Eunop Oabsf (make_floatoflong a s))\n  (Vfloat (Float.abs (cast_long_float s i)))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"unfold make_floatoflong, cast_long_float.\ndestruct s.\neconstructor.\neconstructor; simpl; eauto.\nsimpl; eauto.\nsimpl; eauto.\neconstructor.\neconstructor; simpl; eauto.\nsimpl; eauto.\nsimpl; eauto."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (EV1 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m\n  (Eunop Oabsf\n     match s with\n     | Signed => Eunop Ofloatoflong a\n     | Unsigned => Eunop Ofloatoflongu a\n     end)\n  (Vfloat\n     (Float.abs\n        match s with\n        | Signed => Float.of_long i\n        | Unsigned => Float.of_longu i\n        end)).","conclusion":"eval_expr ge e le m\n  (Eunop Oabsf\n     match s with\n     | Signed => Eunop Ofloatoflong a\n     | Unsigned => Eunop Ofloatoflongu a\n     end)\n  (Vfloat\n     (Float.abs\n        match s with\n        | Signed => Float.of_long i\n        | Unsigned => Float.of_longu i\n        end))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"destruct s.\neconstructor.\neconstructor; simpl; eauto.\nsimpl; eauto.\nsimpl; eauto.\neconstructor.\neconstructor; simpl; eauto.\nsimpl; eauto.\nsimpl; eauto."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (Eunop Oabsf (Eunop Ofloatoflong a))\n  (Vfloat (Float.abs (Float.of_long i))).","conclusion":"eval_expr ge e le m (Eunop Oabsf (Eunop Ofloatoflong a))\n  (Vfloat (Float.abs (Float.of_long i)))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"econstructor.\neconstructor; simpl; eauto.\nsimpl; eauto.\nsimpl; eauto."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (Eunop Oabsf (Eunop Ofloatoflongu a))\n  (Vfloat (Float.abs (Float.of_longu i))).","conclusion":"eval_expr ge e le m (Eunop Oabsf (Eunop Ofloatoflongu a))\n  (Vfloat (Float.abs (Float.of_longu i)))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"econstructor.\neconstructor; simpl; eauto.\nsimpl; eauto.\nsimpl; eauto."},{"statement":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (SEM : option_map (fun b : bool => Val.of_bool (negb b))\n  match classify_bool tya with\n  | bool_case_i =>\n      match va with\n      | Vint n => Some (negb (Int.eq n Int.zero))\n      | Vptr b ofs =>\n          if Archi.ptr64\n          then None\n          else\n           if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n           then Some true\n           else None\n      | _ => None\n      end\n  | bool_case_l =>\n      match va with\n      | Vlong n => Some (negb (Int64.eq n Int64.zero))\n      | Vptr b ofs =>\n          if negb Archi.ptr64\n          then None\n          else\n           if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n           then Some true\n           else None\n      | _ => None\n      end\n  | bool_case_f =>\n      match va with\n      | Vfloat f => Some (negb (Float.cmp Ceq f Float.zero))\n      | _ => None\n      end\n  | bool_case_s =>\n      match va with\n      | Vsingle f => Some (negb (Float32.cmp Ceq f Float32.zero))\n      | _ => None\n      end\n  | bool_default => None\n  end = Some v) (MAKE : match classify_bool tya with\n| bool_case_i => OK (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero))\n| bool_case_l => OK (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero))\n| bool_case_f => OK (Ebinop (Ocmpf Ceq) a (make_floatconst Float.zero))\n| bool_case_s => OK (Ebinop (Ocmpfs Ceq) a (make_singleconst Float32.zero))\n| bool_default => Error (msg \"Cshmgen.make_notbool\")\nend = OK c) (EV1 : eval_expr ge e le m a va) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (SEM : option_map (fun b : bool => Val.of_bool (negb b))\n  match classify_bool tya with\n  | bool_case_i =>\n      match va with\n      | Vint n => Some (negb (Int.eq n Int.zero))\n      | Vptr b ofs =>\n          if Archi.ptr64\n          then None\n          else\n           if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n           then Some true\n           else None\n      | _ => None\n      end\n  | bool_case_l =>\n      match va with\n      | Vlong n => Some (negb (Int64.eq n Int64.zero))\n      | Vptr b ofs =>\n          if negb Archi.ptr64\n          then None\n          else\n           if Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs)\n           then Some true\n           else None\n      | _ => None\n      end\n  | bool_case_f =>\n      match va with\n      | Vfloat f => Some (negb (Float.cmp Ceq f Float.zero))\n      | _ => None\n      end\n  | bool_case_s =>\n      match va with\n      | Vsingle f => Some (negb (Float32.cmp Ceq f Float32.zero))\n      | _ => None\n      end\n  | bool_default => None\n  end = Some v) (MAKE : match classify_bool tya with\n| bool_case_i => OK (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero))\n| bool_case_l => OK (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero))\n| bool_case_f => OK (Ebinop (Ocmpf Ceq) a (make_floatconst Float.zero))\n| bool_case_s => OK (Ebinop (Ocmpfs Ceq) a (make_singleconst Float32.zero))\n| bool_default => Error (msg \"Cshmgen.make_notbool\")\nend = OK c) (EV1 : eval_expr ge e le m a va)","proofString":"destruct (classify_bool tya); inv MAKE; destruct va; simpl in SEM; InvEval.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool, Int.cmpu.\ndestruct (Int.eq i Int.zero); auto.\ndestruct Archi.ptr64 eqn:SF; inv SEM.\ndestruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int.eq_true.\nauto.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto.\ndestruct Archi.ptr64 eqn:SF; inv SEM.\ndestruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int64.eq_true.\nauto.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpf, Val.cmpf_bool.\ndestruct (Float.cmp Ceq f Float.zero); auto.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpfs, Val.cmpfs_bool.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i)) : eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero))\n  (Val.of_bool (negb (negb (Int.eq i Int.zero)))).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero))\n  (Val.of_bool (negb (negb (Int.eq i Int.zero))))","hypotheses":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool, Int.cmpu.\ndestruct (Int.eq i Int.zero); auto."},{"statement":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i)) : eval_binop (Ocmpu Ceq) (Vint i) (Vint Int.zero) m =\nSome (Val.of_bool (negb (negb (Int.eq i Int.zero)))).","conclusion":"eval_binop (Ocmpu Ceq) (Vint i) (Vint Int.zero) m =\nSome (Val.of_bool (negb (negb (Int.eq i Int.zero))))","hypotheses":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i))","proofString":"simpl.\nunfold Val.cmpu, Val.cmpu_bool, Int.cmpu.\ndestruct (Int.eq i Int.zero); auto."},{"statement":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i)) : Some (Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint Int.zero)) =\nSome (Val.of_bool (negb (negb (Int.eq i Int.zero)))).","conclusion":"Some (Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint Int.zero)) =\nSome (Val.of_bool (negb (negb (Int.eq i Int.zero))))","hypotheses":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i))","proofString":"unfold Val.cmpu, Val.cmpu_bool, Int.cmpu.\ndestruct (Int.eq i Int.zero); auto."},{"statement":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i)) : Some (Val.of_optbool (Some (Int.eq i Int.zero))) =\nSome (Val.of_bool (negb (negb (Int.eq i Int.zero)))).","conclusion":"Some (Val.of_optbool (Some (Int.eq i Int.zero))) =\nSome (Val.of_bool (negb (negb (Int.eq i Int.zero))))","hypotheses":"(a : expr) (tya : type) (i : int) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vint i))","proofString":"destruct (Int.eq i Int.zero); auto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if Archi.ptr64\n   then None\n   else\n    if Mem.weak_valid_pointer m b (Ptrofs.unsigned i)\n    then Some true\n    else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero)) v.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero)) v","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if Archi.ptr64\n   then None\n   else\n    if Mem.weak_valid_pointer m b (Ptrofs.unsigned i)\n    then Some true\n    else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b i))","proofString":"destruct Archi.ptr64 eqn:SF; inv SEM.\ndestruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (H0 : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if Mem.weak_valid_pointer m b (Ptrofs.unsigned i) then Some true else None) =\nSome v) : eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero)) v.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero)) v","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (H0 : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if Mem.weak_valid_pointer m b (Ptrofs.unsigned i) then Some true else None) =\nSome v)","proofString":"destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero)) Vfalse.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu Ceq) a (make_intconst Int.zero)) Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_binop (Ocmpu Ceq) (Vptr b i) (Vint Int.zero) m = Some Vfalse.","conclusion":"eval_binop (Ocmpu Ceq) (Vptr b i) (Vint Int.zero) m = Some Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"simpl.\nunfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : Some (Val.cmpu (Mem.valid_pointer m) Ceq (Vptr b i) (Vint Int.zero)) =\nSome Vfalse.","conclusion":"Some (Val.cmpu (Mem.valid_pointer m) Ceq (Vptr b i) (Vint Int.zero)) =\nSome Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Val.cmpu, Val.cmpu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Ceq\n       else None)) = Some Vfalse.","conclusion":"Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Ceq\n       else None)) = Some Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Ceq\n       else None)) = Some Vfalse.","conclusion":"Some\n  (Val.of_optbool\n     (if Archi.ptr64\n      then None\n      else\n       if\n        Int.eq Int.zero Int.zero &&\n        (Mem.valid_pointer m b (Ptrofs.unsigned i)\n         || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n       then Val.cmp_different_blocks Ceq\n       else None)) = Some Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"rewrite SF, V, Int.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : Some\n  (Val.of_optbool\n     (if true && true then Val.cmp_different_blocks Ceq else None)) =\nSome Vfalse.","conclusion":"Some\n  (Val.of_optbool\n     (if true && true then Val.cmp_different_blocks Ceq else None)) =\nSome Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"auto."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero))\n  (Val.of_bool (negb (negb (Int64.eq i Int64.zero)))).","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero))\n  (Val.of_bool (negb (negb (Int64.eq i Int64.zero))))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i)) : eval_binop (Ocmplu Ceq) (Vlong i) (Vlong Int64.zero) m =\nSome (Val.of_bool (negb (negb (Int64.eq i Int64.zero)))).","conclusion":"eval_binop (Ocmplu Ceq) (Vlong i) (Vlong Int64.zero) m =\nSome (Val.of_bool (negb (negb (Int64.eq i Int64.zero))))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"simpl.\nunfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i)) : Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong Int64.zero) =\nSome (Val.of_bool (negb (negb (Int64.eq i Int64.zero)))).","conclusion":"Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong Int64.zero) =\nSome (Val.of_bool (negb (negb (Int64.eq i Int64.zero))))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"unfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.\ndestruct (Int64.eq i Int64.zero); auto."},{"statement":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i)) : option_map Val.of_bool (Some (Int64.eq i Int64.zero)) =\nSome (Val.of_bool (negb (negb (Int64.eq i Int64.zero)))).","conclusion":"option_map Val.of_bool (Some (Int64.eq i Int64.zero)) =\nSome (Val.of_bool (negb (negb (Int64.eq i Int64.zero))))","hypotheses":"(a : expr) (tya : type) (i : int64) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vlong i))","proofString":"destruct (Int64.eq i Int64.zero); auto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if negb Archi.ptr64\n   then None\n   else\n    if Mem.weak_valid_pointer m b (Ptrofs.unsigned i)\n    then Some true\n    else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b i)) : eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero)) v.","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero)) v","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if negb Archi.ptr64\n   then None\n   else\n    if Mem.weak_valid_pointer m b (Ptrofs.unsigned i)\n    then Some true\n    else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b i))","proofString":"destruct Archi.ptr64 eqn:SF; inv SEM.\ndestruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int64.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (H0 : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if Mem.weak_valid_pointer m b (Ptrofs.unsigned i) then Some true else None) =\nSome v) : eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero)) v.","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero)) v","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (H0 : option_map (fun b0 : bool => Val.of_bool (negb b0))\n  (if Mem.weak_valid_pointer m b (Ptrofs.unsigned i) then Some true else None) =\nSome v)","proofString":"destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.\neconstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int64.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero))\n  Vfalse.","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu Ceq) a (make_longconst Int64.zero))\n  Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int64.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : eval_binop (Ocmplu Ceq) (Vptr b i) (Vlong Int64.zero) m = Some Vfalse.","conclusion":"eval_binop (Ocmplu Ceq) (Vptr b i) (Vlong Int64.zero) m = Some Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"simpl.\nunfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int64.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b i) (Vlong Int64.zero) =\nSome Vfalse.","conclusion":"Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b i) (Vlong Int64.zero) =\nSome Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Val.cmplu, Val.cmplu_bool.\nunfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int64.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true) : option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Ceq\n    else None) = Some Vfalse.","conclusion":"option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Ceq\n    else None) = Some Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.weak_valid_pointer m b (Ptrofs.unsigned i) = true)","proofString":"unfold Mem.weak_valid_pointer in V.\nrewrite SF, V, Int64.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Ceq\n    else None) = Some Vfalse.","conclusion":"option_map Val.of_bool\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq Int64.zero Int64.zero &&\n     (Mem.valid_pointer m b (Ptrofs.unsigned i)\n      || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n    then Val.cmp_different_blocks Ceq\n    else None) = Some Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"rewrite SF, V, Int64.eq_true.\nauto."},{"statement":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true) : option_map Val.of_bool\n  (if negb true\n   then None\n   else if true && true then Val.cmp_different_blocks Ceq else None) =\nSome Vfalse.","conclusion":"option_map Val.of_bool\n  (if negb true\n   then None\n   else if true && true then Val.cmp_different_blocks Ceq else None) =\nSome Vfalse","hypotheses":"(a : expr) (tya : type) (b : block) (i : ptrofs) (e : env) (le : temp_env) (m : mem) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b i)) (V : Mem.valid_pointer m b (Ptrofs.unsigned i)\n|| Mem.valid_pointer m b (Ptrofs.unsigned i - 1) = true)","proofString":"auto."},{"statement":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f)) : eval_expr ge e le m (Ebinop (Ocmpf Ceq) a (make_floatconst Float.zero))\n  (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero)))).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpf Ceq) a (make_floatconst Float.zero))\n  (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero))))","hypotheses":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpf, Val.cmpf_bool.\ndestruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f)) : eval_binop (Ocmpf Ceq) (Vfloat f) (Vfloat Float.zero) m =\nSome (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero)))).","conclusion":"eval_binop (Ocmpf Ceq) (Vfloat f) (Vfloat Float.zero) m =\nSome (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero))))","hypotheses":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f))","proofString":"simpl.\nunfold Val.cmpf, Val.cmpf_bool.\ndestruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f)) : Some (Val.cmpf Ceq (Vfloat f) (Vfloat Float.zero)) =\nSome (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero)))).","conclusion":"Some (Val.cmpf Ceq (Vfloat f) (Vfloat Float.zero)) =\nSome (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero))))","hypotheses":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f))","proofString":"unfold Val.cmpf, Val.cmpf_bool.\ndestruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f)) : Some (Val.of_optbool (Some (Float.cmp Ceq f Float.zero))) =\nSome (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero)))).","conclusion":"Some (Val.of_optbool (Some (Float.cmp Ceq f Float.zero))) =\nSome (Val.of_bool (negb (negb (Float.cmp Ceq f Float.zero))))","hypotheses":"(a : expr) (tya : type) (f : float) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vfloat f))","proofString":"destruct (Float.cmp Ceq f Float.zero); auto."},{"statement":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f)) : eval_expr ge e le m (Ebinop (Ocmpfs Ceq) a (make_singleconst Float32.zero))\n  (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero)))).","conclusion":"eval_expr ge e le m (Ebinop (Ocmpfs Ceq) a (make_singleconst Float32.zero))\n  (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero))))","hypotheses":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f))","proofString":"econstructor; eauto with cshm.\nsimpl.\nunfold Val.cmpfs, Val.cmpfs_bool.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f)) : eval_binop (Ocmpfs Ceq) (Vsingle f) (Vsingle Float32.zero) m =\nSome (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero)))).","conclusion":"eval_binop (Ocmpfs Ceq) (Vsingle f) (Vsingle Float32.zero) m =\nSome (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero))))","hypotheses":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f))","proofString":"simpl.\nunfold Val.cmpfs, Val.cmpfs_bool.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f)) : Some (Val.cmpfs Ceq (Vsingle f) (Vsingle Float32.zero)) =\nSome (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero)))).","conclusion":"Some (Val.cmpfs Ceq (Vsingle f) (Vsingle Float32.zero)) =\nSome (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero))))","hypotheses":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f))","proofString":"unfold Val.cmpfs, Val.cmpfs_bool.\ndestruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f)) : Some (Val.of_optbool (Some (Float32.cmp Ceq f Float32.zero))) =\nSome (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero)))).","conclusion":"Some (Val.of_optbool (Some (Float32.cmp Ceq f Float32.zero))) =\nSome (Val.of_bool (negb (negb (Float32.cmp Ceq f Float32.zero))))","hypotheses":"(a : expr) (tya : type) (f : float32) (e : env) (le : temp_env) (m : mem) (EV1 : eval_expr ge e le m a (Vsingle f))","proofString":"destruct (Float32.cmp Ceq f Float32.zero); auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match sem_cast va tya (binarith_type (classify_binarith tya tyb)) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type (classify_binarith tya tyb)) m with\n    | Some v2' =>\n        match classify_binarith tya tyb with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type (classify_binarith tya tyb)) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type (classify_binarith tya tyb)) b)\n     (fun e2' : expr =>\n      match classify_binarith tya tyb with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | bin_case_f => OK (Ebinop fop e1' e2')\n      | bin_case_s => OK (Ebinop sop e1' e2')\n      | bin_default => Error (msg \"Cshmgen.make_binarith\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match sem_cast va tya (binarith_type (classify_binarith tya tyb)) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type (classify_binarith tya tyb)) m with\n    | Some v2' =>\n        match classify_binarith tya tyb with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type (classify_binarith tya tyb)) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type (classify_binarith tya tyb)) b)\n     (fun e2' : expr =>\n      match classify_binarith tya tyb with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | bin_case_f => OK (Ebinop fop e1' e2')\n      | bin_case_s => OK (Ebinop sop e1' e2')\n      | bin_default => Error (msg \"Cshmgen.make_binarith\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"set (cls := classify_binarith tya tyb) in *.\nset (ty := binarith_type cls) in *.\nmonadInv MAKE.\ndestruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (SEM : match sem_cast va tya (binarith_type cls) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type cls) m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type cls) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type cls) b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | bin_case_f => OK (Ebinop fop e1' e2')\n      | bin_case_s => OK (Ebinop sop e1' e2')\n      | bin_default => Error (msg \"Cshmgen.make_binarith\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (SEM : match sem_cast va tya (binarith_type cls) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type cls) m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type cls) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type cls) b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | bin_case_f => OK (Ebinop fop e1' e2')\n      | bin_case_s => OK (Ebinop sop e1' e2')\n      | bin_default => Error (msg \"Cshmgen.make_binarith\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"set (ty := binarith_type cls) in *.\nmonadInv MAKE.\ndestruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya ty a)\n  (fun e1' : expr =>\n   bind (make_cast tyb ty b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | bin_case_f => OK (Ebinop fop e1' e2')\n      | bin_case_s => OK (Ebinop sop e1' e2')\n      | bin_default => Error (msg \"Cshmgen.make_binarith\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya ty a)\n  (fun e1' : expr =>\n   bind (make_cast tyb ty b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | bin_case_f => OK (Ebinop fop e1' e2')\n      | bin_case_s => OK (Ebinop sop e1' e2')\n      | bin_default => Error (msg \"Cshmgen.make_binarith\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"monadInv MAKE.\ndestruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat n1 =>\n                match v2' with\n                | Vfloat n2 => sem_float n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle n1 =>\n                match v2' with\n                | Vsingle n2 => sem_single n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c)","proofString":"destruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (SEM : match sem_cast vb tyb ty m with\n| Some v2' =>\n    match cls with\n    | bin_case_i sg =>\n        match va' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => sem_int sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_l sg =>\n        match va' with\n        | Vlong n1 =>\n            match v2' with\n            | Vlong n2 => sem_long sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_f =>\n        match va' with\n        | Vfloat n1 =>\n            match v2' with\n            | Vfloat n2 => sem_float n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_s =>\n        match va' with\n        | Vsingle n1 =>\n            match v2' with\n            | Vsingle n2 => sem_single n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_default => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (SEM : match sem_cast vb tyb ty m with\n| Some v2' =>\n    match cls with\n    | bin_case_i sg =>\n        match va' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => sem_int sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_l sg =>\n        match va' with\n        | Vlong n1 =>\n            match v2' with\n            | Vlong n2 => sem_long sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_f =>\n        match va' with\n        | Vfloat n1 =>\n            match v2' with\n            | Vfloat n2 => sem_float n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_s =>\n        match va' with\n        | Vsingle n1 =>\n            match v2' with\n            | Vsingle n2 => sem_single n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_default => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c)","proofString":"destruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat n1 =>\n        match vb' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle n1 =>\n        match vb' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat n1 =>\n        match vb' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle n1 =>\n        match vb' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c)","proofString":"exploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat n1 =>\n        match vb' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle n1 =>\n        match vb' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c) (EV1' : eval_expr ge e le m x va') : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat n1 =>\n        match vb' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle n1 =>\n        match vb' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c) (EV1' : eval_expr ge e le m x va')","proofString":"exploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat n1 =>\n        match vb' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle n1 =>\n        match vb' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c) (EV1' : eval_expr ge e le m x va') (EV2' : eval_expr ge e le m x0 vb') : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat n1 =>\n        match vb' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle n1 =>\n        match vb' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| bin_case_f => OK (Ebinop fop x x0)\n| bin_case_s => OK (Ebinop sop x x0)\n| bin_default => Error (msg \"Cshmgen.make_binarith\")\nend = OK c) (EV1' : eval_expr ge e le m x va') (EV2' : eval_expr ge e le m x0 vb')","proofString":"destruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto.\nerewrite <- fop_ok in SEM; eauto with cshm.\nerewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop iop x x0)\n| Unsigned => OK (Ebinop iopu x x0)\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop iop x x0)\n| Unsigned => OK (Ebinop iopu x x0)\nend = OK c)","proofString":"destruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) : eval_binop iop (Vint i) (Vint i0) m = Some v.","conclusion":"eval_binop iop (Vint i) (Vint i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0))","proofString":"rewrite iop_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) : eval_binop iopu (Vint i) (Vint i0) m = Some v.","conclusion":"eval_binop iopu (Vint i) (Vint i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0))","proofString":"rewrite iopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop lop x x0)\n| Unsigned => OK (Ebinop lopu x x0)\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop lop x x0)\n| Unsigned => OK (Ebinop lopu x x0)\nend = OK c)","proofString":"destruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) : eval_binop lop (Vlong i) (Vlong i0) m = Some v.","conclusion":"eval_binop lop (Vlong i) (Vlong i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0))","proofString":"rewrite lop_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) : eval_binop lopu (Vlong i) (Vlong i0) m = Some v.","conclusion":"eval_binop lopu (Vlong i) (Vlong i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0))","proofString":"rewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (f : float) (Ca : sem_cast va tya ty m = Some (Vfloat f)) (f0 : float) (Cb : sem_cast vb tyb ty m = Some (Vfloat f0)) (SEM : sem_float f f0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vfloat f)) (EV2' : eval_expr ge e le m x0 (Vfloat f0)) : eval_expr ge e le m (Ebinop fop x x0) v.","conclusion":"eval_expr ge e le m (Ebinop fop x x0) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (f : float) (Ca : sem_cast va tya ty m = Some (Vfloat f)) (f0 : float) (Cb : sem_cast vb tyb ty m = Some (Vfloat f0)) (SEM : sem_float f f0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vfloat f)) (EV2' : eval_expr ge e le m x0 (Vfloat f0))","proofString":"erewrite <- fop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (f : float32) (Ca : sem_cast va tya ty m = Some (Vsingle f)) (f0 : float32) (Cb : sem_cast vb tyb ty m = Some (Vsingle f0)) (SEM : sem_single f f0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vsingle f)) (EV2' : eval_expr ge e le m x0 (Vsingle f0)) : eval_expr ge e le m (Ebinop sop x x0) v.","conclusion":"eval_expr ge e le m (Ebinop sop x x0) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (f : float32) (Ca : sem_cast va tya ty m = Some (Vsingle f)) (f0 : float32) (Cb : sem_cast vb tyb ty m = Some (Vsingle f0)) (SEM : sem_single f f0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vsingle f)) (EV2' : eval_expr ge e le m x0 (Vsingle f0))","proofString":"erewrite <- sop_ok in SEM; eauto with cshm."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match sem_cast va tya (binarith_type (classify_binarith tya tyb)) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type (classify_binarith tya tyb)) m with\n    | Some v2' =>\n        match classify_binarith tya tyb with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type (classify_binarith tya tyb)) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type (classify_binarith tya tyb)) b)\n     (fun e2' : expr =>\n      match classify_binarith tya tyb with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | _ => Error (msg \"Cshmgen.make_binarith_int\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match sem_cast va tya (binarith_type (classify_binarith tya tyb)) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type (classify_binarith tya tyb)) m with\n    | Some v2' =>\n        match classify_binarith tya tyb with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type (classify_binarith tya tyb)) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type (classify_binarith tya tyb)) b)\n     (fun e2' : expr =>\n      match classify_binarith tya tyb with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | _ => Error (msg \"Cshmgen.make_binarith_int\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"set (cls := classify_binarith tya tyb) in *.\nset (ty := binarith_type cls) in *.\nmonadInv MAKE.\ndestruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (SEM : match sem_cast va tya (binarith_type cls) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type cls) m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type cls) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type cls) b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | _ => Error (msg \"Cshmgen.make_binarith_int\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (SEM : match sem_cast va tya (binarith_type cls) m with\n| Some v1' =>\n    match sem_cast vb tyb (binarith_type cls) m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya (binarith_type cls) a)\n  (fun e1' : expr =>\n   bind (make_cast tyb (binarith_type cls) b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | _ => Error (msg \"Cshmgen.make_binarith_int\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"set (ty := binarith_type cls) in *.\nmonadInv MAKE.\ndestruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya ty a)\n  (fun e1' : expr =>\n   bind (make_cast tyb ty b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | _ => Error (msg \"Cshmgen.make_binarith_int\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (MAKE : bind (make_cast tya ty a)\n  (fun e1' : expr =>\n   bind (make_cast tyb ty b)\n     (fun e2' : expr =>\n      match cls with\n      | bin_case_i Signed => OK (Ebinop iop e1' e2')\n      | bin_case_i Unsigned => OK (Ebinop iopu e1' e2')\n      | bin_case_l Signed => OK (Ebinop lop e1' e2')\n      | bin_case_l Unsigned => OK (Ebinop lopu e1' e2')\n      | _ => Error (msg \"Cshmgen.make_binarith_int\")\n      end)) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"monadInv MAKE.\ndestruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (SEM : match sem_cast va tya ty m with\n| Some v1' =>\n    match sem_cast vb tyb ty m with\n    | Some v2' =>\n        match cls with\n        | bin_case_i sg =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => sem_int sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l sg =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => sem_long sg n1 n2\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c)","proofString":"destruct (sem_cast va tya ty m) as [va'|] eqn:Ca; try discriminate.\ndestruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (SEM : match sem_cast vb tyb ty m with\n| Some v2' =>\n    match cls with\n    | bin_case_i sg =>\n        match va' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => sem_int sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_l sg =>\n        match va' with\n        | Vlong n1 =>\n            match v2' with\n            | Vlong n2 => sem_long sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_f =>\n        match va' with\n        | Vfloat _ => match v2' with\n                      | Vundef | _ => None\n                      end\n        | _ => None\n        end\n    | bin_case_s =>\n        match va' with\n        | Vsingle _ => match v2' with\n                       | Vundef | _ => None\n                       end\n        | _ => None\n        end\n    | bin_default => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (SEM : match sem_cast vb tyb ty m with\n| Some v2' =>\n    match cls with\n    | bin_case_i sg =>\n        match va' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => sem_int sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_l sg =>\n        match va' with\n        | Vlong n1 =>\n            match v2' with\n            | Vlong n2 => sem_long sg n1 n2\n            | _ => None\n            end\n        | _ => None\n        end\n    | bin_case_f =>\n        match va' with\n        | Vfloat _ => match v2' with\n                      | Vundef | _ => None\n                      end\n        | _ => None\n        end\n    | bin_case_s =>\n        match va' with\n        | Vsingle _ => match v2' with\n                       | Vundef | _ => None\n                       end\n        | _ => None\n        end\n    | bin_default => None\n    end\n| None => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c)","proofString":"destruct (sem_cast vb tyb ty m) as [vb'|] eqn:Cb; try discriminate.\nexploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat _ => match vb' with\n                  | Vundef | _ => None\n                  end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle _ => match vb' with\n                   | Vundef | _ => None\n                   end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat _ => match vb' with\n                  | Vundef | _ => None\n                  end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle _ => match vb' with\n                   | Vundef | _ => None\n                   end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c)","proofString":"exploit make_cast_correct.\neexact EQ.\neauto.\neauto.\nintros EV1'.\nexploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat _ => match vb' with\n                  | Vundef | _ => None\n                  end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle _ => match vb' with\n                   | Vundef | _ => None\n                   end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c) (EV1' : eval_expr ge e le m x va') : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat _ => match vb' with\n                  | Vundef | _ => None\n                  end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle _ => match vb' with\n                   | Vundef | _ => None\n                   end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c) (EV1' : eval_expr ge e le m x va')","proofString":"exploit make_cast_correct.\neexact EQ1.\neauto.\neauto.\nintros EV2'.\ndestruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat _ => match vb' with\n                  | Vundef | _ => None\n                  end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle _ => match vb' with\n                   | Vundef | _ => None\n                   end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c) (EV1' : eval_expr ge e le m x va') (EV2' : eval_expr ge e le m x0 vb') : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (cls : binarith_cases) (ty : type) (va' : val) (Ca : sem_cast va tya ty m = Some va') (vb' : val) (Cb : sem_cast vb tyb ty m = Some vb') (SEM : match cls with\n| bin_case_i sg =>\n    match va' with\n    | Vint n1 => match vb' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match va' with\n    | Vlong n1 =>\n        match vb' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match va' with\n    | Vfloat _ => match vb' with\n                  | Vundef | _ => None\n                  end\n    | _ => None\n    end\n| bin_case_s =>\n    match va' with\n    | Vsingle _ => match vb' with\n                   | Vundef | _ => None\n                   end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EQ2 : match cls with\n| bin_case_i Signed => OK (Ebinop iop x x0)\n| bin_case_i Unsigned => OK (Ebinop iopu x x0)\n| bin_case_l Signed => OK (Ebinop lop x x0)\n| bin_case_l Unsigned => OK (Ebinop lopu x x0)\n| _ => Error (msg \"Cshmgen.make_binarith_int\")\nend = OK c) (EV1' : eval_expr ge e le m x va') (EV2' : eval_expr ge e le m x0 vb')","proofString":"destruct cls; inv EQ2; destruct va'; try discriminate; destruct vb'; try discriminate.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto.\ndestruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop iop x x0)\n| Unsigned => OK (Ebinop iopu x x0)\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop iop x x0)\n| Unsigned => OK (Ebinop iopu x x0)\nend = OK c)","proofString":"destruct s; inv H0; econstructor; eauto with cshm.\nrewrite iop_ok; auto.\nrewrite iopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) : eval_binop iop (Vint i) (Vint i0) m = Some v.","conclusion":"eval_binop iop (Vint i) (Vint i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0))","proofString":"rewrite iop_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0)) : eval_binop iopu (Vint i) (Vint i0) m = Some v.","conclusion":"eval_binop iopu (Vint i) (Vint i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int) (Ca : sem_cast va tya ty m = Some (Vint i)) (i0 : int) (Cb : sem_cast vb tyb ty m = Some (Vint i0)) (SEM : sem_int Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vint i)) (EV2' : eval_expr ge e le m x0 (Vint i0))","proofString":"rewrite iopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop lop x x0)\n| Unsigned => OK (Ebinop lopu x x0)\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long s i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop lop x x0)\n| Unsigned => OK (Ebinop lopu x x0)\nend = OK c)","proofString":"destruct s; inv H0; econstructor; eauto with cshm.\nrewrite lop_ok; auto.\nrewrite lopu_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) : eval_binop lop (Vlong i) (Vlong i0) m = Some v.","conclusion":"eval_binop lop (Vlong i) (Vlong i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Signed i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0))","proofString":"rewrite lop_ok; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0)) : eval_binop lopu (Vlong i) (Vlong i0) m = Some v.","conclusion":"eval_binop lopu (Vlong i) (Vlong i0) m = Some v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (i : int64) (Ca : sem_cast va tya ty m = Some (Vlong i)) (i0 : int64) (Cb : sem_cast vb tyb ty m = Some (Vlong i0)) (SEM : sem_long Unsigned i i0 = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : expr) (EQ : make_cast tya ty a = OK x) (x0 : expr) (EQ1 : make_cast tyb ty b = OK x0) (EV1' : eval_expr ge e le m x (Vlong i)) (EV2' : eval_expr ge e le m x0 (Vlong i0))","proofString":"rewrite lopu_ok; auto."},{"statement":"forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v.","conclusion":"forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v","hypotheses":"","proofString":"unfold make_add_ptr_int, sem_add_ptr_int; intros until v; intros MAKE EV1 EV2 SEM; monadInv MAKE.\ndestruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs.\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b c : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.add n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    n2)))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.add n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (cast_int_long si n2))))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Oaddl a\n       (Ebinop Omull (make_longconst (Int64.repr x)) (make_longofint b si)))\n else OK (Ebinop Oadd a (Ebinop Omul (make_intconst (Int.repr x)) b))) = \nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(ty : type) (si : signedness) (a b c : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.add n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    n2)))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.add n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (cast_int_long si n2))))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Oaddl a\n       (Ebinop Omull (make_longconst (Int64.repr x)) (make_longofint b si)))\n else OK (Ebinop Oadd a (Ebinop Omul (make_intconst (Int.repr x)) b))) = \nOK c)","proofString":"destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs.\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vlong\n             (Int64.add n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (cast_int_long si n2))))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si))) v.","conclusion":"eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si))) v","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vlong\n             (Int64.add n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (cast_int_long si n2))))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (i : int64) (i0 : int) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si)))\n  (Vlong\n     (Int64.add i\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (cast_int_long si i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si)))\n  (Vlong\n     (Int64.add i\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (cast_int_long si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (i : int64) (i0 : int) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"eauto with cshm."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si)))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si)))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Oaddl (Vptr b0 i)\n  (Vlong\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_binop Oaddl (Vptr b0 i)\n  (Vlong\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (cast_int_long si i0))))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (cast_int_long si i0))))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (cast_int_long si i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (cast_int_long si i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (cast_int_long si i0)))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0))).","conclusion":"Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (cast_int_long si i0)))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0)))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.add i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0)).","conclusion":"Ptrofs.add i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"assert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0).","conclusion":"Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct si; simpl; apply Ptrofs.agree64_repr; auto."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)) : Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0))","proofString":"auto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vint\n             (Int.add n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   n2)))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  v.","conclusion":"eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  v","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vint\n             (Int.add n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   n2)))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (i i0 : int) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  (Vint\n     (Int.add i\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  (Vint\n     (Int.add i\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (i i0 : int) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"eauto with cshm."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Oadd (Vptr b0 i)\n  (Vint (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_binop Oadd (Vptr b0 i)\n  (Vint (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0))).","conclusion":"Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0)))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.add i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0)).","conclusion":"Ptrofs.add i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0))","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"assert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (ptrofs_of_int si i0) i0) : Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(ty : type) (si : signedness) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (ptrofs_of_int si i0) i0)","proofString":"auto with ptrofs."},{"statement":"(A : forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v) : binary_constructor_correct (make_add (prog_comp_env cunit))\n  (sem_add (prog_comp_env prog)).","conclusion":"binary_constructor_correct (make_add (prog_comp_env cunit))\n  (sem_add (prog_comp_env prog))","hypotheses":"(A : forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v)","proofString":"assert (B: forall ty a b c e le m va vb v,             make_add_ptr_long cunit.(prog_comp_env) ty a b = OK c ->             eval_expr ge e le m a va -> eval_expr ge e le m b vb ->             sem_add_ptr_long (prog_comp_env prog) ty va vb = Some v ->             eval_expr ge e le m c v).\nunfold make_add_ptr_long, sem_add_ptr_long; intros until v; intros MAKE EV1 EV2 SEM; monadInv MAKE.\ndestruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nauto with ptrofs.\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs.\nred; unfold make_add, sem_add;  intros until m; intros SEM MAKE EV1 EV2;  destruct (classify_add tya tyb); eauto.\neapply make_binarith_correct; eauto; intros; auto."},{"statement":"(A : forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v) : forall (ty : type) (a b c : expr) (e : env) (le : temp_env) \n  (m : mem) (va vb v : val),\nmake_add_ptr_long (prog_comp_env cunit) ty a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_long (prog_comp_env prog) ty va vb = Some v ->\neval_expr ge e le m c v.","conclusion":"forall (ty : type) (a b c : expr) (e : env) (le : temp_env) \n  (m : mem) (va vb v : val),\nmake_add_ptr_long (prog_comp_env cunit) ty a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_long (prog_comp_env prog) ty va vb = Some v ->\neval_expr ge e le m c v","hypotheses":"(A : forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v)","proofString":"unfold make_add_ptr_long, sem_add_ptr_long; intros until v; intros MAKE EV1 EV2 SEM; monadInv MAKE.\ndestruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nauto with ptrofs.\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c0 : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c0 ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c0 v0) (ty : type) (a b c : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.add n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.add n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Oaddl a (Ebinop Omull (make_longconst (Int64.repr x)) b))\n else\n  OK\n    (Ebinop Oadd a\n       (Ebinop Omul (make_intconst (Int.repr x)) (Eunop Ointoflong b)))) =\nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c0 : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c0 ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c0 v0) (ty : type) (a b c : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.add n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.add n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Oaddl a (Ebinop Omull (make_longconst (Int64.repr x)) b))\n else\n  OK\n    (Ebinop Oadd a\n       (Ebinop Omul (make_intconst (Int.repr x)) (Eunop Ointoflong b)))) =\nOK c)","proofString":"destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nauto with ptrofs.\ndestruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c v0) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vlong\n             (Int64.add n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b)) v.","conclusion":"eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b)) v","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c v0) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vlong\n             (Int64.add n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b0 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (i i0 : int64) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b))\n  (Vlong\n     (Int64.add i\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b))\n  (Vlong\n     (Int64.add i\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b0 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (i i0 : int64) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"eauto with cshm."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oaddl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Oaddl (Vptr b0 i)\n  (Vlong (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))\n  m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_binop Oaddl (Vptr b0 i)\n  (Vlong (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))\n  m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               i0)))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               i0)))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\nf_equal.\nf_equal.\nf_equal.\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nf_equal.\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0))).","conclusion":"Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0)))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.add i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0)).","conclusion":"Ptrofs.add i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0).","conclusion":"Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0)","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = true) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"auto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c v0) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vint\n             (Int.add n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b))) v.","conclusion":"eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b))) v","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c v0) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (va vb v : val) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vint\n             (Int.add n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.add ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM.\neauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b0 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (i : int) (i0 : int64) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b)))\n  (Vint\n     (Int.add i\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Int.repr (Int64.unsigned i0))))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b)))\n  (Vint\n     (Int.add i\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Int.repr (Int64.unsigned i0)))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b0 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b0 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b0 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (i : int) (i0 : int64) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"eauto with cshm."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b)))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oadd a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b)))\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Oadd (Vptr b0 i)\n  (Vint\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_binop Oadd (Vptr b0 i)\n  (Vint\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.add i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\nf_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.add i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Int64.loword i0)))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0))).","conclusion":"Vptr b0\n  (Ptrofs.add i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Int64.loword i0)))) =\nVptr b0\n  (Ptrofs.add i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0)))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nf_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.add i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0)).","conclusion":"Ptrofs.add i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) =\nPtrofs.add i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0))","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0).","conclusion":"Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0)","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"assert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) : Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0).","conclusion":"Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0)","hypotheses":"(A : forall (ty0 : type) (si : signedness) (a0 b1 c : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty0 si a0 b1 = OK c ->\neval_expr ge e0 le0 m0 a0 va ->\neval_expr ge e0 le0 m0 b1 vb ->\nsem_add_ptr_int (prog_comp_env prog) ty0 si va vb = Some v ->\neval_expr ge e0 le0 m0 c v) (ty : type) (a b : expr) (e : env) (le : temp_env) (m : mem) (b0 : block) (i : ptrofs) (i0 : int64) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (SF : Archi.ptr64 = false) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0))","proofString":"auto with ptrofs."},{"statement":"(A : forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v) (B : forall (ty : type) (a b c : expr) (e : env) (le : temp_env) \n  (m : mem) (va vb v : val),\nmake_add_ptr_long (prog_comp_env cunit) ty a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_long (prog_comp_env prog) ty va vb = Some v ->\neval_expr ge e le m c v) : binary_constructor_correct (make_add (prog_comp_env cunit))\n  (sem_add (prog_comp_env prog)).","conclusion":"binary_constructor_correct (make_add (prog_comp_env cunit))\n  (sem_add (prog_comp_env prog))","hypotheses":"(A : forall (ty : type) (si : signedness) (a b c : expr) \n  (e : env) (le : temp_env) (m : mem) (va vb v : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_int (prog_comp_env prog) ty si va vb = Some v ->\neval_expr ge e le m c v) (B : forall (ty : type) (a b c : expr) (e : env) (le : temp_env) \n  (m : mem) (va vb v : val),\nmake_add_ptr_long (prog_comp_env cunit) ty a b = OK c ->\neval_expr ge e le m a va ->\neval_expr ge e le m b vb ->\nsem_add_ptr_long (prog_comp_env prog) ty va vb = Some v ->\neval_expr ge e le m c v)","proofString":"red; unfold make_add, sem_add;  intros until m; intros SEM MAKE EV1 EV2;  destruct (classify_add tya tyb); eauto.\neapply make_binarith_correct; eauto; intros; auto."},{"statement":"(A : forall (ty : type) (si : signedness) (a0 b0 c0 : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a0 b0 = OK c0 ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c0 v0) (B : forall (ty : type) (a0 b0 c0 : expr) (e0 : env) (le0 : temp_env) \n  (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_long (prog_comp_env cunit) ty a0 b0 = OK c0 ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_long (prog_comp_env prog) ty va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c0 v0) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.add n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.add n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.add n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.add n1 n2))) va tya vb tyb m =\nSome v) (MAKE : make_binarith Oadd Oadd Oaddf Oaddfs Oaddl Oaddl a tya b tyb = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(A : forall (ty : type) (si : signedness) (a0 b0 c0 : expr) \n  (e0 : env) (le0 : temp_env) (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_int (prog_comp_env cunit) ty si a0 b0 = OK c0 ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_int (prog_comp_env prog) ty si va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c0 v0) (B : forall (ty : type) (a0 b0 c0 : expr) (e0 : env) (le0 : temp_env) \n  (m0 : mem) (va0 vb0 v0 : val),\nmake_add_ptr_long (prog_comp_env cunit) ty a0 b0 = OK c0 ->\neval_expr ge e0 le0 m0 a0 va0 ->\neval_expr ge e0 le0 m0 b0 vb0 ->\nsem_add_ptr_long (prog_comp_env prog) ty va0 vb0 = Some v0 ->\neval_expr ge e0 le0 m0 c0 v0) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.add n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.add n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.add n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.add n1 n2))) va tya vb tyb m =\nSome v) (MAKE : make_binarith Oadd Oadd Oaddf Oaddfs Oaddl Oaddl a tya b tyb = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"eapply make_binarith_correct; eauto; intros; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.sub n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    n2)))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.sub n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (cast_int_long si n2))))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Osubl a\n       (Ebinop Omull (make_longconst (Int64.repr x)) (make_longofint b si)))\n else OK (Ebinop Osub a (Ebinop Omul (make_intconst (Int.repr x)) b))) = \nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.sub n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    n2)))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.sub n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (cast_int_long si n2))))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Osubl a\n       (Ebinop Omull (make_longconst (Int64.repr x)) (make_longofint b si)))\n else OK (Ebinop Osub a (Ebinop Omul (make_intconst (Int.repr x)) b))) = \nOK c)","proofString":"destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).\ndestruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs.\ndestruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vlong\n             (Int64.sub n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (cast_int_long si n2))))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si))) v.","conclusion":"eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si))) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vlong\n             (Int64.sub n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (cast_int_long si n2))))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si)))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (make_longofint b si)))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Osubl (Vptr b0 i)\n  (Vlong\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_binop Osubl (Vptr b0 i)\n  (Vlong\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (cast_int_long si i0))))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (cast_int_long si i0))))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (cast_int_long si i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (cast_int_long si i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (cast_int_long si i0)))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0))).","conclusion":"Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (cast_int_long si i0)))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.sub i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0)).","conclusion":"Ptrofs.sub i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (cast_int_long si i0))) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\nassert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"assert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).\ndestruct si; simpl; apply Ptrofs.agree64_repr; auto.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0).","conclusion":"Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct si; simpl; apply Ptrofs.agree64_repr; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)) : Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (cast_int_long si i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0))","proofString":"auto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vint\n             (Int.sub n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   n2)))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  v.","conclusion":"eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vint\n             (Int.sub n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   n2)))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vint n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (ptrofs_of_int si n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))) b))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Osub (Vptr b0 i)\n  (Vint (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"eval_binop Osub (Vptr b0 i)\n  (Vint (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (ptrofs_of_int si i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0))).","conclusion":"Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (ptrofs_of_int si i0)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.sub i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0)).","conclusion":"Ptrofs.sub i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (ptrofs_of_int si i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\nassert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"assert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (ptrofs_of_int si i0) i0) : Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0).","conclusion":"Ptrofs.of_int (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (ptrofs_of_int si i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int) (e : env) (le : temp_env) (m : mem) (ty : type) (si : signedness) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vint i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (ptrofs_of_int si i0) i0)","proofString":"auto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if\n          zlt 0 (Ctypes.sizeof (prog_comp_env prog) ty) &&\n          zle (Ctypes.sizeof (prog_comp_env prog) ty) Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs\n               (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                  (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr x)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr x)))) = \nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if\n          zlt 0 (Ctypes.sizeof (prog_comp_env prog) ty) &&\n          zle (Ctypes.sizeof (prog_comp_env prog) ty) Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs\n               (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                  (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr x)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr x)))) = \nOK c)","proofString":"rewrite (transl_sizeof _ _ _ _ LINK EQ) in EQ0.\nclear EQ.\nset (sz := Ctypes.sizeof (prog_comp_env prog) ty) in *.\ndestruct va; InvEval; destruct vb; InvEval.\ndestruct (eq_block b0 b1); try discriminate.\ndestruct (zlt 0 sz); try discriminate.\ndestruct (zle sz Ptrofs.max_signed); simpl in SEM; inv SEM.\nassert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).\napply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia.\ndestruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if\n          zlt 0 (Ctypes.sizeof (prog_comp_env prog) ty) &&\n          zle (Ctypes.sizeof (prog_comp_env prog) ty) Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs\n               (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                  (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Odivl (Ebinop Osubl a b)\n       (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n else\n  OK\n    (Ebinop Odiv (Ebinop Osub a b)\n       (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))))) =\nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if\n          zlt 0 (Ctypes.sizeof (prog_comp_env prog) ty) &&\n          zle (Ctypes.sizeof (prog_comp_env prog) ty) Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs\n               (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                  (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Odivl (Ebinop Osubl a b)\n       (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n else\n  OK\n    (Ebinop Odiv (Ebinop Osub a b)\n       (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))))) =\nOK c)","proofString":"clear EQ.\nset (sz := Ctypes.sizeof (prog_comp_env prog) ty) in *.\ndestruct va; InvEval; destruct vb; InvEval.\ndestruct (eq_block b0 b1); try discriminate.\ndestruct (zlt 0 sz); try discriminate.\ndestruct (zle sz Ptrofs.max_signed); simpl in SEM; inv SEM.\nassert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).\napply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia.\ndestruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if\n          zlt 0 (Ctypes.sizeof (prog_comp_env prog) ty) &&\n          zle (Ctypes.sizeof (prog_comp_env prog) ty) Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs\n               (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                  (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Odivl (Ebinop Osubl a b)\n       (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n else\n  OK\n    (Ebinop Odiv (Ebinop Osub a b)\n       (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))))) =\nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if\n          zlt 0 (Ctypes.sizeof (prog_comp_env prog) ty) &&\n          zle (Ctypes.sizeof (prog_comp_env prog) ty) Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs\n               (Ptrofs.divs (Ptrofs.sub ofs1 ofs2)\n                  (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ0 : (if Archi.ptr64\n then\n  OK\n    (Ebinop Odivl (Ebinop Osubl a b)\n       (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))))\n else\n  OK\n    (Ebinop Odiv (Ebinop Osub a b)\n       (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))))) =\nOK c)","proofString":"set (sz := Ctypes.sizeof (prog_comp_env prog) ty) in *.\ndestruct va; InvEval; destruct vb; InvEval.\ndestruct (eq_block b0 b1); try discriminate.\ndestruct (zlt 0 sz); try discriminate.\ndestruct (zle sz Ptrofs.max_signed); simpl in SEM; inv SEM.\nassert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).\napply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia.\ndestruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if zlt 0 sz && zle sz Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs (Ptrofs.divs (Ptrofs.sub ofs1 ofs2) (Ptrofs.repr sz)))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (SEM : match va with\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vptr b2 ofs2 =>\n        if eq_block b1 b2\n        then\n         if zlt 0 sz && zle sz Ptrofs.max_signed\n         then\n          Some\n            (Vptrofs (Ptrofs.divs (Ptrofs.sub ofs1 ofs2) (Ptrofs.repr sz)))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c)","proofString":"destruct va; InvEval; destruct vb; InvEval.\ndestruct (eq_block b0 b1); try discriminate.\ndestruct (zlt 0 sz); try discriminate.\ndestruct (zle sz Ptrofs.max_signed); simpl in SEM; inv SEM.\nassert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).\napply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia.\ndestruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (SEM : (if eq_block b0 b1\n then\n  if zlt 0 sz && zle sz Ptrofs.max_signed\n  then Some (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))\n  else None\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (SEM : (if eq_block b0 b1\n then\n  if zlt 0 sz && zle sz Ptrofs.max_signed\n  then Some (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))\n  else None\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c)","proofString":"destruct (eq_block b0 b1); try discriminate.\ndestruct (zlt 0 sz); try discriminate.\ndestruct (zle sz Ptrofs.max_signed); simpl in SEM; inv SEM.\nassert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).\napply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia.\ndestruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (e0 : b0 = b1) (SEM : (if zlt 0 sz && zle sz Ptrofs.max_signed\n then Some (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (e0 : b0 = b1) (SEM : (if zlt 0 sz && zle sz Ptrofs.max_signed\n then Some (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c)","proofString":"destruct (zlt 0 sz); try discriminate.\ndestruct (zle sz Ptrofs.max_signed); simpl in SEM; inv SEM.\nassert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).\napply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia.\ndestruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) : eval_expr ge e le m c\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_expr ge e le m c\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c)","proofString":"assert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).\napply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia.\ndestruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) : Ptrofs.signed (Ptrofs.repr sz) = sz.","conclusion":"Ptrofs.signed (Ptrofs.repr sz) = sz","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c)","proofString":"apply Ptrofs.signed_repr.\ngeneralize Ptrofs.min_signed_neg; lia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) : Ptrofs.min_signed <= sz <= Ptrofs.max_signed.","conclusion":"Ptrofs.min_signed <= sz <= Ptrofs.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c)","proofString":"generalize Ptrofs.min_signed_neg; lia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : eval_expr ge e le m c\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_expr ge e le m c\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n else OK (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))) =\nOK c) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"destruct Archi.ptr64 eqn:SF; inversion EQ0; clear EQ0; subst c.\nassert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs.\nassert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : eval_expr ge e le m\n  (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_expr ge e le m\n  (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"assert (E: Int64.signed (Int64.repr sz) = sz).\napply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Int64.signed (Int64.repr sz) = sz.","conclusion":"Int64.signed (Int64.repr sz) = sz","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"apply Int64.signed_repr.\nreplace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Int64.min_signed <= sz <= Int64.max_signed.","conclusion":"Int64.min_signed <= sz <= Int64.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"replace Int64.max_signed with Ptrofs.max_signed.\ngeneralize Int64.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Int64.min_signed <= sz <= Ptrofs.max_signed.","conclusion":"Int64.min_signed <= sz <= Ptrofs.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"generalize Int64.min_signed_neg; lia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Ptrofs.max_signed = Int64.max_signed.","conclusion":"Ptrofs.max_signed = Int64.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"unfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto.\nreflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Int64.modulus / 2 - 1 = Int64.max_signed.","conclusion":"Int64.modulus / 2 - 1 = Int64.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"reflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) : eval_expr ge e le m\n  (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_expr ge e le m\n  (Ebinop Odivl (Ebinop Osubl a b) (make_longconst (Int64.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz)","proofString":"econstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) : eval_binop Odivl\n  (if negb Archi.ptr64\n   then Vundef\n   else\n    if eq_block b1 b1\n    then Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))\n    else Vundef) (Vlong (Int64.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_binop Odivl\n  (if negb Archi.ptr64\n   then Vundef\n   else\n    if eq_block b1 b1\n    then Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))\n    else Vundef) (Vlong (Int64.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz)","proofString":"rewrite SF, dec_eq_true.\nsimpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) : eval_binop Odivl\n  (if negb true then Vundef else Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0)))\n  (Vlong (Int64.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_binop Odivl\n  (if negb true then Vundef else Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0)))\n  (Vlong (Int64.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz)","proofString":"simpl.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) : (if\n  Int64.eq (Int64.repr sz) Int64.zero\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && Int64.eq (Int64.repr sz) Int64.mone\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  Int64.eq (Int64.repr sz) Int64.zero\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && Int64.eq (Int64.repr sz) Int64.mone\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz)","proofString":"predSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.\nrewrite H in E; rewrite Int64.signed_zero in E; extlia.\npredSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz = Int64.zero) : (if\n  true\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && Int64.eq (Int64.repr sz) Int64.mone\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  true\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && Int64.eq (Int64.repr sz) Int64.mone\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz = Int64.zero)","proofString":"rewrite H in E; rewrite Int64.signed_zero in E; extlia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) : (if\n  false\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && Int64.eq (Int64.repr sz) Int64.mone\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  false\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && Int64.eq (Int64.repr sz) Int64.mone\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero)","proofString":"predSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.\nrewrite H0 in E; rewrite Int64.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz = Int64.mone) : (if\n  false\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && true\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  false\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && true\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz = Int64.mone)","proofString":"rewrite H0 in E; rewrite Int64.signed_mone in E; extlia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone) : (if\n  false\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && false\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  false\n  || Int64.eq (Ptrofs.to_int64 (Ptrofs.sub i i0))\n       (Int64.repr Int64.min_signed) && false\n then None\n else\n  Some\n    (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone)","proofString":"rewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone) : Some (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"Some (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone)","proofString":"unfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone) : Some (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz))) =\nSome\n  (Vlong (Ptrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))).","conclusion":"Some (Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz))) =\nSome\n  (Vlong (Ptrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone)","proofString":"apply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone) : Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)) =\nVlong (Ptrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"Vlong (Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)) =\nVlong (Ptrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone)","proofString":"apply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone) : Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz) =\nPtrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)).","conclusion":"Int64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz) =\nPtrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone)","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone) : Ptrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)) =\nInt64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz).","conclusion":"Ptrofs.to_int64 (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)) =\nInt64.divs (Ptrofs.to_int64 (Ptrofs.sub i i0)) (Int64.repr sz)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = true) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int64.signed (Int64.repr sz) = sz) (H : Int64.repr sz <> Int64.zero) (H0 : Int64.repr sz <> Int64.mone)","proofString":"auto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : eval_expr ge e le m\n  (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_expr ge e le m\n  (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"assert (E: Int.signed (Int.repr sz) = sz).\napply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity.\neconstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Int.signed (Int.repr sz) = sz.","conclusion":"Int.signed (Int.repr sz) = sz","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"apply Int.signed_repr.\nreplace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Int.min_signed <= sz <= Int.max_signed.","conclusion":"Int.min_signed <= sz <= Int.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"replace Int.max_signed with Ptrofs.max_signed.\ngeneralize Int.min_signed_neg; lia.\nunfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Int.min_signed <= sz <= Ptrofs.max_signed.","conclusion":"Int.min_signed <= sz <= Ptrofs.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"generalize Int.min_signed_neg; lia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : Ptrofs.max_signed = Int.max_signed.","conclusion":"Ptrofs.max_signed = Int.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"unfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize.\nrewrite SF.\nreflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : two_power_nat (if Archi.ptr64 then 64%nat else 32%nat) / 2 - 1 =\nInt.max_signed.","conclusion":"two_power_nat (if Archi.ptr64 then 64%nat else 32%nat) / 2 - 1 =\nInt.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"rewrite SF.\nreflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) : two_power_nat 32 / 2 - 1 = Int.max_signed.","conclusion":"two_power_nat 32 / 2 - 1 = Int.max_signed","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz)","proofString":"reflexivity."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) : eval_expr ge e le m\n  (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_expr ge e le m\n  (Ebinop Odiv (Ebinop Osub a b) (make_intconst (Int.repr sz)))\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz)","proofString":"econstructor; eauto with cshm.\nrewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) : eval_binop Odiv\n  (if Archi.ptr64\n   then Vundef\n   else\n    if eq_block b1 b1 then Vint (Ptrofs.to_int (Ptrofs.sub i i0)) else Vundef)\n  (Vint (Int.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_binop Odiv\n  (if Archi.ptr64\n   then Vundef\n   else\n    if eq_block b1 b1 then Vint (Ptrofs.to_int (Ptrofs.sub i i0)) else Vundef)\n  (Vint (Int.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz)","proofString":"rewrite SF, dec_eq_true.\nsimpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) : eval_binop Odiv (Vint (Ptrofs.to_int (Ptrofs.sub i i0))) \n  (Vint (Int.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"eval_binop Odiv (Vint (Ptrofs.to_int (Ptrofs.sub i i0))) \n  (Vint (Int.repr sz)) m =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz)","proofString":"simpl.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) : (if\n  Int.eq (Int.repr sz) Int.zero\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     Int.eq (Int.repr sz) Int.mone\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  Int.eq (Int.repr sz) Int.zero\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     Int.eq (Int.repr sz) Int.mone\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz)","proofString":"predSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.\nrewrite H in E; rewrite Int.signed_zero in E; extlia.\npredSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz = Int.zero) : (if\n  true\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     Int.eq (Int.repr sz) Int.mone\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  true\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     Int.eq (Int.repr sz) Int.mone\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz = Int.zero)","proofString":"rewrite H in E; rewrite Int.signed_zero in E; extlia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) : (if\n  false\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     Int.eq (Int.repr sz) Int.mone\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  false\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     Int.eq (Int.repr sz) Int.mone\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero)","proofString":"predSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.\nrewrite H0 in E; rewrite Int.signed_mone in E; extlia.\nrewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz = Int.mone) : (if\n  false\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     true\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  false\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     true\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz = Int.mone)","proofString":"rewrite H0 in E; rewrite Int.signed_mone in E; extlia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone) : (if\n  false\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     false\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"(if\n  false\n  || Int.eq (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr Int.min_signed) &&\n     false\n then None\n else Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone)","proofString":"rewrite andb_false_r; simpl.\nunfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone) : Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz))) =\nSome (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone)","proofString":"unfold Vptrofs; rewrite SF.\napply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone) : Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz))) =\nSome (Vint (Ptrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))).","conclusion":"Some (Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz))) =\nSome (Vint (Ptrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone)","proofString":"apply f_equal.\napply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone) : Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)) =\nVint (Ptrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))).","conclusion":"Vint (Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)) =\nVint (Ptrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone)","proofString":"apply f_equal.\nsymmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone) : Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz) =\nPtrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)).","conclusion":"Int.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz) =\nPtrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone)","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone) : Ptrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)) =\nInt.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz).","conclusion":"Ptrofs.to_int (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr sz)) =\nInt.divs (Ptrofs.to_int (Ptrofs.sub i i0)) (Int.repr sz)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : ptrofs) (b1 : block) (i0 : ptrofs) (e : env) (le : temp_env) (m : mem) (ty : type) (sz : Z) (l : 0 < sz) (l0 : sz <= Ptrofs.max_signed) (EV1 : eval_expr ge e le m a (Vptr b1 i)) (EV2 : eval_expr ge e le m b (Vptr b1 i0)) (x : Z) (SF : Archi.ptr64 = false) (E1 : Ptrofs.signed (Ptrofs.repr sz) = sz) (E : Int.signed (Int.repr sz) = sz) (H : Int.repr sz <> Int.zero) (H0 : Int.repr sz <> Int.mone)","proofString":"auto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.sub n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.sub n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Osubl a (Ebinop Omull (make_longconst (Int64.repr x)) b))\n else\n  OK\n    (Ebinop Osub a\n       (Ebinop Omul (make_intconst (Int.repr x)) (Eunop Ointoflong b)))) =\nOK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then None\n        else\n         Some\n           (Vint\n              (Int.sub n1\n                 (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                    (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        if Archi.ptr64\n        then\n         Some\n           (Vlong\n              (Int64.sub n1\n                 (Int64.mul\n                    (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n        else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (EQ0 : (if Archi.ptr64\n then OK (Ebinop Osubl a (Ebinop Omull (make_longconst (Int64.repr x)) b))\n else\n  OK\n    (Ebinop Osub a\n       (Ebinop Omul (make_intconst (Int.repr x)) (Eunop Ointoflong b)))) =\nOK c)","proofString":"destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).\ndestruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nauto with ptrofs.\ndestruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vlong\n             (Int64.sub n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b)) v.","conclusion":"eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b)) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (SEM : match va with\n| Vint _ => match vb with\n            | Vundef | _ => None\n            end\n| Vlong n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vlong\n             (Int64.sub n1\n                (Int64.mul\n                   (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) n2)))\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Osubl a\n     (Ebinop Omull\n        (make_longconst (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        b))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Osubl (Vptr b0 i)\n  (Vlong (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))\n  m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_binop Osubl (Vptr b0 i)\n  (Vlong (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))\n  m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               i0)))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int64\n            (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               i0)))\n   else Vundef) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int64\n           (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\napply f_equal.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0))).","conclusion":"Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int64\n        (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.sub i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0)).","conclusion":"Ptrofs.sub i\n  (Ptrofs.of_int64\n     (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0)) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0).","conclusion":"Ptrofs.of_int64\n  (Int64.mul (Int64.repr (Ctypes.sizeof (prog_comp_env prog) ty)) i0) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = true) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"auto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vint\n             (Int.sub n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b))) v.","conclusion":"eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b))) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (SEM : match va with\n| Vint n1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vint\n             (Int.sub n1\n                (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Int.repr (Int64.unsigned n2)))))\n    | _ => None\n    end\n| Vlong _ => match vb with\n             | Vundef | _ => None\n             end\n| Vptr b1 ofs1 =>\n    match vb with\n    | Vlong n2 =>\n        Some\n          (Vptr b1\n             (Ptrofs.sub ofs1\n                (Ptrofs.mul\n                   (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n                   (Ptrofs.of_int64 n2))))\n    | _ => None\n    end\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.\neconstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b)))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Osub a\n     (Ebinop Omul\n        (make_intconst (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty)))\n        (Eunop Ointoflong b)))\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : eval_binop Osub (Vptr b0 i)\n  (Vint\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"eval_binop Osub (Vptr b0 i)\n  (Vint\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) m =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"simpl.\nrewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (if Archi.ptr64\n   then Vundef\n   else\n    Vptr b0\n      (Ptrofs.sub i\n         (Ptrofs.of_int\n            (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n               (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"rewrite SF.\napply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0)))).","conclusion":"Some\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.of_int\n           (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n              (Int64.loword i0))))) =\nSome\n  (Vptr b0\n     (Ptrofs.sub i\n        (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Ptrofs.of_int64 i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Int64.loword i0)))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0))).","conclusion":"Vptr b0\n  (Ptrofs.sub i\n     (Ptrofs.of_int\n        (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n           (Int64.loword i0)))) =\nVptr b0\n  (Ptrofs.sub i\n     (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Ptrofs.of_int64 i0)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\napply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.sub i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0)).","conclusion":"Ptrofs.sub i\n  (Ptrofs.of_int\n     (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n        (Int64.loword i0))) =\nPtrofs.sub i\n  (Ptrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Ptrofs.of_int64 i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"apply f_equal.\nassert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0).","conclusion":"Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"assert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).\nauto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) : Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0).","conclusion":"Ptrofs.of_int\n  (Int.mul (Int.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n     (Int64.loword i0)) =\nPtrofs.mul (Ptrofs.repr (Ctypes.sizeof (prog_comp_env prog) ty))\n  (Ptrofs.of_int64 i0)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (b0 : block) (i : ptrofs) (i0 : int64) (e : env) (le : temp_env) (m : mem) (ty : type) (SF : Archi.ptr64 = false) (EV1 : eval_expr ge e le m a (Vptr b0 i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (H : Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0))","proofString":"auto with ptrofs."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.sub n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.sub n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.sub n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.sub n1 n2))) va tya vb tyb m =\nSome v) (MAKE : make_binarith Osub Osub Osubf Osubfs Osubl Osubl a tya b tyb = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.sub n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.sub n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.sub n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.sub n1 n2))) va tya vb tyb m =\nSome v) (MAKE : make_binarith Osub Osub Osubf Osubfs Osubl Osubl a tya b tyb = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"eapply make_binarith_correct; eauto; intros; auto."},{"statement":"(i : int64) (H : Int64.ltu i Int64.iwordsize = true) : Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i).","conclusion":"Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i)","hypotheses":"(i : int64) (H : Int64.ltu i Int64.iwordsize = true)","proofString":"apply Int64.ltu_inv in H.\ncomput (Int64.unsigned Int64.iwordsize).\nassert (Int64.unsigned i = Int.unsigned (Int64.loword i)).\nunfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia.\nsplit; auto.\nunfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < Int64.unsigned Int64.iwordsize) : Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i).","conclusion":"Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i)","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < Int64.unsigned Int64.iwordsize)","proofString":"comput (Int64.unsigned Int64.iwordsize).\nassert (Int64.unsigned i = Int.unsigned (Int64.loword i)).\nunfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia.\nsplit; auto.\nunfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) : Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i).","conclusion":"Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i)","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64)","proofString":"assert (Int64.unsigned i = Int.unsigned (Int64.loword i)).\nunfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia.\nsplit; auto.\nunfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) : Int64.unsigned i = Int.unsigned (Int64.loword i).","conclusion":"Int64.unsigned i = Int.unsigned (Int64.loword i)","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64)","proofString":"unfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) : Int64.unsigned i = Int.unsigned (Int.repr (Int64.unsigned i)).","conclusion":"Int64.unsigned i = Int.unsigned (Int.repr (Int64.unsigned i))","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64)","proofString":"rewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) : 0 <= Int64.unsigned i <= Int.max_unsigned.","conclusion":"0 <= Int64.unsigned i <= Int.max_unsigned","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64)","proofString":"comput Int.max_unsigned; lia."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i).","conclusion":"Int.ltu (Int64.loword i) Int64.iwordsize' = true /\\\nInt64.unsigned i = Int.unsigned (Int64.loword i)","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"split; auto.\nunfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : Int.ltu (Int64.loword i) Int64.iwordsize' = true.","conclusion":"Int.ltu (Int64.loword i) Int64.iwordsize' = true","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"unfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : (if zlt (Int.unsigned (Int64.loword i)) (Int.unsigned Int64.iwordsize')\n then true\n else false) = true.","conclusion":"(if zlt (Int.unsigned (Int64.loword i)) (Int.unsigned Int64.iwordsize')\n then true\n else false) = true","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"apply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : Int.unsigned (Int64.loword i) < Int.unsigned Int64.iwordsize'.","conclusion":"Int.unsigned (Int64.loword i) < Int.unsigned Int64.iwordsize'","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"rewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : Int64.unsigned i < Int.unsigned Int64.iwordsize'.","conclusion":"Int64.unsigned i < Int.unsigned Int64.iwordsize'","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 64) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"tauto."},{"statement":"(i : int64) (H : Int64.ltu i (Int64.repr 32) = true) : Int.ltu (Int64.loword i) Int.iwordsize = true.","conclusion":"Int.ltu (Int64.loword i) Int.iwordsize = true","hypotheses":"(i : int64) (H : Int64.ltu i (Int64.repr 32) = true)","proofString":"apply Int64.ltu_inv in H.\ncomput (Int64.unsigned (Int64.repr 32)).\nassert (Int64.unsigned i = Int.unsigned (Int64.loword i)).\nunfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia.\nunfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < Int64.unsigned (Int64.repr 32)) : Int.ltu (Int64.loword i) Int.iwordsize = true.","conclusion":"Int.ltu (Int64.loword i) Int.iwordsize = true","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < Int64.unsigned (Int64.repr 32))","proofString":"comput (Int64.unsigned (Int64.repr 32)).\nassert (Int64.unsigned i = Int.unsigned (Int64.loword i)).\nunfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia.\nunfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) : Int.ltu (Int64.loword i) Int.iwordsize = true.","conclusion":"Int.ltu (Int64.loword i) Int.iwordsize = true","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32)","proofString":"assert (Int64.unsigned i = Int.unsigned (Int64.loword i)).\nunfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia.\nunfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) : Int64.unsigned i = Int.unsigned (Int64.loword i).","conclusion":"Int64.unsigned i = Int.unsigned (Int64.loword i)","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32)","proofString":"unfold Int64.loword.\nrewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) : Int64.unsigned i = Int.unsigned (Int.repr (Int64.unsigned i)).","conclusion":"Int64.unsigned i = Int.unsigned (Int.repr (Int64.unsigned i))","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32)","proofString":"rewrite Int.unsigned_repr; auto.\ncomput Int.max_unsigned; lia."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) : 0 <= Int64.unsigned i <= Int.max_unsigned.","conclusion":"0 <= Int64.unsigned i <= Int.max_unsigned","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32)","proofString":"comput Int.max_unsigned; lia."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : Int.ltu (Int64.loword i) Int.iwordsize = true.","conclusion":"Int.ltu (Int64.loword i) Int.iwordsize = true","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"unfold Int.ltu.\napply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : (if zlt (Int.unsigned (Int64.loword i)) (Int.unsigned Int.iwordsize)\n then true\n else false) = true.","conclusion":"(if zlt (Int.unsigned (Int64.loword i)) (Int.unsigned Int.iwordsize)\n then true\n else false) = true","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"apply zlt_true.\nrewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : Int.unsigned (Int64.loword i) < Int.unsigned Int.iwordsize.","conclusion":"Int.unsigned (Int64.loword i) < Int.unsigned Int.iwordsize","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"rewrite <- H0.\ntauto."},{"statement":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i)) : Int64.unsigned i < Int.unsigned Int.iwordsize.","conclusion":"Int64.unsigned i < Int.unsigned Int.iwordsize","hypotheses":"(i : int64) (H : 0 <= Int64.unsigned i < 32) (H0 : Int64.unsigned i = Int.unsigned (Int64.loword i))","proofString":"tauto."},{"statement":"(i : int) (H : Int.ltu i Int64.iwordsize' = true) : Int64.unsigned (Int64.repr (Int.unsigned i)) = Int.unsigned i.","conclusion":"Int64.unsigned (Int64.repr (Int.unsigned i)) = Int.unsigned i","hypotheses":"(i : int) (H : Int.ltu i Int64.iwordsize' = true)","proofString":"apply Int.ltu_inv in H.\ncomput (Int.unsigned Int64.iwordsize').\napply Int64.unsigned_repr.\ncomput Int64.max_unsigned; lia."},{"statement":"(i : int) (H : 0 <= Int.unsigned i < Int.unsigned Int64.iwordsize') : Int64.unsigned (Int64.repr (Int.unsigned i)) = Int.unsigned i.","conclusion":"Int64.unsigned (Int64.repr (Int.unsigned i)) = Int.unsigned i","hypotheses":"(i : int) (H : 0 <= Int.unsigned i < Int.unsigned Int64.iwordsize')","proofString":"comput (Int.unsigned Int64.iwordsize').\napply Int64.unsigned_repr.\ncomput Int64.max_unsigned; lia."},{"statement":"(i : int) (H : 0 <= Int.unsigned i < 64) : Int64.unsigned (Int64.repr (Int.unsigned i)) = Int.unsigned i.","conclusion":"Int64.unsigned (Int64.repr (Int.unsigned i)) = Int.unsigned i","hypotheses":"(i : int) (H : 0 <= Int.unsigned i < 64)","proofString":"apply Int64.unsigned_repr.\ncomput Int64.max_unsigned; lia."},{"statement":"(i : int) (H : 0 <= Int.unsigned i < 64) : 0 <= Int.unsigned i <= Int64.max_unsigned.","conclusion":"0 <= Int.unsigned i <= Int64.max_unsigned","hypotheses":"(i : int) (H : 0 <= Int.unsigned i < 64)","proofString":"comput Int64.max_unsigned; lia."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int.iwordsize then Some (Vint (Int.shl i i0)) else None) =\nSome v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) : eval_expr ge e le m (Ebinop Oshl a b) v.","conclusion":"eval_expr ge e le m (Ebinop Oshl a b) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int.iwordsize then Some (Vint (Int.shl i i0)) else None) =\nSome v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"destruct (Int.ltu i0 Int.iwordsize) eqn:E; inv SEM.\neconstructor; eauto.\nsimpl; rewrite E; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int.iwordsize = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) : eval_expr ge e le m (Ebinop Oshl a b) (Vint (Int.shl i i0)).","conclusion":"eval_expr ge e le m (Ebinop Oshl a b) (Vint (Int.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int.iwordsize = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"econstructor; eauto.\nsimpl; rewrite E; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int.iwordsize = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) : eval_binop Oshl (Vint i) (Vint i0) m = Some (Vint (Int.shl i i0)).","conclusion":"eval_binop Oshl (Vint i) (Vint i0) m = Some (Vint (Int.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int.iwordsize = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"simpl; rewrite E; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 Int64.iwordsize then Some (Vlong (Int64.shl i i0)) else None) =\nSome v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) : eval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b)) v.","conclusion":"eval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b)) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 Int64.iwordsize then Some (Vlong (Int64.shl i i0)) else None) =\nSome v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0))","proofString":"destruct (Int64.ltu i0 Int64.iwordsize) eqn:E; inv SEM.\nexploit small_shift_amount_1; eauto.\nintros [A B].\neconstructor; eauto with cshm.\nsimpl.\nrewrite A.\nf_equal; f_equal.\nunfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) : eval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b))\n  (Vlong (Int64.shl i i0)).","conclusion":"eval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b))\n  (Vlong (Int64.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0))","proofString":"exploit small_shift_amount_1; eauto.\nintros [A B].\neconstructor; eauto with cshm.\nsimpl.\nrewrite A.\nf_equal; f_equal.\nunfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) : Int.ltu (Int64.loword i0) Int64.iwordsize' = true /\\\nInt64.unsigned i0 = Int.unsigned (Int64.loword i0) ->\neval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b))\n  (Vlong (Int64.shl i i0)).","conclusion":"Int.ltu (Int64.loword i0) Int64.iwordsize' = true /\\\nInt64.unsigned i0 = Int.unsigned (Int64.loword i0) ->\neval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b))\n  (Vlong (Int64.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0))","proofString":"intros [A B].\neconstructor; eauto with cshm.\nsimpl.\nrewrite A.\nf_equal; f_equal.\nunfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : eval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b))\n  (Vlong (Int64.shl i i0)).","conclusion":"eval_expr ge e le m (Ebinop Oshll a (Eunop Ointoflong b))\n  (Vlong (Int64.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite A.\nf_equal; f_equal.\nunfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : eval_binop Oshll (Vlong i) (Vint (Int64.loword i0)) m =\nSome (Vlong (Int64.shl i i0)).","conclusion":"eval_binop Oshll (Vlong i) (Vint (Int64.loword i0)) m =\nSome (Vlong (Int64.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"simpl.\nrewrite A.\nf_equal; f_equal.\nunfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : Some\n  (if Int.ltu (Int64.loword i0) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int64.loword i0))\n   else Vundef) = Some (Vlong (Int64.shl i i0)).","conclusion":"Some\n  (if Int.ltu (Int64.loword i0) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int64.loword i0))\n   else Vundef) = Some (Vlong (Int64.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"rewrite A.\nf_equal; f_equal.\nunfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : Some (Vlong (Int64.shl' i (Int64.loword i0))) = Some (Vlong (Int64.shl i i0)).","conclusion":"Some (Vlong (Int64.shl' i (Int64.loword i0))) = Some (Vlong (Int64.shl i i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"f_equal; f_equal.\nunfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : Int64.shl' i (Int64.loword i0) = Int64.shl i i0.","conclusion":"Int64.shl' i (Int64.loword i0) = Int64.shl i i0","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"unfold Int64.shl', Int64.shl.\nrewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : Int64.repr (Z.shiftl (Int64.unsigned i) (Int.unsigned (Int64.loword i0))) =\nInt64.repr (Z.shiftl (Int64.unsigned i) (Int64.unsigned i0)).","conclusion":"Int64.repr (Z.shiftl (Int64.unsigned i) (Int.unsigned (Int64.loword i0))) =\nInt64.repr (Z.shiftl (Int64.unsigned i) (Int64.unsigned i0))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"rewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 (Int64.repr 32)\n then Some (Vint (Int.shl i (Int64.loword i0)))\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) : eval_expr ge e le m (Ebinop Oshl a (Eunop Ointoflong b)) v.","conclusion":"eval_expr ge e le m (Ebinop Oshl a (Eunop Ointoflong b)) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 (Int64.repr 32)\n then Some (Vint (Int.shl i (Int64.loword i0)))\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0))","proofString":"destruct (Int64.ltu i0 (Int64.repr 32)) eqn:E; inv SEM.\neconstructor; eauto with cshm.\nsimpl.\nrewrite small_shift_amount_2; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) : eval_expr ge e le m (Ebinop Oshl a (Eunop Ointoflong b))\n  (Vint (Int.shl i (Int64.loword i0))).","conclusion":"eval_expr ge e le m (Ebinop Oshl a (Eunop Ointoflong b))\n  (Vint (Int.shl i (Int64.loword i0)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0))","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite small_shift_amount_2; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) : eval_binop Oshl (Vint i) (Vint (Int64.loword i0)) m =\nSome (Vint (Int.shl i (Int64.loword i0))).","conclusion":"eval_binop Oshl (Vint i) (Vint (Int64.loword i0)) m =\nSome (Vint (Int.shl i (Int64.loword i0)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0))","proofString":"simpl.\nrewrite small_shift_amount_2; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) : Some\n  (if Int.ltu (Int64.loword i0) Int.iwordsize\n   then Vint (Int.shl i (Int64.loword i0))\n   else Vundef) = Some (Vint (Int.shl i (Int64.loword i0))).","conclusion":"Some\n  (if Int.ltu (Int64.loword i0) Int.iwordsize\n   then Vint (Int.shl i (Int64.loword i0))\n   else Vundef) = Some (Vint (Int.shl i (Int64.loword i0)))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0))","proofString":"rewrite small_shift_amount_2; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int64.iwordsize'\n then Some (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0))))\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : eval_expr ge e le m (Ebinop Oshll a b) v.","conclusion":"eval_expr ge e le m (Ebinop Oshll a b) v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int64.iwordsize'\n then Some (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0))))\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"destruct (Int.ltu i0 Int64.iwordsize') eqn:E; inv SEM.\neconstructor; eauto with cshm.\nsimpl.\nrewrite E.\nunfold Int64.shl', Int64.shl.\nrewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : eval_expr ge e le m (Ebinop Oshll a b)\n  (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0)))).","conclusion":"eval_expr ge e le m (Ebinop Oshll a b)\n  (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"econstructor; eauto with cshm.\nsimpl.\nrewrite E.\nunfold Int64.shl', Int64.shl.\nrewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : eval_binop Oshll (Vlong i) (Vint i0) m =\nSome (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0)))).","conclusion":"eval_binop Oshll (Vlong i) (Vint i0) m =\nSome (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"simpl.\nrewrite E.\nunfold Int64.shl', Int64.shl.\nrewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : Some\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef) =\nSome (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0)))).","conclusion":"Some\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef) =\nSome (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"rewrite E.\nunfold Int64.shl', Int64.shl.\nrewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : Some (Vlong (Int64.shl' i i0)) =\nSome (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0)))).","conclusion":"Some (Vlong (Int64.shl' i i0)) =\nSome (Vlong (Int64.shl i (Int64.repr (Int.unsigned i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"unfold Int64.shl', Int64.shl.\nrewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : Some (Vlong (Int64.repr (Z.shiftl (Int64.unsigned i) (Int.unsigned i0)))) =\nSome\n  (Vlong\n     (Int64.repr\n        (Z.shiftl (Int64.unsigned i)\n           (Int64.unsigned (Int64.repr (Int.unsigned i0)))))).","conclusion":"Some (Vlong (Int64.repr (Z.shiftl (Int64.unsigned i) (Int.unsigned i0)))) =\nSome\n  (Vlong\n     (Int64.repr\n        (Z.shiftl (Int64.unsigned i)\n           (Int64.unsigned (Int64.repr (Int.unsigned i0))))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"rewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int.iwordsize\n then\n  Some\n    (Vint\n       match s with\n       | Signed => Int.shr i i0\n       | Unsigned => Int.shru i i0\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a b)\n| Unsigned => OK (Ebinop Oshru a b)\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int.iwordsize\n then\n  Some\n    (Vint\n       match s with\n       | Signed => Int.shr i i0\n       | Unsigned => Int.shru i i0\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a b)\n| Unsigned => OK (Ebinop Oshru a b)\nend = OK c)","proofString":"destruct (Int.ltu i0 Int.iwordsize) eqn:E; inv SEM.\ndestruct s; inv H0; econstructor; eauto; simpl; rewrite E; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int.iwordsize = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a b)\n| Unsigned => OK (Ebinop Oshru a b)\nend = OK c) : eval_expr ge e le m c\n  (Vint match s with\n        | Signed => Int.shr i i0\n        | Unsigned => Int.shru i i0\n        end).","conclusion":"eval_expr ge e le m c\n  (Vint match s with\n        | Signed => Int.shr i i0\n        | Unsigned => Int.shru i i0\n        end)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int.iwordsize = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a b)\n| Unsigned => OK (Ebinop Oshru a b)\nend = OK c)","proofString":"destruct s; inv H0; econstructor; eauto; simpl; rewrite E; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 Int64.iwordsize\n then\n  Some\n    (Vlong\n       match s with\n       | Signed => Int64.shr i i0\n       | Unsigned => Int64.shru i i0\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 Int64.iwordsize\n then\n  Some\n    (Vlong\n       match s with\n       | Signed => Int64.shr i i0\n       | Unsigned => Int64.shru i i0\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c)","proofString":"destruct (Int64.ltu i0 Int64.iwordsize) eqn:E; inv SEM.\nexploit small_shift_amount_1; eauto.\nintros [A B].\ndestruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite A;  f_equal; f_equal.\nunfold Int64.shr', Int64.shr; rewrite B; auto.\nunfold Int64.shru', Int64.shru; rewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c) : eval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i i0\n     | Unsigned => Int64.shru i i0\n     end).","conclusion":"eval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i i0\n     | Unsigned => Int64.shru i i0\n     end)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c)","proofString":"exploit small_shift_amount_1; eauto.\nintros [A B].\ndestruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite A;  f_equal; f_equal.\nunfold Int64.shr', Int64.shr; rewrite B; auto.\nunfold Int64.shru', Int64.shru; rewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c) : Int.ltu (Int64.loword i0) Int64.iwordsize' = true /\\\nInt64.unsigned i0 = Int.unsigned (Int64.loword i0) ->\neval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i i0\n     | Unsigned => Int64.shru i i0\n     end).","conclusion":"Int.ltu (Int64.loword i0) Int64.iwordsize' = true /\\\nInt64.unsigned i0 = Int.unsigned (Int64.loword i0) ->\neval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i i0\n     | Unsigned => Int64.shru i i0\n     end)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c)","proofString":"intros [A B].\ndestruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite A;  f_equal; f_equal.\nunfold Int64.shr', Int64.shr; rewrite B; auto.\nunfold Int64.shru', Int64.shru; rewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : eval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i i0\n     | Unsigned => Int64.shru i i0\n     end).","conclusion":"eval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i i0\n     | Unsigned => Int64.shru i i0\n     end)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshrlu a (Eunop Ointoflong b))\nend = OK c) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite A;  f_equal; f_equal.\nunfold Int64.shr', Int64.shr; rewrite B; auto.\nunfold Int64.shru', Int64.shru; rewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : Int64.shr' i (Int64.loword i0) = Int64.shr i i0.","conclusion":"Int64.shr' i (Int64.loword i0) = Int64.shr i i0","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"unfold Int64.shr', Int64.shr; rewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0)) : Int64.shru' i (Int64.loword i0) = Int64.shru i i0.","conclusion":"Int64.shru' i (Int64.loword i0) = Int64.shru i i0","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i i0 : int64) (e : env) (le : temp_env) (m : mem) (E : Int64.ltu i0 Int64.iwordsize = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (A : Int.ltu (Int64.loword i0) Int64.iwordsize' = true) (B : Int64.unsigned i0 = Int.unsigned (Int64.loword i0))","proofString":"unfold Int64.shru', Int64.shru; rewrite B; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int) (i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 (Int64.repr 32)\n then\n  Some\n    (Vint\n       match s with\n       | Signed => Int.shr i (Int64.loword i0)\n       | Unsigned => Int.shru i (Int64.loword i0)\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshru a (Eunop Ointoflong b))\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int) (i0 : int64) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int64.ltu i0 (Int64.repr 32)\n then\n  Some\n    (Vint\n       match s with\n       | Signed => Int.shr i (Int64.loword i0)\n       | Unsigned => Int.shru i (Int64.loword i0)\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshru a (Eunop Ointoflong b))\nend = OK c)","proofString":"destruct (Int64.ltu i0 (Int64.repr 32)) eqn:E; inv SEM.\ndestruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite small_shift_amount_2; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshru a (Eunop Ointoflong b))\nend = OK c) : eval_expr ge e le m c\n  (Vint\n     match s with\n     | Signed => Int.shr i (Int64.loword i0)\n     | Unsigned => Int.shru i (Int64.loword i0)\n     end).","conclusion":"eval_expr ge e le m c\n  (Vint\n     match s with\n     | Signed => Int.shr i (Int64.loword i0)\n     | Unsigned => Int.shru i (Int64.loword i0)\n     end)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int) (i0 : int64) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int64.ltu i0 (Int64.repr 32) = true) (EV1 : eval_expr ge e le m a (Vint i)) (EV2 : eval_expr ge e le m b (Vlong i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshr a (Eunop Ointoflong b))\n| Unsigned => OK (Ebinop Oshru a (Eunop Ointoflong b))\nend = OK c)","proofString":"destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite small_shift_amount_2; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int64) (i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int64.iwordsize'\n then\n  Some\n    (Vlong\n       match s with\n       | Signed => Int64.shr i (Int64.repr (Int.unsigned i0))\n       | Unsigned => Int64.shru i (Int64.repr (Int.unsigned i0))\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a b)\n| Unsigned => OK (Ebinop Oshrlu a b)\nend = OK c) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int64) (i0 : int) (v : val) (e : env) (le : temp_env) (m : mem) (s : signedness) (SEM : (if Int.ltu i0 Int64.iwordsize'\n then\n  Some\n    (Vlong\n       match s with\n       | Signed => Int64.shr i (Int64.repr (Int.unsigned i0))\n       | Unsigned => Int64.shru i (Int64.repr (Int.unsigned i0))\n       end)\n else None) = Some v) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a b)\n| Unsigned => OK (Ebinop Oshrlu a b)\nend = OK c)","proofString":"destruct (Int.ltu i0 Int64.iwordsize') eqn:E; inv SEM.\ndestruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite E.\nunfold Int64.shr', Int64.shr; rewrite small_shift_amount_3; auto.\nunfold Int64.shru', Int64.shru; rewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a b)\n| Unsigned => OK (Ebinop Oshrlu a b)\nend = OK c) : eval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i (Int64.repr (Int.unsigned i0))\n     | Unsigned => Int64.shru i (Int64.repr (Int.unsigned i0))\n     end).","conclusion":"eval_expr ge e le m c\n  (Vlong\n     match s with\n     | Signed => Int64.shr i (Int64.repr (Int.unsigned i0))\n     | Unsigned => Int64.shru i (Int64.repr (Int.unsigned i0))\n     end)","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (s : signedness) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) (H0 : match s with\n| Signed => OK (Ebinop Oshrl a b)\n| Unsigned => OK (Ebinop Oshrlu a b)\nend = OK c)","proofString":"destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite E.\nunfold Int64.shr', Int64.shr; rewrite small_shift_amount_3; auto.\nunfold Int64.shru', Int64.shru; rewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : Some (Vlong (Int64.shr' i i0)) =\nSome (Vlong (Int64.shr i (Int64.repr (Int.unsigned i0)))).","conclusion":"Some (Vlong (Int64.shr' i i0)) =\nSome (Vlong (Int64.shr i (Int64.repr (Int.unsigned i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"unfold Int64.shr', Int64.shr; rewrite small_shift_amount_3; auto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0)) : Some (Vlong (Int64.shru' i i0)) =\nSome (Vlong (Int64.shru i (Int64.repr (Int.unsigned i0)))).","conclusion":"Some (Vlong (Int64.shru' i i0)) =\nSome (Vlong (Int64.shru i (Int64.repr (Int.unsigned i0))))","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (i : int64) (i0 : int) (e : env) (le : temp_env) (m : mem) (E : Int.ltu i0 Int64.iwordsize' = true) (EV1 : eval_expr ge e le m a (Vlong i)) (EV2 : eval_expr ge e le m b (Vint i0))","proofString":"unfold Int64.shru', Int64.shru; rewrite small_shift_amount_3; auto."},{"statement":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool\n  (if Archi.ptr64\n   then Val.cmplu_bool (Mem.valid_pointer m) cmp va vb\n   else Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) = \nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb) : eval_expr ge e le m\n  (Ebinop (if Archi.ptr64 then Ocmplu cmp else Ocmpu cmp) a b) v.","conclusion":"eval_expr ge e le m\n  (Ebinop (if Archi.ptr64 then Ocmplu cmp else Ocmpu cmp) a b) v","hypotheses":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool\n  (if Archi.ptr64\n   then Val.cmplu_bool (Mem.valid_pointer m) cmp va vb\n   else Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) = \nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb)","proofString":"destruct Archi.ptr64.\neconstructor; eauto.\neconstructor; eauto.\nsimpl.\nunfold Val.cmpu.\ndestruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bo|]; inv H.\nauto."},{"statement":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb) : eval_expr ge e le m (Ebinop (Ocmplu cmp) a b) v.","conclusion":"eval_expr ge e le m (Ebinop (Ocmplu cmp) a b) v","hypotheses":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb)","proofString":"econstructor; eauto."},{"statement":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb) : eval_expr ge e le m (Ebinop (Ocmpu cmp) a b) v.","conclusion":"eval_expr ge e le m (Ebinop (Ocmpu cmp) a b) v","hypotheses":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb)","proofString":"econstructor; eauto.\nsimpl.\nunfold Val.cmpu.\ndestruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bo|]; inv H.\nauto."},{"statement":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb) : eval_binop (Ocmpu cmp) va vb m = Some v.","conclusion":"eval_binop (Ocmpu cmp) va vb m = Some v","hypotheses":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb)","proofString":"simpl.\nunfold Val.cmpu.\ndestruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bo|]; inv H.\nauto."},{"statement":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb) : Some (Val.cmpu (Mem.valid_pointer m) cmp va vb) = Some v.","conclusion":"Some (Val.cmpu (Mem.valid_pointer m) cmp va vb) = Some v","hypotheses":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb)","proofString":"unfold Val.cmpu.\ndestruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bo|]; inv H.\nauto."},{"statement":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb) : Some (Val.of_optbool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb)) =\nSome v.","conclusion":"Some (Val.of_optbool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb)) =\nSome v","hypotheses":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb v : val) (H : option_map Val.of_bool (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) =\nSome v) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb)","proofString":"destruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bo|]; inv H.\nauto."},{"statement":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb : val) (bo : bool) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb) : Some (Val.of_optbool (Some bo)) = Some (Val.of_bool bo).","conclusion":"Some (Val.of_optbool (Some bo)) = Some (Val.of_bool bo)","hypotheses":"(cmp : comparison) (e : env) (le : temp_env) (m : mem) (a : expr) (va : val) (b : expr) (vb : val) (bo : bool) (H0 : eval_expr ge e le m a va) (H1 : eval_expr ge e le m b vb)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) : eval_expr ge e le m (if Archi.ptr64 then make_longofint a si else a)\n  (Vptrofs (ptrofs_of_int si i)).","conclusion":"eval_expr ge e le m (if Archi.ptr64 then make_longofint a si else a)\n  (Vptrofs (ptrofs_of_int si i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i))","proofString":"unfold Vptrofs, ptrofs_of_int.\ndestruct Archi.ptr64 eqn:SF.\nunfold make_longofint.\ndestruct si.\nreplace (Ptrofs.to_int64 (Ptrofs.of_ints i)) with (Int64.repr (Int.signed i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr.\nreplace (Ptrofs.to_int64 (Ptrofs.of_intu i)) with (Int64.repr (Int.unsigned i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr.\ndestruct si.\nreplace (Ptrofs.to_int (Ptrofs.of_ints i)) with i.\nauto.\nsymmetry.\nauto with ptrofs.\nreplace (Ptrofs.to_int (Ptrofs.of_intu i)) with i.\nauto.\nsymmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) : eval_expr ge e le m (if Archi.ptr64 then make_longofint a si else a)\n  (if Archi.ptr64\n   then\n    Vlong\n      (Ptrofs.to_int64\n         match si with\n         | Signed => Ptrofs.of_ints i\n         | Unsigned => Ptrofs.of_intu i\n         end)\n   else\n    Vint\n      (Ptrofs.to_int\n         match si with\n         | Signed => Ptrofs.of_ints i\n         | Unsigned => Ptrofs.of_intu i\n         end)).","conclusion":"eval_expr ge e le m (if Archi.ptr64 then make_longofint a si else a)\n  (if Archi.ptr64\n   then\n    Vlong\n      (Ptrofs.to_int64\n         match si with\n         | Signed => Ptrofs.of_ints i\n         | Unsigned => Ptrofs.of_intu i\n         end)\n   else\n    Vint\n      (Ptrofs.to_int\n         match si with\n         | Signed => Ptrofs.of_ints i\n         | Unsigned => Ptrofs.of_intu i\n         end))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i))","proofString":"destruct Archi.ptr64 eqn:SF.\nunfold make_longofint.\ndestruct si.\nreplace (Ptrofs.to_int64 (Ptrofs.of_ints i)) with (Int64.repr (Int.signed i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr.\nreplace (Ptrofs.to_int64 (Ptrofs.of_intu i)) with (Int64.repr (Int.unsigned i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr.\ndestruct si.\nreplace (Ptrofs.to_int (Ptrofs.of_ints i)) with i.\nauto.\nsymmetry.\nauto with ptrofs.\nreplace (Ptrofs.to_int (Ptrofs.of_intu i)) with i.\nauto.\nsymmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m (make_longofint a si)\n  (Vlong\n     (Ptrofs.to_int64\n        match si with\n        | Signed => Ptrofs.of_ints i\n        | Unsigned => Ptrofs.of_intu i\n        end)).","conclusion":"eval_expr ge e le m (make_longofint a si)\n  (Vlong\n     (Ptrofs.to_int64\n        match si with\n        | Signed => Ptrofs.of_ints i\n        | Unsigned => Ptrofs.of_intu i\n        end))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"unfold make_longofint.\ndestruct si.\nreplace (Ptrofs.to_int64 (Ptrofs.of_ints i)) with (Int64.repr (Int.signed i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr.\nreplace (Ptrofs.to_int64 (Ptrofs.of_intu i)) with (Int64.repr (Int.unsigned i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m\n  match si with\n  | Signed => Eunop Olongofint a\n  | Unsigned => Eunop Olongofintu a\n  end\n  (Vlong\n     (Ptrofs.to_int64\n        match si with\n        | Signed => Ptrofs.of_ints i\n        | Unsigned => Ptrofs.of_intu i\n        end)).","conclusion":"eval_expr ge e le m\n  match si with\n  | Signed => Eunop Olongofint a\n  | Unsigned => Eunop Olongofintu a\n  end\n  (Vlong\n     (Ptrofs.to_int64\n        match si with\n        | Signed => Ptrofs.of_ints i\n        | Unsigned => Ptrofs.of_intu i\n        end))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"destruct si.\nreplace (Ptrofs.to_int64 (Ptrofs.of_ints i)) with (Int64.repr (Int.signed i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr.\nreplace (Ptrofs.to_int64 (Ptrofs.of_intu i)) with (Int64.repr (Int.unsigned i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m (Eunop Olongofint a)\n  (Vlong (Ptrofs.to_int64 (Ptrofs.of_ints i))).","conclusion":"eval_expr ge e le m (Eunop Olongofint a)\n  (Vlong (Ptrofs.to_int64 (Ptrofs.of_ints i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"replace (Ptrofs.to_int64 (Ptrofs.of_ints i)) with (Int64.repr (Int.signed i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m (Eunop Olongofint a) (Vlong (Int64.repr (Int.signed i))).","conclusion":"eval_expr ge e le m (Eunop Olongofint a) (Vlong (Int64.repr (Int.signed i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : Int64.repr (Int.signed i) = Ptrofs.to_int64 (Ptrofs.of_ints i).","conclusion":"Int64.repr (Int.signed i) = Ptrofs.to_int64 (Ptrofs.of_ints i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"apply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : Int64.eqm (Int.signed i) (Ptrofs.unsigned (Ptrofs.of_ints i)).","conclusion":"Int64.eqm (Int.signed i) (Ptrofs.unsigned (Ptrofs.of_ints i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"rewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : Ptrofs.eqm (Int.signed i) (Ptrofs.unsigned (Ptrofs.of_ints i)).","conclusion":"Ptrofs.eqm (Int.signed i) (Ptrofs.unsigned (Ptrofs.of_ints i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"apply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m (Eunop Olongofintu a)\n  (Vlong (Ptrofs.to_int64 (Ptrofs.of_intu i))).","conclusion":"eval_expr ge e le m (Eunop Olongofintu a)\n  (Vlong (Ptrofs.to_int64 (Ptrofs.of_intu i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"replace (Ptrofs.to_int64 (Ptrofs.of_intu i)) with (Int64.repr (Int.unsigned i)).\neauto with cshm.\napply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m (Eunop Olongofintu a)\n  (Vlong (Int64.repr (Int.unsigned i))).","conclusion":"eval_expr ge e le m (Eunop Olongofintu a)\n  (Vlong (Int64.repr (Int.unsigned i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"eauto with cshm."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : Int64.repr (Int.unsigned i) = Ptrofs.to_int64 (Ptrofs.of_intu i).","conclusion":"Int64.repr (Int.unsigned i) = Ptrofs.to_int64 (Ptrofs.of_intu i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"apply Int64.eqm_samerepr.\nrewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : Int64.eqm (Int.unsigned i) (Ptrofs.unsigned (Ptrofs.of_intu i)).","conclusion":"Int64.eqm (Int.unsigned i) (Ptrofs.unsigned (Ptrofs.of_intu i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"rewrite Ptrofs.eqm64 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true) : Ptrofs.eqm (Int.unsigned i) (Ptrofs.unsigned (Ptrofs.of_intu i)).","conclusion":"Ptrofs.eqm (Int.unsigned i) (Ptrofs.unsigned (Ptrofs.of_intu i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = true)","proofString":"apply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : eval_expr ge e le m a\n  (Vint\n     (Ptrofs.to_int\n        match si with\n        | Signed => Ptrofs.of_ints i\n        | Unsigned => Ptrofs.of_intu i\n        end)).","conclusion":"eval_expr ge e le m a\n  (Vint\n     (Ptrofs.to_int\n        match si with\n        | Signed => Ptrofs.of_ints i\n        | Unsigned => Ptrofs.of_intu i\n        end))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (si : signedness) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"destruct si.\nreplace (Ptrofs.to_int (Ptrofs.of_ints i)) with i.\nauto.\nsymmetry.\nauto with ptrofs.\nreplace (Ptrofs.to_int (Ptrofs.of_intu i)) with i.\nauto.\nsymmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : eval_expr ge e le m a (Vint (Ptrofs.to_int (Ptrofs.of_ints i))).","conclusion":"eval_expr ge e le m a (Vint (Ptrofs.to_int (Ptrofs.of_ints i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"replace (Ptrofs.to_int (Ptrofs.of_ints i)) with i.\nauto.\nsymmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : eval_expr ge e le m a (Vint i).","conclusion":"eval_expr ge e le m a (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : i = Ptrofs.to_int (Ptrofs.of_ints i).","conclusion":"i = Ptrofs.to_int (Ptrofs.of_ints i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : Ptrofs.to_int (Ptrofs.of_ints i) = i.","conclusion":"Ptrofs.to_int (Ptrofs.of_ints i) = i","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"auto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : eval_expr ge e le m a (Vint (Ptrofs.to_int (Ptrofs.of_intu i))).","conclusion":"eval_expr ge e le m a (Vint (Ptrofs.to_int (Ptrofs.of_intu i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"replace (Ptrofs.to_int (Ptrofs.of_intu i)) with i.\nauto.\nsymmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : eval_expr ge e le m a (Vint i).","conclusion":"eval_expr ge e le m a (Vint i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : i = Ptrofs.to_int (Ptrofs.of_intu i).","conclusion":"i = Ptrofs.to_int (Ptrofs.of_intu i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false) : Ptrofs.to_int (Ptrofs.of_intu i) = i.","conclusion":"Ptrofs.to_int (Ptrofs.of_intu i) = i","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int) (H : eval_expr ge e le m a (Vint i)) (SF : Archi.ptr64 = false)","proofString":"auto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (if Archi.ptr64 then a else Eunop Ointoflong a)\n  (Vptrofs (Ptrofs.of_int64 i)).","conclusion":"eval_expr ge e le m (if Archi.ptr64 then a else Eunop Ointoflong a)\n  (Vptrofs (Ptrofs.of_int64 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i))","proofString":"unfold Vptrofs.\ndestruct Archi.ptr64 eqn:SF.\nreplace (Ptrofs.to_int64 (Ptrofs.of_int64 i)) with i.\nauto.\nsymmetry.\nauto with ptrofs.\neconstructor; eauto.\nsimpl.\napply f_equal.\napply f_equal.\napply Int.eqm_samerepr.\nrewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) : eval_expr ge e le m (if Archi.ptr64 then a else Eunop Ointoflong a)\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 (Ptrofs.of_int64 i))\n   else Vint (Ptrofs.to_int (Ptrofs.of_int64 i))).","conclusion":"eval_expr ge e le m (if Archi.ptr64 then a else Eunop Ointoflong a)\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 (Ptrofs.of_int64 i))\n   else Vint (Ptrofs.to_int (Ptrofs.of_int64 i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i))","proofString":"destruct Archi.ptr64 eqn:SF.\nreplace (Ptrofs.to_int64 (Ptrofs.of_int64 i)) with i.\nauto.\nsymmetry.\nauto with ptrofs.\neconstructor; eauto.\nsimpl.\napply f_equal.\napply f_equal.\napply Int.eqm_samerepr.\nrewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m a (Vlong (Ptrofs.to_int64 (Ptrofs.of_int64 i))).","conclusion":"eval_expr ge e le m a (Vlong (Ptrofs.to_int64 (Ptrofs.of_int64 i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true)","proofString":"replace (Ptrofs.to_int64 (Ptrofs.of_int64 i)) with i.\nauto.\nsymmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true) : eval_expr ge e le m a (Vlong i).","conclusion":"eval_expr ge e le m a (Vlong i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true) : i = Ptrofs.to_int64 (Ptrofs.of_int64 i).","conclusion":"i = Ptrofs.to_int64 (Ptrofs.of_int64 i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true)","proofString":"symmetry.\nauto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true) : Ptrofs.to_int64 (Ptrofs.of_int64 i) = i.","conclusion":"Ptrofs.to_int64 (Ptrofs.of_int64 i) = i","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = true)","proofString":"auto with ptrofs."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false) : eval_expr ge e le m (Eunop Ointoflong a)\n  (Vint (Ptrofs.to_int (Ptrofs.of_int64 i))).","conclusion":"eval_expr ge e le m (Eunop Ointoflong a)\n  (Vint (Ptrofs.to_int (Ptrofs.of_int64 i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false)","proofString":"econstructor; eauto.\nsimpl.\napply f_equal.\napply f_equal.\napply Int.eqm_samerepr.\nrewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false) : eval_unop Ointoflong (Vlong i) =\nSome (Vint (Ptrofs.to_int (Ptrofs.of_int64 i))).","conclusion":"eval_unop Ointoflong (Vlong i) =\nSome (Vint (Ptrofs.to_int (Ptrofs.of_int64 i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false)","proofString":"simpl.\napply f_equal.\napply f_equal.\napply Int.eqm_samerepr.\nrewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false) : Some (Vint (Int64.loword i)) =\nSome (Vint (Ptrofs.to_int (Ptrofs.of_int64 i))).","conclusion":"Some (Vint (Int64.loword i)) =\nSome (Vint (Ptrofs.to_int (Ptrofs.of_int64 i)))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false)","proofString":"apply f_equal.\napply f_equal.\napply Int.eqm_samerepr.\nrewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false) : Vint (Int64.loword i) = Vint (Ptrofs.to_int (Ptrofs.of_int64 i)).","conclusion":"Vint (Int64.loword i) = Vint (Ptrofs.to_int (Ptrofs.of_int64 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false)","proofString":"apply f_equal.\napply Int.eqm_samerepr.\nrewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false) : Int64.loword i = Ptrofs.to_int (Ptrofs.of_int64 i).","conclusion":"Int64.loword i = Ptrofs.to_int (Ptrofs.of_int64 i)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false)","proofString":"apply Int.eqm_samerepr.\nrewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false) : Int.eqm (Int64.unsigned i) (Ptrofs.unsigned (Ptrofs.of_int64 i)).","conclusion":"Int.eqm (Int64.unsigned i) (Ptrofs.unsigned (Ptrofs.of_int64 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false)","proofString":"rewrite Ptrofs.eqm32 by auto.\napply Ptrofs.eqm_unsigned_repr."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false) : Ptrofs.eqm (Int64.unsigned i) (Ptrofs.unsigned (Ptrofs.of_int64 i)).","conclusion":"Ptrofs.eqm (Int64.unsigned i) (Ptrofs.unsigned (Ptrofs.of_int64 i))","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : int64) (H : eval_expr ge e le m a (Vlong i)) (SF : Archi.ptr64 = false)","proofString":"apply Ptrofs.eqm_unsigned_repr."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : cmp_ptr m cmp va vb = Some v) (MAKE : OK (make_cmp_ptr cmp a b) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : cmp_ptr m cmp va vb = Some v) (MAKE : OK (make_cmp_ptr cmp a b) = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"inv MAKE.\neapply make_cmp_ptr_correct; eauto."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : cmp_ptr m cmp va vb = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m (make_cmp_ptr cmp a b) v.","conclusion":"eval_expr ge e le m (make_cmp_ptr cmp a b) v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : cmp_ptr m cmp va vb = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"eapply make_cmp_ptr_correct; eauto."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match vb with\n| Vint n2 => cmp_ptr m cmp va (Vptrofs (ptrofs_of_int si n2))\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp a (if Archi.ptr64 then make_longofint b si else b)) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match vb with\n| Vint n2 => cmp_ptr m cmp va (Vptrofs (ptrofs_of_int si n2))\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp a (if Archi.ptr64 then make_longofint b si else b)) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"inv MAKE.\ndestruct vb; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match vb with\n| Vint n2 => cmp_ptr m cmp va (Vptrofs (ptrofs_of_int si n2))\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m\n  (make_cmp_ptr cmp a (if Archi.ptr64 then make_longofint b si else b)) v.","conclusion":"eval_expr ge e le m\n  (make_cmp_ptr cmp a (if Archi.ptr64 then make_longofint b si else b)) v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match vb with\n| Vint n2 => cmp_ptr m cmp va (Vptrofs (ptrofs_of_int si n2))\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"destruct vb; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match va with\n| Vint n1 => cmp_ptr m cmp (Vptrofs (ptrofs_of_int si n1)) vb\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp (if Archi.ptr64 then make_longofint a si else a) b) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match va with\n| Vint n1 => cmp_ptr m cmp (Vptrofs (ptrofs_of_int si n1)) vb\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp (if Archi.ptr64 then make_longofint a si else a) b) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"inv MAKE.\ndestruct va; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match va with\n| Vint n1 => cmp_ptr m cmp (Vptrofs (ptrofs_of_int si n1)) vb\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m\n  (make_cmp_ptr cmp (if Archi.ptr64 then make_longofint a si else a) b) v.","conclusion":"eval_expr ge e le m\n  (make_cmp_ptr cmp (if Archi.ptr64 then make_longofint a si else a) b) v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (si : signedness) (SEM : match va with\n| Vint n1 => cmp_ptr m cmp (Vptrofs (ptrofs_of_int si n1)) vb\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m cmp va vb\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"destruct va; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match vb with\n| Vlong n2 => cmp_ptr m cmp va (Vptrofs (Ptrofs.of_int64 n2))\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp a (if Archi.ptr64 then b else Eunop Ointoflong b)) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match vb with\n| Vlong n2 => cmp_ptr m cmp va (Vptrofs (Ptrofs.of_int64 n2))\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp a (if Archi.ptr64 then b else Eunop Ointoflong b)) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"inv MAKE.\ndestruct vb; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int64_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match vb with\n| Vlong n2 => cmp_ptr m cmp va (Vptrofs (Ptrofs.of_int64 n2))\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m\n  (make_cmp_ptr cmp a (if Archi.ptr64 then b else Eunop Ointoflong b)) v.","conclusion":"eval_expr ge e le m\n  (make_cmp_ptr cmp a (if Archi.ptr64 then b else Eunop Ointoflong b)) v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match vb with\n| Vlong n2 => cmp_ptr m cmp va (Vptrofs (Ptrofs.of_int64 n2))\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"destruct vb; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int64_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match va with\n| Vlong n1 => cmp_ptr m cmp (Vptrofs (Ptrofs.of_int64 n1)) vb\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp (if Archi.ptr64 then a else Eunop Ointoflong a) b) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match va with\n| Vlong n1 => cmp_ptr m cmp (Vptrofs (Ptrofs.of_int64 n1)) vb\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (MAKE : OK (make_cmp_ptr cmp (if Archi.ptr64 then a else Eunop Ointoflong a) b) =\nOK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"inv MAKE.\ndestruct va; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int64_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match va with\n| Vlong n1 => cmp_ptr m cmp (Vptrofs (Ptrofs.of_int64 n1)) vb\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m\n  (make_cmp_ptr cmp (if Archi.ptr64 then a else Eunop Ointoflong a) b) v.","conclusion":"eval_expr ge e le m\n  (make_cmp_ptr cmp (if Archi.ptr64 then a else Eunop Ointoflong a) b) v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : match va with\n| Vlong n1 => cmp_ptr m cmp (Vptrofs (Ptrofs.of_int64 n1)) vb\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m cmp va vb else None\n| _ => None\nend = Some v) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"destruct va; InvEval; eauto using make_cmp_ptr_correct, make_ptrofs_of_int64_correct."},{"statement":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int.cmp cmp n1 n2\n        | Unsigned => Int.cmpu cmp n1 n2\n        end))\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int64.cmp cmp n1 n2\n        | Unsigned => Int64.cmpu cmp n1 n2\n        end)) (fun n1 n2 : float => Some (Val.of_bool (Float.cmp cmp n1 n2)))\n  (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp cmp n1 n2))) va tya\n  vb tyb m = Some v) (MAKE : make_binarith (Ocmp cmp) (Ocmpu cmp) (Ocmpf cmp) (Ocmpfs cmp) \n  (Ocmpl cmp) (Ocmplu cmp) a tya b tyb = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(cmp : comparison) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (SEM : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int.cmp cmp n1 n2\n        | Unsigned => Int.cmpu cmp n1 n2\n        end))\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   Some\n     (Val.of_bool\n        match sg with\n        | Signed => Int64.cmp cmp n1 n2\n        | Unsigned => Int64.cmpu cmp n1 n2\n        end)) (fun n1 n2 : float => Some (Val.of_bool (Float.cmp cmp n1 n2)))\n  (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp cmp n1 n2))) va tya\n  vb tyb m = Some v) (MAKE : make_binarith (Ocmp cmp) (Ocmpu cmp) (Ocmpf cmp) (Ocmpfs cmp) \n  (Ocmpl cmp) (Ocmplu cmp) a tya b tyb = OK c) (EV1 : eval_expr ge e le m a va) (EV2 : eval_expr ge e le m b vb)","proofString":"eapply make_binarith_correct; eauto; intros; auto."},{"statement":"(op : Cop.unary_operation) (a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : transl_unop op a tya = OK c) (H0 : sem_unary_operation op va tya m = Some v) (H1 : eval_expr ge e le m a va) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(op : Cop.unary_operation) (a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : transl_unop op a tya = OK c) (H0 : sem_unary_operation op va tya m = Some v) (H1 : eval_expr ge e le m a va)","proofString":"destruct op; simpl in *.\neapply make_notbool_correct; eauto.\neapply make_notint_correct; eauto.\neapply make_neg_correct; eauto.\neapply make_absfloat_correct; eauto."},{"statement":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_notbool a tya = OK c) (H0 : sem_notbool va tya m = Some v) (H1 : eval_expr ge e le m a va) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_notbool a tya = OK c) (H0 : sem_notbool va tya m = Some v) (H1 : eval_expr ge e le m a va)","proofString":"eapply make_notbool_correct; eauto."},{"statement":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_notint a tya = OK c) (H0 : sem_notint va tya = Some v) (H1 : eval_expr ge e le m a va) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_notint a tya = OK c) (H0 : sem_notint va tya = Some v) (H1 : eval_expr ge e le m a va)","proofString":"eapply make_notint_correct; eauto."},{"statement":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_neg a tya = OK c) (H0 : sem_neg va tya = Some v) (H1 : eval_expr ge e le m a va) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_neg a tya = OK c) (H0 : sem_neg va tya = Some v) (H1 : eval_expr ge e le m a va)","proofString":"eapply make_neg_correct; eauto."},{"statement":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_absfloat a tya = OK c) (H0 : sem_absfloat va tya = Some v) (H1 : eval_expr ge e le m a va) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (c : expr) (va v : val) (e : env) (le : temp_env) (m : mem) (H : make_absfloat a tya = OK c) (H0 : sem_absfloat va tya = Some v) (H1 : eval_expr ge e le m a va)","proofString":"eapply make_absfloat_correct; eauto."},{"statement":"(op : Cop.binary_operation) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : transl_binop (prog_comp_env cunit) op a tya b tyb = OK c) (H0 : sem_binary_operation (prog_comp_env prog) op va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(op : Cop.binary_operation) (a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : transl_binop (prog_comp_env cunit) op a tya b tyb = OK c) (H0 : sem_binary_operation (prog_comp_env prog) op va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"destruct op; simpl in *.\neapply make_add_correct; eauto.\neapply make_sub_correct; eauto.\neapply make_mul_correct; eauto.\neapply make_div_correct; eauto.\neapply make_mod_correct; eauto.\neapply make_and_correct; eauto.\neapply make_or_correct; eauto.\neapply make_xor_correct; eauto.\neapply make_shl_correct; eauto.\neapply make_shr_correct; eauto.\neapply make_cmp_correct; eauto.\neapply make_cmp_correct; eauto.\neapply make_cmp_correct; eauto.\neapply make_cmp_correct; eauto.\neapply make_cmp_correct; eauto.\neapply make_cmp_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_add (prog_comp_env cunit) a tya b tyb = OK c) (H0 : sem_add (prog_comp_env prog) va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_add (prog_comp_env cunit) a tya b tyb = OK c) (H0 : sem_add (prog_comp_env prog) va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_add_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_sub (prog_comp_env cunit) a tya b tyb = OK c) (H0 : sem_sub (prog_comp_env prog) va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_sub (prog_comp_env cunit) a tya b tyb = OK c) (H0 : sem_sub (prog_comp_env prog) va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_sub_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_mul a tya b tyb = OK c) (H0 : sem_mul va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_mul a tya b tyb = OK c) (H0 : sem_mul va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_mul_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_div a tya b tyb = OK c) (H0 : sem_div va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_div a tya b tyb = OK c) (H0 : sem_div va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_div_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_mod a tya b tyb = OK c) (H0 : sem_mod va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_mod a tya b tyb = OK c) (H0 : sem_mod va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_mod_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_and a tya b tyb = OK c) (H0 : sem_and va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_and a tya b tyb = OK c) (H0 : sem_and va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_and_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_or a tya b tyb = OK c) (H0 : sem_or va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_or a tya b tyb = OK c) (H0 : sem_or va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_or_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_xor a tya b tyb = OK c) (H0 : sem_xor va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_xor a tya b tyb = OK c) (H0 : sem_xor va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_xor_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_shl a tya b tyb = OK c) (H0 : sem_shl va tya vb tyb = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_shl a tya b tyb = OK c) (H0 : sem_shl va tya vb tyb = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_shl_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_shr a tya b tyb = OK c) (H0 : sem_shr va tya vb tyb = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_shr a tya b tyb = OK c) (H0 : sem_shr va tya vb tyb = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_shr_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Ceq a tya b tyb = OK c) (H0 : sem_cmp Ceq va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Ceq a tya b tyb = OK c) (H0 : sem_cmp Ceq va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_cmp_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cne a tya b tyb = OK c) (H0 : sem_cmp Cne va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cne a tya b tyb = OK c) (H0 : sem_cmp Cne va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_cmp_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Clt a tya b tyb = OK c) (H0 : sem_cmp Clt va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Clt a tya b tyb = OK c) (H0 : sem_cmp Clt va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_cmp_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cgt a tya b tyb = OK c) (H0 : sem_cmp Cgt va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cgt a tya b tyb = OK c) (H0 : sem_cmp Cgt va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_cmp_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cle a tya b tyb = OK c) (H0 : sem_cmp Cle va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cle a tya b tyb = OK c) (H0 : sem_cmp Cle va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_cmp_correct; eauto."},{"statement":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cge a tya b tyb = OK c) (H0 : sem_cmp Cge va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb) : eval_expr ge e le m c v.","conclusion":"eval_expr ge e le m c v","hypotheses":"(a : expr) (tya : type) (b : expr) (tyb : type) (c : expr) (va vb v : val) (e : env) (le : temp_env) (m : mem) (H : make_cmp Cge a tya b tyb = OK c) (H0 : sem_cmp Cge va tya vb tyb m = Some v) (H1 : eval_expr ge e le m a va) (H2 : eval_expr ge e le m b vb)","proofString":"eapply make_cmp_correct; eauto."},{"statement":"(x : Z) (H : 0 <= x < Int.zwordsize) : Int.ltu (Int.repr x) Int.iwordsize = true.","conclusion":"Int.ltu (Int.repr x) Int.iwordsize = true","hypotheses":"(x : Z) (H : 0 <= x < Int.zwordsize)","proofString":"unfold Int.ltu.\nrewrite Int.unsigned_repr_wordsize, Int.unsigned_repr, zlt_true by (generalize Int.wordsize_max_unsigned; lia).\nauto."},{"statement":"(x : Z) (H : 0 <= x < Int.zwordsize) : (if zlt (Int.unsigned (Int.repr x)) (Int.unsigned Int.iwordsize)\n then true\n else false) = true.","conclusion":"(if zlt (Int.unsigned (Int.repr x)) (Int.unsigned Int.iwordsize)\n then true\n else false) = true","hypotheses":"(x : Z) (H : 0 <= x < Int.zwordsize)","proofString":"rewrite Int.unsigned_repr_wordsize, Int.unsigned_repr, zlt_true by (generalize Int.wordsize_max_unsigned; lia).\nauto."},{"statement":"(x : Z) (H : 0 <= x < Int.zwordsize) : true = true.","conclusion":"true = true","hypotheses":"(x : Z) (H : 0 <= x < Int.zwordsize)","proofString":"auto."},{"statement":"(sz : intsize) (pos width : Z) (H : 0 <= pos) (H0 : 0 < width) (H1 : pos + width <= bitsize_carrier sz) : 0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize.","conclusion":"0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize","hypotheses":"(sz : intsize) (pos width : Z) (H : 0 <= pos) (H0 : 0 < width) (H1 : pos + width <= bitsize_carrier sz)","proofString":"assert (bitsize_carrier sz <= Int.zwordsize) by (destruct sz; compute; congruence).\nunfold first_bit; destruct Archi.big_endian; lia."},{"statement":"(sz : intsize) (pos width : Z) (H : 0 <= pos) (H0 : 0 < width) (H1 : pos + width <= bitsize_carrier sz) (H2 : bitsize_carrier sz <= Int.zwordsize) : 0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize.","conclusion":"0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize","hypotheses":"(sz : intsize) (pos width : Z) (H : 0 <= pos) (H0 : 0 < width) (H1 : pos + width <= bitsize_carrier sz) (H2 : bitsize_carrier sz <= Int.zwordsize)","proofString":"unfold first_bit; destruct Archi.big_endian; lia."},{"statement":"(addr : expr) (ty : type) (bf : bitfield) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (MKLOAD : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk => OK (Eload chunk addr)\n    | By_nothing => Error (msg \"Cshmgen.make_load\")\n    | _ => OK addr\n    end\n| Bits sz sg pos width => make_extract_bitfield sz sg pos width addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (DEREF : deref_loc ty m b ofs bf v) : eval_expr ge e le m code v.","conclusion":"eval_expr ge e le m code v","hypotheses":"(addr : expr) (ty : type) (bf : bitfield) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (MKLOAD : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk => OK (Eload chunk addr)\n    | By_nothing => Error (msg \"Cshmgen.make_load\")\n    | _ => OK addr\n    end\n| Bits sz sg pos width => make_extract_bitfield sz sg pos width addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (DEREF : deref_loc ty m b ofs bf v)","proofString":"inv DEREF.\nrewrite H in MKLOAD.\ninv MKLOAD.\napply eval_Eload with (Vptr b ofs); auto.\nrewrite H in MKLOAD.\ninv MKLOAD.\nauto.\nrewrite H in MKLOAD.\ninv MKLOAD.\nauto.\ninv H.\nunfold make_extract_bitfield in MKLOAD.\nunfold bitfield_extract.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nset (amount1 := Int.repr (Int.zwordsize - first_bit sz pos width - width)) in MKLOAD.\nset (amount2 := Int.repr (Int.zwordsize - width)) in MKLOAD.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MKLOAD.\nset (e1 := Eload (chunk_for_carrier sz) addr).\nassert (E1: eval_expr ge e le m e1 (Vint c)) by (econstructor; eauto).\nset (e2 := Ebinop Oshl e1 (make_intconst amount1)).\nassert (E2: eval_expr ge e le m e2 (Vint (Int.shl c amount1))).\neconstructor; eauto using make_intconst_correct.\ncbn.\nunfold amount1 at 1; rewrite int_ltu_true by lia.\nauto.\neconstructor; eauto using make_intconst_correct.\ndestruct (Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned); cbn.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.unsigned_bitfield_extract_by_shifts by lia.\nauto.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.signed_bitfield_extract_by_shifts by lia.\nauto."},{"statement":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (MKLOAD : match access_mode ty with\n| By_value chunk0 => OK (Eload chunk0 addr)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (chunk : memory_chunk) (H : access_mode ty = By_value chunk) (H0 : Mem.loadv chunk m (Vptr b ofs) = Some v) : eval_expr ge e le m code v.","conclusion":"eval_expr ge e le m code v","hypotheses":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (MKLOAD : match access_mode ty with\n| By_value chunk0 => OK (Eload chunk0 addr)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (chunk : memory_chunk) (H : access_mode ty = By_value chunk) (H0 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"rewrite H in MKLOAD.\ninv MKLOAD.\napply eval_Eload with (Vptr b ofs); auto."},{"statement":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (chunk : memory_chunk) (MKLOAD : OK (Eload chunk addr) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_value chunk) (H0 : Mem.loadv chunk m (Vptr b ofs) = Some v) : eval_expr ge e le m code v.","conclusion":"eval_expr ge e le m code v","hypotheses":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (chunk : memory_chunk) (MKLOAD : OK (Eload chunk addr) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_value chunk) (H0 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"inv MKLOAD.\napply eval_Eload with (Vptr b ofs); auto."},{"statement":"(addr : expr) (ty : type) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (chunk : memory_chunk) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_value chunk) (H0 : Mem.loadv chunk m (Vptr b ofs) = Some v) : eval_expr ge e le m (Eload chunk addr) v.","conclusion":"eval_expr ge e le m (Eload chunk addr) v","hypotheses":"(addr : expr) (ty : type) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (chunk : memory_chunk) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_value chunk) (H0 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"apply eval_Eload with (Vptr b ofs); auto."},{"statement":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : match access_mode ty with\n| By_value chunk => OK (Eload chunk addr)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_reference) : eval_expr ge e le m code (Vptr b ofs).","conclusion":"eval_expr ge e le m code (Vptr b ofs)","hypotheses":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : match access_mode ty with\n| By_value chunk => OK (Eload chunk addr)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_reference)","proofString":"rewrite H in MKLOAD.\ninv MKLOAD.\nauto."},{"statement":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : OK addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_reference) : eval_expr ge e le m code (Vptr b ofs).","conclusion":"eval_expr ge e le m code (Vptr b ofs)","hypotheses":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : OK addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_reference)","proofString":"inv MKLOAD.\nauto."},{"statement":"(ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (EVEXP : eval_expr ge e le m code (Vptr b ofs)) (H : access_mode ty = By_reference) : eval_expr ge e le m code (Vptr b ofs).","conclusion":"eval_expr ge e le m code (Vptr b ofs)","hypotheses":"(ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (EVEXP : eval_expr ge e le m code (Vptr b ofs)) (H : access_mode ty = By_reference)","proofString":"auto."},{"statement":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : match access_mode ty with\n| By_value chunk => OK (Eload chunk addr)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_copy) : eval_expr ge e le m code (Vptr b ofs).","conclusion":"eval_expr ge e le m code (Vptr b ofs)","hypotheses":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : match access_mode ty with\n| By_value chunk => OK (Eload chunk addr)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK addr\nend = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_copy)","proofString":"rewrite H in MKLOAD.\ninv MKLOAD.\nauto."},{"statement":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : OK addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_copy) : eval_expr ge e le m code (Vptr b ofs).","conclusion":"eval_expr ge e le m code (Vptr b ofs)","hypotheses":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (MKLOAD : OK addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : access_mode ty = By_copy)","proofString":"inv MKLOAD.\nauto."},{"statement":"(ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (EVEXP : eval_expr ge e le m code (Vptr b ofs)) (H : access_mode ty = By_copy) : eval_expr ge e le m code (Vptr b ofs).","conclusion":"eval_expr ge e le m code (Vptr b ofs)","hypotheses":"(ty : type) (code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (EVEXP : eval_expr ge e le m code (Vptr b ofs)) (H : access_mode ty = By_copy)","proofString":"auto."},{"statement":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : make_extract_bitfield sz sg pos width addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : load_bitfield ty sz sg pos width m (Vptr b ofs) v) : eval_expr ge e le m code v.","conclusion":"eval_expr ge e le m code v","hypotheses":"(addr : expr) (ty : type) (code : expr) (b : block) (ofs : ptrofs) (v : val) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : make_extract_bitfield sz sg pos width addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (H : load_bitfield ty sz sg pos width m (Vptr b ofs) v)","proofString":"inv H.\nunfold make_extract_bitfield in MKLOAD.\nunfold bitfield_extract.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nset (amount1 := Int.repr (Int.zwordsize - first_bit sz pos width - width)) in MKLOAD.\nset (amount2 := Int.repr (Int.zwordsize - width)) in MKLOAD.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MKLOAD.\nset (e1 := Eload (chunk_for_carrier sz) addr).\nassert (E1: eval_expr ge e le m e1 (Vint c)) by (econstructor; eauto).\nset (e2 := Ebinop Oshl e1 (make_intconst amount1)).\nassert (E2: eval_expr ge e le m e2 (Vint (Int.shl c amount1))).\neconstructor; eauto using make_intconst_correct.\ncbn.\nunfold amount1 at 1; rewrite int_ltu_true by lia.\nauto.\neconstructor; eauto using make_intconst_correct.\ndestruct (Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned); cbn.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.unsigned_bitfield_extract_by_shifts by lia.\nauto.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.signed_bitfield_extract_by_shifts by lia.\nauto."},{"statement":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : make_extract_bitfield sz sg pos width addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : eval_expr ge e le m code (Vint (bitfield_extract sz sg pos width c)).","conclusion":"eval_expr ge e le m code (Vint (bitfield_extract sz sg pos width c))","hypotheses":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : make_extract_bitfield sz sg pos width addr = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"unfold make_extract_bitfield in MKLOAD.\nunfold bitfield_extract.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nset (amount1 := Int.repr (Int.zwordsize - first_bit sz pos width - width)) in MKLOAD.\nset (amount2 := Int.repr (Int.zwordsize - width)) in MKLOAD.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MKLOAD.\nset (e1 := Eload (chunk_for_carrier sz) addr).\nassert (E1: eval_expr ge e le m e1 (Vint c)) by (econstructor; eauto).\nset (e2 := Ebinop Oshl e1 (make_intconst amount1)).\nassert (E2: eval_expr ge e le m e2 (Vint (Int.shl c amount1))).\neconstructor; eauto using make_intconst_correct.\ncbn.\nunfold amount1 at 1; rewrite int_ltu_true by lia.\nauto.\neconstructor; eauto using make_intconst_correct.\ndestruct (Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned); cbn.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.unsigned_bitfield_extract_by_shifts by lia.\nauto.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.signed_bitfield_extract_by_shifts by lia.\nauto."},{"statement":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : eval_expr ge e le m code (Vint (bitfield_extract sz sg pos width c)).","conclusion":"eval_expr ge e le m code (Vint (bitfield_extract sz sg pos width c))","hypotheses":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"unfold bitfield_extract.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nset (amount1 := Int.repr (Int.zwordsize - first_bit sz pos width - width)) in MKLOAD.\nset (amount2 := Int.repr (Int.zwordsize - width)) in MKLOAD.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MKLOAD.\nset (e1 := Eload (chunk_for_carrier sz) addr).\nassert (E1: eval_expr ge e le m e1 (Vint c)) by (econstructor; eauto).\nset (e2 := Ebinop Oshl e1 (make_intconst amount1)).\nassert (E2: eval_expr ge e le m e2 (Vint (Int.shl c amount1))).\neconstructor; eauto using make_intconst_correct.\ncbn.\nunfold amount1 at 1; rewrite int_ltu_true by lia.\nauto.\neconstructor; eauto using make_intconst_correct.\ndestruct (Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned); cbn.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.unsigned_bitfield_extract_by_shifts by lia.\nauto.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.signed_bitfield_extract_by_shifts by lia.\nauto."},{"statement":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : eval_expr ge e le m code\n  (Vint\n     (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n      then Int.unsigned_bitfield_extract (first_bit sz pos width) width c\n      else Int.signed_bitfield_extract (first_bit sz pos width) width c)).","conclusion":"eval_expr ge e le m code\n  (Vint\n     (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n      then Int.unsigned_bitfield_extract (first_bit sz pos width) width c\n      else Int.signed_bitfield_extract (first_bit sz pos width) width c))","hypotheses":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"exploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nset (amount1 := Int.repr (Int.zwordsize - first_bit sz pos width - width)) in MKLOAD.\nset (amount2 := Int.repr (Int.zwordsize - width)) in MKLOAD.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MKLOAD.\nset (e1 := Eload (chunk_for_carrier sz) addr).\nassert (E1: eval_expr ge e le m e1 (Vint c)) by (econstructor; eauto).\nset (e2 := Ebinop Oshl e1 (make_intconst amount1)).\nassert (E2: eval_expr ge e le m e2 (Vint (Int.shl c amount1))).\neconstructor; eauto using make_intconst_correct.\ncbn.\nunfold amount1 at 1; rewrite int_ltu_true by lia.\nauto.\neconstructor; eauto using make_intconst_correct.\ndestruct (Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned); cbn.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.unsigned_bitfield_extract_by_shifts by lia.\nauto.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.signed_bitfield_extract_by_shifts by lia.\nauto."},{"statement":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : 0 < width.","conclusion":"0 < width","hypotheses":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"lia."},{"statement":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : 0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize ->\neval_expr ge e le m code\n  (Vint\n     (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n      then Int.unsigned_bitfield_extract (first_bit sz pos width) width c\n      else Int.signed_bitfield_extract (first_bit sz pos width) width c)).","conclusion":"0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize ->\neval_expr ge e le m code\n  (Vint\n     (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n      then Int.unsigned_bitfield_extract (first_bit sz pos width) width c\n      else Int.signed_bitfield_extract (first_bit sz pos width) width c))","hypotheses":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"intros [A1 A2].\nset (amount1 := Int.repr (Int.zwordsize - first_bit sz pos width - width)) in MKLOAD.\nset (amount2 := Int.repr (Int.zwordsize - width)) in MKLOAD.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MKLOAD.\nset (e1 := Eload (chunk_for_carrier sz) addr).\nassert (E1: eval_expr ge e le m e1 (Vint c)) by (econstructor; eauto).\nset (e2 := Ebinop Oshl e1 (make_intconst amount1)).\nassert (E2: eval_expr ge e le m e2 (Vint (Int.shl c amount1))).\neconstructor; eauto using make_intconst_correct.\ncbn.\nunfold amount1 at 1; rewrite int_ltu_true by lia.\nauto.\neconstructor; eauto using make_intconst_correct.\ndestruct (Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned); cbn.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.unsigned_bitfield_extract_by_shifts by lia.\nauto.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.signed_bitfield_extract_by_shifts by lia.\nauto."},{"statement":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize) : eval_expr ge e le m code\n  (Vint\n     (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n      then Int.unsigned_bitfield_extract (first_bit sz pos width) width c\n      else Int.signed_bitfield_extract (first_bit sz pos width) width c)).","conclusion":"eval_expr ge e le m code\n  (Vint\n     (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n      then Int.unsigned_bitfield_extract (first_bit sz pos width) width c\n      else Int.signed_bitfield_extract (first_bit sz pos width) width c))","hypotheses":"(addr code : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (MKLOAD : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Ebinop\n       (if Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned\n        then Oshru\n        else Oshr)\n       (Ebinop Oshl (Eload (chunk_for_carrier sz) addr)\n          (make_intconst\n             (Int.repr (Int.zwordsize - first_bit sz pos width - width))))\n       (make_intconst (Int.repr (Int.zwordsize - width))))\n else Error (msg \"Cshmgen.extract_bitfield\")) = OK code) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize)","proofString":"set (amount1 := Int.repr (Int.zwordsize - first_bit sz pos width - width)) in MKLOAD.\nset (amount2 := Int.repr (Int.zwordsize - width)) in MKLOAD.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MKLOAD.\nset (e1 := Eload (chunk_for_carrier sz) addr).\nassert (E1: eval_expr ge e le m e1 (Vint c)) by (econstructor; eauto).\nset (e2 := Ebinop Oshl e1 (make_intconst amount1)).\nassert (E2: eval_expr ge e le m e2 (Vint (Int.shl c amount1))).\neconstructor; eauto using make_intconst_correct.\ncbn.\nunfold amount1 at 1; rewrite int_ltu_true by lia.\nauto.\neconstructor; eauto using make_intconst_correct.\ndestruct (Ctypes.intsize_eq sz IBool || Ctypes.signedness_eq sg Unsigned); cbn.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.unsigned_bitfield_extract_by_shifts by lia.\nauto.\nunfold amount2 at 1; rewrite int_ltu_true by lia.\nrewrite Int.signed_bitfield_extract_by_shifts by lia.\nauto."},{"statement":"(addr : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (amount1 : int) (amount2 : int) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize) (e1 : expr) (E1 : eval_expr ge e le m e1 (Vint c)) (e2 : expr) : Some (Vint (Int.shl c amount1)) = Some (Vint (Int.shl c amount1)).","conclusion":"Some (Vint (Int.shl c amount1)) = Some (Vint (Int.shl c amount1))","hypotheses":"(addr : expr) (b : block) (ofs : ptrofs) (e : env) (le : temp_env) (m : mem) (sz : intsize) (sg : signedness) (pos width : Z) (amount1 : int) (amount2 : int) (EVEXP : eval_expr ge e le m addr (Vptr b ofs)) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize) (e1 : expr) (E1 : eval_expr ge e le m e1 (Vint c)) (e2 : expr)","proofString":"auto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (SRC : eval_expr ge e le m src v) (ASG : assign_loc (prog_comp_env prog) ty m b ofs (Bits sz sg pos width) v m') (MK : make_store_bitfield sz sg pos width dst src = OK s) : step ge (State f s k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f s k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (SRC : eval_expr ge e le m src v) (ASG : assign_loc (prog_comp_env prog) ty m b ofs (Bits sz sg pos width) v m') (MK : make_store_bitfield sz sg pos width dst src = OK s)","proofString":"inv ASG.\ninv H5.\nunfold make_store_bitfield in MK.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MK.\neconstructor; eauto.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nrewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (SRC : eval_expr ge e le m src v) (MK : make_store_bitfield sz sg pos width dst src = OK s) (v' : val) (H5 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') : step ge (State f s k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f s k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (SRC : eval_expr ge e le m src v) (MK : make_store_bitfield sz sg pos width dst src = OK s) (v' : val) (H5 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v')","proofString":"inv H5.\nunfold make_store_bitfield in MK.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MK.\neconstructor; eauto.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nrewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (MK : make_store_bitfield sz sg pos width dst src = OK s) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : step ge (State f s k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f s k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (MK : make_store_bitfield sz sg pos width dst src = OK s) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"unfold make_store_bitfield in MK.\ndestruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MK.\neconstructor; eauto.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nrewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (MK : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Sstore (chunk_for_carrier sz) dst\n       (Ebinop Oor\n          (Ebinop Oand\n             (Ebinop Oshl src\n                (make_intconst (Int.repr (first_bit sz pos width))))\n             (make_intconst\n                (Int.shl (Int.repr (two_p width - 1))\n                   (Int.repr (first_bit sz pos width)))))\n          (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n             (make_intconst\n                (Int.not\n                   (Int.shl (Int.repr (two_p width - 1))\n                      (Int.repr (first_bit sz pos width))))))))\n else Error (msg \"Cshmgen.make_store_bitfield\")) = \nOK s) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : step ge (State f s k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f s k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (s : stmt) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (MK : (if zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)\n then\n  OK\n    (Sstore (chunk_for_carrier sz) dst\n       (Ebinop Oor\n          (Ebinop Oand\n             (Ebinop Oshl src\n                (make_intconst (Int.repr (first_bit sz pos width))))\n             (make_intconst\n                (Int.shl (Int.repr (two_p width - 1))\n                   (Int.repr (first_bit sz pos width)))))\n          (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n             (make_intconst\n                (Int.not\n                   (Int.shl (Int.repr (two_p width - 1))\n                      (Int.repr (first_bit sz pos width))))))))\n else Error (msg \"Cshmgen.make_store_bitfield\")) = \nOK s) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"destruct (zle 0 pos && zlt 0 width && zle (pos + width) (bitsize_carrier sz)); inv MK.\neconstructor; eauto.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nrewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : step ge\n  (State f\n     (Sstore (chunk_for_carrier sz) dst\n        (Ebinop Oor\n           (Ebinop Oand\n              (Ebinop Oshl src\n                 (make_intconst (Int.repr (first_bit sz pos width))))\n              (make_intconst\n                 (Int.shl (Int.repr (two_p width - 1))\n                    (Int.repr (first_bit sz pos width)))))\n           (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n              (make_intconst\n                 (Int.not\n                    (Int.shl (Int.repr (two_p width - 1))\n                       (Int.repr (first_bit sz pos width)))))))) k e le m) E0\n  (State f Sskip k e le m').","conclusion":"step ge\n  (State f\n     (Sstore (chunk_for_carrier sz) dst\n        (Ebinop Oor\n           (Ebinop Oand\n              (Ebinop Oshl src\n                 (make_intconst (Int.repr (first_bit sz pos width))))\n              (make_intconst\n                 (Int.shl (Int.repr (two_p width - 1))\n                    (Int.repr (first_bit sz pos width)))))\n           (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n              (make_intconst\n                 (Int.not\n                    (Int.shl (Int.repr (two_p width - 1))\n                       (Int.repr (first_bit sz pos width)))))))) k e le m) E0\n  (State f Sskip k e le m')","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"econstructor; eauto.\nexploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nrewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : eval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)).","conclusion":"eval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n))","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"exploit (first_bit_range sz pos width); eauto.\nlia.\nintros [A1 A2].\nrewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : 0 < width.","conclusion":"0 < width","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"lia."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : 0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize ->\neval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)).","conclusion":"0 <= first_bit sz pos width < Int.zwordsize /\\\n0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize ->\neval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n))","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"intros [A1 A2].\nrewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize) : eval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)).","conclusion":"eval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n))","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize)","proofString":"rewrite Int.bitfield_insert_alternative by lia.\nset (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize) : eval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint\n     (let mask :=\n        Int.shl (Int.repr (two_p width - 1))\n          (Int.repr (first_bit sz pos width)) in\n      Int.or (Int.and (Int.shl n (Int.repr (first_bit sz pos width))) mask)\n        (Int.and c (Int.not mask)))).","conclusion":"eval_expr ge e le m\n  (Ebinop Oor\n     (Ebinop Oand\n        (Ebinop Oshl src (make_intconst (Int.repr (first_bit sz pos width))))\n        (make_intconst\n           (Int.shl (Int.repr (two_p width - 1))\n              (Int.repr (first_bit sz pos width)))))\n     (Ebinop Oand (Eload (chunk_for_carrier sz) dst)\n        (make_intconst\n           (Int.not\n              (Int.shl (Int.repr (two_p width - 1))\n                 (Int.repr (first_bit sz pos width)))))))\n  (Vint\n     (let mask :=\n        Int.shl (Int.repr (two_p width - 1))\n          (Int.repr (first_bit sz pos width)) in\n      Int.or (Int.and (Int.shl n (Int.repr (first_bit sz pos width))) mask)\n        (Int.and c (Int.not mask))))","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize)","proofString":"set (amount := first_bit sz pos width).\nset (mask := Int.shl (Int.repr (two_p width - 1)) (Int.repr amount)).\nrepeat econstructor; eauto.\ncbn.\nrewrite int_ltu_true by lia.\nauto."},{"statement":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize) (amount : Z) (mask : int) : Some\n  (Val.or (Val.and (Vint (Int.shl n (Int.repr amount))) (Vint mask))\n     (Vint (Int.and c (Int.not mask)))) =\nSome\n  (Vint\n     (Int.or (Int.and (Int.shl n (Int.repr amount)) mask)\n        (Int.and c (Int.not mask)))).","conclusion":"Some\n  (Val.or (Val.and (Vint (Int.shl n (Int.repr amount))) (Vint mask))\n     (Vint (Int.and c (Int.not mask)))) =\nSome\n  (Vint\n     (Int.or (Int.and (Int.shl n (Int.repr amount)) mask)\n        (Int.and c (Int.not mask))))","hypotheses":"(f : function) (sz : intsize) (sg : signedness) (pos width : Z) (dst src : expr) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (DST : eval_expr ge e le m dst (Vptr b ofs)) (n : int) (SRC : eval_expr ge e le m src (Vint n)) (attr : Ctypes.attr) (c : int) (H : 0 <= pos) (H0 : 0 < width <= bitsize_intsize sz) (H1 : pos + width <= bitsize_carrier sz) (H3 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H4 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (A1 : 0 <= first_bit sz pos width < Int.zwordsize) (A2 : 0 <= Int.zwordsize - first_bit sz pos width - width < Int.zwordsize) (amount : Z) (mask : int)","proofString":"auto."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (s : stmt) (H : eval_expr ge e le m dst (Vptr b ofs)) (H0 : eval_expr ge e le m src v) (H1 : assign_loc (prog_comp_env prog) ty m b ofs Full v m') (H2 : access_mode ty = By_copy) (H3 : make_memcpy (prog_comp_env cunit) dst src ty = OK s) : step ge (State f s k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f s k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (s : stmt) (H : eval_expr ge e le m dst (Vptr b ofs)) (H0 : eval_expr ge e le m src v) (H1 : assign_loc (prog_comp_env prog) ty m b ofs Full v m') (H2 : access_mode ty = By_copy) (H3 : make_memcpy (prog_comp_env cunit) dst src ty = OK s)","proofString":"inv H1; try congruence.\nmonadInv H3.\nexploit transl_alignof_blockcopy.\neexact LINK.\neauto.\nintros [A B].\nrewrite A, B.\nchange le with (set_optvar None Vundef le) at 2.\neconstructor.\neconstructor.\neauto.\neconstructor.\neauto.\nconstructor.\neconstructor; eauto.\napply alignof_blockcopy_1248.\napply sizeof_pos.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (s : stmt) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (H3 : make_memcpy (prog_comp_env cunit) dst src ty = OK s) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : step ge (State f s k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f s k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (s : stmt) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (H3 : make_memcpy (prog_comp_env cunit) dst src ty = OK s) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"monadInv H3.\nexploit transl_alignof_blockcopy.\neexact LINK.\neauto.\nintros [A B].\nrewrite A, B.\nchange le with (set_optvar None Vundef le) at 2.\neconstructor.\neconstructor.\neauto.\neconstructor.\neauto.\nconstructor.\neconstructor; eauto.\napply alignof_blockcopy_1248.\napply sizeof_pos.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) : step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy x (alignof_blockcopy (prog_comp_env cunit) ty))\n        (dst :: src :: nil)) k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy x (alignof_blockcopy (prog_comp_env cunit) ty))\n        (dst :: src :: nil)) k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x)","proofString":"exploit transl_alignof_blockcopy.\neexact LINK.\neauto.\nintros [A B].\nrewrite A, B.\nchange le with (set_optvar None Vundef le) at 2.\neconstructor.\neconstructor.\neauto.\neconstructor.\neauto.\nconstructor.\neconstructor; eauto.\napply alignof_blockcopy_1248.\napply sizeof_pos.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty) : step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy x (alignof_blockcopy (prog_comp_env cunit) ty))\n        (dst :: src :: nil)) k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy x (alignof_blockcopy (prog_comp_env cunit) ty))\n        (dst :: src :: nil)) k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty)","proofString":"rewrite A, B.\nchange le with (set_optvar None Vundef le) at 2.\neconstructor.\neconstructor.\neauto.\neconstructor.\neauto.\nconstructor.\neconstructor; eauto.\napply alignof_blockcopy_1248.\napply sizeof_pos.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty) : step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy (Ctypes.sizeof (prog_comp_env prog) ty)\n           (alignof_blockcopy (prog_comp_env prog) ty)) \n        (dst :: src :: nil)) k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy (Ctypes.sizeof (prog_comp_env prog) ty)\n           (alignof_blockcopy (prog_comp_env prog) ty)) \n        (dst :: src :: nil)) k e le m) E0 (State f Sskip k e le m')","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty)","proofString":"change le with (set_optvar None Vundef le) at 2.\neconstructor.\neconstructor.\neauto.\neconstructor.\neauto.\nconstructor.\neconstructor; eauto.\napply alignof_blockcopy_1248.\napply sizeof_pos.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty) : step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy (Ctypes.sizeof (prog_comp_env prog) ty)\n           (alignof_blockcopy (prog_comp_env prog) ty)) \n        (dst :: src :: nil)) k e le m) E0\n  (State f Sskip k e (set_optvar None Vundef le) m').","conclusion":"step ge\n  (State f\n     (Sbuiltin None\n        (EF_memcpy (Ctypes.sizeof (prog_comp_env prog) ty)\n           (alignof_blockcopy (prog_comp_env prog) ty)) \n        (dst :: src :: nil)) k e le m) E0\n  (State f Sskip k e (set_optvar None Vundef le) m')","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty)","proofString":"econstructor.\neconstructor.\neauto.\neconstructor.\neauto.\nconstructor.\neconstructor; eauto.\napply alignof_blockcopy_1248.\napply sizeof_pos.\napply sizeof_alignof_blockcopy_compat."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty) : alignof_blockcopy (prog_comp_env prog) ty = 1 \\/\nalignof_blockcopy (prog_comp_env prog) ty = 2 \\/\nalignof_blockcopy (prog_comp_env prog) ty = 4 \\/\nalignof_blockcopy (prog_comp_env prog) ty = 8.","conclusion":"alignof_blockcopy (prog_comp_env prog) ty = 1 \\/\nalignof_blockcopy (prog_comp_env prog) ty = 2 \\/\nalignof_blockcopy (prog_comp_env prog) ty = 4 \\/\nalignof_blockcopy (prog_comp_env prog) ty = 8","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty)","proofString":"apply alignof_blockcopy_1248."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty) : Ctypes.sizeof (prog_comp_env prog) ty >= 0.","conclusion":"Ctypes.sizeof (prog_comp_env prog) ty >= 0","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty)","proofString":"apply sizeof_pos."},{"statement":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty) : (alignof_blockcopy (prog_comp_env prog) ty\n| Ctypes.sizeof (prog_comp_env prog) ty).","conclusion":"(alignof_blockcopy (prog_comp_env prog) ty\n| Ctypes.sizeof (prog_comp_env prog) ty)","hypotheses":"(f : function) (dst src : expr) (ty : type) (k : cont) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H : eval_expr ge e le m dst (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (H0 : eval_expr ge e le m src (Vptr b' ofs')) (H2 : access_mode ty = By_copy) (bytes : list memval) (H4 : access_mode ty = By_copy) (H5 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H6 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H7 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H8 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H9 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (x : Z) (EQ : sizeof (prog_comp_env cunit) ty = OK x) (A : x = Ctypes.sizeof (prog_comp_env prog) ty) (B : alignof_blockcopy (prog_comp_env cunit) ty =\nalignof_blockcopy (prog_comp_env prog) ty)","proofString":"apply sizeof_alignof_blockcopy_compat."},{"statement":"forall (addr : expr) (ty : type) (bf : bitfield) (rhs : expr) \n  (code : stmt) (e : env) (le : temp_env) (m : mem) \n  (b : block) (ofs : ptrofs) (v : val) (m' : mem) \n  (f : function) (k : cont),\nmatch bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk => OK (Sstore chunk addr rhs)\n    | By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n    | _ => Error (msg \"Cshmgen.make_store\")\n    end\n| Bits sz sg pos width => make_store_bitfield sz sg pos width addr rhs\nend = OK code ->\neval_expr ge e le m addr (Vptr b ofs) ->\neval_expr ge e le m rhs v ->\nassign_loc (prog_comp_env prog) ty m b ofs bf v m' ->\nstep ge (State f code k e le m) E0 (State f Sskip k e le m').","conclusion":"forall (addr : expr) (ty : type) (bf : bitfield) (rhs : expr) \n  (code : stmt) (e : env) (le : temp_env) (m : mem) \n  (b : block) (ofs : ptrofs) (v : val) (m' : mem) \n  (f : function) (k : cont),\nmatch bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk => OK (Sstore chunk addr rhs)\n    | By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n    | _ => Error (msg \"Cshmgen.make_store\")\n    end\n| Bits sz sg pos width => make_store_bitfield sz sg pos width addr rhs\nend = OK code ->\neval_expr ge e le m addr (Vptr b ofs) ->\neval_expr ge e le m rhs v ->\nassign_loc (prog_comp_env prog) ty m b ofs bf v m' ->\nstep ge (State f code k e le m) E0 (State f Sskip k e le m')","hypotheses":"","proofString":"intros until k; intros MKSTORE EV1 EV2 ASSIGN.\ninversion ASSIGN; subst.\nrewrite H in MKSTORE; inv MKSTORE.\neconstructor; eauto.\nrewrite H in MKSTORE.\neapply make_memcpy_correct with (b := b) (v := Vptr b' ofs'); eauto.\neapply make_store_bitfield_correct; eauto."},{"statement":"(addr : expr) (ty : type) (bf : bitfield) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (MKSTORE : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk => OK (Sstore chunk addr rhs)\n    | By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n    | _ => Error (msg \"Cshmgen.make_store\")\n    end\n| Bits sz sg pos width => make_store_bitfield sz sg pos width addr rhs\nend = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs bf v m') : step ge (State f code k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f code k e le m) E0 (State f Sskip k e le m')","hypotheses":"(addr : expr) (ty : type) (bf : bitfield) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (MKSTORE : match bf with\n| Full =>\n    match access_mode ty with\n    | By_value chunk => OK (Sstore chunk addr rhs)\n    | By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n    | _ => Error (msg \"Cshmgen.make_store\")\n    end\n| Bits sz sg pos width => make_store_bitfield sz sg pos width addr rhs\nend = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs bf v m')","proofString":"inversion ASSIGN; subst.\nrewrite H in MKSTORE; inv MKSTORE.\neconstructor; eauto.\nrewrite H in MKSTORE.\neapply make_memcpy_correct with (b := b) (v := Vptr b' ofs'); eauto.\neapply make_store_bitfield_correct; eauto."},{"statement":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (MKSTORE : match access_mode ty with\n| By_value chunk0 => OK (Sstore chunk0 addr rhs)\n| By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n| _ => Error (msg \"Cshmgen.make_store\")\nend = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full v m') (chunk : memory_chunk) (H : access_mode ty = By_value chunk) (H0 : Mem.storev chunk m (Vptr b ofs) v = Some m') : step ge (State f code k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f code k e le m) E0 (State f Sskip k e le m')","hypotheses":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (MKSTORE : match access_mode ty with\n| By_value chunk0 => OK (Sstore chunk0 addr rhs)\n| By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n| _ => Error (msg \"Cshmgen.make_store\")\nend = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full v m') (chunk : memory_chunk) (H : access_mode ty = By_value chunk) (H0 : Mem.storev chunk m (Vptr b ofs) v = Some m')","proofString":"rewrite H in MKSTORE; inv MKSTORE.\neconstructor; eauto."},{"statement":"(addr : expr) (ty : type) (rhs : expr) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (chunk : memory_chunk) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full v m') (H : access_mode ty = By_value chunk) (H0 : Mem.storev chunk m (Vptr b ofs) v = Some m') : step ge (State f (Sstore chunk addr rhs) k e le m) E0\n  (State f Sskip k e le m').","conclusion":"step ge (State f (Sstore chunk addr rhs) k e le m) E0\n  (State f Sskip k e le m')","hypotheses":"(addr : expr) (ty : type) (rhs : expr) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (chunk : memory_chunk) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full v m') (H : access_mode ty = By_value chunk) (H0 : Mem.storev chunk m (Vptr b ofs) v = Some m')","proofString":"econstructor; eauto."},{"statement":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (f : function) (k : cont) (MKSTORE : match access_mode ty with\n| By_value chunk => OK (Sstore chunk addr rhs)\n| By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n| _ => Error (msg \"Cshmgen.make_store\")\nend = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full (Vptr b' ofs') m') (EV2 : eval_expr ge e le m rhs (Vptr b' ofs')) (bytes : list memval) (H : access_mode ty = By_copy) (H0 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H1 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H2 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H3 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H4 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : step ge (State f code k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f code k e le m) E0 (State f Sskip k e le m')","hypotheses":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (f : function) (k : cont) (MKSTORE : match access_mode ty with\n| By_value chunk => OK (Sstore chunk addr rhs)\n| By_copy => make_memcpy (prog_comp_env cunit) addr rhs ty\n| _ => Error (msg \"Cshmgen.make_store\")\nend = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full (Vptr b' ofs') m') (EV2 : eval_expr ge e le m rhs (Vptr b' ofs')) (bytes : list memval) (H : access_mode ty = By_copy) (H0 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H1 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H2 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H3 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H4 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"rewrite H in MKSTORE.\neapply make_memcpy_correct with (b := b) (v := Vptr b' ofs'); eauto."},{"statement":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (f : function) (k : cont) (MKSTORE : make_memcpy (prog_comp_env cunit) addr rhs ty = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full (Vptr b' ofs') m') (EV2 : eval_expr ge e le m rhs (Vptr b' ofs')) (bytes : list memval) (H : access_mode ty = By_copy) (H0 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H1 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H2 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H3 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H4 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : step ge (State f code k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f code k e le m) E0 (State f Sskip k e le m')","hypotheses":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (f : function) (k : cont) (MKSTORE : make_memcpy (prog_comp_env cunit) addr rhs ty = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (b' : block) (ofs' : ptrofs) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs Full (Vptr b' ofs') m') (EV2 : eval_expr ge e le m rhs (Vptr b' ofs')) (bytes : list memval) (H : access_mode ty = By_copy) (H0 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs')) (H1 : Ctypes.sizeof (prog_comp_env prog) ty > 0 ->\n(alignof_blockcopy (prog_comp_env prog) ty | Ptrofs.unsigned ofs)) (H2 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Ctypes.sizeof (prog_comp_env prog) ty <=\nPtrofs.unsigned ofs') (H3 : Mem.loadbytes m b' (Ptrofs.unsigned ofs')\n  (Ctypes.sizeof (prog_comp_env prog) ty) = Some bytes) (H4 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"eapply make_memcpy_correct with (b := b) (v := Vptr b' ofs'); eauto."},{"statement":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (sz : intsize) (sg : signedness) (pos width : Z) (MKSTORE : make_store_bitfield sz sg pos width addr rhs = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs (Bits sz sg pos width) v m') (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') : step ge (State f code k e le m) E0 (State f Sskip k e le m').","conclusion":"step ge (State f code k e le m) E0 (State f Sskip k e le m')","hypotheses":"(addr : expr) (ty : type) (rhs : expr) (code : stmt) (e : env) (le : temp_env) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (f : function) (k : cont) (sz : intsize) (sg : signedness) (pos width : Z) (MKSTORE : make_store_bitfield sz sg pos width addr rhs = OK code) (EV1 : eval_expr ge e le m addr (Vptr b ofs)) (EV2 : eval_expr ge e le m rhs v) (ASSIGN : assign_loc (prog_comp_env prog) ty m b ofs (Bits sz sg pos width) v m') (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v')","proofString":"eapply make_store_bitfield_correct; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (t : type) (H : eval_expr ge e le m a v) (H0 : wt_val v t) : eval_expr ge e le m (make_normalization t a) v.","conclusion":"eval_expr ge e le m (make_normalization t a) v","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (t : type) (H : eval_expr ge e le m a v) (H0 : wt_val v t)","proofString":"destruct t; simpl; auto.\ninv H0.\ndestruct i; simpl in H3.\ndestruct s; econstructor; eauto; simpl; congruence.\ndestruct s; econstructor; eauto; simpl; congruence.\nauto.\neconstructor; eauto.\ndestruct H3; subst n; reflexivity.\nauto.\ndestruct i.\ndestruct s; econstructor; eauto.\ndestruct s; econstructor; eauto.\nauto.\neconstructor; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (i : intsize) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a v) (H0 : wt_val v (Tint i s a0)) : eval_expr ge e le m\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match s with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => Eunop Ocast8unsigned a\n  end v.","conclusion":"eval_expr ge e le m\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match s with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => Eunop Ocast8unsigned a\n  end v","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (v : val) (i : intsize) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a v) (H0 : wt_val v (Tint i s a0))","proofString":"inv H0.\ndestruct i; simpl in H3.\ndestruct s; econstructor; eauto; simpl; congruence.\ndestruct s; econstructor; eauto; simpl; congruence.\nauto.\neconstructor; eauto.\ndestruct H3; subst n; reflexivity.\nauto.\ndestruct i.\ndestruct s; econstructor; eauto.\ndestruct s; econstructor; eauto.\nauto.\neconstructor; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : intsize) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : wt_int n i s) : eval_expr ge e le m\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match s with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => Eunop Ocast8unsigned a\n  end (Vint n).","conclusion":"eval_expr ge e le m\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match s with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => Eunop Ocast8unsigned a\n  end (Vint n)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : intsize) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : wt_int n i s)","proofString":"destruct i; simpl in H3.\ndestruct s; econstructor; eauto; simpl; congruence.\ndestruct s; econstructor; eauto; simpl; congruence.\nauto.\neconstructor; eauto.\ndestruct H3; subst n; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : match s with\n| Signed => Int.sign_ext 8 n = n\n| Unsigned => Int.zero_ext 8 n = n\nend) : eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast8signed a\n  | Unsigned => Eunop Ocast8unsigned a\n  end (Vint n).","conclusion":"eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast8signed a\n  | Unsigned => Eunop Ocast8unsigned a\n  end (Vint n)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : match s with\n| Signed => Int.sign_ext 8 n = n\n| Unsigned => Int.zero_ext 8 n = n\nend)","proofString":"destruct s; econstructor; eauto; simpl; congruence."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : match s with\n| Signed => Int.sign_ext 16 n = n\n| Unsigned => Int.zero_ext 16 n = n\nend) : eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast16signed a\n  | Unsigned => Eunop Ocast16unsigned a\n  end (Vint n).","conclusion":"eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast16signed a\n  | Unsigned => Eunop Ocast16unsigned a\n  end (Vint n)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : match s with\n| Signed => Int.sign_ext 16 n = n\n| Unsigned => Int.zero_ext 16 n = n\nend)","proofString":"destruct s; econstructor; eauto; simpl; congruence."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : True) : eval_expr ge e le m a (Vint n).","conclusion":"eval_expr ge e le m a (Vint n)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : True)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : n = Int.zero \\/ n = Int.one) : eval_expr ge e le m (Eunop Ocast8unsigned a) (Vint n).","conclusion":"eval_expr ge e le m (Eunop Ocast8unsigned a) (Vint n)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : n = Int.zero \\/ n = Int.one)","proofString":"econstructor; eauto.\ndestruct H3; subst n; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : n = Int.zero \\/ n = Int.one) : eval_unop Ocast8unsigned (Vint n) = Some (Vint n).","conclusion":"eval_unop Ocast8unsigned (Vint n) = Some (Vint n)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (n : int) (H : eval_expr ge e le m a (Vint n)) (H3 : n = Int.zero \\/ n = Int.one)","proofString":"destruct H3; subst n; reflexivity."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (b : block) (ofs : ptrofs) (H : eval_expr ge e le m a (Vptr b ofs)) (H3 : Archi.ptr64 = false) : eval_expr ge e le m a (Vptr b ofs).","conclusion":"eval_expr ge e le m a (Vptr b ofs)","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (b : block) (ofs : ptrofs) (H : eval_expr ge e le m a (Vptr b ofs)) (H3 : Archi.ptr64 = false)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : intsize) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef) : eval_expr ge e le m\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match s with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => Eunop Ocast8unsigned a\n  end Vundef.","conclusion":"eval_expr ge e le m\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Eunop Ocast8signed a\n      | Unsigned => Eunop Ocast8unsigned a\n      end\n  | I16 =>\n      match s with\n      | Signed => Eunop Ocast16signed a\n      | Unsigned => Eunop Ocast16unsigned a\n      end\n  | I32 => a\n  | IBool => Eunop Ocast8unsigned a\n  end Vundef","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (i : intsize) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef)","proofString":"destruct i.\ndestruct s; econstructor; eauto.\ndestruct s; econstructor; eauto.\nauto.\neconstructor; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef) : eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast8signed a\n  | Unsigned => Eunop Ocast8unsigned a\n  end Vundef.","conclusion":"eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast8signed a\n  | Unsigned => Eunop Ocast8unsigned a\n  end Vundef","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef)","proofString":"destruct s; econstructor; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef) : eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast16signed a\n  | Unsigned => Eunop Ocast16unsigned a\n  end Vundef.","conclusion":"eval_expr ge e le m\n  match s with\n  | Signed => Eunop Ocast16signed a\n  | Unsigned => Eunop Ocast16unsigned a\n  end Vundef","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef)","proofString":"destruct s; econstructor; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef) : eval_expr ge e le m a Vundef.","conclusion":"eval_expr ge e le m a Vundef","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef) : eval_expr ge e le m (Eunop Ocast8unsigned a) Vundef.","conclusion":"eval_expr ge e le m (Eunop Ocast8unsigned a) Vundef","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (s : signedness) (a0 : attr) (H : eval_expr ge e le m a Vundef)","proofString":"econstructor; eauto."},{"statement":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None) : te ! id = None.","conclusion":"te ! id = None","hypotheses":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None)","proofString":"destruct (te!id) as [[b sz] | ] eqn:?; auto.\nexploit me_local_inv; eauto.\nintros [ty EQ].\ncongruence."},{"statement":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None) (b : block) (sz : Z) (Heqo : te ! id = Some (b, sz)) : Some (b, sz) = None.","conclusion":"Some (b, sz) = None","hypotheses":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None) (b : block) (sz : Z) (Heqo : te ! id = Some (b, sz))","proofString":"exploit me_local_inv; eauto.\nintros [ty EQ].\ncongruence."},{"statement":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None) (b : block) (sz : Z) (Heqo : te ! id = Some (b, sz)) : (exists ty : type, e ! id = Some (b, ty)) -> Some (b, sz) = None.","conclusion":"(exists ty : type, e ! id = Some (b, ty)) -> Some (b, sz) = None","hypotheses":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None) (b : block) (sz : Z) (Heqo : te ! id = Some (b, sz))","proofString":"intros [ty EQ].\ncongruence."},{"statement":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None) (b : block) (sz : Z) (Heqo : te ! id = Some (b, sz)) (ty : type) (EQ : e ! id = Some (b, ty)) : Some (b, sz) = None.","conclusion":"Some (b, sz) = None","hypotheses":"(e : Clight.env) (te : env) (id : positive) (H : match_env e te) (H0 : e ! id = None) (b : block) (sz : Z) (Heqo : te ! id = Some (b, sz)) (ty : type) (EQ : e ! id = Some (b, ty))","proofString":"congruence."},{"statement":"(e : Clight.env) (te : env) (H : match_env e te) : blocks_of_env te = Clight.blocks_of_env ge e.","conclusion":"blocks_of_env te = Clight.blocks_of_env ge e","hypotheses":"(e : Clight.env) (te : env) (H : match_env e te)","proofString":"set (R := fun (x: (block * type)) (y: (block * Z)) =>         match x, y with         | (b1, ty), (b2, sz) => b2 = b1 /\\ sz = Ctypes.sizeof ge ty         end).\nassert (list_forall2            (fun i_x i_y => fst i_x = fst i_y /\\ R (snd i_x) (snd i_y))            (PTree.elements e) (PTree.elements te)).\napply PTree.elements_canonical_order.\nintros id [b ty] GET.\nexists (b, Ctypes.sizeof ge ty); split.\neapply me_local; eauto.\nred; auto.\nintros id [b sz] GET.\nexploit me_local_inv; eauto.\nintros [ty EQ].\nexploit me_local; eauto.\nintros EQ1.\nexists (b, ty); split.\nauto.\nred; split; congruence.\nunfold blocks_of_env, Clight.blocks_of_env.\ngeneralize H0.\ninduction 1.\nauto.\nsimpl.\nf_equal; auto.\nunfold block_of_binding, Clight.block_of_binding.\ndestruct a1 as [id1 [blk1 ty1]].\ndestruct b1 as [id2 [blk2 sz2]].\nsimpl in *.\ndestruct H1 as [A [B C]].\ncongruence."},{"statement":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id : positive) (b : block) (ty : type) (GET : e ! id = Some (b, ty)) : te ! id = Some (b, Ctypes.sizeof ge ty).","conclusion":"te ! id = Some (b, Ctypes.sizeof ge ty)","hypotheses":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id : positive) (b : block) (ty : type) (GET : e ! id = Some (b, ty))","proofString":"eapply me_local; eauto."},{"statement":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id : positive) (b : block) (sz : Z) (GET : te ! id = Some (b, sz)) (ty : type) (EQ : e ! id = Some (b, ty)) (EQ1 : te ! id = Some (b, Ctypes.sizeof ge ty)) : e ! id = Some (b, ty).","conclusion":"e ! id = Some (b, ty)","hypotheses":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id : positive) (b : block) (sz : Z) (GET : te ! id = Some (b, sz)) (ty : type) (EQ : e ! id = Some (b, ty)) (EQ1 : te ! id = Some (b, Ctypes.sizeof ge ty))","proofString":"auto."},{"statement":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (H0 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) nil nil) : map block_of_binding nil = map (Clight.block_of_binding ge) nil.","conclusion":"map block_of_binding nil = map (Clight.block_of_binding ge) nil","hypotheses":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (H0 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) nil nil)","proofString":"auto."},{"statement":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id1 : positive) (blk1 : block) (ty1 : type) (al : list (positive * (block * type))) (id2 : positive) (blk2 : block) (sz2 : Z) (bl : list (positive * (block * Z))) (H0 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) ((id1, (blk1, ty1)) :: al)\n  ((id2, (blk2, sz2)) :: bl)) (H1 : id1 = id2 /\\ blk2 = blk1 /\\ sz2 = Ctypes.sizeof (prog_comp_env prog) ty1) (H2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl) (IHlist_forall2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl ->\nmap block_of_binding bl = map (Clight.block_of_binding ge) al) : (blk2, 0, sz2) = (blk1, 0, Ctypes.sizeof (prog_comp_env prog) ty1).","conclusion":"(blk2, 0, sz2) = (blk1, 0, Ctypes.sizeof (prog_comp_env prog) ty1)","hypotheses":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id1 : positive) (blk1 : block) (ty1 : type) (al : list (positive * (block * type))) (id2 : positive) (blk2 : block) (sz2 : Z) (bl : list (positive * (block * Z))) (H0 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) ((id1, (blk1, ty1)) :: al)\n  ((id2, (blk2, sz2)) :: bl)) (H1 : id1 = id2 /\\ blk2 = blk1 /\\ sz2 = Ctypes.sizeof (prog_comp_env prog) ty1) (H2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl) (IHlist_forall2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl ->\nmap block_of_binding bl = map (Clight.block_of_binding ge) al)","proofString":"destruct H1 as [A [B C]].\ncongruence."},{"statement":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id1 : positive) (blk1 : block) (ty1 : type) (al : list (positive * (block * type))) (id2 : positive) (blk2 : block) (sz2 : Z) (bl : list (positive * (block * Z))) (H0 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) ((id1, (blk1, ty1)) :: al)\n  ((id2, (blk2, sz2)) :: bl)) (A : id1 = id2) (B : blk2 = blk1) (C : sz2 = Ctypes.sizeof (prog_comp_env prog) ty1) (H2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl) (IHlist_forall2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl ->\nmap block_of_binding bl = map (Clight.block_of_binding ge) al) : (blk2, 0, sz2) = (blk1, 0, Ctypes.sizeof (prog_comp_env prog) ty1).","conclusion":"(blk2, 0, sz2) = (blk1, 0, Ctypes.sizeof (prog_comp_env prog) ty1)","hypotheses":"(e : Clight.env) (te : env) (H : match_env e te) (R : block * type -> block * Z -> Prop) (id1 : positive) (blk1 : block) (ty1 : type) (al : list (positive * (block * type))) (id2 : positive) (blk2 : block) (sz2 : Z) (bl : list (positive * (block * Z))) (H0 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) ((id1, (blk1, ty1)) :: al)\n  ((id2, (blk2, sz2)) :: bl)) (A : id1 = id2) (B : blk2 = blk1) (C : sz2 = Ctypes.sizeof (prog_comp_env prog) ty1) (H2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl) (IHlist_forall2 : list_forall2\n  (fun (i_x : positive * (block * type)) (i_y : positive * (block * Z)) =>\n   fst i_x = fst i_y /\\ R (snd i_x) (snd i_y)) al bl ->\nmap block_of_binding bl = map (Clight.block_of_binding ge) al)","proofString":"congruence."},{"statement":"(e : Clight.env) (te : env) (m m' : mem) (H : match_env e te) (H0 : Mem.free_list m (Clight.blocks_of_env ge e) = Some m') : Mem.free_list m (blocks_of_env te) = Some m'.","conclusion":"Mem.free_list m (blocks_of_env te) = Some m'","hypotheses":"(e : Clight.env) (te : env) (m m' : mem) (H : match_env e te) (H0 : Mem.free_list m (Clight.blocks_of_env ge e) = Some m')","proofString":"rewrite (match_env_same_blocks _ _ H).\nauto."},{"statement":"(e : Clight.env) (te : env) (m m' : mem) (H : match_env e te) (H0 : Mem.free_list m (Clight.blocks_of_env ge e) = Some m') : Mem.free_list m (Clight.blocks_of_env ge e) = Some m'.","conclusion":"Mem.free_list m (Clight.blocks_of_env ge e) = Some m'","hypotheses":"(e : Clight.env) (te : env) (m m' : mem) (H : match_env e te) (H0 : Mem.free_list m (Clight.blocks_of_env ge e) = Some m')","proofString":"auto."},{"statement":"match_env (PTree.empty (block * type)) (PTree.empty (block * Z)).","conclusion":"match_env (PTree.empty (block * type)) (PTree.empty (block * Z))","hypotheses":"","proofString":"constructor.\nintros until ty.\nrepeat rewrite PTree.gempty.\ncongruence.\nintros until sz.\nrewrite PTree.gempty.\ncongruence."},{"statement":"forall (id : positive) (b : block) (ty : type),\n(PTree.empty (block * type)) ! id = Some (b, ty) ->\n(PTree.empty (block * Z)) ! id = Some (b, Ctypes.sizeof ge ty).","conclusion":"forall (id : positive) (b : block) (ty : type),\n(PTree.empty (block * type)) ! id = Some (b, ty) ->\n(PTree.empty (block * Z)) ! id = Some (b, Ctypes.sizeof ge ty)","hypotheses":"","proofString":"intros until ty.\nrepeat rewrite PTree.gempty.\ncongruence."},{"statement":"(id : positive) (b : block) (ty : type) : (PTree.empty (block * type)) ! id = Some (b, ty) ->\n(PTree.empty (block * Z)) ! id = Some (b, Ctypes.sizeof ge ty).","conclusion":"(PTree.empty (block * type)) ! id = Some (b, ty) ->\n(PTree.empty (block * Z)) ! id = Some (b, Ctypes.sizeof ge ty)","hypotheses":"(id : positive) (b : block) (ty : type)","proofString":"repeat rewrite PTree.gempty.\ncongruence."},{"statement":"(id : positive) (b : block) (ty : type) : None = Some (b, ty) -> None = Some (b, Ctypes.sizeof ge ty).","conclusion":"None = Some (b, ty) -> None = Some (b, Ctypes.sizeof ge ty)","hypotheses":"(id : positive) (b : block) (ty : type)","proofString":"congruence."},{"statement":"forall (id : positive) (b : block) (sz : Z),\n(PTree.empty (block * Z)) ! id = Some (b, sz) ->\nexists ty : type, (PTree.empty (block * type)) ! id = Some (b, ty).","conclusion":"forall (id : positive) (b : block) (sz : Z),\n(PTree.empty (block * Z)) ! id = Some (b, sz) ->\nexists ty : type, (PTree.empty (block * type)) ! id = Some (b, ty)","hypotheses":"","proofString":"intros until sz.\nrewrite PTree.gempty.\ncongruence."},{"statement":"(id : positive) (b : block) (sz : Z) : (PTree.empty (block * Z)) ! id = Some (b, sz) ->\nexists ty : type, (PTree.empty (block * type)) ! id = Some (b, ty).","conclusion":"(PTree.empty (block * Z)) ! id = Some (b, sz) ->\nexists ty : type, (PTree.empty (block * type)) ! id = Some (b, ty)","hypotheses":"(id : positive) (b : block) (sz : Z)","proofString":"rewrite PTree.gempty.\ncongruence."},{"statement":"(id : positive) (b : block) (sz : Z) : None = Some (b, sz) ->\nexists ty : type, (PTree.empty (block * type)) ! id = Some (b, ty).","conclusion":"None = Some (b, sz) ->\nexists ty : type, (PTree.empty (block * type)) ! id = Some (b, ty)","hypotheses":"(id : positive) (b : block) (sz : Z)","proofString":"congruence."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (tvars : list (ident * Z)) (te1 : env) (H0 : OK nil = OK tvars) (H1 : match_env e te1) : exists te2 : env, alloc_variables te1 m tvars te2 m /\\ match_env e te2.","conclusion":"exists te2 : env, alloc_variables te1 m tvars te2 m /\\ match_env e te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (tvars : list (ident * Z)) (te1 : env) (H0 : OK nil = OK tvars) (H1 : match_env e te1)","proofString":"inv H0.\nexists te1; split.\nconstructor.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (te1 : env) (H1 : match_env e te1) : exists te2 : env, alloc_variables te1 m nil te2 m /\\ match_env e te2.","conclusion":"exists te2 : env, alloc_variables te1 m nil te2 m /\\ match_env e te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (te1 : env) (H1 : match_env e te1)","proofString":"exists te1; split.\nconstructor.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (te1 : env) (H1 : match_env e te1) : alloc_variables te1 m nil te1 m.","conclusion":"alloc_variables te1 m nil te1 m","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (te1 : env) (H1 : match_env e te1)","proofString":"constructor."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (te1 : env) (H1 : match_env e te1) : match_env e te1.","conclusion":"match_env e te1","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : Clight.env) (m : mem) (te1 : env) (H1 : match_env e te1)","proofString":"auto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof ge ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars0 : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars0 ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars0 te2 m2 /\\ match_env e2 te2) (tvars : list (ident * Z)) (te1 : env) (H2 : bind (transl_var (prog_comp_env cunit) (id, ty))\n  (fun hd' : ident * Z =>\n   bind (mmap (transl_var (prog_comp_env cunit)) vars)\n     (fun tl' : list (ident * Z) => OK (hd' :: tl'))) = \nOK tvars) (H3 : match_env e te1) : exists te2 : env, alloc_variables te1 m tvars te2 m2 /\\ match_env e2 te2.","conclusion":"exists te2 : env, alloc_variables te1 m tvars te2 m2 /\\ match_env e2 te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof ge ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars0 : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars0 ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars0 te2 m2 /\\ match_env e2 te2) (tvars : list (ident * Z)) (te1 : env) (H2 : bind (transl_var (prog_comp_env cunit) (id, ty))\n  (fun hd' : ident * Z =>\n   bind (mmap (transl_var (prog_comp_env cunit)) vars)\n     (fun tl' : list (ident * Z) => OK (hd' :: tl'))) = \nOK tvars) (H3 : match_env e te1)","proofString":"monadInv H2.\nmonadInv EQ.\nsimpl in *.\nexploit transl_sizeof.\neexact H.\neauto.\nintros SZ; rewrite SZ.\nexploit (IHalloc_variables x0 (PTree.set id (b1, Ctypes.sizeof ge ty) te1)).\nauto.\nconstructor.\nintros until ty0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto.\nintros until sz.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto.\nintros [te2 [ALLOC MENV]].\nexists te2; split.\neconstructor; eauto.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof ge ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x : ident * Z) (EQ : transl_var (prog_comp_env cunit) (id, ty) = OK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) : exists te2 : env, alloc_variables te1 m (x :: x0) te2 m2 /\\ match_env e2 te2.","conclusion":"exists te2 : env, alloc_variables te1 m (x :: x0) te2 m2 /\\ match_env e2 te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof ge ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x : ident * Z) (EQ : transl_var (prog_comp_env cunit) (id, ty) = OK x) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0)","proofString":"monadInv EQ.\nsimpl in *.\nexploit transl_sizeof.\neexact H.\neauto.\nintros SZ; rewrite SZ.\nexploit (IHalloc_variables x0 (PTree.set id (b1, Ctypes.sizeof ge ty) te1)).\nauto.\nconstructor.\nintros until ty0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto.\nintros until sz.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto.\nintros [te2 [ALLOC MENV]].\nexists te2; split.\neconstructor; eauto.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof ge ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) (snd (id, ty)) = OK x1) : exists te2 : env,\n  alloc_variables te1 m ((id, x1) :: x0) te2 m2 /\\ match_env e2 te2.","conclusion":"exists te2 : env,\n  alloc_variables te1 m ((id, x1) :: x0) te2 m2 /\\ match_env e2 te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof ge ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) (snd (id, ty)) = OK x1)","proofString":"simpl in *.\nexploit transl_sizeof.\neexact H.\neauto.\nintros SZ; rewrite SZ.\nexploit (IHalloc_variables x0 (PTree.set id (b1, Ctypes.sizeof ge ty) te1)).\nauto.\nconstructor.\nintros until ty0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto.\nintros until sz.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto.\nintros [te2 [ALLOC MENV]].\nexists te2; split.\neconstructor; eauto.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) : exists te2 : env,\n  alloc_variables te1 m ((id, x1) :: x0) te2 m2 /\\ match_env e2 te2.","conclusion":"exists te2 : env,\n  alloc_variables te1 m ((id, x1) :: x0) te2 m2 /\\ match_env e2 te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1)","proofString":"exploit transl_sizeof.\neexact H.\neauto.\nintros SZ; rewrite SZ.\nexploit (IHalloc_variables x0 (PTree.set id (b1, Ctypes.sizeof ge ty) te1)).\nauto.\nconstructor.\nintros until ty0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto.\nintros until sz.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto.\nintros [te2 [ALLOC MENV]].\nexists te2; split.\neconstructor; eauto.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) : exists te2 : env,\n  alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0)\n    te2 m2 /\\ match_env e2 te2.","conclusion":"exists te2 : env,\n  alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0)\n    te2 m2 /\\ match_env e2 te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty)","proofString":"exploit (IHalloc_variables x0 (PTree.set id (b1, Ctypes.sizeof ge ty) te1)).\nauto.\nconstructor.\nintros until ty0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto.\nintros until sz.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto.\nintros [te2 [ALLOC MENV]].\nexists te2; split.\neconstructor; eauto.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) : mmap (transl_var (prog_comp_env cunit)) vars = OK x0.","conclusion":"mmap (transl_var (prog_comp_env cunit)) vars = OK x0","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty)","proofString":"auto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) : match_env (PTree.set id (b1, ty) e)\n  (PTree.set id (b1, Ctypes.sizeof ge ty) te1).","conclusion":"match_env (PTree.set id (b1, ty) e)\n  (PTree.set id (b1, Ctypes.sizeof ge ty) te1)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty)","proofString":"constructor.\nintros until ty0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto.\nintros until sz.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) : forall (id0 : positive) (b : block) (ty0 : type),\n(PTree.set id (b1, ty) e) ! id0 = Some (b, ty0) ->\n(PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 =\nSome (b, Ctypes.sizeof ge ty0).","conclusion":"forall (id0 : positive) (b : block) (ty0 : type),\n(PTree.set id (b1, ty) e) ! id0 = Some (b, ty0) ->\n(PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 =\nSome (b, Ctypes.sizeof ge ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty)","proofString":"intros until ty0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type) : (PTree.set id (b1, ty) e) ! id0 = Some (b, ty0) ->\n(PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 =\nSome (b, Ctypes.sizeof ge ty0).","conclusion":"(PTree.set id (b1, ty) e) ! id0 = Some (b, ty0) ->\n(PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 =\nSome (b, Ctypes.sizeof ge ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type)","proofString":"repeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type) : (if peq id0 id then Some (b1, ty) else e ! id0) = Some (b, ty0) ->\n(if peq id0 id then Some (b1, Ctypes.sizeof ge ty) else te1 ! id0) =\nSome (b, Ctypes.sizeof ge ty0).","conclusion":"(if peq id0 id then Some (b1, ty) else e ! id0) = Some (b, ty0) ->\n(if peq id0 id then Some (b1, Ctypes.sizeof ge ty) else te1 ! id0) =\nSome (b, Ctypes.sizeof ge ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type)","proofString":"destruct (peq id0 id); intros.\ncongruence.\neapply me_local; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type) (e0 : id0 = id) (H2 : Some (b1, ty) = Some (b, ty0)) : Some (b1, Ctypes.sizeof ge ty) = Some (b, Ctypes.sizeof ge ty0).","conclusion":"Some (b1, Ctypes.sizeof ge ty) = Some (b, Ctypes.sizeof ge ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type) (e0 : id0 = id) (H2 : Some (b1, ty) = Some (b, ty0))","proofString":"congruence."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H2 : e ! id0 = Some (b, ty0)) : te1 ! id0 = Some (b, Ctypes.sizeof ge ty0).","conclusion":"te1 ! id0 = Some (b, Ctypes.sizeof ge ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (ty0 : type) (n : id0 <> id) (H2 : e ! id0 = Some (b, ty0))","proofString":"eapply me_local; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) : forall (id0 : positive) (b : block) (sz : Z),\n(PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 = Some (b, sz) ->\nexists ty0 : type, (PTree.set id (b1, ty) e) ! id0 = Some (b, ty0).","conclusion":"forall (id0 : positive) (b : block) (sz : Z),\n(PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 = Some (b, sz) ->\nexists ty0 : type, (PTree.set id (b1, ty) e) ! id0 = Some (b, ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty)","proofString":"intros until sz.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z) : (PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 = Some (b, sz) ->\nexists ty0 : type, (PTree.set id (b1, ty) e) ! id0 = Some (b, ty0).","conclusion":"(PTree.set id (b1, Ctypes.sizeof ge ty) te1) ! id0 = Some (b, sz) ->\nexists ty0 : type, (PTree.set id (b1, ty) e) ! id0 = Some (b, ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z)","proofString":"repeat rewrite PTree.gsspec.\ndestruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z) : (if peq id0 id then Some (b1, Ctypes.sizeof ge ty) else te1 ! id0) =\nSome (b, sz) ->\nexists ty0 : type,\n  (if peq id0 id then Some (b1, ty) else e ! id0) = Some (b, ty0).","conclusion":"(if peq id0 id then Some (b1, Ctypes.sizeof ge ty) else te1 ! id0) =\nSome (b, sz) ->\nexists ty0 : type,\n  (if peq id0 id then Some (b1, ty) else e ! id0) = Some (b, ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z)","proofString":"destruct (peq id0 id); intros.\nexists ty; congruence.\neapply me_local_inv; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z) (e0 : id0 = id) (H2 : Some (b1, Ctypes.sizeof ge ty) = Some (b, sz)) : exists ty0 : type, Some (b1, ty) = Some (b, ty0).","conclusion":"exists ty0 : type, Some (b1, ty) = Some (b, ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z) (e0 : id0 = id) (H2 : Some (b1, Ctypes.sizeof ge ty) = Some (b, sz))","proofString":"exists ty; congruence."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z) (n : id0 <> id) (H2 : te1 ! id0 = Some (b, sz)) : exists ty0 : type, e ! id0 = Some (b, ty0).","conclusion":"exists ty0 : type, e ! id0 = Some (b, ty0)","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (id0 : positive) (b : block) (sz : Z) (n : id0 <> id) (H2 : te1 ! id0 = Some (b, sz))","proofString":"eapply me_local_inv; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) : (exists te2 : env,\n   alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2 /\\\n   match_env e2 te2) ->\nexists te2 : env,\n  alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0)\n    te2 m2 /\\ match_env e2 te2.","conclusion":"(exists te2 : env,\n   alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2 /\\\n   match_env e2 te2) ->\nexists te2 : env,\n  alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0)\n    te2 m2 /\\ match_env e2 te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te2 : env, alloc_variables te0 m1 tvars te2 m2 /\\ match_env e2 te2) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty)","proofString":"intros [te2 [ALLOC MENV]].\nexists te2; split.\neconstructor; eauto.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te3 : env, alloc_variables te0 m1 tvars te3 m2 /\\ match_env e2 te3) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (te2 : env) (ALLOC : alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2) (MENV : match_env e2 te2) : exists te0 : env,\n  alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0)\n    te0 m2 /\\ match_env e2 te0.","conclusion":"exists te0 : env,\n  alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0)\n    te0 m2 /\\ match_env e2 te0","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te3 : env, alloc_variables te0 m1 tvars te3 m2 /\\ match_env e2 te3) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (te2 : env) (ALLOC : alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2) (MENV : match_env e2 te2)","proofString":"exists te2; split.\neconstructor; eauto.\nauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te3 : env, alloc_variables te0 m1 tvars te3 m2 /\\ match_env e2 te3) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (te2 : env) (ALLOC : alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2) (MENV : match_env e2 te2) : alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0) te2\n  m2.","conclusion":"alloc_variables te1 m ((id, Ctypes.sizeof (prog_comp_env prog) ty) :: x0) te2\n  m2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te3 : env, alloc_variables te0 m1 tvars te3 m2 /\\ match_env e2 te3) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (te2 : env) (ALLOC : alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2) (MENV : match_env e2 te2)","proofString":"econstructor; eauto."},{"statement":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te3 : env, alloc_variables te0 m1 tvars te3 m2 /\\ match_env e2 te3) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (te2 : env) (ALLOC : alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2) (MENV : match_env e2 te2) : match_env e2 te2.","conclusion":"match_env e2 te2","hypotheses":"(cunit : Clight.program) (H : linkorder cunit prog) (e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Clight.env) (H0 : Mem.alloc m 0 (Ctypes.sizeof (prog_comp_env prog) ty) = (m1, b1)) (H1 : Clight.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : forall (tvars : list (ident * Z)) (te0 : env),\nmmap (transl_var (prog_comp_env cunit)) vars = OK tvars ->\nmatch_env (PTree.set id (b1, ty) e) te0 ->\nexists te3 : env, alloc_variables te0 m1 tvars te3 m2 /\\ match_env e2 te3) (te1 : env) (H3 : match_env e te1) (x0 : list (ident * Z)) (EQ1 : mmap (transl_var (prog_comp_env cunit)) vars = OK x0) (x1 : Z) (EQ0 : sizeof (prog_comp_env cunit) ty = OK x1) (SZ : x1 = Ctypes.sizeof (prog_comp_env prog) ty) (te2 : env) (ALLOC : alloc_variables (PTree.set id (b1, Ctypes.sizeof ge ty) te1) m1 x0 te2 m2) (MENV : match_env e2 te2)","proofString":"auto."},{"statement":"PTree.empty val = PTree.empty val.","conclusion":"PTree.empty val = PTree.empty val","hypotheses":"","proofString":"auto."},{"statement":"(a : ident * type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps) : PTree.set (fst a) Vundef (create_undef_temps (map fst temps)) =\n(let (id, _) := a in PTree.set id Vundef (Clight.create_undef_temps temps)).","conclusion":"PTree.set (fst a) Vundef (create_undef_temps (map fst temps)) =\n(let (id, _) := a in PTree.set id Vundef (Clight.create_undef_temps temps))","hypotheses":"(a : ident * type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps)","proofString":"destruct a as [id ty].\nsimpl.\ndecEq.\nauto."},{"statement":"(id : ident) (ty : type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps) : PTree.set (fst (id, ty)) Vundef (create_undef_temps (map fst temps)) =\nPTree.set id Vundef (Clight.create_undef_temps temps).","conclusion":"PTree.set (fst (id, ty)) Vundef (create_undef_temps (map fst temps)) =\nPTree.set id Vundef (Clight.create_undef_temps temps)","hypotheses":"(id : ident) (ty : type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps)","proofString":"simpl.\ndecEq.\nauto."},{"statement":"(id : ident) (ty : type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps) : PTree.set id Vundef (create_undef_temps (map fst temps)) =\nPTree.set id Vundef (Clight.create_undef_temps temps).","conclusion":"PTree.set id Vundef (create_undef_temps (map fst temps)) =\nPTree.set id Vundef (Clight.create_undef_temps temps)","hypotheses":"(id : ident) (ty : type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps)","proofString":"decEq.\nauto."},{"statement":"(id : ident) (ty : type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps) : create_undef_temps (map fst temps) = Clight.create_undef_temps temps.","conclusion":"create_undef_temps (map fst temps) = Clight.create_undef_temps temps","hypotheses":"(id : ident) (ty : type) (temps : list (ident * type)) (IHtemps : create_undef_temps (map fst temps) = Clight.create_undef_temps temps)","proofString":"auto."},{"statement":"(vals : list val) (le1 le2 : Clight.temp_env) (H : match vals with\n| nil => Some le1\n| _ :: _ => None\nend = Some le2) : match vals with\n| nil => Some le1\n| _ :: _ => None\nend = Some le2.","conclusion":"match vals with\n| nil => Some le1\n| _ :: _ => None\nend = Some le2","hypotheses":"(vals : list val) (le1 le2 : Clight.temp_env) (H : match vals with\n| nil => Some le1\n| _ :: _ => None\nend = Some le2)","proofString":"destruct vals; inv H.\nauto."},{"statement":"(le2 : Clight.temp_env) : Some le2 = Some le2.","conclusion":"Some le2 = Some le2","hypotheses":"(le2 : Clight.temp_env)","proofString":"auto."},{"statement":"(a : ident * type) (vars : list (ident * type)) (IHvars : forall (vals0 : list val) (le0 le3 : Clight.temp_env),\nbind_parameter_temps vars vals0 le0 = Some le3 ->\nbind_parameters (map fst vars) vals0 le0 = Some le3) (vals : list val) (le1 le2 : Clight.temp_env) (H : (let (id, _) := a in\n match vals with\n | nil => None\n | v :: vl => bind_parameter_temps vars vl (PTree.set id v le1)\n end) = Some le2) : match vals with\n| nil => None\n| v :: vl => bind_parameters (map fst vars) vl (PTree.set (fst a) v le1)\nend = Some le2.","conclusion":"match vals with\n| nil => None\n| v :: vl => bind_parameters (map fst vars) vl (PTree.set (fst a) v le1)\nend = Some le2","hypotheses":"(a : ident * type) (vars : list (ident * type)) (IHvars : forall (vals0 : list val) (le0 le3 : Clight.temp_env),\nbind_parameter_temps vars vals0 le0 = Some le3 ->\nbind_parameters (map fst vars) vals0 le0 = Some le3) (vals : list val) (le1 le2 : Clight.temp_env) (H : (let (id, _) := a in\n match vals with\n | nil => None\n | v :: vl => bind_parameter_temps vars vl (PTree.set id v le1)\n end) = Some le2)","proofString":"destruct a as [id ty].\ndestruct vals; try discriminate.\nauto."},{"statement":"(id : ident) (ty : type) (vars : list (ident * type)) (IHvars : forall (vals0 : list val) (le0 le3 : Clight.temp_env),\nbind_parameter_temps vars vals0 le0 = Some le3 ->\nbind_parameters (map fst vars) vals0 le0 = Some le3) (vals : list val) (le1 le2 : Clight.temp_env) (H : match vals with\n| nil => None\n| v :: vl => bind_parameter_temps vars vl (PTree.set id v le1)\nend = Some le2) : match vals with\n| nil => None\n| v :: vl =>\n    bind_parameters (map fst vars) vl (PTree.set (fst (id, ty)) v le1)\nend = Some le2.","conclusion":"match vals with\n| nil => None\n| v :: vl =>\n    bind_parameters (map fst vars) vl (PTree.set (fst (id, ty)) v le1)\nend = Some le2","hypotheses":"(id : ident) (ty : type) (vars : list (ident * type)) (IHvars : forall (vals0 : list val) (le0 le3 : Clight.temp_env),\nbind_parameter_temps vars vals0 le0 = Some le3 ->\nbind_parameters (map fst vars) vals0 le0 = Some le3) (vals : list val) (le1 le2 : Clight.temp_env) (H : match vals with\n| nil => None\n| v :: vl => bind_parameter_temps vars vl (PTree.set id v le1)\nend = Some le2)","proofString":"destruct vals; try discriminate.\nauto."},{"statement":"(id : ident) (ty : type) (vars : list (ident * type)) (IHvars : forall (vals0 : list val) (le0 le3 : Clight.temp_env),\nbind_parameter_temps vars vals0 le0 = Some le3 ->\nbind_parameters (map fst vars) vals0 le0 = Some le3) (v : val) (vals : list val) (le1 le2 : Clight.temp_env) (H : bind_parameter_temps vars vals (PTree.set id v le1) = Some le2) : bind_parameters (map fst vars) vals (PTree.set (fst (id, ty)) v le1) =\nSome le2.","conclusion":"bind_parameters (map fst vars) vals (PTree.set (fst (id, ty)) v le1) =\nSome le2","hypotheses":"(id : ident) (ty : type) (vars : list (ident * type)) (IHvars : forall (vals0 : list val) (le0 le3 : Clight.temp_env),\nbind_parameter_temps vars vals0 le0 = Some le3 ->\nbind_parameters (map fst vars) vals0 le0 = Some le3) (v : val) (vals : list val) (le1 le2 : Clight.temp_env) (H : bind_parameter_temps vars vals (PTree.set id v le1) = Some le2)","proofString":"auto."},{"statement":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars) : map fst tvars = var_names vars.","conclusion":"map fst tvars = var_names vars","hypotheses":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars)","proofString":"exploit mmap_inversion; eauto.\ngeneralize vars tvars.\ninduction 1; simpl.\nauto.\nmonadInv H0.\nsimpl; congruence."},{"statement":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars) : list_forall2\n  (fun (x : ident * type) (y : ident * Z) => transl_var ce x = OK y) vars\n  tvars -> map fst tvars = var_names vars.","conclusion":"list_forall2\n  (fun (x : ident * type) (y : ident * Z) => transl_var ce x = OK y) vars\n  tvars -> map fst tvars = var_names vars","hypotheses":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars)","proofString":"generalize vars tvars.\ninduction 1; simpl.\nauto.\nmonadInv H0.\nsimpl; congruence."},{"statement":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars) : forall (vars0 : list (ident * type)) (tvars0 : list (ident * Z)),\nlist_forall2\n  (fun (x : ident * type) (y : ident * Z) => transl_var ce x = OK y) vars0\n  tvars0 -> map fst tvars0 = var_names vars0.","conclusion":"forall (vars0 : list (ident * type)) (tvars0 : list (ident * Z)),\nlist_forall2\n  (fun (x : ident * type) (y : ident * Z) => transl_var ce x = OK y) vars0\n  tvars0 -> map fst tvars0 = var_names vars0","hypotheses":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars)","proofString":"induction 1; simpl.\nauto.\nmonadInv H0.\nsimpl; congruence."},{"statement":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars) (a1 : ident * type) (al : list (ident * type)) (b1 : ident * Z) (bl : list (ident * Z)) (H0 : transl_var ce a1 = OK b1) (H1 : list_forall2\n  (fun (x : ident * type) (y : ident * Z) => transl_var ce x = OK y) al bl) (IHlist_forall2 : map fst bl = var_names al) : fst b1 :: map fst bl = fst a1 :: var_names al.","conclusion":"fst b1 :: map fst bl = fst a1 :: var_names al","hypotheses":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars) (a1 : ident * type) (al : list (ident * type)) (b1 : ident * Z) (bl : list (ident * Z)) (H0 : transl_var ce a1 = OK b1) (H1 : list_forall2\n  (fun (x : ident * type) (y : ident * Z) => transl_var ce x = OK y) al bl) (IHlist_forall2 : map fst bl = var_names al)","proofString":"monadInv H0.\nsimpl; congruence."},{"statement":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars) (a1 : ident * type) (al : list (ident * type)) (bl : list (ident * Z)) (H1 : list_forall2\n  (fun (x0 : ident * type) (y : ident * Z) => transl_var ce x0 = OK y) al bl) (IHlist_forall2 : map fst bl = var_names al) (x : Z) (EQ : sizeof ce (snd a1) = OK x) : fst (fst a1, x) :: map fst bl = fst a1 :: var_names al.","conclusion":"fst (fst a1, x) :: map fst bl = fst a1 :: var_names al","hypotheses":"(ce : composite_env) (vars : list (ident * type)) (tvars : list (ident * Z)) (H : mmap (transl_var ce) vars = OK tvars) (a1 : ident * type) (al : list (ident * type)) (bl : list (ident * Z)) (H1 : list_forall2\n  (fun (x0 : ident * type) (y : ident * Z) => transl_var ce x0 = OK y) al bl) (IHlist_forall2 : map fst bl = var_names al) (x : Z) (EQ : sizeof ce (snd a1) = OK x)","proofString":"simpl; congruence."},{"statement":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (ta : expr) (EVAL : eval_lvalue ge e le m a loc ofs bf) (TR : transl_expr (prog_comp_env cunit) a = OK ta) : exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) a = OK (tb, bf) /\\\n  make_load tb (typeof a) bf = OK ta.","conclusion":"exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) a = OK (tb, bf) /\\\n  make_load tb (typeof a) bf = OK ta","hypotheses":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (ta : expr) (EVAL : eval_lvalue ge e le m a loc ofs bf) (TR : transl_expr (prog_comp_env cunit) a = OK ta)","proofString":"inv EVAL; simpl in TR.\nexists (Eaddrof id); auto.\nexists (Eaddrof id); auto.\nmonadInv TR.\ncbn; rewrite EQ.\nexists x; auto.\nmonadInv TR.\nassert (x1 = bf).\nrewrite H0 in EQ1.\nunfold make_field_access in EQ1.\ndestruct ((prog_comp_env cunit)!id) as [co'|] eqn:E; try discriminate.\nmonadInv EQ1.\nexploit field_offset_stable.\neexact LINK.\neauto.\ninstantiate (1 := i).\nintros [A B].\nsimpl in H1, H2.\ncongruence.\nsubst x1.\nexists x0; split; auto.\nsimpl; rewrite EQ; auto.\nmonadInv TR.\nassert (x1 = bf).\nrewrite H0 in EQ1.\nunfold make_field_access in EQ1.\ndestruct ((prog_comp_env cunit)!id) as [co'|] eqn:E; try discriminate.\nmonadInv EQ1.\nexploit union_field_offset_stable.\neexact LINK.\neauto.\ninstantiate (1 := i).\nintros [A B].\nsimpl in H1, H2.\ncongruence.\nsubst x1.\nexists x0; split; auto.\nsimpl; rewrite EQ; auto."},{"statement":"(loc : block) (ta : expr) (id : positive) (ty : type) (TR : match access_mode ty with\n| By_value chunk => OK (Eload chunk (Eaddrof id))\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK (Eaddrof id)\nend = OK ta) (H : e ! id = Some (loc, ty)) : exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Clight.Evar id ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Clight.Evar id ty)) Full = OK ta.","conclusion":"exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Clight.Evar id ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Clight.Evar id ty)) Full = OK ta","hypotheses":"(loc : block) (ta : expr) (id : positive) (ty : type) (TR : match access_mode ty with\n| By_value chunk => OK (Eload chunk (Eaddrof id))\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK (Eaddrof id)\nend = OK ta) (H : e ! id = Some (loc, ty))","proofString":"exists (Eaddrof id); auto."},{"statement":"(loc : block) (ta : expr) (id : positive) (ty : type) (TR : match access_mode ty with\n| By_value chunk => OK (Eload chunk (Eaddrof id))\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK (Eaddrof id)\nend = OK ta) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some loc) : exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Clight.Evar id ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Clight.Evar id ty)) Full = OK ta.","conclusion":"exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Clight.Evar id ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Clight.Evar id ty)) Full = OK ta","hypotheses":"(loc : block) (ta : expr) (id : positive) (ty : type) (TR : match access_mode ty with\n| By_value chunk => OK (Eload chunk (Eaddrof id))\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK (Eaddrof id)\nend = OK ta) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some loc)","proofString":"exists (Eaddrof id); auto."},{"statement":"(loc : block) (ofs : ptrofs) (ta : expr) (a0 : Clight.expr) (ty : type) (TR : bind (transl_expr (prog_comp_env cunit) a0)\n  (fun tb : expr =>\n   match access_mode ty with\n   | By_value chunk => OK (Eload chunk tb)\n   | By_nothing => Error (msg \"Cshmgen.make_load\")\n   | _ => OK tb\n   end) = OK ta) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs)) : exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Ederef a0 ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Ederef a0 ty)) Full = OK ta.","conclusion":"exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Ederef a0 ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Ederef a0 ty)) Full = OK ta","hypotheses":"(loc : block) (ofs : ptrofs) (ta : expr) (a0 : Clight.expr) (ty : type) (TR : bind (transl_expr (prog_comp_env cunit) a0)\n  (fun tb : expr =>\n   match access_mode ty with\n   | By_value chunk => OK (Eload chunk tb)\n   | By_nothing => Error (msg \"Cshmgen.make_load\")\n   | _ => OK tb\n   end) = OK ta) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs))","proofString":"monadInv TR.\ncbn; rewrite EQ.\nexists x; auto."},{"statement":"(loc : block) (ofs : ptrofs) (ta : expr) (a0 : Clight.expr) (ty : type) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (EQ0 : match access_mode ty with\n| By_value chunk => OK (Eload chunk x)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK x\nend = OK ta) : exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Ederef a0 ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Ederef a0 ty)) Full = OK ta.","conclusion":"exists tb : expr,\n  transl_lvalue (prog_comp_env cunit) (Ederef a0 ty) = OK (tb, Full) /\\\n  make_load tb (typeof (Ederef a0 ty)) Full = OK ta","hypotheses":"(loc : block) (ofs : ptrofs) (ta : expr) (a0 : Clight.expr) (ty : type) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (EQ0 : match access_mode ty with\n| By_value chunk => OK (Eload chunk x)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK x\nend = OK ta)","proofString":"cbn; rewrite EQ.\nexists x; auto."},{"statement":"(loc : block) (ofs : ptrofs) (ta : expr) (a0 : Clight.expr) (ty : type) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (EQ0 : match access_mode ty with\n| By_value chunk => OK (Eload chunk x)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK x\nend = OK ta) : exists tb : expr,\n  bind (OK x) (fun tb0 : expr => OK (tb0, Full)) = OK (tb, Full) /\\\n  match access_mode ty with\n  | By_value chunk => OK (Eload chunk tb)\n  | By_nothing => Error (msg \"Cshmgen.make_load\")\n  | _ => OK tb\n  end = OK ta.","conclusion":"exists tb : expr,\n  bind (OK x) (fun tb0 : expr => OK (tb0, Full)) = OK (tb, Full) /\\\n  match access_mode ty with\n  | By_value chunk => OK (Eload chunk tb)\n  | By_nothing => Error (msg \"Cshmgen.make_load\")\n  | _ => OK tb\n  end = OK ta","hypotheses":"(loc : block) (ofs : ptrofs) (ta : expr) (a0 : Clight.expr) (ty : type) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (EQ0 : match access_mode ty with\n| By_value chunk => OK (Eload chunk x)\n| By_nothing => Error (msg \"Cshmgen.make_load\")\n| _ => OK x\nend = OK ta)","proofString":"exists x; auto."},{"statement":"(loc : block) (bf : bitfield) (ta : expr) (a0 : Clight.expr) (i : ident) (ty : type) (ofs0 : ptrofs) (id : ident) (co : composite) (att : attr) (delta : Z) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs0)) (H0 : typeof a0 = Tstruct id att) (H1 : (prog_comp_env prog) ! id = Some co) (H2 : field_offset (prog_comp_env prog) i (co_members co) = OK (delta, bf)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (x1 : bitfield) (co' : composite) (E : (prog_comp_env cunit) ! id = Some co') (x2 : Z) (EQ2 : make_load\n  (if Archi.ptr64\n   then Ebinop Oaddl x (make_longconst (Int64.repr x2))\n   else Ebinop Oadd x (make_intconst (Int.repr x2))) ty x1 = \nOK ta) (EQ0 : field_offset (prog_comp_env cunit) i (co_members co') = OK (x2, x1)) (A : (prog_comp_env prog) ! id = Some co') (B : field_offset (prog_comp_env prog) i (co_members co') =\nfield_offset (prog_comp_env cunit) i (co_members co')) : x1 = bf.","conclusion":"x1 = bf","hypotheses":"(loc : block) (bf : bitfield) (ta : expr) (a0 : Clight.expr) (i : ident) (ty : type) (ofs0 : ptrofs) (id : ident) (co : composite) (att : attr) (delta : Z) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs0)) (H0 : typeof a0 = Tstruct id att) (H1 : (prog_comp_env prog) ! id = Some co) (H2 : field_offset (prog_comp_env prog) i (co_members co) = OK (delta, bf)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (x1 : bitfield) (co' : composite) (E : (prog_comp_env cunit) ! id = Some co') (x2 : Z) (EQ2 : make_load\n  (if Archi.ptr64\n   then Ebinop Oaddl x (make_longconst (Int64.repr x2))\n   else Ebinop Oadd x (make_intconst (Int.repr x2))) ty x1 = \nOK ta) (EQ0 : field_offset (prog_comp_env cunit) i (co_members co') = OK (x2, x1)) (A : (prog_comp_env prog) ! id = Some co') (B : field_offset (prog_comp_env prog) i (co_members co') =\nfield_offset (prog_comp_env cunit) i (co_members co'))","proofString":"congruence."},{"statement":"(loc : block) (bf : bitfield) (ta : expr) (a0 : Clight.expr) (i : ident) (ty : type) (ofs0 : ptrofs) (id : ident) (co : composite) (att : attr) (delta : Z) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs0)) (H0 : typeof a0 = Tunion id att) (H1 : (prog_comp_env prog) ! id = Some co) (H2 : union_field_offset (prog_comp_env prog) i (co_members co) = OK (delta, bf)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (x1 : bitfield) (co' : composite) (E : (prog_comp_env cunit) ! id = Some co') (x2 : Z) (EQ2 : make_load\n  (if Archi.ptr64\n   then Ebinop Oaddl x (make_longconst (Int64.repr x2))\n   else Ebinop Oadd x (make_intconst (Int.repr x2))) ty x1 = \nOK ta) (EQ0 : union_field_offset (prog_comp_env cunit) i (co_members co') = OK (x2, x1)) (A : (prog_comp_env prog) ! id = Some co') (B : union_field_offset (prog_comp_env prog) i (co_members co') =\nunion_field_offset (prog_comp_env cunit) i (co_members co')) : x1 = bf.","conclusion":"x1 = bf","hypotheses":"(loc : block) (bf : bitfield) (ta : expr) (a0 : Clight.expr) (i : ident) (ty : type) (ofs0 : ptrofs) (id : ident) (co : composite) (att : attr) (delta : Z) (H : Clight.eval_expr ge e le m a0 (Vptr loc ofs0)) (H0 : typeof a0 = Tunion id att) (H1 : (prog_comp_env prog) ! id = Some co) (H2 : union_field_offset (prog_comp_env prog) i (co_members co) = OK (delta, bf)) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a0 = OK x) (x1 : bitfield) (co' : composite) (E : (prog_comp_env cunit) ! id = Some co') (x2 : Z) (EQ2 : make_load\n  (if Archi.ptr64\n   then Ebinop Oaddl x (make_longconst (Int64.repr x2))\n   else Ebinop Oadd x (make_intconst (Int.repr x2))) ty x1 = \nOK ta) (EQ0 : union_field_offset (prog_comp_env cunit) i (co_members co') = OK (x2, x1)) (A : (prog_comp_env prog) ! id = Some co') (B : union_field_offset (prog_comp_env prog) i (co_members co') =\nunion_field_offset (prog_comp_env cunit) i (co_members co'))","proofString":"congruence."},{"statement":"(i : int) (ty : type) : eval_expr tge te le m (make_intconst i) (Vint i).","conclusion":"eval_expr tge te le m (make_intconst i) (Vint i)","hypotheses":"(i : int) (ty : type)","proofString":"apply make_intconst_correct."},{"statement":"(f : float) (ty : type) : eval_expr tge te le m (make_floatconst f) (Vfloat f).","conclusion":"eval_expr tge te le m (make_floatconst f) (Vfloat f)","hypotheses":"(f : float) (ty : type)","proofString":"apply make_floatconst_correct."},{"statement":"(f : float32) (ty : type) : eval_expr tge te le m (make_singleconst f) (Vsingle f).","conclusion":"eval_expr tge te le m (make_singleconst f) (Vsingle f)","hypotheses":"(f : float32) (ty : type)","proofString":"apply make_singleconst_correct."},{"statement":"(i : int64) (ty : type) : eval_expr tge te le m (make_longconst i) (Vlong i).","conclusion":"eval_expr tge te le m (make_longconst i) (Vlong i)","hypotheses":"(i : int64) (ty : type)","proofString":"apply make_longconst_correct."},{"statement":"(id : positive) (ty : type) (v : val) (H : le ! id = Some v) : eval_expr tge te le m (Evar id) v.","conclusion":"eval_expr tge te le m (Evar id) v","hypotheses":"(id : positive) (ty : type) (v : val) (H : le ! id = Some v)","proofString":"constructor; auto."},{"statement":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta x : expr) (x0 : bitfield) (EQ : transl_lvalue (prog_comp_env cunit) a = OK (x, x0)) (EQ0 : match x0 with\n| Full => OK x\n| Bits _ _ _ _ => Error (msg \"Cshmgen.transl_expr: addrof bitfield\")\nend = OK ta) : eval_expr tge te le m ta (Vptr loc ofs).","conclusion":"eval_expr tge te le m ta (Vptr loc ofs)","hypotheses":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta x : expr) (x0 : bitfield) (EQ : transl_lvalue (prog_comp_env cunit) a = OK (x, x0)) (EQ0 : match x0 with\n| Full => OK x\n| Bits _ _ _ _ => Error (msg \"Cshmgen.transl_expr: addrof bitfield\")\nend = OK ta)","proofString":"destruct x0; inv EQ0.\napply H0 in EQ.\ndestruct EQ.\nauto."},{"statement":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta : expr) (EQ : transl_lvalue (prog_comp_env cunit) a = OK (ta, Full)) : eval_expr tge te le m ta (Vptr loc ofs).","conclusion":"eval_expr tge te le m ta (Vptr loc ofs)","hypotheses":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta : expr) (EQ : transl_lvalue (prog_comp_env cunit) a = OK (ta, Full))","proofString":"apply H0 in EQ.\ndestruct EQ.\nauto."},{"statement":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta : expr) (EQ : Full = Full /\\ eval_expr tge te le m ta (Vptr loc ofs)) : eval_expr tge te le m ta (Vptr loc ofs).","conclusion":"eval_expr tge te le m ta (Vptr loc ofs)","hypotheses":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta : expr) (EQ : Full = Full /\\ eval_expr tge te le m ta (Vptr loc ofs))","proofString":"destruct EQ.\nauto."},{"statement":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta : expr) (H1 : Full = Full) (H2 : eval_expr tge te le m ta (Vptr loc ofs)) : eval_expr tge te le m ta (Vptr loc ofs).","conclusion":"eval_expr tge te le m ta (Vptr loc ofs)","hypotheses":"(a : Clight.expr) (ty : type) (loc : block) (ofs : ptrofs) (H : eval_lvalue ge e le m a loc ofs Full) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nFull = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (ta : expr) (H1 : Full = Full) (H2 : eval_expr tge te le m ta (Vptr loc ofs))","proofString":"auto."},{"statement":"(op : Cop.unary_operation) (a : Clight.expr) (ty : type) (v1 v : val) (H : Clight.eval_expr ge e le m a v1) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a = OK ta0 -> eval_expr tge te le m ta0 v1) (H1 : sem_unary_operation op v1 (typeof a) m = Some v) (ta x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (EQ0 : transl_unop op x (typeof a) = OK ta) : eval_expr tge te le m ta v.","conclusion":"eval_expr tge te le m ta v","hypotheses":"(op : Cop.unary_operation) (a : Clight.expr) (ty : type) (v1 v : val) (H : Clight.eval_expr ge e le m a v1) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a = OK ta0 -> eval_expr tge te le m ta0 v1) (H1 : sem_unary_operation op v1 (typeof a) m = Some v) (ta x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (EQ0 : transl_unop op x (typeof a) = OK ta)","proofString":"eapply transl_unop_correct; eauto."},{"statement":"(op : Cop.binary_operation) (a1 a2 : Clight.expr) (ty : type) (v1 v2 v : val) (H : Clight.eval_expr ge e le m a1 v1) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a1 = OK ta0 -> eval_expr tge te le m ta0 v1) (H1 : Clight.eval_expr ge e le m a2 v2) (H2 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a2 = OK ta0 -> eval_expr tge te le m ta0 v2) (H3 : sem_binary_operation ge op v1 (typeof a1) v2 (typeof a2) m = Some v) (ta x : expr) (EQ : transl_expr (prog_comp_env cunit) a1 = OK x) (x0 : expr) (EQ1 : transl_expr (prog_comp_env cunit) a2 = OK x0) (EQ2 : transl_binop (prog_comp_env cunit) op x (typeof a1) x0 (typeof a2) = OK ta) : eval_expr tge te le m ta v.","conclusion":"eval_expr tge te le m ta v","hypotheses":"(op : Cop.binary_operation) (a1 a2 : Clight.expr) (ty : type) (v1 v2 v : val) (H : Clight.eval_expr ge e le m a1 v1) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a1 = OK ta0 -> eval_expr tge te le m ta0 v1) (H1 : Clight.eval_expr ge e le m a2 v2) (H2 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a2 = OK ta0 -> eval_expr tge te le m ta0 v2) (H3 : sem_binary_operation ge op v1 (typeof a1) v2 (typeof a2) m = Some v) (ta x : expr) (EQ : transl_expr (prog_comp_env cunit) a1 = OK x) (x0 : expr) (EQ1 : transl_expr (prog_comp_env cunit) a2 = OK x0) (EQ2 : transl_binop (prog_comp_env cunit) op x (typeof a1) x0 (typeof a2) = OK ta)","proofString":"eapply transl_binop_correct; eauto."},{"statement":"(a : Clight.expr) (ty : type) (v1 v : val) (H : Clight.eval_expr ge e le m a v1) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a = OK ta0 -> eval_expr tge te le m ta0 v1) (H1 : sem_cast v1 (typeof a) ty m = Some v) (ta x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (EQ0 : make_cast (typeof a) ty x = OK ta) : eval_expr tge te le m ta v.","conclusion":"eval_expr tge te le m ta v","hypotheses":"(a : Clight.expr) (ty : type) (v1 v : val) (H : Clight.eval_expr ge e le m a v1) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a = OK ta0 -> eval_expr tge te le m ta0 v1) (H1 : sem_cast v1 (typeof a) ty m = Some v) (ta x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (EQ0 : make_cast (typeof a) ty x = OK ta)","proofString":"eapply make_cast_correct; eauto."},{"statement":"(ty1 ty : type) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty1 = OK x) : eval_expr tge te le m (make_ptrofsconst x)\n  (Vptrofs (Ptrofs.repr (Ctypes.sizeof ge ty1))).","conclusion":"eval_expr tge te le m (make_ptrofsconst x)\n  (Vptrofs (Ptrofs.repr (Ctypes.sizeof ge ty1)))","hypotheses":"(ty1 ty : type) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty1 = OK x)","proofString":"rewrite (transl_sizeof _ _ _ _ LINK EQ).\napply make_ptrofsconst_correct."},{"statement":"(ty1 ty : type) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty1 = OK x) : eval_expr tge te le m\n  (make_ptrofsconst (Ctypes.sizeof (prog_comp_env prog) ty1))\n  (Vptrofs (Ptrofs.repr (Ctypes.sizeof ge ty1))).","conclusion":"eval_expr tge te le m\n  (make_ptrofsconst (Ctypes.sizeof (prog_comp_env prog) ty1))\n  (Vptrofs (Ptrofs.repr (Ctypes.sizeof ge ty1)))","hypotheses":"(ty1 ty : type) (x : Z) (EQ : sizeof (prog_comp_env cunit) ty1 = OK x)","proofString":"apply make_ptrofsconst_correct."},{"statement":"(ty1 ty : type) (x : Z) (EQ : alignof (prog_comp_env cunit) ty1 = OK x) : eval_expr tge te le m (make_ptrofsconst x)\n  (Vptrofs (Ptrofs.repr (Ctypes.alignof ge ty1))).","conclusion":"eval_expr tge te le m (make_ptrofsconst x)\n  (Vptrofs (Ptrofs.repr (Ctypes.alignof ge ty1)))","hypotheses":"(ty1 ty : type) (x : Z) (EQ : alignof (prog_comp_env cunit) ty1 = OK x)","proofString":"rewrite (transl_alignof _ _ _ _ LINK EQ).\napply make_ptrofsconst_correct."},{"statement":"(ty1 ty : type) (x : Z) (EQ : alignof (prog_comp_env cunit) ty1 = OK x) : eval_expr tge te le m\n  (make_ptrofsconst (Ctypes.alignof (prog_comp_env prog) ty1))\n  (Vptrofs (Ptrofs.repr (Ctypes.alignof ge ty1))).","conclusion":"eval_expr tge te le m\n  (make_ptrofsconst (Ctypes.alignof (prog_comp_env prog) ty1))\n  (Vptrofs (Ptrofs.repr (Ctypes.alignof ge ty1)))","hypotheses":"(ty1 ty : type) (x : Z) (EQ : alignof (prog_comp_env cunit) ty1 = OK x)","proofString":"apply make_ptrofsconst_correct."},{"statement":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta) : eval_expr tge te le m ta v.","conclusion":"eval_expr tge te le m ta v","hypotheses":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta)","proofString":"exploit transl_expr_lvalue; eauto.\nintros [tb [TRLVAL MKLOAD]].\napply H0 in TRLVAL; destruct TRLVAL.\neapply make_load_correct; eauto."},{"statement":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta) : (exists tb : expr,\n   transl_lvalue (prog_comp_env cunit) a = OK (tb, bf) /\\\n   make_load tb (typeof a) bf = OK ta) -> eval_expr tge te le m ta v.","conclusion":"(exists tb : expr,\n   transl_lvalue (prog_comp_env cunit) a = OK (tb, bf) /\\\n   make_load tb (typeof a) bf = OK ta) -> eval_expr tge te le m ta v","hypotheses":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta)","proofString":"intros [tb [TRLVAL MKLOAD]].\napply H0 in TRLVAL; destruct TRLVAL.\neapply make_load_correct; eauto."},{"statement":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta) (tb : expr) (TRLVAL : transl_lvalue (prog_comp_env cunit) a = OK (tb, bf)) (MKLOAD : make_load tb (typeof a) bf = OK ta) : eval_expr tge te le m ta v.","conclusion":"eval_expr tge te le m ta v","hypotheses":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta) (tb : expr) (TRLVAL : transl_lvalue (prog_comp_env cunit) a = OK (tb, bf)) (MKLOAD : make_load tb (typeof a) bf = OK ta)","proofString":"apply H0 in TRLVAL; destruct TRLVAL.\neapply make_load_correct; eauto."},{"statement":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta) (tb : expr) (H2 : bf = bf) (H3 : eval_expr tge te le m tb (Vptr loc ofs)) (MKLOAD : make_load tb (typeof a) bf = OK ta) : eval_expr tge te le m ta v.","conclusion":"eval_expr tge te le m ta v","hypotheses":"(a : Clight.expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue ge e le m a loc ofs bf) (H0 : forall (ta0 : expr) (bf' : bitfield),\ntransl_lvalue (prog_comp_env cunit) a = OK (ta0, bf') ->\nbf = bf' /\\ eval_expr tge te le m ta0 (Vptr loc ofs)) (H1 : deref_loc (typeof a) m loc ofs bf v) (ta : expr) (TR : transl_expr (prog_comp_env cunit) a = OK ta) (tb : expr) (H2 : bf = bf) (H3 : eval_expr tge te le m tb (Vptr loc ofs)) (MKLOAD : make_load tb (typeof a) bf = OK ta)","proofString":"eapply make_load_correct; eauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) : Full = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero).","conclusion":"Full = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero)","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty))","proofString":"exploit (me_local _ _ MENV); eauto.\nintros EQ.\nsplit; auto.\neconstructor.\neapply eval_var_addr_local.\neauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) : te ! id = Some (l, Ctypes.sizeof ge ty) ->\nFull = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero).","conclusion":"te ! id = Some (l, Ctypes.sizeof ge ty) ->\nFull = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero)","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty))","proofString":"intros EQ.\nsplit; auto.\neconstructor.\neapply eval_var_addr_local.\neauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) (EQ : te ! id = Some (l, Ctypes.sizeof ge ty)) : Full = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero).","conclusion":"Full = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero)","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) (EQ : te ! id = Some (l, Ctypes.sizeof ge ty))","proofString":"split; auto.\neconstructor.\neapply eval_var_addr_local.\neauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) (EQ : te ! id = Some (l, Ctypes.sizeof ge ty)) : eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero).","conclusion":"eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero)","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) (EQ : te ! id = Some (l, Ctypes.sizeof ge ty))","proofString":"econstructor.\neapply eval_var_addr_local.\neauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) (EQ : te ! id = Some (l, Ctypes.sizeof ge ty)) : eval_var_addr tge te id l.","conclusion":"eval_var_addr tge te id l","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = Some (l, ty)) (EQ : te ! id = Some (l, Ctypes.sizeof ge ty))","proofString":"eapply eval_var_addr_local.\neauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l) : Full = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero).","conclusion":"Full = Full /\\ eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero)","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l)","proofString":"split; auto.\neconstructor.\neapply eval_var_addr_global.\neapply match_env_globals; eauto.\nrewrite symbols_preserved.\nauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l) : eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero).","conclusion":"eval_expr tge te le m (Eaddrof id) (Vptr l Ptrofs.zero)","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l)","proofString":"econstructor.\neapply eval_var_addr_global.\neapply match_env_globals; eauto.\nrewrite symbols_preserved.\nauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l) : eval_var_addr tge te id l.","conclusion":"eval_var_addr tge te id l","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l)","proofString":"eapply eval_var_addr_global.\neapply match_env_globals; eauto.\nrewrite symbols_preserved.\nauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l) : te ! id = None.","conclusion":"te ! id = None","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l)","proofString":"eapply match_env_globals; eauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l) : Genv.find_symbol tge id = Some l.","conclusion":"Genv.find_symbol tge id = Some l","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l)","proofString":"rewrite symbols_preserved.\nauto."},{"statement":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l) : Genv.find_symbol ge id = Some l.","conclusion":"Genv.find_symbol ge id = Some l","hypotheses":"(id : positive) (l : block) (ty : type) (H : e ! id = None) (H0 : Genv.find_symbol ge id = Some l)","proofString":"auto."},{"statement":"(a : Clight.expr) (ty : type) (l : block) (ofs : ptrofs) (H : Clight.eval_expr ge e le m a (Vptr l ofs)) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a = OK ta0 ->\neval_expr tge te le m ta0 (Vptr l ofs)) (ta : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK ta) : Full = Full /\\ eval_expr tge te le m ta (Vptr l ofs).","conclusion":"Full = Full /\\ eval_expr tge te le m ta (Vptr l ofs)","hypotheses":"(a : Clight.expr) (ty : type) (l : block) (ofs : ptrofs) (H : Clight.eval_expr ge e le m a (Vptr l ofs)) (H0 : forall ta0 : expr,\ntransl_expr (prog_comp_env cunit) a = OK ta0 ->\neval_expr tge te le m ta0 (Vptr l ofs)) (ta : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK ta)","proofString":"eauto."},{"statement":"(tal : list expr) (H : transl_arglist (prog_comp_env cunit) nil nil = OK tal) : eval_exprlist tge te le m tal nil.","conclusion":"eval_exprlist tge te le m tal nil","hypotheses":"(tal : list expr) (H : transl_arglist (prog_comp_env cunit) nil nil = OK tal)","proofString":"monadInv H.\nconstructor."},{"statement":"eval_exprlist tge te le m nil nil.","conclusion":"eval_exprlist tge te le m nil nil","hypotheses":"","proofString":"constructor."},{"statement":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal0 : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal0 ->\neval_exprlist tge te le m tal0 vl) (tal : list expr) (H2 : transl_arglist (prog_comp_env cunit) (a :: bl) (ty :: tyl) = OK tal) : eval_exprlist tge te le m tal (v2 :: vl).","conclusion":"eval_exprlist tge te le m tal (v2 :: vl)","hypotheses":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal0 : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal0 ->\neval_exprlist tge te le m tal0 vl) (tal : list expr) (H2 : transl_arglist (prog_comp_env cunit) (a :: bl) (ty :: tyl) = OK tal)","proofString":"monadInv H2.\nconstructor.\neapply make_cast_correct; eauto.\neapply transl_expr_correct; eauto.\nauto."},{"statement":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1) : eval_exprlist tge te le m (x0 :: x1) (v2 :: vl).","conclusion":"eval_exprlist tge te le m (x0 :: x1) (v2 :: vl)","hypotheses":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1)","proofString":"constructor.\neapply make_cast_correct; eauto.\neapply transl_expr_correct; eauto.\nauto."},{"statement":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1) : eval_expr tge te le m x0 v2.","conclusion":"eval_expr tge te le m x0 v2","hypotheses":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1)","proofString":"eapply make_cast_correct; eauto.\neapply transl_expr_correct; eauto."},{"statement":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1) : eval_expr tge te le m x v1.","conclusion":"eval_expr tge te le m x v1","hypotheses":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1)","proofString":"eapply transl_expr_correct; eauto."},{"statement":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1) : eval_exprlist tge te le m x1 vl.","conclusion":"eval_exprlist tge te le m x1 vl","hypotheses":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : forall tal : list expr,\ntransl_arglist (prog_comp_env cunit) bl tyl = OK tal ->\neval_exprlist tge te le m tal vl) (x : expr) (EQ : transl_expr (prog_comp_env cunit) a = OK x) (x0 : expr) (EQ1 : make_cast (typeof a) ty x = OK x0) (x1 : list expr) (EQ0 : transl_arglist (prog_comp_env cunit) bl tyl = OK x1)","proofString":"auto."},{"statement":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : typlist_of_arglist bl tyl = map argtype_of_type tyl) : argtype_of_type ty :: typlist_of_arglist bl tyl =\nargtype_of_type ty :: map argtype_of_type tyl.","conclusion":"argtype_of_type ty :: typlist_of_arglist bl tyl =\nargtype_of_type ty :: map argtype_of_type tyl","hypotheses":"(a : Clight.expr) (bl : list Clight.expr) (ty : type) (tyl : list type) (v1 v2 : val) (vl : list val) (H : Clight.eval_expr ge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v2) (H1 : Clight.eval_exprlist ge e le m bl tyl vl) (IHeval_exprlist : typlist_of_arglist bl tyl = map argtype_of_type tyl)","proofString":"f_equal; auto."},{"statement":"(ts : stmt) (tk : cont) (ts' : stmt) (tk' : cont) (f : function) (te : env) (le : temp_env) (m : mem) (H : match_transl (Sblock ts) tk ts' tk') : star step tge (State f ts' tk' te le m) E0 (State f ts (Kblock tk) te le m).","conclusion":"star step tge (State f ts' tk' te le m) E0 (State f ts (Kblock tk) te le m)","hypotheses":"(ts : stmt) (tk : cont) (ts' : stmt) (tk' : cont) (f : function) (te : env) (le : temp_env) (m : mem) (H : match_transl (Sblock ts) tk ts' tk')","proofString":"inv H.\napply star_one.\nconstructor.\napply star_refl."},{"statement":"(ts : stmt) (tk' : cont) (f : function) (te : env) (le : temp_env) (m : mem) : star step tge (State f (Sblock ts) tk' te le m) E0\n  (State f ts (Kblock tk') te le m).","conclusion":"star step tge (State f (Sblock ts) tk' te le m) E0\n  (State f ts (Kblock tk') te le m)","hypotheses":"(ts : stmt) (tk' : cont) (f : function) (te : env) (le : temp_env) (m : mem)","proofString":"apply star_one.\nconstructor."},{"statement":"(ts : stmt) (tk' : cont) (f : function) (te : env) (le : temp_env) (m : mem) : step tge (State f (Sblock ts) tk' te le m) E0\n  (State f ts (Kblock tk') te le m).","conclusion":"step tge (State f (Sblock ts) tk' te le m) E0\n  (State f ts (Kblock tk') te le m)","hypotheses":"(ts : stmt) (tk' : cont) (f : function) (te : env) (le : temp_env) (m : mem)","proofString":"constructor."},{"statement":"(tk : cont) (ts' : stmt) (f : function) (te : env) (le : temp_env) (m : mem) : star step tge (State f ts' (Kblock tk) te le m) E0\n  (State f ts' (Kblock tk) te le m).","conclusion":"star step tge (State f ts' (Kblock tk) te le m) E0\n  (State f ts' (Kblock tk) te le m)","hypotheses":"(tk : cont) (ts' : stmt) (f : function) (te : env) (le : temp_env) (m : mem)","proofString":"apply star_refl."},{"statement":"(f : Clight.function) (e : Clight.env) (le : Clight.temp_env) (te : env) (nbrk ncnt : nat) (k : Clight.cont) (tf : function) (tk : cont) (m : mem) (cu : Clight.program) (H : linkorder cu prog) (H0 : transl_function (prog_comp_env cu) f = OK tf) (H1 : match_env e te) (H2 : match_cont (prog_comp_env cu) (fn_return f) nbrk ncnt k tk) : match_states (Clight.State f Clight.Sskip k e le m)\n  (State tf Sskip tk te le m).","conclusion":"match_states (Clight.State f Clight.Sskip k e le m)\n  (State tf Sskip tk te le m)","hypotheses":"(f : Clight.function) (e : Clight.env) (le : Clight.temp_env) (te : env) (nbrk ncnt : nat) (k : Clight.cont) (tf : function) (tk : cont) (m : mem) (cu : Clight.program) (H : linkorder cu prog) (H0 : transl_function (prog_comp_env cu) f = OK tf) (H1 : match_env e te) (H2 : match_cont (prog_comp_env cu) (fn_return f) nbrk ncnt k tk)","proofString":"econstructor; eauto.\nsimpl; reflexivity.\nconstructor."},{"statement":"(ce' : composite_env) (nbrk' ncnt' : nat) (ce : type) (tyret : composite_env) (nbrk ncnt : nat) : match_cont ce' ce nbrk' ncnt' Clight.Kstop Kstop.","conclusion":"match_cont ce' ce nbrk' ncnt' Clight.Kstop Kstop","hypotheses":"(ce' : composite_env) (nbrk' ncnt' : nat) (ce : type) (tyret : composite_env) (nbrk ncnt : nat)","proofString":"apply match_Kstop."},{"statement":"(ce' : composite_env) (nbrk' ncnt' : nat) (ce : composite_env) (tyret : type) (nbrk ncnt nbrk'0 ncnt'0 : nat) (f : Clight.function) (e : Clight.env) (k : Clight.cont) (id : option ident) (tf : function) (te : env) (le : Clight.temp_env) (tk : cont) (cu : Clight.program) (H : linkorder cu prog) (H0 : transl_function (prog_comp_env cu) f = OK tf) (H1 : match_env e te) (H2 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k tk) (IHmatch_cont : match_cont ce' (fn_return f) nbrk' ncnt' (Clight.call_cont k) (call_cont tk)) : match_cont ce' tyret nbrk' ncnt' (Clight.Kcall id f e le k)\n  (Kcall id tf te le tk).","conclusion":"match_cont ce' tyret nbrk' ncnt' (Clight.Kcall id f e le k)\n  (Kcall id tf te le tk)","hypotheses":"(ce' : composite_env) (nbrk' ncnt' : nat) (ce : composite_env) (tyret : type) (nbrk ncnt nbrk'0 ncnt'0 : nat) (f : Clight.function) (e : Clight.env) (k : Clight.cont) (id : option ident) (tf : function) (te : env) (le : Clight.temp_env) (tk : cont) (cu : Clight.program) (H : linkorder cu prog) (H0 : transl_function (prog_comp_env cu) f = OK tf) (H1 : match_env e te) (H2 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k tk) (IHmatch_cont : match_cont ce' (fn_return f) nbrk' ncnt' (Clight.call_cont k) (call_cont tk))","proofString":"eapply match_Kcall; eauto."},{"statement":"(ce' : composite_env) (nbrk' ncnt' : nat) (ce : composite_env) (tyret : type) (nbrk ncnt nbrk'0 ncnt'0 : nat) (f : Clight.function) (e : Clight.env) (k : Clight.cont) (id : positive) (a : expr) (tf : function) (te : env) (le : Clight.temp_env) (tk : cont) (cu : Clight.program) (H : linkorder cu prog) (H0 : transl_function (prog_comp_env cu) f = OK tf) (H1 : match_env e te) (H2 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k tk) (H3 : forall (v : val) (e0 : env) (le0 : PTree.tree val) (m : mem),\nwt_val v tyret -> le0 ! id = Some v -> eval_expr tge e0 le0 m a v) (IHmatch_cont : match_cont ce' (fn_return f) nbrk' ncnt' (Clight.call_cont k) (call_cont tk)) : match_cont ce' tyret nbrk' ncnt' (Clight.Kcall (Some id) f e le k)\n  (Kcall (Some id) tf te le (Kseq (Sset id a) tk)).","conclusion":"match_cont ce' tyret nbrk' ncnt' (Clight.Kcall (Some id) f e le k)\n  (Kcall (Some id) tf te le (Kseq (Sset id a) tk))","hypotheses":"(ce' : composite_env) (nbrk' ncnt' : nat) (ce : composite_env) (tyret : type) (nbrk ncnt nbrk'0 ncnt'0 : nat) (f : Clight.function) (e : Clight.env) (k : Clight.cont) (id : positive) (a : expr) (tf : function) (te : env) (le : Clight.temp_env) (tk : cont) (cu : Clight.program) (H : linkorder cu prog) (H0 : transl_function (prog_comp_env cu) f = OK tf) (H1 : match_env e te) (H2 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k tk) (H3 : forall (v : val) (e0 : env) (le0 : PTree.tree val) (m : mem),\nwt_val v tyret -> le0 ! id = Some v -> eval_expr tge e0 le0 m a v) (IHmatch_cont : match_cont ce' (fn_return f) nbrk' ncnt' (Clight.call_cont k) (call_cont tk))","proofString":"eapply match_Kcall_normalize; eauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (k : Clight.cont) (tk : cont) (ce' : composite_env) (nbrk' ncnt' : nat) (H : match_cont ce tyret nbrk ncnt k tk) (H0 : Clight.is_call_cont k) : match_cont ce' tyret nbrk' ncnt' k tk /\\ is_call_cont tk.","conclusion":"match_cont ce' tyret nbrk' ncnt' k tk /\\ is_call_cont tk","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (k : Clight.cont) (tk : cont) (ce' : composite_env) (nbrk' ncnt' : nat) (H : match_cont ce tyret nbrk ncnt k tk) (H0 : Clight.is_call_cont k)","proofString":"inv H; simpl in H0; try contradiction; simpl.\nsplit; auto; apply match_Kstop.\nsplit; auto; eapply match_Kcall; eauto.\nsplit; auto; eapply match_Kcall_normalize; eauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (ce' : composite_env) (nbrk' ncnt' : nat) (H0 : True) : match_cont ce' tyret nbrk' ncnt' Clight.Kstop Kstop /\\ True.","conclusion":"match_cont ce' tyret nbrk' ncnt' Clight.Kstop Kstop /\\ True","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (ce' : composite_env) (nbrk' ncnt' : nat) (H0 : True)","proofString":"split; auto; apply match_Kstop."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (ce' : composite_env) (nbrk' ncnt' : nat) (f : Clight.function) (e : Clight.env) (k0 : Clight.cont) (id : option ident) (le : Clight.temp_env) (H0 : True) (nbrk'0 ncnt'0 : nat) (tf : function) (te : env) (tk0 : cont) (cu : Clight.program) (H1 : linkorder cu prog) (H2 : transl_function (prog_comp_env cu) f = OK tf) (H3 : match_env e te) (H4 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k0 tk0) : match_cont ce' tyret nbrk' ncnt' (Clight.Kcall id f e le k0)\n  (Kcall id tf te le tk0) /\\ True.","conclusion":"match_cont ce' tyret nbrk' ncnt' (Clight.Kcall id f e le k0)\n  (Kcall id tf te le tk0) /\\ True","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (ce' : composite_env) (nbrk' ncnt' : nat) (f : Clight.function) (e : Clight.env) (k0 : Clight.cont) (id : option ident) (le : Clight.temp_env) (H0 : True) (nbrk'0 ncnt'0 : nat) (tf : function) (te : env) (tk0 : cont) (cu : Clight.program) (H1 : linkorder cu prog) (H2 : transl_function (prog_comp_env cu) f = OK tf) (H3 : match_env e te) (H4 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k0 tk0)","proofString":"split; auto; eapply match_Kcall; eauto."},{"statement":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (ce' : composite_env) (nbrk' ncnt' : nat) (f : Clight.function) (e : Clight.env) (k0 : Clight.cont) (id : positive) (le : Clight.temp_env) (H0 : True) (nbrk'0 ncnt'0 : nat) (a : expr) (tf : function) (te : env) (tk0 : cont) (cu : Clight.program) (H1 : linkorder cu prog) (H2 : transl_function (prog_comp_env cu) f = OK tf) (H3 : match_env e te) (H4 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k0 tk0) (H5 : forall (v : val) (e0 : env) (le0 : PTree.tree val) (m : mem),\nwt_val v tyret -> le0 ! id = Some v -> eval_expr tge e0 le0 m a v) : match_cont ce' tyret nbrk' ncnt' (Clight.Kcall (Some id) f e le k0)\n  (Kcall (Some id) tf te le (Kseq (Sset id a) tk0)) /\\ True.","conclusion":"match_cont ce' tyret nbrk' ncnt' (Clight.Kcall (Some id) f e le k0)\n  (Kcall (Some id) tf te le (Kseq (Sset id a) tk0)) /\\ True","hypotheses":"(ce : composite_env) (tyret : type) (nbrk ncnt : nat) (ce' : composite_env) (nbrk' ncnt' : nat) (f : Clight.function) (e : Clight.env) (k0 : Clight.cont) (id : positive) (le : Clight.temp_env) (H0 : True) (nbrk'0 ncnt'0 : nat) (a : expr) (tf : function) (te : env) (tk0 : cont) (cu : Clight.program) (H1 : linkorder cu prog) (H2 : transl_function (prog_comp_env cu) f = OK tf) (H3 : match_env e te) (H4 : match_cont (prog_comp_env cu) (fn_return f) nbrk'0 ncnt'0 k0 tk0) (H5 : forall (v : val) (e0 : env) (le0 : PTree.tree val) (m : mem),\nwt_val v tyret -> le0 ! id = Some v -> eval_expr tge e0 le0 m a v)","proofString":"split; auto; eapply match_Kcall_normalize; eauto."},{"statement":"(S : Clight.state) (H : Clight.initial_state prog S) : exists R : state, initial_state tprog R /\\ match_states S R.","conclusion":"exists R : state, initial_state tprog R /\\ match_states S R","hypotheses":"(S : Clight.state) (H : Clight.initial_state prog S)","proofString":"inv H.\nexploit function_ptr_translated; eauto.\nintros (cu & tf & A & B & C).\nassert (D: Genv.find_symbol tge (AST.prog_main tprog) = Some b).\ndestruct TRANSL as (P & Q & R).\nrewrite Q.\nrewrite symbols_preserved.\nauto.\nassert (E: funsig tf = signature_of_type nil type_int32s cc_default).\neapply transl_fundef_sig2; eauto.\neconstructor; split.\neconstructor; eauto.\napply (Genv.init_mem_match TRANSL).\neauto.\neconstructor; eauto.\ninstantiate (1 := prog_comp_env cu).\nconstructor; auto.\nexact I.\nconstructor."},{"statement":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) : exists R : state,\n  initial_state tprog R /\\\n  match_states (Clight.Callstate f nil Clight.Kstop m0) R.","conclusion":"exists R : state,\n  initial_state tprog R /\\\n  match_states (Clight.Callstate f nil Clight.Kstop m0) R","hypotheses":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b)","proofString":"assert (E: funsig tf = signature_of_type nil type_int32s cc_default).\neapply transl_fundef_sig2; eauto.\neconstructor; split.\neconstructor; eauto.\napply (Genv.init_mem_match TRANSL).\neauto.\neconstructor; eauto.\ninstantiate (1 := prog_comp_env cu).\nconstructor; auto.\nexact I.\nconstructor."},{"statement":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) : funsig tf = signature_of_type nil type_int32s cc_default.","conclusion":"funsig tf = signature_of_type nil type_int32s cc_default","hypotheses":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b)","proofString":"eapply transl_fundef_sig2; eauto."},{"statement":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default) : exists R : state,\n  initial_state tprog R /\\\n  match_states (Clight.Callstate f nil Clight.Kstop m0) R.","conclusion":"exists R : state,\n  initial_state tprog R /\\\n  match_states (Clight.Callstate f nil Clight.Kstop m0) R","hypotheses":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default)","proofString":"econstructor; split.\neconstructor; eauto.\napply (Genv.init_mem_match TRANSL).\neauto.\neconstructor; eauto.\ninstantiate (1 := prog_comp_env cu).\nconstructor; auto.\nexact I.\nconstructor."},{"statement":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default) : match_cont (prog_comp_env cu) type_int32s 0 0 Clight.Kstop Kstop.","conclusion":"match_cont (prog_comp_env cu) type_int32s 0 0 Clight.Kstop Kstop","hypotheses":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default)","proofString":"constructor; auto."},{"statement":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default) : Clight.is_call_cont Clight.Kstop.","conclusion":"Clight.is_call_cont Clight.Kstop","hypotheses":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default)","proofString":"exact I."},{"statement":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default) : Val.has_argtype_list nil (map argtype_of_type nil).","conclusion":"Val.has_argtype_list nil (map argtype_of_type nil)","hypotheses":"(b : block) (f : Ctypes.fundef Clight.function) (m0 : mem) (ge0 : Genv.t (Ctypes.fundef Clight.function) type) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Clight.program) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : match_fundef cu f tf) (C : linkorder cu prog) (D : Genv.find_symbol tge (AST.prog_main tprog) = Some b) (E : funsig tf = signature_of_type nil type_int32s cc_default)","proofString":"constructor."},{"statement":"(S : Clight.state) (R : state) (r : int) (H : match_states S R) (H0 : Clight.final_state S r) : final_state R r.","conclusion":"final_state R r","hypotheses":"(S : Clight.state) (R : state) (r : int) (H : match_states S R) (H0 : Clight.final_state S r)","proofString":"inv H0.\ninv H.\ninv MK.\nconstructor."},{"statement":"(R : state) (r : int) (m : mem) (H : match_states (Clight.Returnstate (Vint r) Clight.Kstop m) R) : final_state R r.","conclusion":"final_state R r","hypotheses":"(R : state) (r : int) (m : mem) (H : match_states (Clight.Returnstate (Vint r) Clight.Kstop m) R)","proofString":"inv H.\ninv MK.\nconstructor."},{"statement":"(r : int) (m : mem) (tres : type) (tk : cont) (ce : composite_env) (MK : match_cont ce tres 0 0 Clight.Kstop tk) (WT : wt_val (Vint r) tres) : final_state (Returnstate (Vint r) tk m) r.","conclusion":"final_state (Returnstate (Vint r) tk m) r","hypotheses":"(r : int) (m : mem) (tres : type) (tk : cont) (ce : composite_env) (MK : match_cont ce tres 0 0 Clight.Kstop tk) (WT : wt_val (Vint r) tres)","proofString":"inv MK.\nconstructor."},{"statement":"(r : int) (m : mem) (tres : type) (ce : composite_env) (WT : wt_val (Vint r) tres) : final_state (Returnstate (Vint r) Kstop m) r.","conclusion":"final_state (Returnstate (Vint r) Kstop m) r","hypotheses":"(r : int) (m : mem) (tres : type) (ce : composite_env) (WT : wt_val (Vint r) tres)","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics2 prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics2 prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}