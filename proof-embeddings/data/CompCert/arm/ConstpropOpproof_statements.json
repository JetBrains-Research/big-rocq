{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/arm/ConstpropOpproof.v","fileSamples":[{"statement":"(r : positive) (id : ident) (ofs : ptrofs) (H : AE.get r ae = Ptr (Gl id ofs)) : Val.lessdef rs # r (Genv.symbol_address ge id ofs).","proofString":"apply vmatch_ptr_gl with bc; auto.\nrewrite <- H.\napply MATCH."},{"statement":"(r : positive) (id : ident) (ofs : ptrofs) (H : AE.get r ae = Ptr (Gl id ofs)) : vmatch bc rs # r (Ptr (Gl id ofs)).","proofString":"rewrite <- H.\napply MATCH."},{"statement":"(r : positive) (id : ident) (ofs : ptrofs) (H : AE.get r ae = Ptr (Gl id ofs)) : vmatch bc rs # r (AE.get r ae).","proofString":"apply MATCH."},{"statement":"(r : positive) (ofs : ptrofs) (H : AE.get r ae = Ptr (Stk ofs)) : Val.lessdef rs # r (Vptr sp ofs).","proofString":"apply vmatch_ptr_stk with bc; auto.\nrewrite <- H.\napply MATCH."},{"statement":"(r : positive) (ofs : ptrofs) (H : AE.get r ae = Ptr (Stk ofs)) : vmatch bc rs # r (Ptr (Stk ofs)).","proofString":"rewrite <- H.\napply MATCH."},{"statement":"(r : positive) (ofs : ptrofs) (H : AE.get r ae = Ptr (Stk ofs)) : vmatch bc rs # r (AE.get r ae).","proofString":"apply MATCH."},{"statement":"(n : int) (v : val) (H : v = Vint n) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst n) nil m = Some v' /\\\n  Val.lessdef (Vint n) v'.","proofString":"exists (Vint n); auto."},{"statement":"(n : int) (v : val) (H0 : vmatch bc v (IU n)) : exists v' : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst n) nil m = Some v' /\\\n  Val.lessdef v v'.","proofString":"exists (Vint n); split; auto.\ninv H0; auto."},{"statement":"(n : int) (v : val) (H0 : vmatch bc v (IU n)) : Val.lessdef v (Vint n).","proofString":"inv H0; auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc rs # r2 v2) (H1 : rs # r1 = Vint n1) : Val.cmp_bool (swap_comparison c) rs # r2 (Vint n1) =\nVal.cmp_bool c (Vint n1) rs # r2.","proofString":"apply Val.swap_cmp_bool."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc rs # r1 v1) (H1 : rs # r2 = Vint n2) : Val.cmp_bool c rs # r1 (Vint n2) = Val.cmp_bool c rs # r1 (Vint n2).","proofString":"auto."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (n1 : int) (v2 : aval) (H : vmatch bc rs # r2 v2) (H1 : rs # r1 = Vint n1) : Val.cmpu_bool (Mem.valid_pointer m) (swap_comparison c) rs # r2 (Vint n1) =\nVal.cmpu_bool (Mem.valid_pointer m) c (Vint n1) rs # r2.","proofString":"apply Val.swap_cmpu_bool."},{"statement":"(cond : condition) (args : list positive) (vl : list AVal.t) (c : comparison) (r1 r2 : reg) (v1 : aval) (n2 : int) (H0 : vmatch bc rs # r1 v1) (H1 : rs # r2 = Vint n2) : Val.cmpu_bool (Mem.valid_pointer m) c rs # r1 (Vint n2) =\nVal.cmpu_bool (Mem.valid_pointer m) c rs # r1 (Vint n2).","proofString":"auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : let (op', args') := make_cmp_base c args vl in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"unfold make_cmp_base.\ngeneralize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [c' args'].\nintros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : let (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in (Ocmp c', args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"generalize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [c' args'].\nintros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : (let (cond', args') := cond_strength_reduction c args vl in\n eval_condition cond' rs ## args' m = eval_condition c rs ## args m) ->\nlet (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in (Ocmp c', args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"destruct (cond_strength_reduction c args vl) as [c' args'].\nintros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (c' : condition) (args' : list reg) : eval_condition c' rs ## args' m = eval_condition c rs ## args m ->\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ocmp c') rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (c' : condition) (args' : list reg) (EQ : eval_condition c' rs ## args' m = eval_condition c rs ## args m) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ocmp c') rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite EQ.\nauto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (c' : condition) (args' : list reg) (EQ : eval_condition c' rs ## args' m = eval_condition c rs ## args m) : Val.lessdef (Val.of_optbool (eval_condition c rs ## args m))\n  (Val.of_optbool (eval_condition c rs ## args m)).","proofString":"auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (op', args') := make_cmp c args vl in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"assert (Y: forall r, vincl (AE.get r ae) (Uns Ptop 1) = true ->             rs#r = Vundef \\/ rs#r = Vint Int.zero \\/ rs#r = Vint Int.one).\nintros.\napply vmatch_Uns_1 with bc Ptop.\neapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH.\nunfold make_cmp.\ncase (make_cmp_match c args vl); intros.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one.","proofString":"intros.\napply vmatch_Uns_1 with bc Ptop.\neapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (r : positive) (H : vincl (AE.get r ae) (Uns Ptop 1) = true) : rs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one.","proofString":"apply vmatch_Uns_1 with bc Ptop.\neapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (r : positive) (H : vincl (AE.get r ae) (Uns Ptop 1) = true) : vmatch bc rs # r (Uns Ptop 1).","proofString":"eapply vmatch_ge.\neapply vincl_ge; eauto.\napply MATCH."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (op', args') := make_cmp c args vl in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"unfold make_cmp.\ncase (make_cmp_match c args vl); intros.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) : vl = map (fun r : positive => AE.get r ae) args ->\nlet (op', args') :=\n  match make_cmp_match c args vl with\n  | make_cmp_case1 n r1 v1 | make_cmp_case3 n r1 v1 =>\n      make_cmp_imm_eq c args vl n r1 v1\n  | make_cmp_case2 n r1 v1 | make_cmp_case4 n r1 v1 =>\n      make_cmp_imm_ne c args vl n r1 v1\n  | make_cmp_default c0 args0 vl0 => make_cmp_base c0 args0 vl0\n  end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c rs ## args m)) v.","proofString":"case (make_cmp_match c args vl); intros.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\nunfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_eq (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Ceq Int.one) rs ## (r1 :: nil) m)) v.","proofString":"exists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompimm Ceq Int.one) rs ## (r1 :: nil) m))\n  rs # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Ceq rs # r1 (Vint Int.one)))\n  rs # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Ceq rs # r1 (Vint Int.one)))\n  rs # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Ceq Int.zero) rs ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompimm Ceq Int.zero) rs ## (r1 :: nil) m))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Ceq rs # r1 (Vint Int.zero)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Ceq rs # r1 (Vint Int.zero)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') := make_cmp_base (Ccompimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_ne (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Cne Int.zero) rs ## (r1 :: nil) m)) v.","proofString":"exists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompimm Cne Int.zero) rs ## (r1 :: nil) m)) \n  rs # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Cne rs # r1 (Vint Int.zero)))\n  rs # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Cne rs # r1 (Vint Int.zero)))\n  rs # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompimm Cne Int.one) rs ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool (eval_condition (Ccompimm Cne Int.one) rs ## (r1 :: nil) m))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef (Val.of_optbool (Val.cmp_bool Cne rs # r1 (Vint Int.one)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef (Val.of_optbool (Val.cmp_bool Cne rs # r1 (Vint Int.one)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') := make_cmp_base (Ccompimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_eq (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_eq.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Ceq Int.one) rs ## (r1 :: nil) m)) v.","proofString":"exists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompuimm Ceq Int.one) rs ## (r1 :: nil) m)) \n  rs # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq rs # r1 (Vint Int.one)))\n  rs # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq rs # r1 (Vint Int.one)))\n  rs # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Ceq Int.zero) rs ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompuimm Ceq Int.zero) rs ## (r1 :: nil) m))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq rs # r1 (Vint Int.zero)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E1 : Int.eq_dec Int.zero Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Ceq rs # r1 (Vint Int.zero)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  make_cmp_base (Ccompuimm Ceq n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Ceq n) rs ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  make_cmp_imm_ne (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) n r1 v1 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"unfold make_cmp_imm_ne.\ndestruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) : let (op', args') :=\n  if Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)\n  then (Omove, r1 :: nil)\n  else\n   if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n   then (Oxorimm Int.one, r1 :: nil)\n   else make_cmp_base (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1)) eqn:E0.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\ndestruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Cne Int.zero) rs ## (r1 :: nil) m)) v.","proofString":"exists (rs#r1); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompuimm Cne Int.zero) rs ## (r1 :: nil) m)) \n  rs # r1.","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne rs # r1 (Vint Int.zero)))\n  rs # r1.","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne rs # r1 (Vint Int.zero)))\n  rs # r1.","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  if Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)\n  then (Oxorimm Int.one, r1 :: nil)\n  else make_cmp_base (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"destruct (Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1)) eqn:E1.\nsimpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto.\napply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"simpl in H; inv H.\nInvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E1 : Int.eq_dec n Int.one && vincl (AE.get r1 ae) (Uns Ptop 1) = true) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"InvBooleans.\nsubst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (E0 : Int.eq_dec n Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) (H : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"subst n.\nexists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.one) \n    rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool\n       (eval_condition (Ccompuimm Cne Int.one) rs ## (r1 :: nil) m)) v.","proofString":"exists (Val.xor rs#r1 (Vint Int.one)); split; auto.\nsimpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (eval_condition (Ccompuimm Cne Int.one) rs ## (r1 :: nil) m))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"simpl.\nexploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne rs # r1 (Vint Int.one)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"exploit Y; eauto.\nintros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (r1 : reg) (E0 : Int.eq_dec Int.one Int.zero && vincl (AE.get r1 ae) (Uns Ptop 1) = false) (H0 : vincl (AE.get r1 ae) (Uns Ptop 1) = true) : rs # r1 = Vundef \\/ rs # r1 = Vint Int.zero \\/ rs # r1 = Vint Int.one ->\nVal.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) Cne rs # r1 (Vint Int.one)))\n  (Val.xor rs # r1 (Vint Int.one)).","proofString":"intros [A | [A | A]]; rewrite A; simpl; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (n : int) (r1 : reg) (v1 : aval) (H : v1 :: nil = map (fun r : positive => AE.get r ae) (r1 :: nil)) (E0 : Int.eq_dec n Int.zero && vincl v1 (Uns Ptop 1) = false) (E1 : Int.eq_dec n Int.one && vincl v1 (Uns Ptop 1) = false) : let (op', args') :=\n  make_cmp_base (Ccompuimm Cne n) (r1 :: nil) (v1 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef\n    (Val.of_optbool (eval_condition (Ccompuimm Cne n) rs ## (r1 :: nil) m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (args : list positive) (vl : list AVal.t) (Y : forall r : positive,\nvincl (AE.get r ae) (Uns Ptop 1) = true ->\nrs # r = Vundef \\/ rs # r = Vint Int.zero \\/ rs # r = Vint Int.one) (c0 : condition) (args0 : list reg) (vl0 : list aval) (H : vl0 = map (fun r : positive => AE.get r ae) args0) : let (op', args') := make_cmp_base c0 args0 vl0 in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.of_optbool (eval_condition c0 rs ## args0 m)) v.","proofString":"apply make_cmp_base_correct; auto."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) : let (op', args') :=\n  match resolve_branch (eval_static_condition c vl) with\n  | Some b => (Omove, (if b then r1 else r2) :: nil)\n  | None =>\n      let (c', args') := cond_strength_reduction c args vl in\n      (Osel c' ty, r1 :: r2 :: args')\n  end in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c rs ## args m) rs # r1 rs # r2 ty)\n    v.","proofString":"destruct (resolve_branch (eval_static_condition c vl)) as [b|] eqn:RB.\nexists (if b then rs#r1 else rs#r2); split.\nsimpl.\ndestruct b; auto.\ndestruct (eval_condition c rs##args m) as [b'|] eqn:EC; simpl; auto.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize.\ngeneralize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [cond' args']; intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove\n    rs ## ((if b then r1 else r2) :: nil) m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c rs ## args m) rs # r1 rs # r2 ty)\n    v.","proofString":"exists (if b then rs#r1 else rs#r2); split.\nsimpl.\ndestruct b; auto.\ndestruct (eval_condition c rs##args m) as [b'|] eqn:EC; simpl; auto.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : eval_operation ge (Vptr sp Ptrofs.zero) Omove\n  rs ## ((if b then r1 else r2) :: nil) m =\nSome (if b then rs # r1 else rs # r2).","proofString":"simpl.\ndestruct b; auto."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : Some rs # (if b then r1 else r2) = Some (if b then rs # r1 else rs # r2).","proofString":"destruct b; auto."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) : Val.lessdef (Val.select (eval_condition c rs ## args m) rs # r1 rs # r2 ty)\n  (if b then rs # r1 else rs # r2).","proofString":"destruct (eval_condition c rs##args m) as [b'|] eqn:EC; simpl; auto.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c rs ## args m = Some b') : Val.lessdef (Val.normalize (if b' then rs # r1 else rs # r2) ty)\n  (if b then rs # r1 else rs # r2).","proofString":"assert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH).\nsubst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c rs ## args m = Some b') : b = b'.","proofString":"eapply resolve_branch_sound; eauto.\nrewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c rs ## args m = Some b') : cmatch (Some b') (eval_static_condition c vl).","proofString":"rewrite <- EC.\napply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c rs ## args m = Some b') : cmatch (eval_condition c rs ## args m) (eval_static_condition c vl).","proofString":"apply eval_static_condition_sound with bc.\nsubst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c rs ## args m = Some b') : list_forall2 (vmatch bc) rs ## args vl.","proofString":"subst vl.\nexact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (b : bool) (RB : resolve_branch\n  (eval_static_condition c (map (fun r : positive => AE.get r ae) args)) =\nSome b) (b' : bool) (EC : eval_condition c rs ## args m = Some b') : list_forall2 (vmatch bc) rs ## args\n  (map (fun r : positive => AE.get r ae) args).","proofString":"exact (aregs_sound _ _ _ args MATCH)."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (b' : bool) (EC : eval_condition c rs ## args m = Some b') (H0 : b = b') : Val.lessdef (Val.normalize (if b' then rs # r1 else rs # r2) ty)\n  (if b then rs # r1 else rs # r2).","proofString":"subst b'.\napply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (b : bool) (RB : resolve_branch (eval_static_condition c vl) = Some b) (EC : eval_condition c rs ## args m = Some b) : Val.lessdef (Val.normalize (if b then rs # r1 else rs # r2) ty)\n  (if b then rs # r1 else rs # r2).","proofString":"apply Val.lessdef_normalize."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (RB : resolve_branch (eval_static_condition c vl) = None) : let (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in\n  (Osel c' ty, r1 :: r2 :: args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c rs ## args m) rs # r1 rs # r2 ty)\n    v.","proofString":"generalize (cond_strength_reduction_correct c args vl H).\ndestruct (cond_strength_reduction c args vl) as [cond' args']; intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (RB : resolve_branch (eval_static_condition c vl) = None) : (let (cond', args') := cond_strength_reduction c args vl in\n eval_condition cond' rs ## args' m = eval_condition c rs ## args m) ->\nlet (op', args') :=\n  let (c', args') := cond_strength_reduction c args vl in\n  (Osel c' ty, r1 :: r2 :: args') in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op' rs ## args' m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c rs ## args m) rs # r1 rs # r2 ty)\n    v.","proofString":"destruct (cond_strength_reduction c args vl) as [cond' args']; intros EQ.\neconstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(c : condition) (ty : typ) (r1 r2 : reg) (args : list positive) (vl : list AVal.t) (H : vl = map (fun r : positive => AE.get r ae) args) (RB : resolve_branch (eval_static_condition c vl) = None) (cond' : condition) (args' : list reg) (EQ : eval_condition cond' rs ## args' m = eval_condition c rs ## args m) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Osel cond' ty)\n    rs ## (r1 :: r2 :: args') m = Some v /\\\n  Val.lessdef (Val.select (eval_condition c rs ## args m) rs # r1 rs # r2 ty)\n    v.","proofString":"econstructor; split.\nsimpl; eauto.\nrewrite EQ; auto."},{"statement":"(n : int) (r : reg) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.add rs # r (Vint n)) v.","proofString":"subst.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.add_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.add rs # r (Vint Int.zero)) v.","proofString":"exists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.add_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.add rs # r (Vint Int.zero)) rs # r.","proofString":"destruct (rs#r); simpl; auto.\nrewrite Int.add_zero; auto."},{"statement":"(r : reg) (i : int) : Val.lessdef (Vint (Int.add i Int.zero)) (Vint i).","proofString":"rewrite Int.add_zero; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oaddimm n) rs ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.add rs # r (Vint n)) v.","proofString":"exists (Val.add rs#r (Vint n)); auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : rs # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shr rs # r1 (Vint n)) v.","proofString":"subst.\nexists (rs#r1); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shr rs # r1 (Vint Int.zero)) v.","proofString":"exists (rs#r1); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) : Val.lessdef (Val.shr rs # r1 (Vint Int.zero)) rs # r1.","proofString":"destruct (rs#r1); simpl; auto.\nrewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) (i : int) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shr i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shr_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) (i : int) : Val.lessdef (if Int.ltu Int.zero Int.iwordsize then Vint i else Vundef)\n  (Vint i).","proofString":"auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : rs # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shru rs # r1 (Vint n)) v.","proofString":"subst.\nexists (rs#r1); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.shru rs # r1 (Vint Int.zero)) v.","proofString":"exists (rs#r1); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) : Val.lessdef (Val.shru rs # r1 (Vint Int.zero)) rs # r1.","proofString":"destruct (rs#r1); simpl; auto.\nrewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) (i : int) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shru i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shru_zero.\nauto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) (i : int) : Val.lessdef (if Int.ltu Int.zero Int.iwordsize then Vint i else Vundef)\n  (Vint i).","proofString":"auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : rs # r2 = Vint n) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) rs ## nil m =\n  Some v /\\ Val.lessdef (Val.mul rs # r1 (Vint n)) v.","proofString":"subst.\nexists (Vint Int.zero); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) rs ## nil m =\n  Some v /\\ Val.lessdef (Val.mul rs # r1 (Vint Int.zero)) v.","proofString":"exists (Vint Int.zero); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) : Val.lessdef (Val.mul rs # r1 (Vint Int.zero)) (Vint Int.zero).","proofString":"destruct (rs#r1); simpl; auto.\nrewrite Int.mul_zero; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vint Int.zero) (i : int) : Val.lessdef (Vint (Int.mul i Int.zero)) (Vint Int.zero).","proofString":"rewrite Int.mul_zero; auto."},{"statement":"(n : int) (r1 : reg) (r2 : positive) (H : rs # r2 = Vint n) (H0 : n <> Int.zero) (H1 : n = Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.mul rs # r1 (Vint n)) v.","proofString":"subst.\nexists (rs#r1); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int.one <> Int.zero) (H : rs # r2 = Vint Int.one) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some v /\\\n  Val.lessdef (Val.mul rs # r1 (Vint Int.one)) v.","proofString":"exists (rs#r1); split; auto.\ndestruct (rs#r1); simpl; auto.\nrewrite Int.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int.one <> Int.zero) (H : rs # r2 = Vint Int.one) : Val.lessdef (Val.mul rs # r1 (Vint Int.one)) rs # r1.","proofString":"destruct (rs#r1); simpl; auto.\nrewrite Int.mul_one; auto."},{"statement":"(r1 : reg) (r2 : positive) (H0 : Int.one <> Int.zero) (H : rs # r2 = Vint Int.one) (i : int) : Val.lessdef (Vint (Int.mul i Int.one)) (Vint i).","proofString":"rewrite Int.mul_one; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) : let (op, args) :=\n  if Int.eq n Int.one\n  then (Omove, r1 :: nil)\n  else\n   match Int.is_power2 n with\n   | Some l =>\n       if Int.ltu l (Int.repr 31)\n       then (Oshrximm l, r1 :: nil)\n       else (Odiv, r1 :: r2 :: nil)\n   | None => (Odiv, r1 :: r2 :: nil)\n   end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"predSpec Int.eq Int.eq_spec n Int.one; intros.\nsubst.\nrewrite H0 in H.\ndestruct (rs#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto.\ndestruct (Int.is_power2 n) eqn:?.\ndestruct (Int.ltu i (Int.repr 31)) eqn:?.\nexists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence.\nexists v; auto.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n = Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"subst.\nrewrite H0 in H.\ndestruct (rs#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite H0 in H.\ndestruct (rs#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divs rs # r1 (Vint Int.one) = Some v) (H0 : rs # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (rs#r1) eqn:?;    try (rewrite Val.divs_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) : let (op, args) :=\n  match Int.is_power2 n with\n  | Some l =>\n      if Int.ltu l (Int.repr 31)\n      then (Oshrximm l, r1 :: nil)\n      else (Odiv, r1 :: r2 :: nil)\n  | None => (Odiv, r1 :: r2 :: nil)\n  end in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int.is_power2 n) eqn:?.\ndestruct (Int.ltu i (Int.repr 31)) eqn:?.\nexists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence.\nexists v; auto.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) : let (op, args) :=\n  if Int.ltu i (Int.repr 31)\n  then (Oshrximm i, r1 :: nil)\n  else (Odiv, r1 :: r2 :: nil) in\nexists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (Int.ltu i (Int.repr 31)) eqn:?.\nexists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence.\nexists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oshrximm i) rs ## (r1 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; split; auto.\nsimpl.\neapply Val.divs_pow2; eauto.\ncongruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : eval_operation ge (Vptr sp Ptrofs.zero) (Oshrximm i) rs ## (r1 :: nil) m =\nSome v.","proofString":"simpl.\neapply Val.divs_pow2; eauto.\ncongruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : Val.shrx rs # r1 (Vint i) = Some v.","proofString":"eapply Val.divs_pow2; eauto.\ncongruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = true) : Val.divs rs # r1 (Vint n) = Some v.","proofString":"congruence."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) (i : int) (Heqo : Int.is_power2 n = Some i) (Heqb : Int.ltu i (Int.repr 31) = false) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odiv rs ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divs rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n <> Int.one) (Heqo : Int.is_power2 n = None) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Odiv rs ## (r1 :: r2 :: nil) m =\n  Some w /\\ Val.lessdef v w.","proofString":"exists v; auto."},{"statement":"(n : int) (r1 r2 : positive) (v : val) (H : Val.divu rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint n) (H1 : n = Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"subst.\nrewrite H0 in H.\ndestruct (rs#r1) eqn:?;    try (rewrite Val.divu_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divu rs # r1 rs # r2 = Some v) (H0 : rs # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"rewrite H0 in H.\ndestruct (rs#r1) eqn:?;    try (rewrite Val.divu_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(r1 r2 : positive) (v : val) (H : Val.divu rs # r1 (Vint Int.one) = Some v) (H0 : rs # r2 = Vint Int.one) : exists w : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r1 :: nil) m = Some w /\\\n  Val.lessdef v w.","proofString":"destruct (rs#r1) eqn:?;    try (rewrite Val.divu_one in H; exists (Vint i); split; simpl; try rewrite Heqv0; auto);    inv H; auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Ointconst Int.zero, nil)\n  else\n   if Int.eq n Int.mone\n   then (Omove, r :: nil)\n   else\n    if\n     match x with\n     | Uns _ m0 => Int.eq (Int.zero_ext m0 (Int.not n)) Int.zero\n     | _ => false\n     end\n    then (Omove, r :: nil)\n    else (Oandimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst n.\nexists (Vint Int.zero); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.and_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.and_mone; auto.\ndestruct (match x with Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero                       | _ => false end) eqn:UNS.\ndestruct x; try congruence.\nexists (rs#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) rs ## nil m =\n  Some v /\\ Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"subst n.\nexists (Vint Int.zero); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.and_zero; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc rs # r x) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.zero) rs ## nil m =\n  Some v /\\ Val.lessdef (Val.and rs # r (Vint Int.zero)) v.","proofString":"exists (Vint Int.zero); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.and_zero; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc rs # r x) : Val.lessdef (Val.and rs # r (Vint Int.zero)) (Vint Int.zero).","proofString":"destruct (rs#r); simpl; auto.\nrewrite Int.and_zero; auto."},{"statement":"(r : positive) (x : aval) (i : int) (H : vmatch bc (Vint i) x) : Val.lessdef (Vint (Int.and i Int.zero)) (Vint Int.zero).","proofString":"rewrite Int.and_zero; auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : n <> Int.zero) : let (op, args) :=\n  if Int.eq n Int.mone\n  then (Omove, r :: nil)\n  else\n   if\n    match x with\n    | Uns _ m0 => Int.eq (Int.zero_ext m0 (Int.not n)) Int.zero\n    | _ => false\n    end\n   then (Omove, r :: nil)\n   else (Oandimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.and_mone; auto.\ndestruct (match x with Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero                       | _ => false end) eqn:UNS.\ndestruct x; try congruence.\nexists (rs#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : n <> Int.zero) (H1 : n = Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"subst n.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : Int.mone <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and rs # r (Vint Int.mone)) v.","proofString":"exists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : Int.mone <> Int.zero) : Val.lessdef (Val.and rs # r (Vint Int.mone)) rs # r.","proofString":"destruct (rs#r); simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(r : positive) (x : aval) (i : int) (H : vmatch bc (Vint i) x) (H0 : Int.mone <> Int.zero) : Val.lessdef (Vint (Int.and i Int.mone)) (Vint i).","proofString":"rewrite Int.and_mone; auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) : let (op, args) :=\n  if\n   match x with\n   | Uns _ m0 => Int.eq (Int.zero_ext m0 (Int.not n)) Int.zero\n   | _ => false\n   end\n  then (Omove, r :: nil)\n  else (Oandimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"destruct (match x with Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero                       | _ => false end) eqn:UNS.\ndestruct x; try congruence.\nexists (rs#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : match x with\n| Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero\n| _ => false\nend = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"destruct x; try congruence.\nexists (rs#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H : vmatch bc rs # r (Uns p n0)) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"exists (rs#r); split; auto.\ninv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H : vmatch bc rs # r (Uns p n0)) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) : Val.lessdef (Val.and rs # r (Vint n)) rs # r.","proofString":"inv H; auto.\nsimpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) : Val.lessdef (Val.and (Vint i) (Vint n)) (Vint i).","proofString":"simpl.\nreplace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) : Val.lessdef (Vint (Int.and i n)) (Vint i).","proofString":"replace (Int.and i n) with i; auto.\ngeneralize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) : i = Int.and i n.","proofString":"generalize (Int.eq_spec (Int.zero_ext n0 (Int.not n)) Int.zero); rewrite UNS; intro EQ.\nInt.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) : i = Int.and i n.","proofString":"Int.bit_solve.\ndestruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) : Int.testbit i i0 = Int.testbit i i0 && Int.testbit n i0.","proofString":"destruct (zlt i0 n0).\nreplace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive.\nrewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && Int.testbit n i0.","proofString":"replace (Int.testbit n i0) with (negb (Int.testbit Int.zero i0)).\nrewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto.\nrewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && negb (Int.testbit Int.zero i0).","proofString":"rewrite Int.bits_zero.\nsimpl.\nrewrite andb_true_r.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && negb false.","proofString":"simpl.\nrewrite andb_true_r.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0 && true.","proofString":"rewrite andb_true_r.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : Int.testbit i i0 = Int.testbit i i0.","proofString":"auto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (Int.testbit Int.zero i0) = Int.testbit n i0.","proofString":"rewrite <- EQ.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (Int.testbit (Int.zero_ext n0 (Int.not n)) i0) = Int.testbit n i0.","proofString":"rewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (if zlt i0 n0 then Int.testbit (Int.not n) i0 else false) =\nInt.testbit n i0.","proofString":"rewrite zlt_true by auto.\nrewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (Int.testbit (Int.not n) i0) = Int.testbit n i0.","proofString":"rewrite Int.bits_not by auto.\napply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (l : i0 < n0) : negb (negb (Int.testbit n i0)) = Int.testbit n i0.","proofString":"apply negb_involutive."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (g : i0 >= n0) : Int.testbit i i0 = Int.testbit i i0 && Int.testbit n i0.","proofString":"rewrite H6 by auto.\nauto."},{"statement":"(n : int) (r : positive) (p : aptr) (n0 : Z) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : Int.eq (Int.zero_ext n0 (Int.not n)) Int.zero = true) (i : int) (H5 : 0 <= n0) (H6 : is_uns n0 i) (H2 : Vint i = rs # r) (EQ : Int.zero_ext n0 (Int.not n) = Int.zero) (i0 : Z) (H : 0 <= i0 < Int.zwordsize) (g : i0 >= n0) : false = false && Int.testbit n i0.","proofString":"auto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : match x with\n| Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero\n| _ => false\nend = false) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oandimm n) rs ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.and rs # r (Vint n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : positive) (x : aval) (H : vmatch bc rs # r x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (UNS : match x with\n| Uns _ k => Int.eq (Int.zero_ext k (Int.not n)) Int.zero\n| _ => false\nend = false) : eval_operation ge (Vptr sp Ptrofs.zero) (Oandimm n) rs ## (r :: nil) m =\nSome (Val.and rs # r (Vint n)).","proofString":"auto."},{"statement":"(n : int) (r : reg) : let (op, args) :=\n  if Int.eq n Int.zero\n  then (Omove, r :: nil)\n  else\n   if Int.eq n Int.mone\n   then (Ointconst Int.mone, nil)\n   else (Oorimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.or rs # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst n.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Vint Int.mone); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.or_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.or rs # r (Vint n)) v.","proofString":"subst n.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.or rs # r (Vint Int.zero)) v.","proofString":"exists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.or rs # r (Vint Int.zero)) rs # r.","proofString":"destruct (rs#r); simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(r : reg) (i : int) : Val.lessdef (Vint (Int.or i Int.zero)) (Vint i).","proofString":"rewrite Int.or_zero; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) : let (op, args) :=\n  if Int.eq n Int.mone\n  then (Ointconst Int.mone, nil)\n  else (Oorimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.or rs # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Vint Int.mone); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.or_mone; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n = Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.mone) rs ## nil m =\n  Some v /\\ Val.lessdef (Val.or rs # r (Vint n)) v.","proofString":"subst n.\nexists (Vint Int.mone); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Ointconst Int.mone) rs ## nil m =\n  Some v /\\ Val.lessdef (Val.or rs # r (Vint Int.mone)) v.","proofString":"exists (Vint Int.mone); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : Val.lessdef (Val.or rs # r (Vint Int.mone)) (Vint Int.mone).","proofString":"destruct (rs#r); simpl; auto.\nrewrite Int.or_mone; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) (i : int) : Val.lessdef (Vint (Int.or i Int.mone)) (Vint Int.mone).","proofString":"rewrite Int.or_mone; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oorimm n) rs ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.or rs # r (Vint n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : eval_operation ge (Vptr sp Ptrofs.zero) (Oorimm n) rs ## (r :: nil) m =\nSome (Val.or rs # r (Vint n)).","proofString":"auto."},{"statement":"(n : int) (r : reg) : let (op, args) :=\n  if Int.eq n Int.zero then (Omove, r :: nil) else (Oxorimm n, r :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.xor rs # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; intros.\nsubst n.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.xor_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Val.notint (rs#r)); split.\nauto.\ndestruct (rs#r); simpl; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n = Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xor rs # r (Vint n)) v.","proofString":"subst n.\nexists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.xor_zero; auto."},{"statement":"(r : reg) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omove rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xor rs # r (Vint Int.zero)) v.","proofString":"exists (rs#r); split; auto.\ndestruct (rs#r); simpl; auto.\nrewrite Int.xor_zero; auto."},{"statement":"(r : reg) : Val.lessdef (Val.xor rs # r (Vint Int.zero)) rs # r.","proofString":"destruct (rs#r); simpl; auto.\nrewrite Int.xor_zero; auto."},{"statement":"(r : reg) (i : int) : Val.lessdef (Vint (Int.xor i Int.zero)) (Vint i).","proofString":"rewrite Int.xor_zero; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) rs ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xor rs # r (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone; intros.\nsubst n.\nexists (Val.notint (rs#r)); split.\nauto.\ndestruct (rs#r); simpl; auto.\neconstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n = Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) rs ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xor rs # r (Vint n)) v.","proofString":"subst n.\nexists (Val.notint (rs#r)); split.\nauto.\ndestruct (rs#r); simpl; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.mone) \n    rs ## (r :: nil) m = Some v /\\\n  Val.lessdef (Val.xor rs # r (Vint Int.mone)) v.","proofString":"exists (Val.notint (rs#r)); split.\nauto.\ndestruct (rs#r); simpl; auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm Int.mone) rs ## (r :: nil) m =\nSome (Val.notint rs # r).","proofString":"auto."},{"statement":"(r : reg) (H : Int.mone <> Int.zero) : Val.lessdef (Val.xor rs # r (Vint Int.mone)) (Val.notint rs # r).","proofString":"destruct (rs#r); simpl; auto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) rs ## (r :: nil) m =\n  Some v /\\ Val.lessdef (Val.xor rs # r (Vint n)) v.","proofString":"econstructor; split; eauto.\nauto."},{"statement":"(n : int) (r : reg) (H : n <> Int.zero) (H0 : n <> Int.mone) : eval_operation ge (Vptr sp Ptrofs.zero) (Oxorimm n) rs ## (r :: nil) m =\nSome (Val.xor rs # r (Vint n)).","proofString":"auto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : rs # r2 = Vfloat n) : let (op, args) :=\n  if Float.eq_dec n (Float.of_int (Int.repr 2))\n  then (Oaddf, r1 :: r1 :: nil)\n  else (Omulf, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"destruct (Float.eq_dec n (Float.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r1); simpl; auto.\nrewrite Float.mul2_add; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : rs # r2 = Vfloat n) (e : n = Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddf rs ## (r1 :: r1 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r1); simpl; auto.\nrewrite Float.mul2_add; auto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : rs # r2 = Vfloat n) (e : n = Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addf rs # r1 rs # r1) = Some v /\\\n  Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r1); simpl; auto.\nrewrite Float.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vfloat (Float.of_int (Int.repr 2))) : Val.lessdef (Val.mulf rs # r1 (Vfloat (Float.of_int (Int.repr 2))))\n  (Val.addf rs # r1 rs # r1).","proofString":"destruct (rs#r1); simpl; auto.\nrewrite Float.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vfloat (Float.of_int (Int.repr 2))) (f : float) : Val.lessdef (Vfloat (Float.mul f (Float.of_int (Int.repr 2))))\n  (Vfloat (Float.add f f)).","proofString":"rewrite Float.mul2_add; auto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : rs # r2 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulf rs ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : reg) (r2 : positive) (H : rs # r2 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulf rs # r1 rs # r2) = Some v /\\\n  Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"econstructor; split; eauto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat n) : let (op, args) :=\n  if Float.eq_dec n (Float.of_int (Int.repr 2))\n  then (Oaddf, r2 :: r2 :: nil)\n  else (Omulf, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"destruct (Float.eq_dec n (Float.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat n) (e : n = Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddf rs ## (r2 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat n) (e : n = Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addf rs # r2 rs # r2) = Some v /\\\n  Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat (Float.of_int (Int.repr 2))) : Val.lessdef (Val.mulf (Vfloat (Float.of_int (Int.repr 2))) rs # r2)\n  (Val.addf rs # r2 rs # r2).","proofString":"destruct (rs#r2); simpl; auto.\nrewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat (Float.of_int (Int.repr 2))) (f : float) : Val.lessdef (Vfloat (Float.mul (Float.of_int (Int.repr 2)) f))\n  (Vfloat (Float.add f f)).","proofString":"rewrite Float.mul2_add; auto.\nrewrite Float.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat (Float.of_int (Int.repr 2))) (f : float) : Val.lessdef (Vfloat (Float.mul (Float.of_int (Int.repr 2)) f))\n  (Vfloat (Float.mul f (Float.of_int (Int.repr 2)))).","proofString":"rewrite Float.mul_commut; auto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulf rs ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float) (r1 : positive) (r2 : reg) (H : rs # r1 = Vfloat n) (n0 : n <> Float.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulf rs # r1 rs # r2) = Some v /\\\n  Val.lessdef (Val.mulf rs # r1 rs # r2) v.","proofString":"econstructor; split; eauto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : rs # r2 = Vsingle n) : let (op, args) :=\n  if Float32.eq_dec n (Float32.of_int (Int.repr 2))\n  then (Oaddfs, r1 :: r1 :: nil)\n  else (Omulfs, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"destruct (Float32.eq_dec n (Float32.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r1); simpl; auto.\nrewrite Float32.mul2_add; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : rs # r2 = Vsingle n) (e : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddfs rs ## (r1 :: r1 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r1); simpl; auto.\nrewrite Float32.mul2_add; auto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : rs # r2 = Vsingle n) (e : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addfs rs # r1 rs # r1) = Some v /\\\n  Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r1); simpl; auto.\nrewrite Float32.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vsingle (Float32.of_int (Int.repr 2))) : Val.lessdef (Val.mulfs rs # r1 (Vsingle (Float32.of_int (Int.repr 2))))\n  (Val.addfs rs # r1 rs # r1).","proofString":"destruct (rs#r1); simpl; auto.\nrewrite Float32.mul2_add; auto."},{"statement":"(r1 : reg) (r2 : positive) (H : rs # r2 = Vsingle (Float32.of_int (Int.repr 2))) (f : float32) : Val.lessdef (Vsingle (Float32.mul f (Float32.of_int (Int.repr 2))))\n  (Vsingle (Float32.add f f)).","proofString":"rewrite Float32.mul2_add; auto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : rs # r2 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulfs rs ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : reg) (r2 : positive) (H : rs # r2 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulfs rs # r1 rs # r2) = Some v /\\\n  Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"econstructor; split; eauto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle n) : let (op, args) :=\n  if Float32.eq_dec n (Float32.of_int (Int.repr 2))\n  then (Oaddfs, r2 :: r2 :: nil)\n  else (Omulfs, r1 :: r2 :: nil) in\nexists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op rs ## args m = Some v /\\\n  Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"destruct (Float32.eq_dec n (Float32.of_int (Int.repr 2))); intros.\nsimpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto.\nsimpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle n) (e : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Oaddfs rs ## (r2 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle n) (e : n = Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.addfs rs # r2 rs # r2) = Some v /\\\n  Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"econstructor; split.\neauto.\nrewrite H; subst n.\ndestruct (rs#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle (Float32.of_int (Int.repr 2))) : Val.lessdef (Val.mulfs (Vsingle (Float32.of_int (Int.repr 2))) rs # r2)\n  (Val.addfs rs # r2 rs # r2).","proofString":"destruct (rs#r2); simpl; auto.\nrewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle (Float32.of_int (Int.repr 2))) (f : float32) : Val.lessdef (Vsingle (Float32.mul (Float32.of_int (Int.repr 2)) f))\n  (Vsingle (Float32.add f f)).","proofString":"rewrite Float32.mul2_add; auto.\nrewrite Float32.mul_commut; auto."},{"statement":"(r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle (Float32.of_int (Int.repr 2))) (f : float32) : Val.lessdef (Vsingle (Float32.mul (Float32.of_int (Int.repr 2)) f))\n  (Vsingle (Float32.mul f (Float32.of_int (Int.repr 2)))).","proofString":"rewrite Float32.mul_commut; auto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) Omulfs rs ## (r1 :: r2 :: nil) m =\n  Some v /\\ Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"simpl.\neconstructor; split; eauto."},{"statement":"(n : float32) (r1 : positive) (r2 : reg) (H : rs # r1 = Vsingle n) (n0 : n <> Float32.of_int (Int.repr 2)) : exists v : val,\n  Some (Val.mulfs rs # r1 rs # r2) = Some v /\\\n  Val.lessdef (Val.mulfs rs # r1 rs # r2) v.","proofString":"econstructor; split; eauto."}]}