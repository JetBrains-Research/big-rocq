{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/reordering/Reordering.v","fileSamples":[{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : contigious_actids G) : event_mem (ThreadEvent et en) (thread_trace G et) <-> E (ThreadEvent et en).","conclusion":"event_mem (ThreadEvent et en) (thread_trace G et) <-> E (ThreadEvent et en)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : contigious_actids G)","proofString":"red in CONT.\ndestruct (CONT _ NINIT) as [N EQ].\nsplit; intros HSET.\nenough (IN' :      (acts_set G ∩₁ (fun e => et = tid e))        (ThreadEvent et en)    ).\napply IN'.\napply EQ, thread_set_iff.\nunfold thread_trace, thread_actid_trace in HSET.\nins.\nrewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET.\nunfold thread_trace, thread_actid_trace.\nins.\nrewrite EQ, thread_seq_set_size.\nins.\nautorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N) : event_mem (ThreadEvent et en) (thread_trace G et) <-> E (ThreadEvent et en).","conclusion":"event_mem (ThreadEvent et en) (thread_trace G et) <-> E (ThreadEvent et en)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N)","proofString":"destruct (CONT _ NINIT) as [N EQ].\nsplit; intros HSET.\nenough (IN' :      (acts_set G ∩₁ (fun e => et = tid e))        (ThreadEvent et en)    ).\napply IN'.\napply EQ, thread_set_iff.\nunfold thread_trace, thread_actid_trace in HSET.\nins.\nrewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET.\nunfold thread_trace, thread_actid_trace.\nins.\nrewrite EQ, thread_seq_set_size.\nins.\nautorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) : event_mem (ThreadEvent et en) (thread_trace G et) <-> E (ThreadEvent et en).","conclusion":"event_mem (ThreadEvent et en) (thread_trace G et) <-> E (ThreadEvent et en)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N)","proofString":"split; intros HSET.\nenough (IN' :      (acts_set G ∩₁ (fun e => et = tid e))        (ThreadEvent et en)    ).\napply IN'.\napply EQ, thread_set_iff.\nunfold thread_trace, thread_actid_trace in HSET.\nins.\nrewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET.\nunfold thread_trace, thread_actid_trace.\nins.\nrewrite EQ, thread_seq_set_size.\nins.\nautorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et)) : E (ThreadEvent et en).","conclusion":"E (ThreadEvent et en)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et))","proofString":"enough (IN' :      (acts_set G ∩₁ (fun e => et = tid e))        (ThreadEvent et en)    ).\napply IN'.\napply EQ, thread_set_iff.\nunfold thread_trace, thread_actid_trace in HSET.\nins.\nrewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et)) (IN' : (E ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)) : E (ThreadEvent et en).","conclusion":"E (ThreadEvent et en)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et)) (IN' : (E ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en))","proofString":"apply IN'."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et)) : (E ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en).","conclusion":"(E ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et))","proofString":"apply EQ, thread_set_iff.\nunfold thread_trace, thread_actid_trace in HSET.\nins.\nrewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et)) : en < N.","conclusion":"en < N","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en) (thread_trace G et))","proofString":"unfold thread_trace, thread_actid_trace in HSET.\nins.\nrewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end))) : en < N.","conclusion":"en < N","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end)))","proofString":"ins.\nrewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end))) : en < N.","conclusion":"en < N","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end)))","proofString":"rewrite EQ, thread_seq_set_size in HSET.\nins.\nnow autorewrite with calc_length in HSET."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en)\n  (trace_map lab (trace_map (ThreadEvent et) (trace_fin (List.seq 0 N))))) : en < N.","conclusion":"en < N","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : event_mem (ThreadEvent et en)\n  (trace_map lab (trace_map (ThreadEvent et) (trace_fin (List.seq 0 N)))))","proofString":"ins.\nnow autorewrite with calc_length in HSET."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : en < length (map lab (map (ThreadEvent et) (List.seq 0 N)))) : en < N.","conclusion":"en < N","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : en < length (map lab (map (ThreadEvent et) (List.seq 0 N))))","proofString":"now autorewrite with calc_length in HSET."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en)) : event_mem (ThreadEvent et en) (thread_trace G et).","conclusion":"event_mem (ThreadEvent et en) (thread_trace G et)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en))","proofString":"unfold thread_trace, thread_actid_trace.\nins.\nrewrite EQ, thread_seq_set_size.\nins.\nautorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en)) : event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end)).","conclusion":"event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end))","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en))","proofString":"ins.\nrewrite EQ, thread_seq_set_size.\nins.\nautorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en)) : event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end)).","conclusion":"event_mem (ThreadEvent et en)\n  (trace_map lab\n     (trace_map (ThreadEvent et)\n        match set_size (E ∩₁ (fun e : actid => et = tid e)) with\n        | NOinfinity => trace_inf (fun x : nat => x)\n        | NOnum n => trace_fin (List.seq 0 n)\n        end))","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en))","proofString":"rewrite EQ, thread_seq_set_size.\nins.\nautorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en)) : event_mem (ThreadEvent et en)\n  (trace_map lab (trace_map (ThreadEvent et) (trace_fin (List.seq 0 N)))).","conclusion":"event_mem (ThreadEvent et en)\n  (trace_map lab (trace_map (ThreadEvent et) (trace_fin (List.seq 0 N))))","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en))","proofString":"ins.\nautorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en)) : en < length (map lab (map (ThreadEvent et) (List.seq 0 N))).","conclusion":"en < length (map lab (map (ThreadEvent et) (List.seq 0 N)))","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en))","proofString":"autorewrite with calc_length.\neapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en)) : en < N.","conclusion":"en < N","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en))","proofString":"eapply thread_set_iff, EQ.\nbasic_solver."},{"statement":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en)) : (E ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en).","conclusion":"(E ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)","hypotheses":"(et : thread_id) (en : nat) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat, E ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (N : nat) (EQ : E ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (HSET : E (ThreadEvent et en))","proofString":"basic_solver."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) : forall x : location, exists ! y : value, last_val_spec x y.","conclusion":"forall x : location, exists ! y : value, last_val_spec x y","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a)))","proofString":"intro l.\ndestruct last_val_exists        with (l := l)          as [v SPEC]; auto.\nexists v.\nred.\nsplit; auto.\nintros v' SPEC'.\neapply last_val_unique; eauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) : exists ! y : value, last_val_spec l y.","conclusion":"exists ! y : value, last_val_spec l y","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location)","proofString":"destruct last_val_exists        with (l := l)          as [v SPEC]; auto.\nexists v.\nred.\nsplit; auto.\nintros v' SPEC'.\neapply last_val_unique; eauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v) : exists ! y : value, last_val_spec l y.","conclusion":"exists ! y : value, last_val_spec l y","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v)","proofString":"exists v.\nred.\nsplit; auto.\nintros v' SPEC'.\neapply last_val_unique; eauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v) : unique (fun y : value => last_val_spec l y) v.","conclusion":"unique (fun y : value => last_val_spec l y) v","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v)","proofString":"red.\nsplit; auto.\nintros v' SPEC'.\neapply last_val_unique; eauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v) : last_val_spec l v /\\ (forall x' : value, last_val_spec l x' -> v = x').","conclusion":"last_val_spec l v /\\ (forall x' : value, last_val_spec l x' -> v = x')","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v)","proofString":"split; auto.\nintros v' SPEC'.\neapply last_val_unique; eauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v) : forall x' : value, last_val_spec l x' -> v = x'.","conclusion":"forall x' : value, last_val_spec l x' -> v = x'","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v)","proofString":"intros v' SPEC'.\neapply last_val_unique; eauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v) (v' : value) (SPEC' : last_val_spec l v') : v = v'.","conclusion":"v = v'","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (l : location) (v : value) (SPEC : last_val_spec l v) (v' : value) (SPEC' : last_val_spec l v')","proofString":"eapply last_val_unique; eauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (b : location -> value) (SPEC : forall x : location, last_val_spec x (b x)) : exists b0 : behavior, behavior_spec b0.","conclusion":"exists b0 : behavior, behavior_spec b0","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (b : location -> value) (SPEC : forall x : location, last_val_spec x (b x))","proofString":"exists b.\nred.\nauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (b : location -> value) (SPEC : forall x : location, last_val_spec x (b x)) : behavior_spec b.","conclusion":"behavior_spec b","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (b : location -> value) (SPEC : forall x : location, last_val_spec x (b x))","proofString":"red.\nauto."},{"statement":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (b : location -> value) (SPEC : forall x : location, last_val_spec x (b x)) : forall l : location, last_val_spec l (b l).","conclusion":"forall l : location, last_val_spec l (b l)","hypotheses":"(WF : Wf G) (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (b : location -> value) (SPEC : forall x : location, last_val_spec x (b x))","proofString":"auto."},{"statement":"(b : behavior) (m : actid -> actid) (WF : Wf G) (WF' : Wf G') (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (MAP : m ↑₁ E ≡₁ E') (EQ : eq_dom E (lab' ∘ m) lab) (INJ : inj_dom E m) (MAPCO : co' ⊆ m ↑ co) (BEH1 : forall l : location, last_val_spec G l (b l)) : forall l : location, last_val_spec G' l (b l).","conclusion":"forall l : location, last_val_spec G' l (b l)","hypotheses":"(b : behavior) (m : actid -> actid) (WF : Wf G) (WF' : Wf G') (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (MAP : m ↑₁ E ≡₁ E') (EQ : eq_dom E (lab' ∘ m) lab) (INJ : inj_dom E m) (MAPCO : co' ⊆ m ↑ co) (BEH1 : forall l : location, last_val_spec G l (b l))","proofString":"intro l.\neapply same_last_val; eauto."},{"statement":"(b : behavior) (m : actid -> actid) (WF : Wf G) (WF' : Wf G') (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (MAP : m ↑₁ E ≡₁ E') (EQ : eq_dom E (lab' ∘ m) lab) (INJ : inj_dom E m) (MAPCO : co' ⊆ m ↑ co) (BEH1 : forall l0 : location, last_val_spec G l0 (b l0)) (l : location) : last_val_spec G' l (b l).","conclusion":"last_val_spec G' l (b l)","hypotheses":"(b : behavior) (m : actid -> actid) (WF : Wf G) (WF' : Wf G') (INIT : (fun a : actid => is_init a) ⊆₁ E) (FIN : set_finite (E \\₁ (fun a : actid => is_init a))) (MAP : m ↑₁ E ≡₁ E') (EQ : eq_dom E (lab' ∘ m) lab) (INJ : inj_dom E m) (MAPCO : co' ⊆ m ↑ co) (BEH1 : forall l0 : location, last_val_spec G l0 (b l0)) (l : location)","proofString":"eapply same_last_val; eauto."},{"statement":"(X1 X2 : WCore.t) (STEP : xmm_step_trace trs X1 X2) : clos_trans_n1 WCore.t xmm_step X1 X2.","conclusion":"clos_trans_n1 WCore.t xmm_step X1 X2","hypotheses":"(X1 X2 : WCore.t) (STEP : xmm_step_trace trs X1 X2)","proofString":"apply tn1_step, STEP."},{"statement":"(X1 X' X2 : WCore.t) (STEP : xmm_step_trace trs X' X2) (IH : clos_trans_n1 WCore.t (xmm_step_trace trs) X1 X') (IHIH : clos_trans_n1 WCore.t xmm_step X1 X') : clos_trans_n1 WCore.t xmm_step X1 X2.","conclusion":"clos_trans_n1 WCore.t xmm_step X1 X2","hypotheses":"(X1 X' X2 : WCore.t) (STEP : xmm_step_trace trs X' X2) (IH : clos_trans_n1 WCore.t (xmm_step_trace trs) X1 X') (IHIH : clos_trans_n1 WCore.t xmm_step X1 X')","proofString":"apply Relation_Operators.tn1_trans with X'; auto.\napply STEP."},{"statement":"(X1 X' X2 : WCore.t) (STEP : xmm_step_trace trs X' X2) (IH : clos_trans_n1 WCore.t (xmm_step_trace trs) X1 X') (IHIH : clos_trans_n1 WCore.t xmm_step X1 X') : xmm_step X' X2.","conclusion":"xmm_step X' X2","hypotheses":"(X1 X' X2 : WCore.t) (STEP : xmm_step_trace trs X' X2) (IH : clos_trans_n1 WCore.t (xmm_step_trace trs) X1 X') (IHIH : clos_trans_n1 WCore.t xmm_step X1 X')","proofString":"apply STEP."}]}