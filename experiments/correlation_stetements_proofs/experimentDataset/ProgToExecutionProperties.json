[{"statement":"Lemma depf_preserves_set_expr s (depfs : DepsFile.t) (AA : forall r, depfs r ⊆₁ s) :\n  forall expr, DepsFile.expr_deps depfs expr ⊆₁ s.","proof":"ins.\ninduction expr.\n1,2: unfold DepsFile.expr_deps, DepsFile.val_deps; desf; apply AA.\nunfold DepsFile.expr_deps.\nunfold DepsFile.val_deps, RegFun.find.\ndesf.\n{\nbasic_solver.\n}\nall: rewrite AA.\n3: rewrite AA.\nall: basic_solver.\n"},{"statement":"Lemma depf_preserves_set_lexpr s (depfs : DepsFile.t) (AA : forall r, depfs r ⊆₁ s) :\n  forall expr, DepsFile.lexpr_deps depfs expr ⊆₁ s.","proof":"ins.\ninduction expr.\nall: unfold DepsFile.lexpr_deps, DepsFile.val_deps; desf; apply AA.\n"},{"statement":"Lemma wft_sbE : sb ≡ ⦗E⦘ ⨾ sb ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold Execution.sb; basic_solver 42.\n"},{"statement":"Lemma wf_thread_state_init l thread:\n      wf_thread_state thread (init l).","proof":"unfold init.\nconstructor; simpls.\n{\nins.\ninv LT.\n}\n{\nbasic_solver.\n}\n1-4: basic_solver.\nins.\nunfold DepsFile.init.\nsimpls.\n"},{"statement":"Lemma add_preserves_lab thread s s' e hl s1 s2 s3 s4\n      (WF : wf_thread_state thread s)\n      (UG : G s' = add (G s) thread (eindex s) hl s1 s2 s3 s4)\n      (ACT : acts_set (G s) e) :\n  lab (G s') e = lab (G s) e.","proof":"unfold add in UG.\nrewrite UG.\nsimpls.\nrewrite updo; auto.\nintros HH; subst.\nred in ACT.\napply WF in ACT.\ndesc.\ninv REP.\nlia.\n"},{"statement":"Lemma add_rmw_preserves_lab thread s s' e hl s1 s2 s3 s4 s5\n      (WF : wf_thread_state thread s)\n      (UG : G s' = add_rmw (G s) thread (eindex s) hl s1 s2 s3 s4 s5)\n      (ACT : acts_set (G s) e) :\n  lab (G s') e = lab (G s) e.","proof":"unfold add in UG.\nrewrite UG.\nsimpls.\nrewrite !updo; auto.\nall: intros HH; subst.\nall: red in ACT; apply WF in ACT.\nall: desc; inv REP; lia.\n"},{"statement":"Lemma add_preserves_acts_clos thread ll s s' hl s1 s2 s3 s4\n      (WF : wf_thread_state thread s)\n      (STEP : istep thread ll s s')\n      (LABELS : ll = hl :: nil)\n      (UG : G s' = add (G s) thread (eindex s) hl s1 s2 s3 s4)\n      (UINDEX : eindex s' = eindex s + 1) :\n  forall n : nat,\n    n < eindex s + 1 ->\n    acts_set (add (G s) thread (eindex s) hl s1 s2 s3 s4)\n             (ThreadEvent thread n).","proof":"unfold add.\nsimpls.\nins.\nassert (n <= eindex s) as NS by lia.\napply Const.le_lteq in NS.\ndestruct NS as [LT|LT]; [right|left].\n{\napply (acts_clos WF).\nlia.\n}\ndesf.\n"},{"statement":"Lemma add_rmw_preserves_acts_clos thread ll s s' rl wl s1 s2 s3 s4\n      (WF : wf_thread_state thread s)\n      (STEP : istep thread ll s s')\n      (LABELS : ll = wl :: rl :: nil)\n      (UG : G s' = add_rmw (G s) thread (eindex s) rl wl s1 s2 s3 s4)\n      (UINDEX : eindex s' = eindex s + 2) :\n  forall n : nat,\n    n < eindex s + 2 ->\n    acts_set (add_rmw (G s) thread (eindex s) rl wl s1 s2 s3 s4)\n             (ThreadEvent thread n).","proof":"unfold add_rmw.\nsimpls.\nins.\nassert (n <= eindex s + 1) as NS by lia.\napply Const.le_lteq in NS.\ndestruct NS as [LT|LT].\n{\napply Const.le_lteq in LT.\ndestruct LT as [LT|LT].\n{\nright.\napply (acts_clos WF).\nlia.\n}\nrewrite Const.add_comm in LT.\ninv LT.\nleft.\nby right.\n}\nrewrite Const.add_comm in LT.\ninv LT.\nrewrite Const.add_comm.\ndo 2 left.\neauto.\n"},{"statement":"Lemma step_preserves_E thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : step thread state state') :\n  acts_set (ProgToExecution.G state) ⊆₁\n  acts_set (ProgToExecution.G state').","proof":"red in STEP.\ndesc.\ncdes STEP.\ndestruct ISTEP0.\nall: rewrite UG; auto.\n1-4: by unfold add, acts_set; simpls; right.\nall: by unfold add_rmw, acts_set; simpls; repeat right.\n"},{"statement":"Lemma step_preserves_instrs thread state state'\n      (STEP : step thread state state') :\n  instrs state' = instrs state.","proof":"inv STEP.\ninv H.\n"},{"statement":"Lemma steps_preserve_instrs thread state state'\n      (STEPS : (step thread)＊ state state') :\n  instrs state' = instrs state.","proof":"apply clos_rt_rtn1 in STEPS.\ninduction STEPS; auto.\nrewrite <- IHSTEPS.\neapply step_preserves_instrs; eauto.\n"},{"statement":"Lemma ectrl_increasing (tid : thread_id) s s' (STEP : step tid s s'):\n  (ectrl s) ⊆₁ (ectrl s').","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0; rewrite UECTRL; try done.\nbasic_solver.\n"},{"statement":"Lemma ectrl_increasing_steps (tid : thread_id) s s' (STEP : (step tid)＊ s s'):\n  (ectrl s) ⊆₁ (ectrl s').","proof":"induction STEP.\n{\neby eapply ectrl_increasing.\n}\n{\ndone.\n}\nunfolder in *; basic_solver.\n"},{"statement":"Lemma ctrl_increasing (tid : thread_id) s s' (STEP : step tid s s'):\n  (ctrl (G s)) ⊆ (ctrl (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw; ins; basic_solver.\n"},{"statement":"Lemma rmw_dep_increasing (tid : thread_id) s s' (STEP : step tid s s'):\n  (rmw_dep (G s)) ⊆ (rmw_dep (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw; ins; basic_solver.\n"},{"statement":"Lemma addr_increasing (tid : thread_id) s s' (STEP : step tid s s'):\n  (addr (G s)) ⊆ (addr (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw; ins; basic_solver.\n"},{"statement":"Lemma data_increasing (tid : thread_id) s s' (STEP : step tid s s'):\n  (data (G s)) ⊆ (data (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw; ins; basic_solver.\n"},{"statement":"Lemma wf_thread_state_step thread s s'\n      (WF : wf_thread_state thread s)\n      (STEP : step thread s s') :\n  wf_thread_state thread s'.","proof":"destruct STEP as [ll STEP].\ncdes STEP.\nconstructor.\n{\ndestruct ISTEP0.\nall: rewrite UG.\nall: try rewrite UINDEX.\nall: try apply WF.\nall: try (intros e [HH|IN]; [eexists; splits; eauto; lia|];        edestruct (acts_rep WF); eauto; desc;        eexists; splits; eauto; lia).\nall: intros e [[HH|IN]|IN].\nall: try (eexists; splits; eauto; lia).\nall: edestruct (acts_rep WF); eauto; desc.\nall: eexists; splits; eauto; lia.\n}\n{\ndestruct ISTEP0.\nall: rewrite UG.\nall: try rewrite UINDEX.\n1,2: by apply WF.\n1-4: by eapply add_preserves_acts_clos; eauto.\nall: eapply add_rmw_preserves_acts_clos; eauto.\n}\n{\nsplit; [|basic_solver].\ndestruct ISTEP0.\nall: rewrite UG.\n1,2: by apply WF.\n1-4: unfold add; simpls; rewrite (wft_rmwE WF) at 1;      basic_solver.\nall: unfold add_rmw; simpls; rewrite (wft_rmwE WF) at 1;      basic_solver.\n}\n{\nassert (RMW_HELPER: forall ldlab stlab dps ldps edps r w,               rmw (add_rmw (G s) thread (eindex s) ldlab stlab                            dps ldps (ectrl s) edps) r w               -> exists index : nat,                 r = ThreadEvent thread index                 /\\ w = ThreadEvent thread (S index)).\n{\nunfold add_rmw.\nsimpls.\nintros lblab stlab dps ldps edps r w RMW.\ndestruct RMW as [RMW|RMW].\n2: by apply WF.\nred in RMW.\ndesf.\nrewrite Const.add_comm.\neexists.\nsplits; eauto.\n}\ndestruct ISTEP0.\nall: rewrite UG.\n1,2: by apply WF.\n1-4: by unfold add; simpls; apply WF.\nall: apply RMW_HELPER.\n}\n{\nsplit; [|basic_solver].\ndestruct ISTEP0.\nall: rewrite UG.\n1,2: by apply WF.\nall: unfold add, add_rmw; simpls; rewrite (wft_dataE WF) at 1.\n1,3,4: basic_solver 10.\n1: seq_rewrite <- (set_inter_absorb_r                        (depf_preserves_set_expr _ (wft_depfE WF) expr)).\n3: seq_rewrite <- (set_inter_absorb_r                        (depf_preserves_set_expr _ (wft_depfE WF) expr_add)).\n2,4: seq_rewrite <- (set_inter_absorb_r                           (depf_preserves_set_expr _ (wft_depfE WF) expr_new)).\nall: basic_solver 12.\n}\n{\nsplit; [|basic_solver].\ndestruct ISTEP0.\nall: rewrite UG.\n1,2: by apply WF.\n1,2,4: unfold add; simpls; rewrite (wft_addrE WF) at 1;      seq_rewrite <- (set_inter_absorb_r                        (depf_preserves_set_lexpr _ (wft_depfE WF) lexpr));      basic_solver.\nall: unfold add, add_rmw; simpls; rewrite (wft_addrE WF) at 1.\n{\nbasic_solver.\n}\nall: seq_rewrite <- (set_inter_absorb_r                           (depf_preserves_set_lexpr _ (wft_depfE WF) lexpr));      basic_solver 10.\n}\n{\nsplit; [|basic_solver].\ndestruct ISTEP0.\nall: rewrite UG.\n1,2: by apply WF.\nall: unfold add, add_rmw; simpls; rewrite (wft_ctrlE WF) at 1;      seq_rewrite <- (set_inter_absorb_r (wft_ectrlE WF));      basic_solver 10.\n}\n{\nsplit; [|basic_solver].\ndestruct ISTEP0.\nall: rewrite UG.\n1,2: by apply WF.\nall: unfold add; simpls; rewrite (wft_rmw_depE WF) at 1.\n4-5: seq_rewrite <- (set_inter_absorb_r                          (depf_preserves_set_expr _ (wft_depfE WF) expr_old)).\nall: basic_solver.\n}\n{\ndestruct ISTEP0.\nall: rewrite UG, UECTRL.\n{\nby apply WF.\n}\n{\nrewrite (wft_ectrlE WF).\nerewrite depf_preserves_set_expr.\n2: by apply WF.\nbasic_solver.\n}\n1-4: etransitivity; [by apply (wft_ectrlE WF)|];      unfold add, acts_set; basic_solver.\nall: etransitivity; [by apply (wft_ectrlE WF)|];      unfold add_rmw, acts_set; basic_solver.\n}\nassert (acts_set (G s) ⊆₁ acts_set (G s')) as EE.\n{\neapply step_preserves_E; eauto.\nred.\neauto.\n}\ndestruct ISTEP0.\nall: rewrite UDEPS; ins.\nall: try unfold RegFun.add, RegFun.find.\nall: try by rewrite (wft_depfE WF).\nall: destruct (Reg.eq_dec r reg).\nall: try by rewrite (wft_depfE WF).\n{\nby rewrite depf_preserves_set_expr; [|by apply WF].\n}\nall: rewrite UG; unfold add, add_rmw, acts_set; simpls; basic_solver.\n"},{"statement":"Lemma wf_thread_state_steps thread s s'\n      (WF : wf_thread_state thread s)\n      (STEP : (step thread)＊ s s') :\n  wf_thread_state thread s'.","proof":"induction STEP.\n2: done.\n{\neapply wf_thread_state_step; eauto.\n}\napply IHSTEP2.\nby apply IHSTEP1.\n"},{"statement":"Lemma steps_preserve_E thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : (step thread)＊ state state') :\n  acts_set (ProgToExecution.G state) ⊆₁\n  acts_set (ProgToExecution.G state').","proof":"intros e EE.\ninduction STEP.\n2: done.\n{\neapply step_preserves_E; eauto.\n}\neapply IHSTEP2.\n{\neapply wf_thread_state_steps; eauto.\n}\neapply IHSTEP1; eauto.\n"},{"statement":"Lemma rmw_in_thread_restricted_rmw thread G'\n      (TEH : thread_restricted_execution G thread G') :\n  rmw G' ⊆ rmw G.","proof":"rewrite (tr_rmw TEH).\nbasic_solver.\n"},{"statement":"Lemma step_preserves_rmw thread state state'\n      (STEP : step thread state state') :\n  rmw (ProgToExecution.G state) ⊆\n  rmw (ProgToExecution.G state').","proof":"red in STEP.\ndesc.\ncdes STEP.\ndestruct ISTEP0.\nall: rewrite UG; auto.\n1,2: done.\n1-4: unfold add; simpls.\nall: unfold add_rmw; simpls.\n"},{"statement":"Lemma steps_preserve_rmw thread state state'\n      (STEP : (step thread)＊ state state') :\n  rmw (ProgToExecution.G state) ⊆\n  rmw (ProgToExecution.G state').","proof":"induction STEP.\n2: done.\n{\neapply step_preserves_rmw; eauto.\n}\netransitivity; eauto.\n"},{"statement":"Lemma step_dont_add_rmw thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : step thread state state') :\n  ⦗ acts_set (ProgToExecution.G state) ⦘ ⨾ rmw (ProgToExecution.G state') ⊆\n  rmw (ProgToExecution.G state).","proof":"red in STEP.\ndesc.\ncdes STEP.\ndestruct ISTEP0.\nall: rewrite UG; auto.\n1,2: basic_solver.\n1-4: unfold add; simpls; basic_solver.\n{\nunfold add_rmw.\nsimpls.\nrewrite seq_union_r.\napply inclusion_union_l; [|basic_solver].\nintros x y HH.\napply seq_eqv_l in HH.\ndestruct HH as [EE HH].\nred in HH.\ndesf.\nexfalso.\nedestruct (acts_rep GPC); eauto.\ndesf.\nlia.\n}\n{\nunfold add_rmw.\nsimpls.\nrewrite seq_union_r.\napply inclusion_union_l; [|basic_solver].\nintros x y HH.\napply seq_eqv_l in HH.\ndestruct HH as [EE HH].\nred in HH.\ndesf.\nexfalso.\nedestruct (acts_rep GPC); eauto.\ndesf.\nlia.\n}\nunfold add_rmw.\nsimpls.\nrewrite seq_union_r.\napply inclusion_union_l; [|basic_solver].\nintros x y HH.\napply seq_eqv_l in HH.\ndestruct HH as [EE HH].\nred in HH.\ndesf.\nexfalso.\nedestruct (acts_rep GPC); eauto.\ndesf.\nlia.\n"},{"statement":"Lemma steps_dont_add_rmw thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : (step thread)＊ state state') :\n  ⦗ acts_set (ProgToExecution.G state) ⦘ ⨾ rmw (ProgToExecution.G state') ⊆\n  rmw (ProgToExecution.G state).","proof":"induction STEP.\n2: basic_solver.\n{\neapply step_dont_add_rmw; eauto.\n}\netransitivity.\n2: by apply IHSTEP1.\nintros a b HH.\napply seq_eqv_l in HH.\ndestruct HH as [EEA HH].\napply seq_eqv_l.\nsplit; auto.\napply IHSTEP2.\n{\neapply wf_thread_state_steps; eauto.\n}\napply seq_eqv_l.\nsplit; auto.\neapply steps_preserve_E; eauto.\n"},{"statement":"Lemma lab_thread_eq_thread_restricted_lab thread e G'\n      (EE : (acts_set G') e)\n      (TEH : thread_restricted_execution G thread G') :\n  lab G e = lab G' e.","proof":"rewrite (tr_lab TEH); auto.\n"},{"statement":"Lemma same_lab_u2v_dom_restricted thread G'\n  (TEH : thread_restricted_execution G thread G') :\n  same_lab_u2v_dom (acts_set G') (lab G) (lab G').","proof":"red.\nins.\nred.\nrewrite (tr_lab TEH); auto.\ndesf.\n"},{"statement":"Lemma step_preserves_lab e state state'\n      (GPC : wf_thread_state (tid e) state)\n      (STEP : step (tid e) state state')\n      (EE : acts_set (ProgToExecution.G state) e) :\n  lab (ProgToExecution.G state') e =\n  lab (ProgToExecution.G state) e.","proof":"red in STEP.\ndesc.\ncdes STEP.\nedestruct (acts_rep GPC) as [ii]; eauto.\ndesc.\ndestruct ISTEP0.\nall: rewrite UG; auto.\n1-4: unfold add; simpls; rewrite updo; auto.\n5-7: unfold add_rmw; simpls; rewrite updo; auto;    [unfold add_rmw; simpls; rewrite updo; auto|].\nall: intros HH; rewrite REP in HH; inv HH; lia.\n"},{"statement":"Lemma steps_preserve_lab e state state'\n      (GPC : wf_thread_state (tid e) state)\n      (STEP : (step (tid e))＊ state state')\n      (EE : acts_set (ProgToExecution.G state) e) :\n  lab (ProgToExecution.G state') e =\n  lab (ProgToExecution.G state) e.","proof":"induction STEP.\n2: done.\n{\napply step_preserves_lab; auto.\n}\nrewrite IHSTEP2.\n{\nrewrite IHSTEP1; auto.\n}\n{\neapply wf_thread_state_steps; eauto.\n}\neapply steps_preserve_E; eauto.\n"},{"statement":"Lemma step_empty_same_E thread state state'\n      (STEP : istep thread nil state state') :\n  acts_set (ProgToExecution.G state') ≡₁\n  acts_set (ProgToExecution.G state).","proof":"cdes STEP.\ninv ISTEP0.\nall: by rewrite UG.\n"},{"statement":"Lemma steps_empty_same_E thread state state'\n      (STEPS : (istep thread nil)＊ state state') :\n  acts_set (ProgToExecution.G state') ≡₁\n  acts_set (ProgToExecution.G state).","proof":"induction STEPS.\n2: done.\n{\neapply step_empty_same_E; eauto.\n}\netransitivity; eauto.\n"},{"statement":"Lemma step_same_E_empty_in thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : step thread state state') :\n  acts_set (ProgToExecution.G state') ⊆₁\n    acts_set (ProgToExecution.G state)\n  <->\n  istep thread nil state state'.","proof":"assert (~ Execution.acts_set (ProgToExecution.G state)            (ThreadEvent thread (eindex state))) as XX.\n{\nintros HH.\napply (acts_rep GPC) in HH.\ndesc.\ninv REP.\nlia.\n}\nred in STEP.\ndesc.\nred in STEP.\ndesc.\nsplit; intros IN.\n2: {\ncdes IN.\ninv ISTEP2; by rewrite UG.\n}\ndestruct ISTEP0.\n{\nred.\nsplits; auto.\neexists.\nsplits; eauto.\neapply assign; eauto.\n}\n{\nred.\nsplits; auto.\neexists.\nsplits; eauto.\neapply if_; eauto.\n}\nall: exfalso; apply XX; apply IN.\n1-4: by rewrite UG; unfold acts_set, add; simpls; left.\nall: by rewrite UG; unfold acts_set, add_rmw; simpls;    left; right.\n"},{"statement":"Lemma step_same_E_empty thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : step thread state state') :\n  acts_set (ProgToExecution.G state') ≡₁\n    acts_set (ProgToExecution.G state)\n  <->\n  istep thread nil state state'.","proof":"etransitivity.\n2: eapply step_same_E_empty_in; eauto.\nsplit; [basic_solver|].\nintros HH.\nsplit; auto.\neapply step_preserves_E; eauto.\n"},{"statement":"Lemma steps_same_E_empty_in thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : (step thread)＊ state state') :\n  acts_set (ProgToExecution.G state') ⊆₁\n    acts_set (ProgToExecution.G state)\n  <->\n  (istep thread nil)＊ state state'.","proof":"assert (istep thread [] ⊆ step thread) as AA.\n{\nunfold step.\nbasic_solver.\n}\nsplit.\n2: {\nintros ST.\ninduction ST as [x y ST| |].\n2: done.\n{\napply step_same_E_empty_in in ST; auto.\n}\nassert (wf_thread_state thread y) as YY.\n{\neapply wf_thread_state_steps; eauto.\neapply clos_refl_trans_mori; eauto.\n}\netransitivity.\n{\napply IHST2; auto.\neapply clos_refl_trans_mori; eauto.\n}\napply IHST1; auto.\neapply clos_refl_trans_mori; eauto.\n}\ninduction STEP; intros.\n2: by apply rt_refl.\n{\napply rt_step.\nby apply step_same_E_empty_in.\n}\nassert (wf_thread_state thread y) as YY.\n{\neapply wf_thread_state_steps; eauto.\n}\nassert (acts_set (ProgToExecution.G y) ⊆₁          acts_set (ProgToExecution.G z)) as XX.\n{\neapply steps_preserve_E; eauto.\n}\neapply rt_trans.\n{\napply IHSTEP1; auto.\nby rewrite XX.\n}\napply IHSTEP2; auto.\netransitivity; eauto.\neapply steps_preserve_E; eauto.\n"},{"statement":"Lemma steps_same_E_empty thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : (step thread)＊ state state') :\n  acts_set (ProgToExecution.G state') ≡₁\n    acts_set (ProgToExecution.G state)\n  <->\n  (istep thread nil)＊ state state'.","proof":"etransitivity.\n2: by eapply steps_same_E_empty_in; eauto.\nsplit; [basic_solver|].\nintros IN.\nsplit; auto.\neapply steps_preserve_E; eauto.\n"},{"statement":"Lemma steps_same_eindex thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : (istep thread nil)＊ state state') :\n  (eindex state') = (eindex state).","proof":"induction STEP.\n2: done.\n{\ncdes H.\ndestruct ISTEP0; desf.\n}\nrewrite IHSTEP2.\n{\nby rewrite IHSTEP1.\n}\neapply wf_thread_state_steps; eauto.\neapply clos_refl_trans_mori; eauto.\nunfold step.\nbasic_solver.\n"},{"statement":"Lemma step_old_restrict thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : (step thread) state state') :\n  let GO := (ProgToExecution.G state) in\n  let GN := (ProgToExecution.G state') in\n  ⟪ ORMW  : (rmw GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (rmw GN) ⨾ ⦗ (acts_set GO) ⦘ ⟫ /\\\n  ⟪ ODATA : (data GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (data GN) ⨾ ⦗ (acts_set GO)⦘ ⟫ /\\\n  ⟪ OADDR : (addr GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (addr GN) ⨾ ⦗ (acts_set GO)⦘ ⟫ /\\\n  ⟪ OCTRL : (ctrl GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (ctrl GN) ⨾ ⦗ (acts_set GO)⦘ ⟫ /\\\n  ⟪ OFAILDEP : (rmw_dep GO) ≡\n                ⦗ (acts_set GO) ⦘ ⨾ (rmw_dep GN) ⨾ ⦗ (acts_set GO)⦘ ⟫.","proof":"red in STEP.\ndesc.\nred in STEP.\ndesc.\nassert (~ acts_set (ProgToExecution.G state) (ThreadEvent thread (eindex state))) as XX.\n{\nintros HH.\napply (acts_rep GPC) in HH.\ndesc.\ninv REP.\nlia.\n}\nassert (~ acts_set (ProgToExecution.G state) (ThreadEvent thread (eindex state + 1))) as YY.\n{\nintros HH.\napply (acts_rep GPC) in HH.\ndesc.\ninv REP.\nlia.\n}\ndestruct ISTEP0; simpls.\nall: rewrite UG.\n1,2: by splits; apply GPC.\nall: unfold add, add_rmw; simpls; splits.\nall: try apply GPC.\nall: try by (rewrite (wft_rmwE GPC) at 1; basic_solver).\nall: try by (rewrite (wft_dataE GPC) at 1; basic_solver).\nall: try by (rewrite (wft_addrE GPC) at 1; basic_solver).\nall: try by (rewrite (wft_ctrlE GPC) at 1; basic_solver).\nall: try by (rewrite (wft_rmw_depE GPC) at 1; basic_solver).\nall: rewrite (wft_ctrlE GPC) at 1; basic_solver 10.\n"},{"statement":"Lemma steps_old_restrict thread state state'\n      (GPC : wf_thread_state thread state)\n      (STEP : (step thread)＊ state state') :\n  let GO := (ProgToExecution.G state) in\n  let GN := (ProgToExecution.G state') in\n  ⟪ ORMW  : (rmw GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (rmw GN) ⨾ ⦗ (acts_set GO) ⦘ ⟫ /\\\n  ⟪ ODATA : (data GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (data GN) ⨾ ⦗ (acts_set GO)⦘ ⟫ /\\\n  ⟪ OADDR : (addr GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (addr GN) ⨾ ⦗ (acts_set GO)⦘ ⟫ /\\\n  ⟪ OCTRL : (ctrl GO) ≡\n             ⦗ (acts_set GO) ⦘ ⨾ (ctrl GN) ⨾ ⦗ (acts_set GO)⦘ ⟫ /\\\n  ⟪ OFAILDEP : (rmw_dep GO) ≡\n                ⦗ (acts_set GO) ⦘ ⨾ (rmw_dep GN) ⨾ ⦗ (acts_set GO)⦘ ⟫.","proof":"induction STEP.\n2: {\nsimpls.\nsplits; apply GPC.\n}\n{\neapply step_old_restrict; eauto.\n}\nassert (wf_thread_state thread y) as GPC'.\n{\neapply wf_thread_state_steps; eauto.\n}\nsimpls.\ndesc.\nassert (acts_set (ProgToExecution.G x) ⊆₁ acts_set (ProgToExecution.G y)) as XX.\n{\neapply steps_preserve_E; eauto.\n}\nspecialize (IHSTEP1 GPC).\nspecialize (IHSTEP2 GPC').\ndesc.\nsplits.\n{\nrewrite ORMW0, ORMW.\ngeneralize XX.\nbasic_solver 10.\n}\n{\nrewrite ODATA0, ODATA.\ngeneralize XX.\nbasic_solver 10.\n}\n{\nrewrite OADDR0, OADDR.\ngeneralize XX.\nbasic_solver 10.\n}\n{\nrewrite OCTRL0, OCTRL.\ngeneralize XX.\nbasic_solver 10.\n}\nrewrite OFAILDEP0, OFAILDEP.\ngeneralize XX.\nbasic_solver 10.\n"},{"statement":"Lemma step_middle_set thread state state' C\n      (OIN : (acts_set (G state)) ⊆₁ C)\n      (INN : C ⊆₁ (acts_set (G state')))\n      (STEP : (step thread) state state')\n      (RMWC : forall r w (RMW : (rmw (G state')) r w),\n                       C r <-> C w) :\n        C ≡₁ (acts_set (G state)) \\/\n        C ≡₁ (acts_set (G state')).","proof":"destruct (classic (C ⊆₁ (acts_set (G state)))) as [INO|NINO].\n{\nleft.\nby split.\n}\nright.\nsplit; auto.\nred in STEP.\ndesc.\nred in STEP.\ndesc.\nunfold set_subset in NINO.\napply not_all_ex_not in NINO.\ndesc.\nassert (G'1: (exists new_lbl add_dep1 add_ldep add_ctrl add_dep2,                   G state' = add (G state) thread (eindex state)                                  new_lbl add_dep1 add_ldep add_ctrl add_dep2)               -> acts_set (G state') ⊆₁ C).\n{\nins.\ndesf.\nrewrite H in *; auto.\nunfold add, acts_set in *; simpls.\nintros y [AA|BB]; [|by apply OIN].\ndestruct (classic (C y)) as [|NC]; auto.\nexfalso; apply NINO; ins.\nset (YY := H0).\napply INN in YY.\nred in YY.\ndesf.\n}\nassert (G'2: (exists new_lbl1 new_lbl2 add_dep1 add_ldep add_ctrl add_dep2,                   G state' = add_rmw (G state) thread (eindex state)                                      new_lbl1 new_lbl2                                      add_dep1 add_ldep add_ctrl add_dep2)               -> acts_set (G state') ⊆₁ C).\n{\nins.\ndesf.\nrewrite H in *; auto.\nunfold add_rmw, acts_set in *; simpls.\ndestruct (classic (C (ThreadEvent thread (eindex state)))) as [ZZ|NC].\n2: {\nexfalso.\napply NINO.\nins.\nset (YY := H0); apply INN in YY.\nunfolder in YY; desf.\nexfalso.\napply NC.\neapply RMWC; [|by apply H0].\nby left.\n}\nintros x [[AA|BB]|CC]; [ | | by apply OIN]; desf.\neapply RMWC with (r:=ThreadEvent thread (eindex state)); auto.\nby left.\n}\ndestruct ISTEP0.\nall: rewrite UG in *; auto.\n1-4: eapply G'1; repeat eexists.\nall: eapply G'2; repeat eexists.\n"},{"statement":"Lemma steps_middle_set thread state state' C cindex\n      (GPC : wf_thread_state thread state)\n      (OIN : (acts_set (G state)) ⊆₁ C)\n      (INN : C ⊆₁ (acts_set (G state')))\n      (STEP : (step thread)＊ state state')\n      (CCLOS : forall index (LT : index < cindex), \n          C (ThreadEvent thread index))\n      (CREP :\n         forall e (INC : C e),\n           exists index,\n             ⟪ EREP : e = ThreadEvent thread index ⟫ /\\\n             ⟪ IIND : index < cindex ⟫)\n      (RMWC : forall r w (RMW : (rmw (G state')) r w),\n                       C r <-> C w) :\n  exists state'',\n    ⟪ STEP1 : (step thread)＊ state state'' ⟫ /\\\n    ⟪ STEP2 : (step thread)＊ state'' state' ⟫ /\\\n    ⟪ CACTS : (acts_set (G state'')) ≡₁ C ⟫.","proof":"apply clos_rt_rt1n in STEP.\ninduction STEP.\n{\nexists x.\nsplits.\n1,2: apply rt_refl.\nby split.\n}\nassert (wf_thread_state thread y) as GPC'.\n{\neapply wf_thread_state_step; eauto.\n}\ndestruct (Compare_dec.le_ge_dec cindex (eindex y)) as [LL|LL].\n{\nassert (C ⊆₁ acts_set (G y)) as UU.\n{\nintros a HH.\napply CREP in HH.\ndesc.\nsubst.\napply (acts_clos GPC').\nlia.\n}\nedestruct step_middle_set with (state:=x) (state':=y) as [YY|YY]; eauto.\n{\nins.\napply RMWC.\neapply steps_preserve_rmw; eauto.\n}\n{\nexists x.\nsplits.\n{\napply rt_refl.\n}\n{\napply rt_begin.\nright.\neexists; eauto.\n}\nby rewrite YY.\n}\nexists y.\nsplits.\n{\nby apply rt_step.\n}\n{\nby apply clos_rt1n_rt.\n}\nby rewrite YY.\n}\nassert (acts_set (G y) ⊆₁ C) as UU.\n{\nintros a HH.\napply (acts_rep GPC') in HH.\ndesc.\nsubst.\napply CCLOS.\nlia.\n}\nspecialize (IHSTEP GPC' UU INN RMWC).\ndesc.\nexists state''.\nsplits; auto.\napply rt_begin.\nright.\neexists; eauto.\n"},{"statement":"Lemma tid_initi G prog \n      (GPROG : program_execution prog G)\n      (PROG_NINIT : ~ (IdentMap.In tid_init prog)) : \n  (acts_set G) ∩₁ Tid_ tid_init ⊆₁ is_init.","proof":"red.\nunfolder.\nintros e [EE TIDe].\nunfold tid, is_init in *.\ndestruct e eqn:Heq; auto.\ndestruct GPROG as [HH _].\nrewrite <- Heq in EE.\nspecialize (HH e EE).\ndesf.\n"},{"statement":"Lemma istep_eindex_shift thread st st' lbl\n      (STEP : ProgToExecution.istep thread lbl st st') :\n  eindex st' = eindex st + length lbl.","proof":"cdes STEP.\ninv ISTEP0.\nall: simpls; lia.\n"},{"statement":"Lemma eindex_step_mon thread st st'\n      (STEP : ProgToExecution.step thread st st') :\n  eindex st <= eindex st'.","proof":"cdes STEP.\nrewrite (istep_eindex_shift STEP0).\nlia.\n"},{"statement":"Lemma eindex_steps_mon thread st st'\n      (STEPS : (ProgToExecution.step thread)＊ st st') :\n  eindex st <= eindex st'.","proof":"apply clos_rt_rt1n in STEPS.\ninduction STEPS; auto.\napply eindex_step_mon in H.\nlia.\n"},{"statement":"Lemma eindex_not_in_rmw thread st st'\n      (TNIL : thread <> tid_init)\n      (WTS : wf_thread_state thread st)\n      (STEPS : (ProgToExecution.step thread)＊ st st') :\n  ~ (codom_rel (Execution.rmw (ProgToExecution.G st'))\n               (ThreadEvent thread (eindex st))).","proof":"intros [y RMW].\napply clos_rt_rtn1 in STEPS.\ninduction STEPS.\n{\neapply wft_rmwE in RMW; eauto.\ndestruct_seq RMW as [AA BB].\neapply acts_rep in BB; eauto.\ndesf.\nlia.\n}\napply IHSTEPS.\ndestruct H as [ll HH].\ncdes HH.\ninv ISTEP0; simpls.\n1,2: by rewrite <- UG.\nall: rewrite UG in RMW; unfold add in RMW; simpls.\nall: destruct RMW as [RMW|RMW]; simpls.\nall: red in RMW; desf.\nall: apply clos_rtn1_rt in STEPS.\nall: apply eindex_steps_mon in STEPS.\nall: lia.\n"},{"statement":"Lemma step_threads_set s1 s2 t\n      (STEP: step t s1 s2):\n  threads_set (ProgToExecution.G s2) ⊆₁ threads_set (ProgToExecution.G s1) ∪₁ eq t /\\ \n  threads_set (ProgToExecution.G s1) ⊆₁ threads_set (ProgToExecution.G s2).","proof":"inv STEP.\ninv H.\nred in H0, H1.\ndesc.\ninv H2.\nall: rewrite UG; try by vauto.\nall: simpl; basic_solver.\n"},{"statement":"Lemma steps_threads_set s1 s2 t\n      (STEP: (step t)^* s1 s2):\n  threads_set (ProgToExecution.G s2) ⊆₁ threads_set (ProgToExecution.G s1) ∪₁ eq t /\\\n  threads_set (ProgToExecution.G s1) ⊆₁ threads_set (ProgToExecution.G s2).","proof":"induction STEP.\n{\nby apply step_threads_set in H.\n}\n{\nbasic_solver.\n}\ndesc.\nsplit.\n{\nrewrite IHSTEP2, IHSTEP1.\nbasic_solver.\n}\nrewrite IHSTEP3, IHSTEP0.\nbasic_solver.\n"}]