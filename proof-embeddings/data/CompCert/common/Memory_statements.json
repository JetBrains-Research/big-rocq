{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Memory.v","fileSamples":[{"statement":"(cont1 cont2 : PMap.t (ZMap.t memval)) (acc1 acc2 : PMap.t (Z -> perm_kind -> option permission)) (next1 next2 : block) (a1 : forall (b : positive) (ofs : Z),\nperm_order'' (acc1 # b ofs Max) (acc1 # b ofs Cur)) (a2 : forall (b : positive) (ofs : Z),\nperm_order'' (acc2 # b ofs Max) (acc2 # b ofs Cur)) (b1 : forall (b : positive) (ofs : Z) (k : perm_kind),\n~ Plt b next1 -> acc1 # b ofs k = None) (b2 : forall (b : positive) (ofs : Z) (k : perm_kind),\n~ Plt b next2 -> acc2 # b ofs k = None) (c1 : forall b : positive, fst cont1 # b = Undef) (c2 : forall b : positive, fst cont2 # b = Undef) (H : cont1 = cont2) (H0 : acc1 = acc2) (H1 : next1 = next2) : {|\n  mem_contents := cont1;\n  mem_access := acc1;\n  nextblock := next1;\n  access_max := a1;\n  nextblock_noaccess := b1;\n  contents_default := c1\n|} =\n{|\n  mem_contents := cont2;\n  mem_access := acc2;\n  nextblock := next2;\n  access_max := a2;\n  nextblock_noaccess := b2;\n  contents_default := c2\n|}.","proofString":"subst.\nf_equal; apply proof_irr."},{"statement":"(cont2 : PMap.t (ZMap.t memval)) (acc2 : PMap.t (Z -> perm_kind -> option permission)) (next2 : block) (a1 a2 : forall (b : positive) (ofs : Z),\nperm_order'' (acc2 # b ofs Max) (acc2 # b ofs Cur)) (b1 b2 : forall (b : positive) (ofs : Z) (k : perm_kind),\n~ Plt b next2 -> acc2 # b ofs k = None) (c1 c2 : forall b : positive, fst cont2 # b = Undef) : {|\n  mem_contents := cont2;\n  mem_access := acc2;\n  nextblock := next2;\n  access_max := a1;\n  nextblock_noaccess := b1;\n  contents_default := c1\n|} =\n{|\n  mem_contents := cont2;\n  mem_access := acc2;\n  nextblock := next2;\n  access_max := a2;\n  nextblock_noaccess := b2;\n  contents_default := c2\n|}.","proofString":"f_equal; apply proof_irr."},{"statement":"(m : mem) (b b' : block) (H : valid_block m b) (H0 : ~ valid_block m b') (H1 : b = b') : False.","proofString":"subst b'.\ncontradiction."},{"statement":"(m : mem) (b : block) (H : valid_block m b) (H0 : ~ valid_block m b) : False.","proofString":"contradiction."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p1 p2 : permission) (H : match (mem_access m) # b ofs k with\n| Some p' => perm_order p' p1\n| None => False\nend) (H0 : perm_order p1 p2) : match (mem_access m) # b ofs k with\n| Some p' => perm_order p' p2\n| None => False\nend.","proofString":"destruct (m.(mem_access)#b ofs k); auto.\neapply perm_order_trans; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p1 p2 p : permission) (H : perm_order p p1) (H0 : perm_order p1 p2) : perm_order p p2.","proofString":"eapply perm_order_trans; eauto."},{"statement":"forall (po1 po2 : option permission) (p : permission),\nperm_order' po2 p -> perm_order'' po1 po2 -> perm_order' po1 p.","proofString":"unfold perm_order', perm_order''.\nintros.\ndestruct po2; try contradiction.\ndestruct po1; try contradiction.\neapply perm_order_trans; eauto."},{"statement":"forall (po1 po2 : option permission) (p : permission),\nmatch po2 with\n| Some p' => perm_order p' p\n| None => False\nend ->\nmatch po1 with\n| Some p1 => match po2 with\n             | Some p2 => perm_order p1 p2\n             | None => True\n             end\n| None => match po2 with\n          | Some _ => False\n          | None => True\n          end\nend -> match po1 with\n       | Some p' => perm_order p' p\n       | None => False\n       end.","proofString":"intros.\ndestruct po2; try contradiction.\ndestruct po1; try contradiction.\neapply perm_order_trans; eauto."},{"statement":"(po1 po2 : option permission) (p : permission) (H : match po2 with\n| Some p' => perm_order p' p\n| None => False\nend) (H0 : match po1 with\n| Some p1 => match po2 with\n             | Some p2 => perm_order p1 p2\n             | None => True\n             end\n| None => match po2 with\n          | Some _ => False\n          | None => True\n          end\nend) : match po1 with\n| Some p' => perm_order p' p\n| None => False\nend.","proofString":"destruct po2; try contradiction.\ndestruct po1; try contradiction.\neapply perm_order_trans; eauto."},{"statement":"(po1 : option permission) (p0 p : permission) (H : perm_order p0 p) (H0 : match po1 with\n| Some p1 => perm_order p1 p0\n| None => False\nend) : match po1 with\n| Some p' => perm_order p' p\n| None => False\nend.","proofString":"destruct po1; try contradiction.\neapply perm_order_trans; eauto."},{"statement":"(p1 p0 p : permission) (H : perm_order p0 p) (H0 : perm_order p1 p0) : perm_order p1 p.","proofString":"eapply perm_order_trans; eauto."},{"statement":"(H : forall (po1 po2 : option permission) (p : permission),\nperm_order' po2 p -> perm_order'' po1 po2 -> perm_order' po1 p) : forall (m : mem) (b : block) (ofs : Z) (p : permission),\nperm m b ofs Cur p -> perm m b ofs Max p.","proofString":"unfold perm; intros.\ngeneralize (access_max m b ofs).\neauto."},{"statement":"(H : forall (po1 po2 : option permission) (p0 : permission),\nperm_order' po2 p0 -> perm_order'' po1 po2 -> perm_order' po1 p0) (m : mem) (b : block) (ofs : Z) (p : permission) (H0 : perm_order' ((mem_access m) # b ofs Cur) p) : perm_order' ((mem_access m) # b ofs Max) p.","proofString":"generalize (access_max m b ofs).\neauto."},{"statement":"(H : forall (po1 po2 : option permission) (p0 : permission),\nperm_order' po2 p0 -> perm_order'' po1 po2 -> perm_order' po1 p0) (m : mem) (b : block) (ofs : Z) (p : permission) (H0 : perm_order' ((mem_access m) # b ofs Cur) p) : perm_order'' ((mem_access m) # b ofs Max) ((mem_access m) # b ofs Cur) ->\nperm_order' ((mem_access m) # b ofs Max) p.","proofString":"eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m b ofs Cur p) : perm m b ofs k p.","proofString":"destruct k; auto.\napply perm_cur_max.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (p : permission) (H : perm m b ofs Cur p) : perm m b ofs Max p.","proofString":"apply perm_cur_max.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (p : permission) (H : perm m b ofs Cur p) : perm m b ofs Cur p.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m b ofs k p) : perm m b ofs Max p.","proofString":"destruct k; auto.\napply perm_cur_max.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (p : permission) (H : perm m b ofs Cur p) : perm m b ofs Max p.","proofString":"apply perm_cur_max.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (p : permission) (H : perm m b ofs Cur p) : perm m b ofs Cur p.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m) # b ofs k) p) : valid_block m b.","proofString":"destruct (plt b m.(nextblock)).\nauto.\nassert (m.(mem_access)#b ofs k = None).\neapply nextblock_noaccess; eauto.\nrewrite H0 in H.\ncontradiction."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m) # b ofs k) p) (p0 : Plt b (nextblock m)) : valid_block m b.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m) # b ofs k) p) (n : ~ Plt b (nextblock m)) : valid_block m b.","proofString":"assert (m.(mem_access)#b ofs k = None).\neapply nextblock_noaccess; eauto.\nrewrite H0 in H.\ncontradiction."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m) # b ofs k) p) (n : ~ Plt b (nextblock m)) : (mem_access m) # b ofs k = None.","proofString":"eapply nextblock_noaccess; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m) # b ofs k) p) (n : ~ Plt b (nextblock m)) (H0 : (mem_access m) # b ofs k = None) : valid_block m b.","proofString":"rewrite H0 in H.\ncontradiction."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' None p) (n : ~ Plt b (nextblock m)) (H0 : (mem_access m) # b ofs k = None) : valid_block m b.","proofString":"contradiction."},{"statement":"(p1 p2 : permission) : {perm_order p1 p2} + {~ perm_order p1 p2}.","proofString":"destruct p1; destruct p2; (left; constructor) || (right; intro PO; inversion PO)."},{"statement":"(op : option permission) (p : permission) : {perm_order' op p} + {~ perm_order' op p}.","proofString":"destruct op; unfold perm_order'.\napply perm_order_dec.\nright; tauto."},{"statement":"(p0 p : permission) : {perm_order p0 p} + {~ perm_order p0 p}.","proofString":"apply perm_order_dec."},{"statement":"(p : permission) : {False} + {~ False}.","proofString":"right; tauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) : {perm_order' ((mem_access m) # b ofs k) p} +\n{~ perm_order' ((mem_access m) # b ofs k) p}.","proofString":"apply perm_order'_dec."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"induction lo using (well_founded_induction_type (Zwf_up_well_founded hi)).\ndestruct (zlt lo hi).\ndestruct (perm_dec m b lo k p).\ndestruct (H (lo + 1)).\nred.\nlia.\nleft; red; intros.\ndestruct (zeq lo ofs).\ncongruence.\napply r.\nlia.\nright; red; intros.\nelim n.\nred; intros; apply H0; lia.\nright; red; intros.\nelim n.\napply H0.\nlia.\nleft; red; intros.\nextlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"destruct (zlt lo hi).\ndestruct (perm_dec m b lo k p).\ndestruct (H (lo + 1)).\nred.\nlia.\nleft; red; intros.\ndestruct (zeq lo ofs).\ncongruence.\napply r.\nlia.\nright; red; intros.\nelim n.\nred; intros; apply H0; lia.\nright; red; intros.\nelim n.\napply H0.\nlia.\nleft; red; intros.\nextlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"destruct (perm_dec m b lo k p).\ndestruct (H (lo + 1)).\nred.\nlia.\nleft; red; intros.\ndestruct (zeq lo ofs).\ncongruence.\napply r.\nlia.\nright; red; intros.\nelim n.\nred; intros; apply H0; lia.\nright; red; intros.\nelim n.\napply H0.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"destruct (H (lo + 1)).\nred.\nlia.\nleft; red; intros.\ndestruct (zeq lo ofs).\ncongruence.\napply r.\nlia.\nright; red; intros.\nelim n.\nred; intros; apply H0; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) : Zwf_up hi (lo + 1) lo.","proofString":"red.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) : lo < lo + 1 <= hi.","proofString":"lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (r : range_perm m b (lo + 1) hi k p) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"left; red; intros.\ndestruct (zeq lo ofs).\ncongruence.\napply r.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (r : range_perm m b (lo + 1) hi k p) (ofs : Z) (H0 : lo <= ofs < hi) : perm m b ofs k p.","proofString":"destruct (zeq lo ofs).\ncongruence.\napply r.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (r : range_perm m b (lo + 1) hi k p) (ofs : Z) (H0 : lo <= ofs < hi) (e : lo = ofs) : perm m b ofs k p.","proofString":"congruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (r : range_perm m b (lo + 1) hi k p) (ofs : Z) (H0 : lo <= ofs < hi) (n : lo <> ofs) : perm m b ofs k p.","proofString":"apply r.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (r : range_perm m b (lo + 1) hi k p) (ofs : Z) (H0 : lo <= ofs < hi) (n : lo <> ofs) : lo + 1 <= ofs < hi.","proofString":"lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (n : ~ range_perm m b (lo + 1) hi k p) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"right; red; intros.\nelim n.\nred; intros; apply H0; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (n : ~ range_perm m b (lo + 1) hi k p) (H0 : range_perm m b lo hi k p) : False.","proofString":"elim n.\nred; intros; apply H0; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (p0 : perm m b lo k p) (n : ~ range_perm m b (lo + 1) hi k p) (H0 : range_perm m b lo hi k p) : range_perm m b (lo + 1) hi k p.","proofString":"red; intros; apply H0; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (n : ~ perm m b lo k p) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"right; red; intros.\nelim n.\napply H0.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (n : ~ perm m b lo k p) (H0 : range_perm m b lo hi k p) : False.","proofString":"elim n.\napply H0.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (n : ~ perm m b lo k p) (H0 : range_perm m b lo hi k p) : perm m b lo k p.","proofString":"apply H0.\nlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (l : lo < hi) (n : ~ perm m b lo k p) (H0 : range_perm m b lo hi k p) : lo <= lo < hi.","proofString":"lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (g : lo >= hi) : {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.","proofString":"left; red; intros.\nextlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (k : perm_kind) (p : permission) (H : forall y : Z,\nZwf_up hi y lo -> {range_perm m b y hi k p} + {~ range_perm m b y hi k p}) (g : lo >= hi) (ofs : Z) (H0 : lo <= ofs < hi) : perm m b ofs k p.","proofString":"extlia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p1 p2 : permission) (H : valid_access m chunk b ofs p1) (H0 : perm_order p1 p2) : valid_access m chunk b ofs p2.","proofString":"inv H.\nconstructor; eauto with mem."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p1 p2 : permission) (H0 : perm_order p1 p2) (H1 : range_perm m b ofs (ofs + size_chunk chunk) Cur p1) (H2 : (align_chunk chunk | ofs)) : valid_access m chunk b ofs p2.","proofString":"constructor; eauto with mem."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : valid_access m chunk b ofs Freeable) : valid_access m chunk b ofs p.","proofString":"eapply valid_access_implies; eauto.\nconstructor."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : valid_access m chunk b ofs Freeable) : perm_order Freeable p.","proofString":"constructor."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : valid_access m chunk b ofs Nonempty) : valid_block m b.","proofString":"destruct H.\nassert (perm m b ofs Cur Nonempty).\napply H.\ngeneralize (size_chunk_pos chunk).\nlia.\neauto with mem."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur Nonempty) (H0 : (align_chunk chunk | ofs)) : valid_block m b.","proofString":"assert (perm m b ofs Cur Nonempty).\napply H.\ngeneralize (size_chunk_pos chunk).\nlia.\neauto with mem."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur Nonempty) (H0 : (align_chunk chunk | ofs)) : perm m b ofs Cur Nonempty.","proofString":"apply H.\ngeneralize (size_chunk_pos chunk).\nlia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur Nonempty) (H0 : (align_chunk chunk | ofs)) : ofs <= ofs < ofs + size_chunk chunk.","proofString":"generalize (size_chunk_pos chunk).\nlia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur Nonempty) (H0 : (align_chunk chunk | ofs)) : size_chunk chunk > 0 -> ofs <= ofs < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur Nonempty) (H0 : (align_chunk chunk | ofs)) (H1 : perm m b ofs Cur Nonempty) : valid_block m b.","proofString":"eauto with mem."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : valid_access m chunk b ofs p) : perm m b ofs k p.","proofString":"destruct H.\napply perm_cur.\napply H.\ngeneralize (size_chunk_pos chunk).\nlia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) : perm m b ofs k p.","proofString":"apply perm_cur.\napply H.\ngeneralize (size_chunk_pos chunk).\nlia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) : perm m b ofs Cur p.","proofString":"apply H.\ngeneralize (size_chunk_pos chunk).\nlia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) : ofs <= ofs < ofs + size_chunk chunk.","proofString":"generalize (size_chunk_pos chunk).\nlia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : range_perm m b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) : size_chunk chunk > 0 -> ofs <= ofs < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(m : mem) (chunk1 chunk2 : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : size_chunk chunk1 = size_chunk chunk2) (H0 : align_chunk chunk2 <= align_chunk chunk1) (H1 : valid_access m chunk1 b ofs p) : valid_access m chunk2 b ofs p.","proofString":"inv H1.\nrewrite H in H2.\nconstructor; auto.\neapply Z.divide_trans; eauto.\neapply align_le_divides; eauto."},{"statement":"(m : mem) (chunk1 chunk2 : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : size_chunk chunk1 = size_chunk chunk2) (H0 : align_chunk chunk2 <= align_chunk chunk1) (H2 : range_perm m b ofs (ofs + size_chunk chunk1) Cur p) (H3 : (align_chunk chunk1 | ofs)) : valid_access m chunk2 b ofs p.","proofString":"rewrite H in H2.\nconstructor; auto.\neapply Z.divide_trans; eauto.\neapply align_le_divides; eauto."},{"statement":"(m : mem) (chunk1 chunk2 : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : size_chunk chunk1 = size_chunk chunk2) (H0 : align_chunk chunk2 <= align_chunk chunk1) (H2 : range_perm m b ofs (ofs + size_chunk chunk2) Cur p) (H3 : (align_chunk chunk1 | ofs)) : valid_access m chunk2 b ofs p.","proofString":"constructor; auto.\neapply Z.divide_trans; eauto.\neapply align_le_divides; eauto."},{"statement":"(m : mem) (chunk1 chunk2 : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : size_chunk chunk1 = size_chunk chunk2) (H0 : align_chunk chunk2 <= align_chunk chunk1) (H2 : range_perm m b ofs (ofs + size_chunk chunk2) Cur p) (H3 : (align_chunk chunk1 | ofs)) : (align_chunk chunk2 | ofs).","proofString":"eapply Z.divide_trans; eauto.\neapply align_le_divides; eauto."},{"statement":"(m : mem) (chunk1 chunk2 : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : size_chunk chunk1 = size_chunk chunk2) (H0 : align_chunk chunk2 <= align_chunk chunk1) (H2 : range_perm m b ofs (ofs + size_chunk chunk2) Cur p) (H3 : (align_chunk chunk1 | ofs)) : (align_chunk chunk2 | align_chunk chunk1).","proofString":"eapply align_le_divides; eauto."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) : {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.","proofString":"destruct (range_perm_dec m b ofs (ofs + size_chunk chunk) Cur p).\ndestruct (Zdivide_dec (align_chunk chunk) ofs).\nleft; constructor; auto.\nright; red; intro V; inv V; contradiction.\nright; red; intro V; inv V; contradiction."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (r : range_perm m b ofs (ofs + size_chunk chunk) Cur p) : {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.","proofString":"destruct (Zdivide_dec (align_chunk chunk) ofs).\nleft; constructor; auto.\nright; red; intro V; inv V; contradiction."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (r : range_perm m b ofs (ofs + size_chunk chunk) Cur p) (d : (align_chunk chunk | ofs)) : {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.","proofString":"left; constructor; auto."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (r : range_perm m b ofs (ofs + size_chunk chunk) Cur p) (n : ~ (align_chunk chunk | ofs)) : {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.","proofString":"right; red; intro V; inv V; contradiction."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (n : ~ range_perm m b ofs (ofs + size_chunk chunk) Cur p) : {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.","proofString":"right; red; intro V; inv V; contradiction."},{"statement":"(m : mem) (b : block) (ofs : Z) : valid_pointer m b ofs = true <-> perm m b ofs Cur Nonempty.","proofString":"unfold valid_pointer.\ndestruct (perm_dec m b ofs Cur Nonempty); simpl;  intuition congruence."},{"statement":"(m : mem) (b : block) (ofs : Z) : valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.","proofString":"rewrite valid_pointer_nonempty_perm.\nsplit; intros.\nsplit.\nsimpl; red; intros.\nreplace ofs0 with ofs by lia.\nauto.\nsimpl.\napply Z.divide_1_l.\ndestruct H.\napply H.\nsimpl.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) : perm m b ofs Cur Nonempty <-> valid_access m Mint8unsigned b ofs Nonempty.","proofString":"split; intros.\nsplit.\nsimpl; red; intros.\nreplace ofs0 with ofs by lia.\nauto.\nsimpl.\napply Z.divide_1_l.\ndestruct H.\napply H.\nsimpl.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : perm m b ofs Cur Nonempty) : valid_access m Mint8unsigned b ofs Nonempty.","proofString":"split.\nsimpl; red; intros.\nreplace ofs0 with ofs by lia.\nauto.\nsimpl.\napply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : perm m b ofs Cur Nonempty) : range_perm m b ofs (ofs + size_chunk Mint8unsigned) Cur Nonempty.","proofString":"simpl; red; intros.\nreplace ofs0 with ofs by lia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : perm m b ofs Cur Nonempty) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + 1) : perm m b ofs0 Cur Nonempty.","proofString":"replace ofs0 with ofs by lia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : perm m b ofs Cur Nonempty) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + 1) : perm m b ofs Cur Nonempty.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : perm m b ofs Cur Nonempty) : (align_chunk Mint8unsigned | ofs).","proofString":"simpl.\napply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : perm m b ofs Cur Nonempty) : (1 | ofs).","proofString":"apply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : valid_access m Mint8unsigned b ofs Nonempty) : perm m b ofs Cur Nonempty.","proofString":"destruct H.\napply H.\nsimpl.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk Mint8unsigned) Cur Nonempty) (H0 : (align_chunk Mint8unsigned | ofs)) : perm m b ofs Cur Nonempty.","proofString":"apply H.\nsimpl.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk Mint8unsigned) Cur Nonempty) (H0 : (align_chunk Mint8unsigned | ofs)) : ofs <= ofs < ofs + size_chunk Mint8unsigned.","proofString":"simpl.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : range_perm m b ofs (ofs + size_chunk Mint8unsigned) Cur Nonempty) (H0 : (align_chunk Mint8unsigned | ofs)) : ofs <= ofs < ofs + 1.","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) : weak_valid_pointer m b ofs = true <->\nvalid_pointer m b ofs = true \\/ valid_pointer m b (ofs - 1) = true.","proofString":"unfold weak_valid_pointer.\nnow rewrite orb_true_iff."},{"statement":"(m : mem) (b : block) (ofs : Z) : valid_pointer m b ofs || valid_pointer m b (ofs - 1) = true <->\nvalid_pointer m b ofs = true \\/ valid_pointer m b (ofs - 1) = true.","proofString":"now rewrite orb_true_iff."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : valid_pointer m b ofs = true) : weak_valid_pointer m b ofs = true.","proofString":"apply weak_valid_pointer_spec.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (H : valid_pointer m b ofs = true) : valid_pointer m b ofs = true \\/ valid_pointer m b (ofs - 1) = true.","proofString":"auto."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.of_nat (Datatypes.length (a :: vl)) -> r <> q) : ZMap.get q (setN vl (p + 1) (ZMap.set p a c)) = ZMap.get q c.","proofString":"simpl length in H.\nrewrite Nat2Z.inj_succ in H.\ntransitivity (ZMap.get q (ZMap.set p a c)).\napply IHvl.\nintros.\napply H.\nlia.\napply ZMap.gso.\napply not_eq_sym.\napply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.of_nat (S (Datatypes.length vl)) -> r <> q) : ZMap.get q (setN vl (p + 1) (ZMap.set p a c)) = ZMap.get q c.","proofString":"rewrite Nat2Z.inj_succ in H.\ntransitivity (ZMap.get q (ZMap.set p a c)).\napply IHvl.\nintros.\napply H.\nlia.\napply ZMap.gso.\napply not_eq_sym.\napply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r <> q) : ZMap.get q (setN vl (p + 1) (ZMap.set p a c)) = ZMap.get q c.","proofString":"transitivity (ZMap.get q (ZMap.set p a c)).\napply IHvl.\nintros.\napply H.\nlia.\napply ZMap.gso.\napply not_eq_sym.\napply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r <> q) : ZMap.get q (setN vl (p + 1) (ZMap.set p a c)) = ZMap.get q (ZMap.set p a c).","proofString":"apply IHvl.\nintros.\napply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r <> q) : forall r : Z, p + 1 <= r < p + 1 + Z.of_nat (Datatypes.length vl) -> r <> q.","proofString":"intros.\napply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r0 : Z, p0 <= r0 < p0 + Z.of_nat (Datatypes.length vl) -> r0 <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r0 : Z,\np <= r0 < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r0 <> q) (r : Z) (H0 : p + 1 <= r < p + 1 + Z.of_nat (Datatypes.length vl)) : r <> q.","proofString":"apply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r0 : Z, p0 <= r0 < p0 + Z.of_nat (Datatypes.length vl) -> r0 <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r0 : Z,\np <= r0 < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r0 <> q) (r : Z) (H0 : p + 1 <= r < p + 1 + Z.of_nat (Datatypes.length vl)) : p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)).","proofString":"lia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r <> q) : ZMap.get q (ZMap.set p a c) = ZMap.get q c.","proofString":"apply ZMap.gso.\napply not_eq_sym.\napply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r <> q) : q <> p.","proofString":"apply not_eq_sym.\napply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r <> q) : p <> q.","proofString":"apply H.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (c0 : ZMap.t memval) (p0 q0 : Z),\n(forall r : Z, p0 <= r < p0 + Z.of_nat (Datatypes.length vl) -> r <> q0) ->\nZMap.get q0 (setN vl p0 c0) = ZMap.get q0 c0) (c : ZMap.t memval) (p q : Z) (H : forall r : Z, p <= r < p + Z.succ (Z.of_nat (Datatypes.length vl)) -> r <> q) : p <= p < p + Z.succ (Z.of_nat (Datatypes.length vl)).","proofString":"lia."},{"statement":"(vl : list memval) (c : ZMap.t memval) (p q : Z) (H : q < p \\/ q >= p + Z.of_nat (Datatypes.length vl)) : ZMap.get q (setN vl p c) = ZMap.get q c.","proofString":"apply setN_other.\nintros.\nlia."},{"statement":"(vl : list memval) (c : ZMap.t memval) (p q : Z) (H : q < p \\/ q >= p + Z.of_nat (Datatypes.length vl)) : forall r : Z, p <= r < p + Z.of_nat (Datatypes.length vl) -> r <> q.","proofString":"intros.\nlia."},{"statement":"(vl : list memval) (c : ZMap.t memval) (p q : Z) (H : q < p \\/ q >= p + Z.of_nat (Datatypes.length vl)) (r : Z) (H0 : p <= r < p + Z.of_nat (Datatypes.length vl)) : r <> q.","proofString":"lia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 : Z) (c0 : ZMap.t memval),\ngetN (Datatypes.length vl) p0 (setN vl p0 c0) = vl) (p : Z) (c : ZMap.t memval) : ZMap.get p (setN vl (p + 1) (ZMap.set p a c))\n:: getN (Datatypes.length vl) (p + 1) (setN vl (p + 1) (ZMap.set p a c)) =\na :: vl.","proofString":"decEq.\nrewrite setN_outside.\napply ZMap.gss.\nlia.\napply IHvl."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 : Z) (c0 : ZMap.t memval),\ngetN (Datatypes.length vl) p0 (setN vl p0 c0) = vl) (p : Z) (c : ZMap.t memval) : ZMap.get p (setN vl (p + 1) (ZMap.set p a c)) = a.","proofString":"rewrite setN_outside.\napply ZMap.gss.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 : Z) (c0 : ZMap.t memval),\ngetN (Datatypes.length vl) p0 (setN vl p0 c0) = vl) (p : Z) (c : ZMap.t memval) : ZMap.get p (ZMap.set p a c) = a.","proofString":"apply ZMap.gss."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 : Z) (c0 : ZMap.t memval),\ngetN (Datatypes.length vl) p0 (setN vl p0 c0) = vl) (p : Z) (c : ZMap.t memval) : p < p + 1 \\/ p >= p + 1 + Z.of_nat (Datatypes.length vl).","proofString":"lia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 : Z) (c0 : ZMap.t memval),\ngetN (Datatypes.length vl) p0 (setN vl p0 c0) = vl) (p : Z) (c : ZMap.t memval) : getN (Datatypes.length vl) (p + 1) (setN vl (p + 1) (ZMap.set p a c)) = vl.","proofString":"apply IHvl."},{"statement":"(c1 c2 : ZMap.t memval) (p : Z) (H : forall i : Z, p <= i < p + Z.of_nat 0 -> ZMap.get i c1 = ZMap.get i c2) : getN 0 p c1 = getN 0 p c2.","proofString":"auto."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i : Z, p0 <= i < p0 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i : Z, p <= i < p + Z.of_nat (S n) -> ZMap.get i c1 = ZMap.get i c2) : getN (S n) p c1 = getN (S n) p c2.","proofString":"rewrite Nat2Z.inj_succ in H.\nsimpl.\ndecEq.\napply H.\nlia.\napply IHn.\nintros.\napply H.\nlia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i : Z, p0 <= i < p0 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i : Z,\np <= i < p + Z.succ (Z.of_nat n) -> ZMap.get i c1 = ZMap.get i c2) : getN (S n) p c1 = getN (S n) p c2.","proofString":"simpl.\ndecEq.\napply H.\nlia.\napply IHn.\nintros.\napply H.\nlia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i : Z, p0 <= i < p0 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i : Z,\np <= i < p + Z.succ (Z.of_nat n) -> ZMap.get i c1 = ZMap.get i c2) : ZMap.get p c1 :: getN n (p + 1) c1 = ZMap.get p c2 :: getN n (p + 1) c2.","proofString":"decEq.\napply H.\nlia.\napply IHn.\nintros.\napply H.\nlia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i : Z, p0 <= i < p0 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i : Z,\np <= i < p + Z.succ (Z.of_nat n) -> ZMap.get i c1 = ZMap.get i c2) : ZMap.get p c1 = ZMap.get p c2.","proofString":"apply H.\nlia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i : Z, p0 <= i < p0 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i : Z,\np <= i < p + Z.succ (Z.of_nat n) -> ZMap.get i c1 = ZMap.get i c2) : p <= p < p + Z.succ (Z.of_nat n).","proofString":"lia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i : Z, p0 <= i < p0 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i : Z,\np <= i < p + Z.succ (Z.of_nat n) -> ZMap.get i c1 = ZMap.get i c2) : getN n (p + 1) c1 = getN n (p + 1) c2.","proofString":"apply IHn.\nintros.\napply H.\nlia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i : Z, p0 <= i < p0 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i : Z,\np <= i < p + Z.succ (Z.of_nat n) -> ZMap.get i c1 = ZMap.get i c2) : forall i : Z,\np + 1 <= i < p + 1 + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2.","proofString":"intros.\napply H.\nlia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i0 : Z, p0 <= i0 < p0 + Z.of_nat n -> ZMap.get i0 c1 = ZMap.get i0 c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i0 : Z,\np <= i0 < p + Z.succ (Z.of_nat n) -> ZMap.get i0 c1 = ZMap.get i0 c2) (i : Z) (H0 : p + 1 <= i < p + 1 + Z.of_nat n) : ZMap.get i c1 = ZMap.get i c2.","proofString":"apply H.\nlia."},{"statement":"(c1 c2 : ZMap.t memval) (n : nat) (IHn : forall p0 : Z,\n(forall i0 : Z, p0 <= i0 < p0 + Z.of_nat n -> ZMap.get i0 c1 = ZMap.get i0 c2) ->\ngetN n p0 c1 = getN n p0 c2) (p : Z) (H : forall i0 : Z,\np <= i0 < p + Z.succ (Z.of_nat n) -> ZMap.get i0 c1 = ZMap.get i0 c2) (i : Z) (H0 : p + 1 <= i < p + 1 + Z.of_nat n) : p <= i < p + Z.succ (Z.of_nat n).","proofString":"lia."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (Datatypes.length vl))) : getN n p (setN vl q c) = getN n p c.","proofString":"apply getN_exten.\nintros.\napply setN_other.\nintros; red; intros; subst r.\neelim H; eauto."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (Datatypes.length vl))) : forall i : Z,\np <= i < p + Z.of_nat n -> ZMap.get i (setN vl q c) = ZMap.get i c.","proofString":"intros.\napply setN_other.\nintros; red; intros; subst r.\neelim H; eauto."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (Datatypes.length vl))) (i : Z) (H0 : p <= i < p + Z.of_nat n) : ZMap.get i (setN vl q c) = ZMap.get i c.","proofString":"apply setN_other.\nintros; red; intros; subst r.\neelim H; eauto."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (Datatypes.length vl))) (i : Z) (H0 : p <= i < p + Z.of_nat n) : forall r : Z, q <= r < q + Z.of_nat (Datatypes.length vl) -> r <> i.","proofString":"intros; red; intros; subst r.\neelim H; eauto."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (Datatypes.length vl))) (i : Z) (H0 : p <= i < p + Z.of_nat n) (H1 : q <= i < q + Z.of_nat (Datatypes.length vl)) : False.","proofString":"eelim H; eauto."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : p + Z.of_nat n <= q \\/ q + Z.of_nat (Datatypes.length vl) <= p) : getN n p (setN vl q c) = getN n p c.","proofString":"apply getN_setN_disjoint.\napply Intv.disjoint_range.\nauto."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : p + Z.of_nat n <= q \\/ q + Z.of_nat (Datatypes.length vl) <= p) : Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (Datatypes.length vl)).","proofString":"apply Intv.disjoint_range.\nauto."},{"statement":"(vl : list memval) (q : Z) (c : ZMap.t memval) (n : nat) (p : Z) (H : p + Z.of_nat n <= q \\/ q + Z.of_nat (Datatypes.length vl) <= p) : snd (p, p + Z.of_nat n) <= fst (q, q + Z.of_nat (Datatypes.length vl)) \\/\nsnd (q, q + Z.of_nat (Datatypes.length vl)) <= fst (p, p + Z.of_nat n).","proofString":"auto."},{"statement":"(q : Z) (c : ZMap.t memval) : fst c = fst c.","proofString":"auto."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (q0 : Z) (c0 : ZMap.t memval), fst (setN vl q0 c0) = fst c0) (q : Z) (c : ZMap.t memval) : fst (setN vl (q + 1) (ZMap.set q a c)) = fst c.","proofString":"rewrite IHvl.\nauto."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (q0 : Z) (c0 : ZMap.t memval), fst (setN vl q0 c0) = fst c0) (q : Z) (c : ZMap.t memval) : fst (ZMap.set q a c) = fst c.","proofString":"auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) : ~ perm empty b ofs k p.","proofString":"unfold perm, empty; simpl.\ntauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) : ~ False.","proofString":"tauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) : ~ valid_access empty chunk b ofs p.","proofString":"red; intros.\nelim (perm_empty b ofs Cur p).\napply H.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : valid_access empty chunk b ofs p) : False.","proofString":"elim (perm_empty b ofs Cur p).\napply H.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : valid_access empty chunk b ofs p) : perm empty b ofs Cur p.","proofString":"apply H.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : valid_access empty chunk b ofs p) : ofs <= ofs < ofs + size_chunk chunk.","proofString":"generalize (size_chunk_pos chunk); lia."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : valid_access m chunk b ofs Readable) : exists v : val, load chunk m b ofs = Some v.","proofString":"econstructor.\nunfold load.\nrewrite pred_dec_true; eauto."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) : load chunk m b ofs = Some v -> valid_access m chunk b ofs Readable.","proofString":"unfold load.\ndestruct (valid_access_dec m chunk b ofs Readable); intros.\nauto.\ncongruence."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) : (if valid_access_dec m chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n else None) = Some v -> valid_access m chunk b ofs Readable.","proofString":"destruct (valid_access_dec m chunk b ofs Readable); intros.\nauto.\ncongruence."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (v0 : valid_access m chunk b ofs Readable) (H : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) =\nSome v) : valid_access m chunk b ofs Readable.","proofString":"auto."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (n : ~ valid_access m chunk b ofs Readable) (H : None = Some v) : valid_access m chunk b ofs Readable.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) : load chunk m b ofs = Some v ->\nv = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"unfold load.\ndestruct (valid_access_dec m chunk b ofs Readable); intros.\ncongruence.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) : (if valid_access_dec m chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n else None) = Some v ->\nv = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"destruct (valid_access_dec m chunk b ofs Readable); intros.\ncongruence.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (v0 : valid_access m chunk b ofs Readable) (H : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) =\nSome v) : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (n : ~ valid_access m chunk b ofs Readable) (H : None = Some v) : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"congruence."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) : Val.has_type v (type_of_chunk chunk).","proofString":"exploit load_result; eauto; intros.\nrewrite H0.\napply decode_val_type."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : Val.has_type v (type_of_chunk chunk).","proofString":"rewrite H0.\napply decode_val_type."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : Val.has_type\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n  (type_of_chunk chunk).","proofString":"apply decode_val_type."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) : Val.has_rettype v (xtype_of_chunk chunk).","proofString":"exploit load_result; eauto; intros.\nrewrite H0.\napply decode_val_xtype."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : Val.has_rettype v (xtype_of_chunk chunk).","proofString":"rewrite H0.\napply decode_val_xtype."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : Val.has_rettype\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n  (xtype_of_chunk chunk).","proofString":"apply decode_val_xtype."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) : match chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend.","proofString":"exploit load_result; eauto.\nset (l := getN (size_chunk_nat chunk) ofs m.(mem_contents)#b).\nintros.\nsubst v.\napply decode_val_cast."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b) ->\nmatch chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend.","proofString":"set (l := getN (size_chunk_nat chunk) ofs m.(mem_contents)#b).\nintros.\nsubst v.\napply decode_val_cast."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (l : list memval) : v = decode_val chunk l ->\nmatch chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend.","proofString":"intros.\nsubst v.\napply decode_val_cast."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (l : list memval) (H0 : v = decode_val chunk l) : match chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend.","proofString":"subst v.\napply decode_val_cast."},{"statement":"(m : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (l : list memval) (H : load chunk m b ofs = Some (decode_val chunk l)) : match chunk with\n| Mbool => decode_val chunk l = Val.norm_bool (decode_val chunk l)\n| Mint8signed => decode_val chunk l = Val.sign_ext 8 (decode_val chunk l)\n| Mint8unsigned => decode_val chunk l = Val.zero_ext 8 (decode_val chunk l)\n| Mint16signed => decode_val chunk l = Val.sign_ext 16 (decode_val chunk l)\n| Mint16unsigned => decode_val chunk l = Val.zero_ext 16 (decode_val chunk l)\n| _ => True\nend.","proofString":"apply decode_val_cast."},{"statement":"(m : mem) (b : block) (ofs : Z) : load Mbool m b ofs = option_map Val.norm_bool (load Mint8unsigned m b ofs).","proofString":"unfold load.\nchange (size_chunk_nat Mbool) with (size_chunk_nat Mint8unsigned).\nset (cl := getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mbool b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : (if valid_access_dec m Mbool b ofs Readable\n then\n  Some\n    (decode_val Mbool (getN (size_chunk_nat Mbool) ofs (mem_contents m) # b))\n else None) =\noption_map Val.norm_bool\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then\n    Some\n      (decode_val Mint8unsigned\n         (getN (size_chunk_nat Mint8unsigned) ofs (mem_contents m) # b))\n   else None).","proofString":"change (size_chunk_nat Mbool) with (size_chunk_nat Mint8unsigned).\nset (cl := getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mbool b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : (if valid_access_dec m Mbool b ofs Readable\n then\n  Some\n    (decode_val Mbool\n       (getN (size_chunk_nat Mint8unsigned) ofs (mem_contents m) # b))\n else None) =\noption_map Val.norm_bool\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then\n    Some\n      (decode_val Mint8unsigned\n         (getN (size_chunk_nat Mint8unsigned) ofs (mem_contents m) # b))\n   else None).","proofString":"set (cl := getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mbool b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) : (if valid_access_dec m Mbool b ofs Readable\n then Some (decode_val Mbool cl)\n else None) =\noption_map Val.norm_bool\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then Some (decode_val Mint8unsigned cl)\n   else None).","proofString":"destruct (valid_access_dec m Mbool b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mbool b ofs Readable) : Some (decode_val Mbool cl) =\noption_map Val.norm_bool\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then Some (decode_val Mint8unsigned cl)\n   else None).","proofString":"rewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mbool b ofs Readable) : Some (decode_val Mbool cl) =\noption_map Val.norm_bool (Some (decode_val Mint8unsigned cl)).","proofString":"unfold decode_val.\ndestruct (proj_bytes cl); auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mbool b ofs Readable) : Some\n  match proj_bytes cl with\n  | Some bl =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | None => Vundef\n  end =\noption_map Val.norm_bool\n  (Some\n     match proj_bytes cl with\n     | Some bl => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n     | None => Vundef\n     end).","proofString":"destruct (proj_bytes cl); auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (n : ~ valid_access m Mbool b ofs Readable) : None =\noption_map Val.norm_bool\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then Some (decode_val Mint8unsigned cl)\n   else None).","proofString":"rewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : load Mint8signed m b ofs =\noption_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).","proofString":"unfold load.\nchange (size_chunk_nat Mint8signed) with (size_chunk_nat Mint8unsigned).\nset (cl := getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mint8signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : (if valid_access_dec m Mint8signed b ofs Readable\n then\n  Some\n    (decode_val Mint8signed\n       (getN (size_chunk_nat Mint8signed) ofs (mem_contents m) # b))\n else None) =\noption_map (Val.sign_ext 8)\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then\n    Some\n      (decode_val Mint8unsigned\n         (getN (size_chunk_nat Mint8unsigned) ofs (mem_contents m) # b))\n   else None).","proofString":"change (size_chunk_nat Mint8signed) with (size_chunk_nat Mint8unsigned).\nset (cl := getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mint8signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : (if valid_access_dec m Mint8signed b ofs Readable\n then\n  Some\n    (decode_val Mint8signed\n       (getN (size_chunk_nat Mint8unsigned) ofs (mem_contents m) # b))\n else None) =\noption_map (Val.sign_ext 8)\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then\n    Some\n      (decode_val Mint8unsigned\n         (getN (size_chunk_nat Mint8unsigned) ofs (mem_contents m) # b))\n   else None).","proofString":"set (cl := getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mint8signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) : (if valid_access_dec m Mint8signed b ofs Readable\n then Some (decode_val Mint8signed cl)\n else None) =\noption_map (Val.sign_ext 8)\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then Some (decode_val Mint8unsigned cl)\n   else None).","proofString":"destruct (valid_access_dec m Mint8signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) : Some (decode_val Mint8signed cl) =\noption_map (Val.sign_ext 8)\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then Some (decode_val Mint8unsigned cl)\n   else None).","proofString":"rewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) : Some (decode_val Mint8signed cl) =\noption_map (Val.sign_ext 8) (Some (decode_val Mint8unsigned cl)).","proofString":"unfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) : Some\n  match proj_bytes cl with\n  | Some bl => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end =\noption_map (Val.sign_ext 8)\n  (Some\n     match proj_bytes cl with\n     | Some bl => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n     | None => Vundef\n     end).","proofString":"destruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) (l : list byte) : Some (Vint (Int.sign_ext 8 (Int.repr (decode_int l)))) =\noption_map (Val.sign_ext 8)\n  (Some (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))).","proofString":"simpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) (l : list byte) : Some (Vint (Int.sign_ext 8 (Int.repr (decode_int l)))) =\nSome (Vint (Int.sign_ext 8 (Int.zero_ext 8 (Int.repr (decode_int l))))).","proofString":"decEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) (l : list byte) : Vint (Int.sign_ext 8 (Int.repr (decode_int l))) =\nVint (Int.sign_ext 8 (Int.zero_ext 8 (Int.repr (decode_int l)))).","proofString":"decEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) (l : list byte) : Int.sign_ext 8 (Int.repr (decode_int l)) =\nInt.sign_ext 8 (Int.zero_ext 8 (Int.repr (decode_int l))).","proofString":"rewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) (l : list byte) : Int.sign_ext 8 (Int.repr (decode_int l)) =\nInt.sign_ext 8 (Int.repr (decode_int l)).","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint8signed b ofs Readable) (l : list byte) : 0 < 8.","proofString":"compute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (n : ~ valid_access m Mint8signed b ofs Readable) : None =\noption_map (Val.sign_ext 8)\n  (if valid_access_dec m Mint8unsigned b ofs Readable\n   then Some (decode_val Mint8unsigned cl)\n   else None).","proofString":"rewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : load Mint16signed m b ofs =\noption_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).","proofString":"unfold load.\nchange (size_chunk_nat Mint16signed) with (size_chunk_nat Mint16unsigned).\nset (cl := getN (size_chunk_nat Mint16unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mint16signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : (if valid_access_dec m Mint16signed b ofs Readable\n then\n  Some\n    (decode_val Mint16signed\n       (getN (size_chunk_nat Mint16signed) ofs (mem_contents m) # b))\n else None) =\noption_map (Val.sign_ext 16)\n  (if valid_access_dec m Mint16unsigned b ofs Readable\n   then\n    Some\n      (decode_val Mint16unsigned\n         (getN (size_chunk_nat Mint16unsigned) ofs (mem_contents m) # b))\n   else None).","proofString":"change (size_chunk_nat Mint16signed) with (size_chunk_nat Mint16unsigned).\nset (cl := getN (size_chunk_nat Mint16unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mint16signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) : (if valid_access_dec m Mint16signed b ofs Readable\n then\n  Some\n    (decode_val Mint16signed\n       (getN (size_chunk_nat Mint16unsigned) ofs (mem_contents m) # b))\n else None) =\noption_map (Val.sign_ext 16)\n  (if valid_access_dec m Mint16unsigned b ofs Readable\n   then\n    Some\n      (decode_val Mint16unsigned\n         (getN (size_chunk_nat Mint16unsigned) ofs (mem_contents m) # b))\n   else None).","proofString":"set (cl := getN (size_chunk_nat Mint16unsigned) ofs m.(mem_contents)#b).\ndestruct (valid_access_dec m Mint16signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) : (if valid_access_dec m Mint16signed b ofs Readable\n then Some (decode_val Mint16signed cl)\n else None) =\noption_map (Val.sign_ext 16)\n  (if valid_access_dec m Mint16unsigned b ofs Readable\n   then Some (decode_val Mint16unsigned cl)\n   else None).","proofString":"destruct (valid_access_dec m Mint16signed b ofs Readable).\nrewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto.\nrewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) : Some (decode_val Mint16signed cl) =\noption_map (Val.sign_ext 16)\n  (if valid_access_dec m Mint16unsigned b ofs Readable\n   then Some (decode_val Mint16unsigned cl)\n   else None).","proofString":"rewrite pred_dec_true; auto.\nunfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) : Some (decode_val Mint16signed cl) =\noption_map (Val.sign_ext 16) (Some (decode_val Mint16unsigned cl)).","proofString":"unfold decode_val.\ndestruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) : Some\n  match proj_bytes cl with\n  | Some bl => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end =\noption_map (Val.sign_ext 16)\n  (Some\n     match proj_bytes cl with\n     | Some bl => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n     | None => Vundef\n     end).","proofString":"destruct (proj_bytes cl); auto.\nsimpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) (l : list byte) : Some (Vint (Int.sign_ext 16 (Int.repr (decode_int l)))) =\noption_map (Val.sign_ext 16)\n  (Some (Vint (Int.zero_ext 16 (Int.repr (decode_int l))))).","proofString":"simpl.\ndecEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) (l : list byte) : Some (Vint (Int.sign_ext 16 (Int.repr (decode_int l)))) =\nSome (Vint (Int.sign_ext 16 (Int.zero_ext 16 (Int.repr (decode_int l))))).","proofString":"decEq.\ndecEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) (l : list byte) : Vint (Int.sign_ext 16 (Int.repr (decode_int l))) =\nVint (Int.sign_ext 16 (Int.zero_ext 16 (Int.repr (decode_int l)))).","proofString":"decEq.\nrewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) (l : list byte) : Int.sign_ext 16 (Int.repr (decode_int l)) =\nInt.sign_ext 16 (Int.zero_ext 16 (Int.repr (decode_int l))).","proofString":"rewrite Int.sign_ext_zero_ext.\nauto.\ncompute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) (l : list byte) : Int.sign_ext 16 (Int.repr (decode_int l)) =\nInt.sign_ext 16 (Int.repr (decode_int l)).","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (v : valid_access m Mint16signed b ofs Readable) (l : list byte) : 0 < 16.","proofString":"compute; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (cl : list memval) (n : ~ valid_access m Mint16signed b ofs Readable) : None =\noption_map (Val.sign_ext 16)\n  (if valid_access_dec m Mint16unsigned b ofs Readable\n   then Some (decode_val Mint16unsigned cl)\n   else None).","proofString":"rewrite pred_dec_false; auto."},{"statement":"(m : mem) (b : block) (ofs len : Z) (H : range_perm m b ofs (ofs + len) Cur Readable) : exists bytes : list memval, loadbytes m b ofs len = Some bytes.","proofString":"econstructor.\nunfold loadbytes.\nrewrite pred_dec_true; eauto."},{"statement":"(m : mem) (b : block) (ofs len : Z) (bytes : list memval) : loadbytes m b ofs len = Some bytes ->\nrange_perm m b ofs (ofs + len) Cur Readable.","proofString":"unfold loadbytes.\ndestruct (range_perm_dec m b ofs (ofs + len) Cur Readable).\nauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs len : Z) (bytes : list memval) : (if range_perm_dec m b ofs (ofs + len) Cur Readable\n then Some (getN (Z.to_nat len) ofs (mem_contents m) # b)\n else None) = Some bytes -> range_perm m b ofs (ofs + len) Cur Readable.","proofString":"destruct (range_perm_dec m b ofs (ofs + len) Cur Readable).\nauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs len : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + len) Cur Readable) : Some (getN (Z.to_nat len) ofs (mem_contents m) # b) = Some bytes ->\nrange_perm m b ofs (ofs + len) Cur Readable.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs len : Z) (bytes : list memval) (n : ~ range_perm m b ofs (ofs + len) Cur Readable) : None = Some bytes -> range_perm m b ofs (ofs + len) Cur Readable.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (bytes : list memval) (H : (if range_perm_dec m b ofs (ofs + size_chunk chunk) Cur Readable\n then Some (getN (Z.to_nat (size_chunk chunk)) ofs (mem_contents m) # b)\n else None) = Some bytes) (H0 : (align_chunk chunk | ofs)) : (if valid_access_dec m chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n else None) = Some (decode_val chunk bytes).","proofString":"destruct (range_perm_dec m b ofs (ofs + size_chunk chunk) Cur Readable);  try congruence.\ninv H.\nrewrite pred_dec_true.\nauto.\nsplit; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H : Some (getN (Z.to_nat (size_chunk chunk)) ofs (mem_contents m) # b) =\nSome bytes) (H0 : (align_chunk chunk | ofs)) : (if valid_access_dec m chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n else None) = Some (decode_val chunk bytes).","proofString":"inv H.\nrewrite pred_dec_true.\nauto.\nsplit; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (r : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H0 : (align_chunk chunk | ofs)) : (if valid_access_dec m chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n else None) =\nSome\n  (decode_val chunk\n     (getN (Z.to_nat (size_chunk chunk)) ofs (mem_contents m) # b)).","proofString":"rewrite pred_dec_true.\nauto.\nsplit; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (r : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H0 : (align_chunk chunk | ofs)) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) =\nSome\n  (decode_val chunk\n     (getN (Z.to_nat (size_chunk chunk)) ofs (mem_contents m) # b)).","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (r : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H0 : (align_chunk chunk | ofs)) : valid_access m chunk b ofs Readable.","proofString":"split; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) : exists bytes : list memval,\n  loadbytes m b ofs (size_chunk chunk) = Some bytes /\\\n  v = decode_val chunk bytes.","proofString":"exploit load_valid_access; eauto.\nintros [A B].\nexploit load_result; eauto.\nintros.\nexists (getN (size_chunk_nat chunk) ofs m.(mem_contents)#b); split.\nunfold loadbytes.\nrewrite pred_dec_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) : valid_access m chunk b ofs Readable ->\nexists bytes : list memval,\n  loadbytes m b ofs (size_chunk chunk) = Some bytes /\\\n  v = decode_val chunk bytes.","proofString":"intros [A B].\nexploit load_result; eauto.\nintros.\nexists (getN (size_chunk_nat chunk) ofs m.(mem_contents)#b); split.\nunfold loadbytes.\nrewrite pred_dec_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (A : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) : exists bytes : list memval,\n  loadbytes m b ofs (size_chunk chunk) = Some bytes /\\\n  v = decode_val chunk bytes.","proofString":"exploit load_result; eauto.\nintros.\nexists (getN (size_chunk_nat chunk) ofs m.(mem_contents)#b); split.\nunfold loadbytes.\nrewrite pred_dec_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (A : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b) ->\nexists bytes : list memval,\n  loadbytes m b ofs (size_chunk chunk) = Some bytes /\\\n  v = decode_val chunk bytes.","proofString":"intros.\nexists (getN (size_chunk_nat chunk) ofs m.(mem_contents)#b); split.\nunfold loadbytes.\nrewrite pred_dec_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (A : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : exists bytes : list memval,\n  loadbytes m b ofs (size_chunk chunk) = Some bytes /\\\n  v = decode_val chunk bytes.","proofString":"exists (getN (size_chunk_nat chunk) ofs m.(mem_contents)#b); split.\nunfold loadbytes.\nrewrite pred_dec_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (A : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : loadbytes m b ofs (size_chunk chunk) =\nSome (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"unfold loadbytes.\nrewrite pred_dec_true; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (A : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : (if range_perm_dec m b ofs (ofs + size_chunk chunk) Cur Readable\n then Some (getN (Z.to_nat (size_chunk chunk)) ofs (mem_contents m) # b)\n else None) = Some (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"rewrite pred_dec_true; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (H : load chunk m b ofs = Some v) (A : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)) : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"auto."},{"statement":"(c : ZMap.t memval) (p : Z) : 0%nat = 0%nat.","proofString":"auto."},{"statement":"(c : ZMap.t memval) (n : nat) (IHn : forall p0 : Z, Datatypes.length (getN n p0 c) = n) (p : Z) : S (Datatypes.length (getN n (p + 1) c)) = S n.","proofString":"decEq; auto."},{"statement":"(m : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : (if range_perm_dec m b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m) # b)\n else None) = Some bytes) : Datatypes.length bytes = Z.to_nat n.","proofString":"destruct (range_perm_dec m b ofs (ofs + n) Cur Readable); try congruence.\ninv H.\napply getN_length."},{"statement":"(m : mem) (b : block) (ofs n : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : Some (getN (Z.to_nat n) ofs (mem_contents m) # b) = Some bytes) : Datatypes.length bytes = Z.to_nat n.","proofString":"inv H.\napply getN_length."},{"statement":"(m : mem) (b : block) (ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) : Datatypes.length (getN (Z.to_nat n) ofs (mem_contents m) # b) = Z.to_nat n.","proofString":"apply getN_length."},{"statement":"(m : mem) (b : block) (ofs n : Z) (H : n <= 0) : loadbytes m b ofs n = Some nil.","proofString":"unfold loadbytes.\nrewrite pred_dec_true.\nrewrite Z_to_nat_neg; auto.\nred; intros.\nextlia."},{"statement":"(m : mem) (b : block) (ofs n : Z) (H : n <= 0) : (if range_perm_dec m b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m) # b)\n else None) = Some nil.","proofString":"rewrite pred_dec_true.\nrewrite Z_to_nat_neg; auto.\nred; intros.\nextlia."},{"statement":"(m : mem) (b : block) (ofs n : Z) (H : n <= 0) : Some (getN (Z.to_nat n) ofs (mem_contents m) # b) = Some nil.","proofString":"rewrite Z_to_nat_neg; auto."},{"statement":"(m : mem) (b : block) (ofs n : Z) (H : n <= 0) : range_perm m b ofs (ofs + n) Cur Readable.","proofString":"red; intros.\nextlia."},{"statement":"(m : mem) (b : block) (ofs n : Z) (H : n <= 0) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) : perm m b ofs0 Cur Readable.","proofString":"extlia."},{"statement":"(c : ZMap.t memval) (n2 : nat) (p : Z) : getN (0 + n2) p c = getN 0 p c ++ getN n2 (p + Z.of_nat 0) c.","proofString":"simpl.\ndecEq.\nlia."},{"statement":"(c : ZMap.t memval) (n2 : nat) (p : Z) : getN n2 p c = getN n2 (p + 0) c.","proofString":"decEq.\nlia."},{"statement":"(c : ZMap.t memval) (n2 : nat) (p : Z) : p = p + 0.","proofString":"lia."},{"statement":"(c : ZMap.t memval) (n1 : nat) (IHn1 : forall (n0 : nat) (p0 : Z),\ngetN (n1 + n0) p0 c = getN n1 p0 c ++ getN n0 (p0 + Z.of_nat n1) c) (n2 : nat) (p : Z) : getN (S n1 + n2) p c = getN (S n1) p c ++ getN n2 (p + Z.of_nat (S n1)) c.","proofString":"rewrite Nat2Z.inj_succ.\nsimpl.\ndecEq.\nreplace (p + Z.succ (Z.of_nat n1)) with ((p + 1) + Z.of_nat n1) by lia.\nauto."},{"statement":"(c : ZMap.t memval) (n1 : nat) (IHn1 : forall (n0 : nat) (p0 : Z),\ngetN (n1 + n0) p0 c = getN n1 p0 c ++ getN n0 (p0 + Z.of_nat n1) c) (n2 : nat) (p : Z) : getN (S n1 + n2) p c =\ngetN (S n1) p c ++ getN n2 (p + Z.succ (Z.of_nat n1)) c.","proofString":"simpl.\ndecEq.\nreplace (p + Z.succ (Z.of_nat n1)) with ((p + 1) + Z.of_nat n1) by lia.\nauto."},{"statement":"(c : ZMap.t memval) (n1 : nat) (IHn1 : forall (n0 : nat) (p0 : Z),\ngetN (n1 + n0) p0 c = getN n1 p0 c ++ getN n0 (p0 + Z.of_nat n1) c) (n2 : nat) (p : Z) : ZMap.get p c :: getN (n1 + n2) (p + 1) c =\nZMap.get p c :: getN n1 (p + 1) c ++ getN n2 (p + Z.succ (Z.of_nat n1)) c.","proofString":"decEq.\nreplace (p + Z.succ (Z.of_nat n1)) with ((p + 1) + Z.of_nat n1) by lia.\nauto."},{"statement":"(c : ZMap.t memval) (n1 : nat) (IHn1 : forall (n0 : nat) (p0 : Z),\ngetN (n1 + n0) p0 c = getN n1 p0 c ++ getN n0 (p0 + Z.of_nat n1) c) (n2 : nat) (p : Z) : getN (n1 + n2) (p + 1) c =\ngetN n1 (p + 1) c ++ getN n2 (p + Z.succ (Z.of_nat n1)) c.","proofString":"replace (p + Z.succ (Z.of_nat n1)) with ((p + 1) + Z.of_nat n1) by lia.\nauto."},{"statement":"(c : ZMap.t memval) (n1 : nat) (IHn1 : forall (n0 : nat) (p0 : Z),\ngetN (n1 + n0) p0 c = getN n1 p0 c ++ getN n0 (p0 + Z.of_nat n1) c) (n2 : nat) (p : Z) : getN (n1 + n2) (p + 1) c =\ngetN n1 (p + 1) c ++ getN n2 (p + 1 + Z.of_nat n1) c.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (H : (if range_perm_dec m b ofs (ofs + n1) Cur Readable\n then Some (getN (Z.to_nat n1) ofs (mem_contents m) # b)\n else None) = Some bytes1) (H0 : (if range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable\n then Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b)\n else None) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : (if range_perm_dec m b ofs (ofs + (n1 + n2)) Cur Readable\n then Some (getN (Z.to_nat (n1 + n2)) ofs (mem_contents m) # b)\n else None) = Some (bytes1 ++ bytes2).","proofString":"destruct (range_perm_dec m b ofs (ofs + n1) Cur Readable); try congruence.\ndestruct (range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable); try congruence.\nrewrite pred_dec_true.\nrewrite Z2Nat.inj_add by lia.\nrewrite getN_concat.\nrewrite Z2Nat.id by lia.\ncongruence.\nred; intros.\nassert (ofs0 < ofs + n1 \\/ ofs0 >= ofs + n1) by lia.\ndestruct H4.\napply r; lia.\napply r0; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (H0 : (if range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable\n then Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b)\n else None) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : (if range_perm_dec m b ofs (ofs + (n1 + n2)) Cur Readable\n then Some (getN (Z.to_nat (n1 + n2)) ofs (mem_contents m) # b)\n else None) = Some (bytes1 ++ bytes2).","proofString":"destruct (range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable); try congruence.\nrewrite pred_dec_true.\nrewrite Z2Nat.inj_add by lia.\nrewrite getN_concat.\nrewrite Z2Nat.id by lia.\ncongruence.\nred; intros.\nassert (ofs0 < ofs + n1 \\/ ofs0 >= ofs + n1) by lia.\ndestruct H4.\napply r; lia.\napply r0; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : (if range_perm_dec m b ofs (ofs + (n1 + n2)) Cur Readable\n then Some (getN (Z.to_nat (n1 + n2)) ofs (mem_contents m) # b)\n else None) = Some (bytes1 ++ bytes2).","proofString":"rewrite pred_dec_true.\nrewrite Z2Nat.inj_add by lia.\nrewrite getN_concat.\nrewrite Z2Nat.id by lia.\ncongruence.\nred; intros.\nassert (ofs0 < ofs + n1 \\/ ofs0 >= ofs + n1) by lia.\ndestruct H4.\napply r; lia.\napply r0; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : Some (getN (Z.to_nat (n1 + n2)) ofs (mem_contents m) # b) =\nSome (bytes1 ++ bytes2).","proofString":"rewrite Z2Nat.inj_add by lia.\nrewrite getN_concat.\nrewrite Z2Nat.id by lia.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : Some (getN (Z.to_nat n1 + Z.to_nat n2) ofs (mem_contents m) # b) =\nSome (bytes1 ++ bytes2).","proofString":"rewrite getN_concat.\nrewrite Z2Nat.id by lia.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : Some\n  (getN (Z.to_nat n1) ofs (mem_contents m) # b ++\n   getN (Z.to_nat n2) (ofs + Z.of_nat (Z.to_nat n1)) (mem_contents m) # b) =\nSome (bytes1 ++ bytes2).","proofString":"rewrite Z2Nat.id by lia.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : Some\n  (getN (Z.to_nat n1) ofs (mem_contents m) # b ++\n   getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) =\nSome (bytes1 ++ bytes2).","proofString":"congruence."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable.","proofString":"red; intros.\nassert (ofs0 < ofs + n1 \\/ ofs0 >= ofs + n1) by lia.\ndestruct H4.\napply r; lia.\napply r0; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) (ofs0 : Z) (H3 : ofs <= ofs0 < ofs + (n1 + n2)) : perm m b ofs0 Cur Readable.","proofString":"assert (ofs0 < ofs + n1 \\/ ofs0 >= ofs + n1) by lia.\ndestruct H4.\napply r; lia.\napply r0; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) (ofs0 : Z) (H3 : ofs <= ofs0 < ofs + (n1 + n2)) (H4 : ofs0 < ofs + n1 \\/ ofs0 >= ofs + n1) : perm m b ofs0 Cur Readable.","proofString":"destruct H4.\napply r; lia.\napply r0; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) (ofs0 : Z) (H3 : ofs <= ofs0 < ofs + (n1 + n2)) (H4 : ofs0 < ofs + n1) : perm m b ofs0 Cur Readable.","proofString":"apply r; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes1 bytes2 : list memval) (r : range_perm m b ofs (ofs + n1) Cur Readable) (H : Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1) (r0 : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable) (H0 : Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2) (H1 : n1 >= 0) (H2 : n2 >= 0) (ofs0 : Z) (H3 : ofs <= ofs0 < ofs + (n1 + n2)) (H4 : ofs0 >= ofs + n1) : perm m b ofs0 Cur Readable.","proofString":"apply r0; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (H : (if range_perm_dec m b ofs (ofs + (n1 + n2)) Cur Readable\n then Some (getN (Z.to_nat (n1 + n2)) ofs (mem_contents m) # b)\n else None) = Some bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : exists bytes1 bytes2 : list memval,\n  (if range_perm_dec m b ofs (ofs + n1) Cur Readable\n   then Some (getN (Z.to_nat n1) ofs (mem_contents m) # b)\n   else None) = Some bytes1 /\\\n  (if range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable\n   then Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b)\n   else None) = Some bytes2 /\\ bytes = bytes1 ++ bytes2.","proofString":"destruct (range_perm_dec m b ofs (ofs + (n1 + n2)) Cur Readable);  try congruence.\nrewrite Z2Nat.inj_add in H by lia.\nrewrite getN_concat in H.\nrewrite Z2Nat.id in H by lia.\nrepeat rewrite pred_dec_true.\neconstructor; econstructor.\nsplit.\nreflexivity.\nsplit.\nreflexivity.\ncongruence.\nred; intros; apply r; lia.\nred; intros; apply r; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable) (H : Some (getN (Z.to_nat (n1 + n2)) ofs (mem_contents m) # b) = Some bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : exists bytes1 bytes2 : list memval,\n  (if range_perm_dec m b ofs (ofs + n1) Cur Readable\n   then Some (getN (Z.to_nat n1) ofs (mem_contents m) # b)\n   else None) = Some bytes1 /\\\n  (if range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable\n   then Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b)\n   else None) = Some bytes2 /\\ bytes = bytes1 ++ bytes2.","proofString":"rewrite Z2Nat.inj_add in H by lia.\nrewrite getN_concat in H.\nrewrite Z2Nat.id in H by lia.\nrepeat rewrite pred_dec_true.\neconstructor; econstructor.\nsplit.\nreflexivity.\nsplit.\nreflexivity.\ncongruence.\nred; intros; apply r; lia.\nred; intros; apply r; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable) (H : Some (getN (Z.to_nat n1 + Z.to_nat n2) ofs (mem_contents m) # b) = Some bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : exists bytes1 bytes2 : list memval,\n  (if range_perm_dec m b ofs (ofs + n1) Cur Readable\n   then Some (getN (Z.to_nat n1) ofs (mem_contents m) # b)\n   else None) = Some bytes1 /\\\n  (if range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable\n   then Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b)\n   else None) = Some bytes2 /\\ bytes = bytes1 ++ bytes2.","proofString":"rewrite getN_concat in H.\nrewrite Z2Nat.id in H by lia.\nrepeat rewrite pred_dec_true.\neconstructor; econstructor.\nsplit.\nreflexivity.\nsplit.\nreflexivity.\ncongruence.\nred; intros; apply r; lia.\nred; intros; apply r; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable) (H : Some\n  (getN (Z.to_nat n1) ofs (mem_contents m) # b ++\n   getN (Z.to_nat n2) (ofs + Z.of_nat (Z.to_nat n1)) (mem_contents m) # b) =\nSome bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : exists bytes1 bytes2 : list memval,\n  (if range_perm_dec m b ofs (ofs + n1) Cur Readable\n   then Some (getN (Z.to_nat n1) ofs (mem_contents m) # b)\n   else None) = Some bytes1 /\\\n  (if range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable\n   then Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b)\n   else None) = Some bytes2 /\\ bytes = bytes1 ++ bytes2.","proofString":"rewrite Z2Nat.id in H by lia.\nrepeat rewrite pred_dec_true.\neconstructor; econstructor.\nsplit.\nreflexivity.\nsplit.\nreflexivity.\ncongruence.\nred; intros; apply r; lia.\nred; intros; apply r; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable) (H : Some\n  (getN (Z.to_nat n1) ofs (mem_contents m) # b ++\n   getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = \nSome bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : exists bytes1 bytes2 : list memval,\n  (if range_perm_dec m b ofs (ofs + n1) Cur Readable\n   then Some (getN (Z.to_nat n1) ofs (mem_contents m) # b)\n   else None) = Some bytes1 /\\\n  (if range_perm_dec m b (ofs + n1) (ofs + n1 + n2) Cur Readable\n   then Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b)\n   else None) = Some bytes2 /\\ bytes = bytes1 ++ bytes2.","proofString":"repeat rewrite pred_dec_true.\neconstructor; econstructor.\nsplit.\nreflexivity.\nsplit.\nreflexivity.\ncongruence.\nred; intros; apply r; lia.\nred; intros; apply r; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable) (H : Some\n  (getN (Z.to_nat n1) ofs (mem_contents m) # b ++\n   getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = \nSome bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : exists bytes1 bytes2 : list memval,\n  Some (getN (Z.to_nat n1) ofs (mem_contents m) # b) = Some bytes1 /\\\n  Some (getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = Some bytes2 /\\\n  bytes = bytes1 ++ bytes2.","proofString":"econstructor; econstructor.\nsplit.\nreflexivity.\nsplit.\nreflexivity.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable) (H : Some\n  (getN (Z.to_nat n1) ofs (mem_contents m) # b ++\n   getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = \nSome bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : range_perm m b (ofs + n1) (ofs + n1 + n2) Cur Readable.","proofString":"red; intros; apply r; lia."},{"statement":"(m : mem) (b : block) (ofs n1 n2 : Z) (bytes : list memval) (r : range_perm m b ofs (ofs + (n1 + n2)) Cur Readable) (H : Some\n  (getN (Z.to_nat n1) ofs (mem_contents m) # b ++\n   getN (Z.to_nat n2) (ofs + n1) (mem_contents m) # b) = \nSome bytes) (H0 : n1 >= 0) (H1 : n2 >= 0) : range_perm m b ofs (ofs + n1) Cur Readable.","proofString":"red; intros; apply r; lia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (ofs : Z) (v1 v2 : val) (H : forall z : Z,\n0 <= z < size_chunk ch ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) (H0 : load ch m1 b ofs = Some v1) (H1 : load ch m2 b ofs = Some v2) : v1 = v2.","proofString":"apply load_result in H0.\napply load_result in H1.\nsubst.\nf_equal.\nrewrite size_chunk_conv in H.\nremember (size_chunk_nat ch) as n; clear Heqn.\nrevert ofs H; induction n; intros; simpl; auto.\nf_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (ofs : Z) (v1 v2 : val) (H : forall z : Z,\n0 <= z < size_chunk ch ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) (H0 : v1 = decode_val ch (getN (size_chunk_nat ch) ofs (mem_contents m1) # b)) (H1 : load ch m2 b ofs = Some v2) : v1 = v2.","proofString":"apply load_result in H1.\nsubst.\nf_equal.\nrewrite size_chunk_conv in H.\nremember (size_chunk_nat ch) as n; clear Heqn.\nrevert ofs H; induction n; intros; simpl; auto.\nf_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (ofs : Z) (v1 v2 : val) (H : forall z : Z,\n0 <= z < size_chunk ch ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) (H0 : v1 = decode_val ch (getN (size_chunk_nat ch) ofs (mem_contents m1) # b)) (H1 : v2 = decode_val ch (getN (size_chunk_nat ch) ofs (mem_contents m2) # b)) : v1 = v2.","proofString":"subst.\nf_equal.\nrewrite size_chunk_conv in H.\nremember (size_chunk_nat ch) as n; clear Heqn.\nrevert ofs H; induction n; intros; simpl; auto.\nf_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (ofs : Z) (H : forall z : Z,\n0 <= z < size_chunk ch ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : decode_val ch (getN (size_chunk_nat ch) ofs (mem_contents m1) # b) =\ndecode_val ch (getN (size_chunk_nat ch) ofs (mem_contents m2) # b).","proofString":"f_equal.\nrewrite size_chunk_conv in H.\nremember (size_chunk_nat ch) as n; clear Heqn.\nrevert ofs H; induction n; intros; simpl; auto.\nf_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (ofs : Z) (H : forall z : Z,\n0 <= z < size_chunk ch ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : getN (size_chunk_nat ch) ofs (mem_contents m1) # b =\ngetN (size_chunk_nat ch) ofs (mem_contents m2) # b.","proofString":"rewrite size_chunk_conv in H.\nremember (size_chunk_nat ch) as n; clear Heqn.\nrevert ofs H; induction n; intros; simpl; auto.\nf_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (ofs : Z) (H : forall z : Z,\n0 <= z < Z.of_nat (size_chunk_nat ch) ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : getN (size_chunk_nat ch) ofs (mem_contents m1) # b =\ngetN (size_chunk_nat ch) ofs (mem_contents m2) # b.","proofString":"remember (size_chunk_nat ch) as n; clear Heqn.\nrevert ofs H; induction n; intros; simpl; auto.\nf_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (ofs : Z) (n : nat) (H : forall z : Z,\n0 <= z < Z.of_nat n ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : getN n ofs (mem_contents m1) # b = getN n ofs (mem_contents m2) # b.","proofString":"revert ofs H; induction n; intros; simpl; auto.\nf_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z : Z,\n 0 <= z < Z.of_nat n ->\n ZMap.get (ofs0 + z) (mem_contents m1) # b =\n ZMap.get (ofs0 + z) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z : Z,\n0 <= z < Z.of_nat (S n) ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : ZMap.get ofs (mem_contents m1) # b :: getN n (ofs + 1) (mem_contents m1) # b =\nZMap.get ofs (mem_contents m2) # b :: getN n (ofs + 1) (mem_contents m2) # b.","proofString":"f_equal.\nrewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia.\napply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z : Z,\n 0 <= z < Z.of_nat n ->\n ZMap.get (ofs0 + z) (mem_contents m1) # b =\n ZMap.get (ofs0 + z) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z : Z,\n0 <= z < Z.of_nat (S n) ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : ZMap.get ofs (mem_contents m1) # b = ZMap.get ofs (mem_contents m2) # b.","proofString":"rewrite Nat2Z.inj_succ in H.\nreplace ofs with (ofs+0) by lia.\napply H; lia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z : Z,\n 0 <= z < Z.of_nat n ->\n ZMap.get (ofs0 + z) (mem_contents m1) # b =\n ZMap.get (ofs0 + z) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z : Z,\n0 <= z < Z.succ (Z.of_nat n) ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : ZMap.get ofs (mem_contents m1) # b = ZMap.get ofs (mem_contents m2) # b.","proofString":"replace ofs with (ofs+0) by lia.\napply H; lia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z : Z,\n 0 <= z < Z.of_nat n ->\n ZMap.get (ofs0 + z) (mem_contents m1) # b =\n ZMap.get (ofs0 + z) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z : Z,\n0 <= z < Z.succ (Z.of_nat n) ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : ZMap.get (ofs + 0) (mem_contents m1) # b =\nZMap.get (ofs + 0) (mem_contents m2) # b.","proofString":"apply H; lia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z : Z,\n 0 <= z < Z.of_nat n ->\n ZMap.get (ofs0 + z) (mem_contents m1) # b =\n ZMap.get (ofs0 + z) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z : Z,\n0 <= z < Z.of_nat (S n) ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : getN n (ofs + 1) (mem_contents m1) # b =\ngetN n (ofs + 1) (mem_contents m2) # b.","proofString":"apply IHn.\nintros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z : Z,\n 0 <= z < Z.of_nat n ->\n ZMap.get (ofs0 + z) (mem_contents m1) # b =\n ZMap.get (ofs0 + z) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z : Z,\n0 <= z < Z.of_nat (S n) ->\nZMap.get (ofs + z) (mem_contents m1) # b =\nZMap.get (ofs + z) (mem_contents m2) # b) : forall z : Z,\n0 <= z < Z.of_nat n ->\nZMap.get (ofs + 1 + z) (mem_contents m1) # b =\nZMap.get (ofs + 1 + z) (mem_contents m2) # b.","proofString":"intros.\nrewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z0 : Z,\n 0 <= z0 < Z.of_nat n ->\n ZMap.get (ofs0 + z0) (mem_contents m1) # b =\n ZMap.get (ofs0 + z0) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z0 : Z,\n0 <= z0 < Z.of_nat (S n) ->\nZMap.get (ofs + z0) (mem_contents m1) # b =\nZMap.get (ofs + z0) (mem_contents m2) # b) (z : Z) (H0 : 0 <= z < Z.of_nat n) : ZMap.get (ofs + 1 + z) (mem_contents m1) # b =\nZMap.get (ofs + 1 + z) (mem_contents m2) # b.","proofString":"rewrite <- Z.add_assoc.\napply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z0 : Z,\n 0 <= z0 < Z.of_nat n ->\n ZMap.get (ofs0 + z0) (mem_contents m1) # b =\n ZMap.get (ofs0 + z0) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z0 : Z,\n0 <= z0 < Z.of_nat (S n) ->\nZMap.get (ofs + z0) (mem_contents m1) # b =\nZMap.get (ofs + z0) (mem_contents m2) # b) (z : Z) (H0 : 0 <= z < Z.of_nat n) : ZMap.get (ofs + (1 + z)) (mem_contents m1) # b =\nZMap.get (ofs + (1 + z)) (mem_contents m2) # b.","proofString":"apply H.\nrewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z0 : Z,\n 0 <= z0 < Z.of_nat n ->\n ZMap.get (ofs0 + z0) (mem_contents m1) # b =\n ZMap.get (ofs0 + z0) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z0 : Z,\n0 <= z0 < Z.of_nat (S n) ->\nZMap.get (ofs + z0) (mem_contents m1) # b =\nZMap.get (ofs + z0) (mem_contents m2) # b) (z : Z) (H0 : 0 <= z < Z.of_nat n) : 0 <= 1 + z < Z.of_nat (S n).","proofString":"rewrite Nat2Z.inj_succ.\nlia."},{"statement":"(ch : memory_chunk) (m1 m2 : mem') (b : positive) (n : nat) (IHn : forall ofs0 : Z,\n(forall z0 : Z,\n 0 <= z0 < Z.of_nat n ->\n ZMap.get (ofs0 + z0) (mem_contents m1) # b =\n ZMap.get (ofs0 + z0) (mem_contents m2) # b) ->\ngetN n ofs0 (mem_contents m1) # b = getN n ofs0 (mem_contents m2) # b) (ofs : Z) (H : forall z0 : Z,\n0 <= z0 < Z.of_nat (S n) ->\nZMap.get (ofs + z0) (mem_contents m1) # b =\nZMap.get (ofs + z0) (mem_contents m2) # b) (z : Z) (H0 : 0 <= z < Z.of_nat n) : 0 <= 1 + z < Z.succ (Z.of_nat n).","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"exploit load_valid_access; eauto.\nintros [A B].\nsimpl in *.\nexploit load_loadbytes.\neexact H.\nsimpl.\nintros [bytes [LB EQ]].\nchange 8 with (4 + 4) in LB.\nexploit loadbytes_split.\neexact LB.\nlia.\nlia.\nintros (bytes1 & bytes2 & LB1 & LB2 & APP).\nchange 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) : valid_access m Mint64 b ofs Readable ->\nexists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"intros [A B].\nsimpl in *.\nexploit load_loadbytes.\neexact H.\nsimpl.\nintros [bytes [LB EQ]].\nchange 8 with (4 + 4) in LB.\nexploit loadbytes_split.\neexact LB.\nlia.\nlia.\nintros (bytes1 & bytes2 & LB1 & LB2 & APP).\nchange 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + size_chunk Mint64) Cur Readable) (B : (align_chunk Mint64 | ofs)) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"simpl in *.\nexploit load_loadbytes.\neexact H.\nsimpl.\nintros [bytes [LB EQ]].\nchange 8 with (4 + 4) in LB.\nexploit loadbytes_split.\neexact LB.\nlia.\nlia.\nintros (bytes1 & bytes2 & LB1 & LB2 & APP).\nchange 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"exploit load_loadbytes.\neexact H.\nsimpl.\nintros [bytes [LB EQ]].\nchange 8 with (4 + 4) in LB.\nexploit loadbytes_split.\neexact LB.\nlia.\nlia.\nintros (bytes1 & bytes2 & LB1 & LB2 & APP).\nchange 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) : (exists bytes : list memval,\n   loadbytes m b ofs 8 = Some bytes /\\ v = decode_val Mint64 bytes) ->\nexists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"intros [bytes [LB EQ]].\nchange 8 with (4 + 4) in LB.\nexploit loadbytes_split.\neexact LB.\nlia.\nlia.\nintros (bytes1 & bytes2 & LB1 & LB2 & APP).\nchange 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs 8 = Some bytes) (EQ : v = decode_val Mint64 bytes) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"change 8 with (4 + 4) in LB.\nexploit loadbytes_split.\neexact LB.\nlia.\nlia.\nintros (bytes1 & bytes2 & LB1 & LB2 & APP).\nchange 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"exploit loadbytes_split.\neexact LB.\nlia.\nlia.\nintros (bytes1 & bytes2 & LB1 & LB2 & APP).\nchange 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs 4 = Some bytes1) (LB2 : loadbytes m b (ofs + 4) 4 = Some bytes2) (APP : bytes = bytes1 ++ bytes2) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"change 4 with (size_chunk Mint32) in LB1.\nexploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + 4) 4 = Some bytes2) (APP : bytes = bytes1 ++ bytes2) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"exploit loadbytes_load.\neexact LB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nintros L1.\nchange 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + 4) 4 = Some bytes2) (APP : bytes = bytes1 ++ bytes2) : (4 | ofs).","proofString":"apply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + 4) 4 = Some bytes2) (APP : bytes = bytes1 ++ bytes2) : (4 | 8).","proofString":"exists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + 4) 4 = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"change 4 with (size_chunk Mint32) in LB2.\nexploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"exploit loadbytes_load.\neexact LB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto.\nintros L2.\nexists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) : (4 | ofs + 4).","proofString":"apply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) : (4 | ofs).","proofString":"apply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) : (4 | 8).","proofString":"exists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) : (4 | 4).","proofString":"exists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : exists v1 v2 : val,\n  load Mint32 m b ofs = Some (if Archi.big_endian then v1 else v2) /\\\n  load Mint32 m b (ofs + 4) = Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef v (Val.longofwords v1 v2).","proofString":"exists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).\nsplit.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : load Mint32 m b ofs =\nSome\n  (if Archi.big_endian\n   then decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2)\n   else decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)) /\\\nload Mint32 m b (ofs + 4) =\nSome\n  (if Archi.big_endian\n   then decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)\n   else decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2)) /\\\nVal.lessdef v\n  (Val.longofwords\n     (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2))\n     (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1))).","proofString":"split.\ndestruct Archi.big_endian; auto.\nsplit.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : load Mint32 m b ofs =\nSome\n  (if Archi.big_endian\n   then decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2)\n   else decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).","proofString":"destruct Archi.big_endian; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : load Mint32 m b (ofs + 4) =\nSome\n  (if Archi.big_endian\n   then decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)\n   else decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2)) /\\\nVal.lessdef v\n  (Val.longofwords\n     (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2))\n     (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1))).","proofString":"split.\ndestruct Archi.big_endian; auto.\nrewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : load Mint32 m b (ofs + 4) =\nSome\n  (if Archi.big_endian\n   then decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)\n   else decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2)).","proofString":"destruct Archi.big_endian; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : Val.lessdef v\n  (Val.longofwords\n     (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2))\n     (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1))).","proofString":"rewrite EQ.\nrewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : Val.lessdef (decode_val Mint64 bytes)\n  (Val.longofwords\n     (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2))\n     (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1))).","proofString":"rewrite APP.\napply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : Val.lessdef (decode_val Mint64 (bytes1 ++ bytes2))\n  (Val.longofwords\n     (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2))\n     (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1))).","proofString":"apply decode_val_int64; auto.\nerewrite loadbytes_length; eauto.\nreflexivity.\nerewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : Datatypes.length bytes1 = 4%nat.","proofString":"erewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : Z.to_nat (size_chunk Mint32) = 4%nat.","proofString":"reflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : Datatypes.length bytes2 = 4%nat.","proofString":"erewrite loadbytes_length; eauto.\nreflexivity."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (H : load Mint64 m b ofs = Some v) (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Readable) (B : (8 | ofs)) (bytes : list memval) (LB : loadbytes m b ofs (4 + 4) = Some bytes) (EQ : v = decode_val Mint64 bytes) (bytes1 bytes2 : list memval) (LB1 : loadbytes m b ofs (size_chunk Mint32) = Some bytes1) (LB2 : loadbytes m b (ofs + size_chunk Mint32) (size_chunk Mint32) = Some bytes2) (APP : bytes = bytes1 ++ bytes2) (L1 : load Mint32 m b ofs = Some (decode_val Mint32 bytes1)) (L2 : load Mint32 m b (ofs + size_chunk Mint32) = Some (decode_val Mint32 bytes2)) : Z.to_nat (size_chunk Mint32) = 4%nat.","proofString":"reflexivity."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : Ptrofs.unsigned (Ptrofs.add i (Ptrofs.of_int (Int.repr 4))) =\nPtrofs.unsigned i + 4.","proofString":"rewrite Ptrofs.add_unsigned.\nreplace (Ptrofs.unsigned (Ptrofs.of_int (Int.repr 4))) with (Int.unsigned (Int.repr 4))    by (symmetry; apply Ptrofs.agree32_of_int; auto).\nchange (Int.unsigned (Int.repr 4)) with 4.\napply Ptrofs.unsigned_repr.\nexploit (Zdivide_interval (Ptrofs.unsigned i) Ptrofs.modulus 8).\nlia.\napply Ptrofs.unsigned_range.\nauto.\nexists (two_p (Ptrofs.zwordsize - 3)).\nunfold Ptrofs.modulus, Ptrofs.zwordsize, Ptrofs.wordsize.\nunfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity.\nunfold Ptrofs.max_unsigned.\nlia."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : Ptrofs.unsigned\n  (Ptrofs.repr\n     (Ptrofs.unsigned i + Ptrofs.unsigned (Ptrofs.of_int (Int.repr 4)))) =\nPtrofs.unsigned i + 4.","proofString":"replace (Ptrofs.unsigned (Ptrofs.of_int (Int.repr 4))) with (Int.unsigned (Int.repr 4))    by (symmetry; apply Ptrofs.agree32_of_int; auto).\nchange (Int.unsigned (Int.repr 4)) with 4.\napply Ptrofs.unsigned_repr.\nexploit (Zdivide_interval (Ptrofs.unsigned i) Ptrofs.modulus 8).\nlia.\napply Ptrofs.unsigned_range.\nauto.\nexists (two_p (Ptrofs.zwordsize - 3)).\nunfold Ptrofs.modulus, Ptrofs.zwordsize, Ptrofs.wordsize.\nunfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity.\nunfold Ptrofs.max_unsigned.\nlia."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : Ptrofs.unsigned (Ptrofs.repr (Ptrofs.unsigned i + Int.unsigned (Int.repr 4))) =\nPtrofs.unsigned i + 4.","proofString":"change (Int.unsigned (Int.repr 4)) with 4.\napply Ptrofs.unsigned_repr.\nexploit (Zdivide_interval (Ptrofs.unsigned i) Ptrofs.modulus 8).\nlia.\napply Ptrofs.unsigned_range.\nauto.\nexists (two_p (Ptrofs.zwordsize - 3)).\nunfold Ptrofs.modulus, Ptrofs.zwordsize, Ptrofs.wordsize.\nunfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity.\nunfold Ptrofs.max_unsigned.\nlia."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : Ptrofs.unsigned (Ptrofs.repr (Ptrofs.unsigned i + 4)) = Ptrofs.unsigned i + 4.","proofString":"apply Ptrofs.unsigned_repr.\nexploit (Zdivide_interval (Ptrofs.unsigned i) Ptrofs.modulus 8).\nlia.\napply Ptrofs.unsigned_range.\nauto.\nexists (two_p (Ptrofs.zwordsize - 3)).\nunfold Ptrofs.modulus, Ptrofs.zwordsize, Ptrofs.wordsize.\nunfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity.\nunfold Ptrofs.max_unsigned.\nlia."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : 0 <= Ptrofs.unsigned i + 4 <= Ptrofs.max_unsigned.","proofString":"exploit (Zdivide_interval (Ptrofs.unsigned i) Ptrofs.modulus 8).\nlia.\napply Ptrofs.unsigned_range.\nauto.\nexists (two_p (Ptrofs.zwordsize - 3)).\nunfold Ptrofs.modulus, Ptrofs.zwordsize, Ptrofs.wordsize.\nunfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity.\nunfold Ptrofs.max_unsigned.\nlia."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : 0 < 8.","proofString":"lia."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : 0 <= Ptrofs.unsigned i < Ptrofs.modulus.","proofString":"apply Ptrofs.unsigned_range."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : (8 | Ptrofs.unsigned i).","proofString":"auto."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : (8 | Ptrofs.modulus).","proofString":"exists (two_p (Ptrofs.zwordsize - 3)).\nunfold Ptrofs.modulus, Ptrofs.zwordsize, Ptrofs.wordsize.\nunfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : Ptrofs.modulus = two_p (Ptrofs.zwordsize - 3) * 8.","proofString":"unfold Ptrofs.modulus, Ptrofs.zwordsize, Ptrofs.wordsize.\nunfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : two_power_nat Wordsize_Ptrofs.wordsize =\ntwo_p (Z.of_nat Wordsize_Ptrofs.wordsize - 3) * 8.","proofString":"unfold Wordsize_Ptrofs.wordsize.\ndestruct Archi.ptr64; reflexivity."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : two_power_nat (if Archi.ptr64 then 64%nat else 32%nat) =\ntwo_p (Z.of_nat (if Archi.ptr64 then 64%nat else 32%nat) - 3) * 8.","proofString":"destruct Archi.ptr64; reflexivity."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : 0 <= Ptrofs.unsigned i <= Ptrofs.modulus - 8 ->\n0 <= Ptrofs.unsigned i + 4 <= Ptrofs.max_unsigned.","proofString":"unfold Ptrofs.max_unsigned.\nlia."},{"statement":"(i : ptrofs) (H : Archi.ptr64 = false) (H0 : (8 | Ptrofs.unsigned i)) : 0 <= Ptrofs.unsigned i <= Ptrofs.modulus - 8 ->\n0 <= Ptrofs.unsigned i + 4 <= Ptrofs.modulus - 1.","proofString":"lia."},{"statement":"(m1 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : valid_access m1 chunk b ofs Writable) : {m2 : mem | store chunk m1 b ofs v = Some m2}.","proofString":"unfold store.\ndestruct (valid_access_dec m1 chunk b ofs Writable).\neauto.\ncontradiction."},{"statement":"(m1 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : valid_access m1 chunk b ofs Writable) : {m2 : mem\n| (if valid_access_dec m1 chunk b ofs Writable\n   then\n    Some\n      {|\n        mem_contents :=\n          PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n            (mem_contents m1);\n        mem_access := mem_access m1;\n        nextblock := nextblock m1;\n        access_max :=\n          fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n        nextblock_noaccess :=\n          fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n            (H0 : ~ Plt b0 (nextblock m1)) =>\n          store_obligation_2 m1 b0 ofs0 k H0;\n        contents_default :=\n          fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n      |}\n   else None) = Some m2}.","proofString":"destruct (valid_access_dec m1 chunk b ofs Writable).\neauto.\ncontradiction."},{"statement":"(m1 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H v0 : valid_access m1 chunk b ofs Writable) : {m2 : mem\n| Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H0 : ~ Plt b0 (nextblock m1)) =>\n        store_obligation_2 m1 b0 ofs0 k H0;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n    |} = Some m2}.","proofString":"eauto."},{"statement":"(m1 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : valid_access m1 chunk b ofs Writable) (n : ~ valid_access m1 chunk b ofs Writable) : {m2 : mem | None = Some m2}.","proofString":"contradiction."},{"statement":"(v0 : valid_access m1 chunk b ofs Writable) : mem_access\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |} = mem_access m1.","proofString":"auto."},{"statement":"(v0 : valid_access m1 chunk b ofs Writable) : mem_contents\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |} =\nPMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n  (mem_contents m1).","proofString":"auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm m1 b' ofs' k p) : perm m2 b' ofs' k p.","proofString":"unfold perm in *.\nrewrite store_access; auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs' k) p) : perm_order' ((mem_access m2) # b' ofs' k) p.","proofString":"rewrite store_access; auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm m2 b' ofs' k p) : perm m1 b' ofs' k p.","proofString":"unfold perm in *.\nrewrite store_access in H; auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m2) # b' ofs' k) p) : perm_order' ((mem_access m1) # b' ofs' k) p.","proofString":"rewrite store_access in H; auto."},{"statement":"nextblock m2 = nextblock m1.","proofString":"unfold store in STORE.\ndestruct ( valid_access_dec m1 chunk b ofs Writable); inv STORE.\nauto."},{"statement":"(v0 : valid_access m1 chunk b ofs Writable) : nextblock\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |} = nextblock m1.","proofString":"auto."},{"statement":"(b' : block) (H : Plt b' (nextblock m1)) : Plt b' (nextblock m2).","proofString":"rewrite nextblock_store; auto."},{"statement":"(b' : block) (H : Plt b' (nextblock m2)) : Plt b' (nextblock m1).","proofString":"rewrite nextblock_store in H; auto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H : valid_access m1 chunk' b' ofs' p) : valid_access m2 chunk' b' ofs' p.","proofString":"inv H.\nconstructor; try red; auto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H0 : range_perm m1 b' ofs' (ofs' + size_chunk chunk') Cur p) (H1 : (align_chunk chunk' | ofs')) : valid_access m2 chunk' b' ofs' p.","proofString":"constructor; try red; auto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H : valid_access m2 chunk' b' ofs' p) : valid_access m1 chunk' b' ofs' p.","proofString":"inv H.\nconstructor; try red; auto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H0 : range_perm m2 b' ofs' (ofs' + size_chunk chunk') Cur p) (H1 : (align_chunk chunk' | ofs')) : valid_access m1 chunk' b' ofs' p.","proofString":"constructor; try red; auto with mem."},{"statement":"(v0 : valid_access m1 chunk b ofs Writable) : valid_access m1 chunk b ofs Writable.","proofString":"auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) : exists v' : val,\n  load chunk' m2 b ofs = Some v' /\\ decode_encode_val v chunk chunk' v'.","proofString":"exploit (valid_access_load m2 chunk').\neapply valid_access_compat.\nsymmetry; eauto.\nauto.\neauto with mem.\nintros [v' LOAD].\nexists v'; split; auto.\nexploit load_result; eauto.\nintros B.\nrewrite B.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') : exists v'0 : val,\n  load chunk' m2 b ofs = Some v'0 /\\ decode_encode_val v chunk chunk' v'0.","proofString":"exists v'; split; auto.\nexploit load_result; eauto.\nintros B.\nrewrite B.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') : decode_encode_val v chunk chunk' v'.","proofString":"exploit load_result; eauto.\nintros B.\nrewrite B.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b) ->\ndecode_encode_val v chunk chunk' v'.","proofString":"intros B.\nrewrite B.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : decode_encode_val v chunk chunk' v'.","proofString":"rewrite B.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : decode_encode_val v chunk chunk'\n  (decode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)).","proofString":"rewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : decode_encode_val v chunk chunk'\n  (decode_val chunk'\n     (getN (size_chunk_nat chunk') ofs\n        (PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n           (mem_contents m1)) # b)).","proofString":"rewrite PMap.gss.\nreplace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : decode_encode_val v chunk chunk'\n  (decode_val chunk'\n     (getN (size_chunk_nat chunk') ofs\n        (setN (encode_val chunk v) ofs (mem_contents m1) # b))).","proofString":"replace (size_chunk_nat chunk') with (length (encode_val chunk v)).\nrewrite getN_setN_same.\napply decode_encode_val_general.\nrewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : decode_encode_val v chunk chunk'\n  (decode_val chunk'\n     (getN (Datatypes.length (encode_val chunk v)) ofs\n        (setN (encode_val chunk v) ofs (mem_contents m1) # b))).","proofString":"rewrite getN_setN_same.\napply decode_encode_val_general."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : decode_encode_val v chunk chunk' (decode_val chunk' (encode_val chunk v)).","proofString":"apply decode_encode_val_general."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : Datatypes.length (encode_val chunk v) = size_chunk_nat chunk'.","proofString":"rewrite encode_val_length.\nrepeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : size_chunk_nat chunk = size_chunk_nat chunk'.","proofString":"repeat rewrite size_chunk_conv in H.\napply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : Z.of_nat (size_chunk_nat chunk') = Z.of_nat (size_chunk_nat chunk)) (H0 : align_chunk chunk' <= align_chunk chunk) (v' : val) (LOAD : load chunk' m2 b ofs = Some v') (B : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs (mem_contents m2) # b)) : size_chunk_nat chunk = size_chunk_nat chunk'.","proofString":"apply Nat2Z.inj; auto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (H1 : type_of_chunk chunk' = type_of_chunk chunk) : load chunk' m2 b ofs = Some (Val.load_result chunk' v).","proofString":"destruct (load_store_similar chunk') as [v' [A B]]; auto.\nrewrite A.\ndecEq.\neapply decode_encode_val_similar with (chunk1 := chunk); eauto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (H1 : type_of_chunk chunk' = type_of_chunk chunk) (v' : val) (A : load chunk' m2 b ofs = Some v') (B : decode_encode_val v chunk chunk' v') : load chunk' m2 b ofs = Some (Val.load_result chunk' v).","proofString":"rewrite A.\ndecEq.\neapply decode_encode_val_similar with (chunk1 := chunk); eauto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (H1 : type_of_chunk chunk' = type_of_chunk chunk) (v' : val) (A : load chunk' m2 b ofs = Some v') (B : decode_encode_val v chunk chunk' v') : Some v' = Some (Val.load_result chunk' v).","proofString":"decEq.\neapply decode_encode_val_similar with (chunk1 := chunk); eauto."},{"statement":"(chunk' : memory_chunk) (H : size_chunk chunk' = size_chunk chunk) (H0 : align_chunk chunk' <= align_chunk chunk) (H1 : type_of_chunk chunk' = type_of_chunk chunk) (v' : val) (A : load chunk' m2 b ofs = Some v') (B : decode_encode_val v chunk chunk' v') : v' = Val.load_result chunk' v.","proofString":"eapply decode_encode_val_similar with (chunk1 := chunk); eauto."},{"statement":"align_chunk chunk <= align_chunk chunk.","proofString":"lia."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : load chunk' m2 b' ofs' = load chunk' m1 b' ofs'.","proofString":"unfold load.\ndestruct (valid_access_dec m1 chunk' b' ofs' Readable).\nrewrite pred_dec_true.\ndecEq.\ndecEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto.\neauto with mem.\nrewrite pred_dec_false.\nauto.\neauto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : (if valid_access_dec m2 chunk' b' ofs' Readable\n then\n  Some\n    (decode_val chunk'\n       (getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b'))\n else None) =\n(if valid_access_dec m1 chunk' b' ofs' Readable\n then\n  Some\n    (decode_val chunk'\n       (getN (size_chunk_nat chunk') ofs' (mem_contents m1) # b'))\n else None).","proofString":"destruct (valid_access_dec m1 chunk' b' ofs' Readable).\nrewrite pred_dec_true.\ndecEq.\ndecEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto.\neauto with mem.\nrewrite pred_dec_false.\nauto.\neauto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) : (if valid_access_dec m2 chunk' b' ofs' Readable\n then\n  Some\n    (decode_val chunk'\n       (getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b'))\n else None) =\nSome\n  (decode_val chunk'\n     (getN (size_chunk_nat chunk') ofs' (mem_contents m1) # b')).","proofString":"rewrite pred_dec_true.\ndecEq.\ndecEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto.\neauto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) : Some\n  (decode_val chunk'\n     (getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b')) =\nSome\n  (decode_val chunk'\n     (getN (size_chunk_nat chunk') ofs' (mem_contents m1) # b')).","proofString":"decEq.\ndecEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) : decode_val chunk' (getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b') =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs' (mem_contents m1) # b').","proofString":"decEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) : getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b' =\ngetN (size_chunk_nat chunk') ofs' (mem_contents m1) # b'.","proofString":"rewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) : getN (size_chunk_nat chunk') ofs'\n  (PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n     (mem_contents m1)) # b' =\ngetN (size_chunk_nat chunk') ofs' (mem_contents m1) # b'.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) : getN (size_chunk_nat chunk') ofs'\n  (if peq b' b\n   then setN (encode_val chunk v) ofs (mem_contents m1) # b\n   else (mem_contents m1) # b') =\ngetN (size_chunk_nat chunk') ofs' (mem_contents m1) # b'.","proofString":"destruct (peq b' b).\nsubst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition.\nauto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) (e : b' = b) : getN (size_chunk_nat chunk') ofs'\n  (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (size_chunk_nat chunk') ofs' (mem_contents m1) # b'.","proofString":"subst b'.\napply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition."},{"statement":"(chunk' : memory_chunk) (ofs' : Z) (v0 : valid_access m1 chunk' b ofs' Readable) (H : b <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : getN (size_chunk_nat chunk') ofs'\n  (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (size_chunk_nat chunk') ofs' (mem_contents m1) # b.","proofString":"apply getN_setN_outside.\nrewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition."},{"statement":"(chunk' : memory_chunk) (ofs' : Z) (v0 : valid_access m1 chunk' b ofs' Readable) (H : b <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : ofs' + Z.of_nat (size_chunk_nat chunk') <= ofs \\/\nofs + Z.of_nat (Datatypes.length (encode_val chunk v)) <= ofs'.","proofString":"rewrite encode_val_length.\nrepeat rewrite <- size_chunk_conv.\nintuition."},{"statement":"(chunk' : memory_chunk) (ofs' : Z) (v0 : valid_access m1 chunk' b ofs' Readable) (H : b <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : ofs' + Z.of_nat (size_chunk_nat chunk') <= ofs \\/\nofs + Z.of_nat (size_chunk_nat chunk) <= ofs'.","proofString":"repeat rewrite <- size_chunk_conv.\nintuition."},{"statement":"(chunk' : memory_chunk) (ofs' : Z) (v0 : valid_access m1 chunk' b ofs' Readable) (H : b <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"intuition."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) (n : b' <> b) : getN (size_chunk_nat chunk') ofs' (mem_contents m1) # b' =\ngetN (size_chunk_nat chunk') ofs' (mem_contents m1) # b'.","proofString":"auto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (v0 : valid_access m1 chunk' b' ofs' Readable) : valid_access m2 chunk' b' ofs' Readable.","proofString":"eauto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (n : ~ valid_access m1 chunk' b' ofs' Readable) : (if valid_access_dec m2 chunk' b' ofs' Readable\n then\n  Some\n    (decode_val chunk'\n       (getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b'))\n else None) = None.","proofString":"rewrite pred_dec_false.\nauto.\neauto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') (n : ~ valid_access m1 chunk' b' ofs' Readable) : ~ valid_access m2 chunk' b' ofs' Readable.","proofString":"eauto with mem."},{"statement":"loadbytes m2 b ofs (size_chunk chunk) = Some (encode_val chunk v).","proofString":"assert (valid_access m2 chunk b ofs Readable) by eauto with mem.\nunfold loadbytes.\nrewrite pred_dec_true.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (Z.to_nat (size_chunk chunk)) with (length (encode_val chunk v)).\nrewrite getN_setN_same.\nauto.\nrewrite encode_val_length.\nauto.\napply H."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : loadbytes m2 b ofs (size_chunk chunk) = Some (encode_val chunk v).","proofString":"unfold loadbytes.\nrewrite pred_dec_true.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (Z.to_nat (size_chunk chunk)) with (length (encode_val chunk v)).\nrewrite getN_setN_same.\nauto.\nrewrite encode_val_length.\nauto.\napply H."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : (if range_perm_dec m2 b ofs (ofs + size_chunk chunk) Cur Readable\n then Some (getN (Z.to_nat (size_chunk chunk)) ofs (mem_contents m2) # b)\n else None) = Some (encode_val chunk v).","proofString":"rewrite pred_dec_true.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (Z.to_nat (size_chunk chunk)) with (length (encode_val chunk v)).\nrewrite getN_setN_same.\nauto.\nrewrite encode_val_length.\nauto.\napply H."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : Some (getN (Z.to_nat (size_chunk chunk)) ofs (mem_contents m2) # b) =\nSome (encode_val chunk v).","proofString":"rewrite store_mem_contents; simpl.\nrewrite PMap.gss.\nreplace (Z.to_nat (size_chunk chunk)) with (length (encode_val chunk v)).\nrewrite getN_setN_same.\nauto.\nrewrite encode_val_length.\nauto."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : Some\n  (getN (Z.to_nat (size_chunk chunk)) ofs\n     (PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1)) # b) = Some (encode_val chunk v).","proofString":"rewrite PMap.gss.\nreplace (Z.to_nat (size_chunk chunk)) with (length (encode_val chunk v)).\nrewrite getN_setN_same.\nauto.\nrewrite encode_val_length.\nauto."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : Some\n  (getN (Z.to_nat (size_chunk chunk)) ofs\n     (setN (encode_val chunk v) ofs (mem_contents m1) # b)) =\nSome (encode_val chunk v).","proofString":"replace (Z.to_nat (size_chunk chunk)) with (length (encode_val chunk v)).\nrewrite getN_setN_same.\nauto.\nrewrite encode_val_length.\nauto."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : Some\n  (getN (Datatypes.length (encode_val chunk v)) ofs\n     (setN (encode_val chunk v) ofs (mem_contents m1) # b)) =\nSome (encode_val chunk v).","proofString":"rewrite getN_setN_same.\nauto."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : Some (encode_val chunk v) = Some (encode_val chunk v).","proofString":"auto."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : Datatypes.length (encode_val chunk v) = Z.to_nat (size_chunk chunk).","proofString":"rewrite encode_val_length.\nauto."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : size_chunk_nat chunk = Z.to_nat (size_chunk chunk).","proofString":"auto."},{"statement":"(H : valid_access m2 chunk b ofs Readable) : range_perm m2 b ofs (ofs + size_chunk chunk) Cur Readable.","proofString":"apply H."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') : loadbytes m2 b' ofs' n = loadbytes m1 b' ofs' n.","proofString":"unfold loadbytes.\ndestruct (range_perm_dec m1 b' ofs' (ofs' + n) Cur Readable).\nrewrite pred_dec_true.\ndecEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia.\nauto.\nred; intros.\neauto with mem.\nrewrite pred_dec_false.\nauto.\nred; intro; elim n0; red; intros; eauto with mem."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') : (if range_perm_dec m2 b' ofs' (ofs' + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs' (mem_contents m2) # b')\n else None) =\n(if range_perm_dec m1 b' ofs' (ofs' + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs' (mem_contents m1) # b')\n else None).","proofString":"destruct (range_perm_dec m1 b' ofs' (ofs' + n) Cur Readable).\nrewrite pred_dec_true.\ndecEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia.\nauto.\nred; intros.\neauto with mem.\nrewrite pred_dec_false.\nauto.\nred; intro; elim n0; red; intros; eauto with mem."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) : (if range_perm_dec m2 b' ofs' (ofs' + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs' (mem_contents m2) # b')\n else None) = Some (getN (Z.to_nat n) ofs' (mem_contents m1) # b').","proofString":"rewrite pred_dec_true.\ndecEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia.\nauto.\nred; intros.\neauto with mem."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) : Some (getN (Z.to_nat n) ofs' (mem_contents m2) # b') =\nSome (getN (Z.to_nat n) ofs' (mem_contents m1) # b').","proofString":"decEq.\nrewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia.\nauto."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) : getN (Z.to_nat n) ofs' (mem_contents m2) # b' =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b'.","proofString":"rewrite store_mem_contents; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia.\nauto."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) : getN (Z.to_nat n) ofs'\n  (PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n     (mem_contents m1)) # b' = getN (Z.to_nat n) ofs' (mem_contents m1) # b'.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia.\nauto."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) : getN (Z.to_nat n) ofs'\n  (if peq b' b\n   then setN (encode_val chunk v) ofs (mem_contents m1) # b\n   else (mem_contents m1) # b') =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b'.","proofString":"destruct (peq b' b).\nsubst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia.\nauto."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) (e : b' = b) : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b'.","proofString":"subst b'.\ndestruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : b <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b.","proofString":"destruct H.\ncongruence.\ndestruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : b <> b) : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b.","proofString":"congruence."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b.","proofString":"destruct (zle n 0) as [z | n0].\nrewrite (Z_to_nat_neg _ z).\nauto.\ndestruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (z : n <= 0) : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b.","proofString":"rewrite (Z_to_nat_neg _ z).\nauto."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (z : n <= 0) : getN 0 ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN 0 ofs' (mem_contents m1) # b.","proofString":"auto."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : n > 0) : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b.","proofString":"destruct H.\nextlia.\napply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : n <= 0) (n0 : n > 0) : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b.","proofString":"extlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : n > 0) : getN (Z.to_nat n) ofs' (setN (encode_val chunk v) ofs (mem_contents m1) # b) =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b.","proofString":"apply getN_setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : n > 0) : ofs' + Z.of_nat (Z.to_nat n) <= ofs \\/\nofs + Z.of_nat (Datatypes.length (encode_val chunk v)) <= ofs'.","proofString":"rewrite encode_val_length.\nrewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : n > 0) : ofs' + Z.of_nat (Z.to_nat n) <= ofs \\/\nofs + Z.of_nat (size_chunk_nat chunk) <= ofs'.","proofString":"rewrite <- size_chunk_conv.\nrewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : n > 0) : ofs' + Z.of_nat (Z.to_nat n) <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"rewrite Z2Nat.id.\nauto.\nlia."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : n > 0) : ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"auto."},{"statement":"(ofs' n : Z) (r : range_perm m1 b ofs' (ofs' + n) Cur Readable) (H : ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : n > 0) : 0 <= n.","proofString":"lia."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) (n0 : b' <> b) : getN (Z.to_nat n) ofs' (mem_contents m1) # b' =\ngetN (Z.to_nat n) ofs' (mem_contents m1) # b'.","proofString":"auto."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) : range_perm m2 b' ofs' (ofs' + n) Cur Readable.","proofString":"red; intros.\neauto with mem."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (r : range_perm m1 b' ofs' (ofs' + n) Cur Readable) (ofs0 : Z) (H0 : ofs' <= ofs0 < ofs' + n) : perm m2 b' ofs0 Cur Readable.","proofString":"eauto with mem."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : ~ range_perm m1 b' ofs' (ofs' + n) Cur Readable) : (if range_perm_dec m2 b' ofs' (ofs' + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs' (mem_contents m2) # b')\n else None) = None.","proofString":"rewrite pred_dec_false.\nauto.\nred; intro; elim n0; red; intros; eauto with mem."},{"statement":"(b' : block) (ofs' n : Z) (H : b' <> b \\/ n <= 0 \\/ ofs' + n <= ofs \\/ ofs + size_chunk chunk <= ofs') (n0 : ~ range_perm m1 b' ofs' (ofs' + n) Cur Readable) : ~ range_perm m2 b' ofs' (ofs' + n) Cur Readable.","proofString":"red; intro; elim n0; red; intros; eauto with mem."},{"statement":"(p q : Z) (c : ZMap.t memval) (H : p <= q < p + 0) : In (ZMap.get q (setN nil p c)) nil.","proofString":"extlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.of_nat (Datatypes.length (a :: vl))) : In (ZMap.get q (setN (a :: vl) p c)) (a :: vl).","proofString":"simpl length in H.\nrewrite Nat2Z.inj_succ in H.\nsimpl.\ndestruct (zeq p q).\nsubst q.\nrewrite setN_outside.\nrewrite ZMap.gss.\nauto with coqlib.\nlia.\nright.\napply IHvl.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.of_nat (S (Datatypes.length vl))) : In (ZMap.get q (setN (a :: vl) p c)) (a :: vl).","proofString":"rewrite Nat2Z.inj_succ in H.\nsimpl.\ndestruct (zeq p q).\nsubst q.\nrewrite setN_outside.\nrewrite ZMap.gss.\nauto with coqlib.\nlia.\nright.\napply IHvl.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.succ (Z.of_nat (Datatypes.length vl))) : In (ZMap.get q (setN (a :: vl) p c)) (a :: vl).","proofString":"simpl.\ndestruct (zeq p q).\nsubst q.\nrewrite setN_outside.\nrewrite ZMap.gss.\nauto with coqlib.\nlia.\nright.\napply IHvl.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.succ (Z.of_nat (Datatypes.length vl))) : a = ZMap.get q (setN vl (p + 1) (ZMap.set p a c)) \\/\nIn (ZMap.get q (setN vl (p + 1) (ZMap.set p a c))) vl.","proofString":"destruct (zeq p q).\nsubst q.\nrewrite setN_outside.\nrewrite ZMap.gss.\nauto with coqlib.\nlia.\nright.\napply IHvl.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.succ (Z.of_nat (Datatypes.length vl))) (e : p = q) : a = ZMap.get q (setN vl (p + 1) (ZMap.set p a c)) \\/\nIn (ZMap.get q (setN vl (p + 1) (ZMap.set p a c))) vl.","proofString":"subst q.\nrewrite setN_outside.\nrewrite ZMap.gss.\nauto with coqlib.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q : Z) (c0 : ZMap.t memval),\np0 <= q < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q (setN vl p0 c0)) vl) (p : Z) (c : ZMap.t memval) (H : p <= p < p + Z.succ (Z.of_nat (Datatypes.length vl))) : a = ZMap.get p (setN vl (p + 1) (ZMap.set p a c)) \\/\nIn (ZMap.get p (setN vl (p + 1) (ZMap.set p a c))) vl.","proofString":"rewrite setN_outside.\nrewrite ZMap.gss.\nauto with coqlib.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q : Z) (c0 : ZMap.t memval),\np0 <= q < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q (setN vl p0 c0)) vl) (p : Z) (c : ZMap.t memval) (H : p <= p < p + Z.succ (Z.of_nat (Datatypes.length vl))) : a = ZMap.get p (ZMap.set p a c) \\/ In (ZMap.get p (ZMap.set p a c)) vl.","proofString":"rewrite ZMap.gss.\nauto with coqlib."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q : Z) (c0 : ZMap.t memval),\np0 <= q < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q (setN vl p0 c0)) vl) (p : Z) (c : ZMap.t memval) (H : p <= p < p + Z.succ (Z.of_nat (Datatypes.length vl))) : a = a \\/ In a vl.","proofString":"auto with coqlib."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q : Z) (c0 : ZMap.t memval),\np0 <= q < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q (setN vl p0 c0)) vl) (p : Z) (c : ZMap.t memval) (H : p <= p < p + Z.succ (Z.of_nat (Datatypes.length vl))) : p < p + 1 \\/ p >= p + 1 + Z.of_nat (Datatypes.length vl).","proofString":"lia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.succ (Z.of_nat (Datatypes.length vl))) (n : p <> q) : a = ZMap.get q (setN vl (p + 1) (ZMap.set p a c)) \\/\nIn (ZMap.get q (setN vl (p + 1) (ZMap.set p a c))) vl.","proofString":"right.\napply IHvl.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.succ (Z.of_nat (Datatypes.length vl))) (n : p <> q) : In (ZMap.get q (setN vl (p + 1) (ZMap.set p a c))) vl.","proofString":"apply IHvl.\nlia."},{"statement":"(a : memval) (vl : list memval) (IHvl : forall (p0 q0 : Z) (c0 : ZMap.t memval),\np0 <= q0 < p0 + Z.of_nat (Datatypes.length vl) ->\nIn (ZMap.get q0 (setN vl p0 c0)) vl) (p q : Z) (c : ZMap.t memval) (H : p <= q < p + Z.succ (Z.of_nat (Datatypes.length vl))) (n : p <> q) : p + 1 <= q < p + 1 + Z.of_nat (Datatypes.length vl).","proofString":"lia."},{"statement":"(c : ZMap.t memval) (q p : Z) (H : p <= q < p + Z.of_nat 0) : In (ZMap.get q c) (getN 0 p c).","proofString":"simpl in H; extlia."},{"statement":"(c : ZMap.t memval) (q : Z) (n : nat) (IHn : forall p0 : Z, p0 <= q < p0 + Z.of_nat n -> In (ZMap.get q c) (getN n p0 c)) (p : Z) (H : p <= q < p + Z.of_nat (S n)) : In (ZMap.get q c) (getN (S n) p c).","proofString":"rewrite Nat2Z.inj_succ in H.\nsimpl.\ndestruct (zeq p q).\nsubst q.\nauto.\nright.\napply IHn.\nlia."},{"statement":"(c : ZMap.t memval) (q : Z) (n : nat) (IHn : forall p0 : Z, p0 <= q < p0 + Z.of_nat n -> In (ZMap.get q c) (getN n p0 c)) (p : Z) (H : p <= q < p + Z.succ (Z.of_nat n)) : In (ZMap.get q c) (getN (S n) p c).","proofString":"simpl.\ndestruct (zeq p q).\nsubst q.\nauto.\nright.\napply IHn.\nlia."},{"statement":"(c : ZMap.t memval) (q : Z) (n : nat) (IHn : forall p0 : Z, p0 <= q < p0 + Z.of_nat n -> In (ZMap.get q c) (getN n p0 c)) (p : Z) (H : p <= q < p + Z.succ (Z.of_nat n)) : ZMap.get p c = ZMap.get q c \\/ In (ZMap.get q c) (getN n (p + 1) c).","proofString":"destruct (zeq p q).\nsubst q.\nauto.\nright.\napply IHn.\nlia."},{"statement":"(c : ZMap.t memval) (q : Z) (n : nat) (IHn : forall p0 : Z, p0 <= q < p0 + Z.of_nat n -> In (ZMap.get q c) (getN n p0 c)) (p : Z) (H : p <= q < p + Z.succ (Z.of_nat n)) (e : p = q) : ZMap.get p c = ZMap.get q c \\/ In (ZMap.get q c) (getN n (p + 1) c).","proofString":"subst q.\nauto."},{"statement":"(c : ZMap.t memval) (n : nat) (p : Z) (H : p <= p < p + Z.succ (Z.of_nat n)) (IHn : forall p0 : Z, p0 <= p < p0 + Z.of_nat n -> In (ZMap.get p c) (getN n p0 c)) : ZMap.get p c = ZMap.get p c \\/ In (ZMap.get p c) (getN n (p + 1) c).","proofString":"auto."},{"statement":"(c : ZMap.t memval) (q : Z) (n : nat) (IHn : forall p0 : Z, p0 <= q < p0 + Z.of_nat n -> In (ZMap.get q c) (getN n p0 c)) (p : Z) (H : p <= q < p + Z.succ (Z.of_nat n)) (n0 : p <> q) : ZMap.get p c = ZMap.get q c \\/ In (ZMap.get q c) (getN n (p + 1) c).","proofString":"right.\napply IHn.\nlia."},{"statement":"(c : ZMap.t memval) (q : Z) (n : nat) (IHn : forall p0 : Z, p0 <= q < p0 + Z.of_nat n -> In (ZMap.get q c) (getN n p0 c)) (p : Z) (H : p <= q < p + Z.succ (Z.of_nat n)) (n0 : p <> q) : In (ZMap.get q c) (getN n (p + 1) c).","proofString":"apply IHn.\nlia."},{"statement":"(c : ZMap.t memval) (q : Z) (n : nat) (IHn : forall p0 : Z, p0 <= q < p0 + Z.of_nat n -> In (ZMap.get q c) (getN n p0 c)) (p : Z) (H : p <= q < p + Z.succ (Z.of_nat n)) (n0 : p <> q) : p + 1 <= q < p + 1 + Z.of_nat n.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') : exists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"exploit load_result; eauto.\nerewrite store_mem_contents by eauto; simpl.\nrewrite PMap.gss.\nset (c := (mem_contents m1)#b).\nintros V'.\ndestruct (size_chunk_nat_pos chunk) as [sz SIZE].\ndestruct (size_chunk_nat_pos chunk') as [sz' SIZE'].\ndestruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') : v' =\ndecode_val chunk' (getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b) ->\nexists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"erewrite store_mem_contents by eauto; simpl.\nrewrite PMap.gss.\nset (c := (mem_contents m1)#b).\nintros V'.\ndestruct (size_chunk_nat_pos chunk) as [sz SIZE].\ndestruct (size_chunk_nat_pos chunk') as [sz' SIZE'].\ndestruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') : v' =\ndecode_val chunk'\n  (getN (size_chunk_nat chunk') ofs'\n     (PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1)) # b) ->\nexists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"rewrite PMap.gss.\nset (c := (mem_contents m1)#b).\nintros V'.\ndestruct (size_chunk_nat_pos chunk) as [sz SIZE].\ndestruct (size_chunk_nat_pos chunk') as [sz' SIZE'].\ndestruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') : v' =\ndecode_val chunk'\n  (getN (size_chunk_nat chunk') ofs'\n     (setN (encode_val chunk v) ofs (mem_contents m1) # b)) ->\nexists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"set (c := (mem_contents m1)#b).\nintros V'.\ndestruct (size_chunk_nat_pos chunk) as [sz SIZE].\ndestruct (size_chunk_nat_pos chunk') as [sz' SIZE'].\ndestruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) : v' =\ndecode_val chunk'\n  (getN (size_chunk_nat chunk') ofs' (setN (encode_val chunk v) ofs c)) ->\nexists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"intros V'.\ndestruct (size_chunk_nat_pos chunk) as [sz SIZE].\ndestruct (size_chunk_nat_pos chunk') as [sz' SIZE'].\ndestruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (V' : v' =\ndecode_val chunk'\n  (getN (size_chunk_nat chunk') ofs' (setN (encode_val chunk v) ofs c))) : exists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"destruct (size_chunk_nat_pos chunk) as [sz SIZE].\ndestruct (size_chunk_nat_pos chunk') as [sz' SIZE'].\ndestruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (V' : v' =\ndecode_val chunk'\n  (getN (size_chunk_nat chunk') ofs' (setN (encode_val chunk v) ofs c))) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) : exists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"destruct (size_chunk_nat_pos chunk') as [sz' SIZE'].\ndestruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (V' : v' =\ndecode_val chunk'\n  (getN (size_chunk_nat chunk') ofs' (setN (encode_val chunk v) ofs c))) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : exists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"destruct (encode_val chunk v) as [ | mv1 mvl] eqn:ENC.\ngeneralize (encode_val_length chunk v); rewrite ENC; simpl; congruence.\nset (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (ENC : encode_val chunk v = nil) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' (setN nil ofs c))) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : exists\n  (mv1 : memval) (mvl : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv1 :: mvl) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv1 \\/\n   ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl').","proofString":"generalize (encode_val_length chunk v); rewrite ENC; simpl; congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (V' : v' =\ndecode_val chunk'\n  (getN (size_chunk_nat chunk') ofs' (setN (mv1 :: mvl) ofs c))) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : exists\n  (mv0 : memval) (mvl0 : list memval) (mv1' : memval) \n(mvl' : list memval),\n  shape_encoding chunk v (mv0 :: mvl0) /\\\n  shape_decoding chunk' (mv1' :: mvl') v' /\\\n  (ofs' = ofs /\\ mv1' = mv0 \\/\n   ofs' > ofs /\\ In mv1' mvl0 \\/ ofs' < ofs /\\ In mv0 mvl').","proofString":"set (c' := setN (mv1::mvl) ofs c) in *.\nexists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').\nsplit.\nrewrite <- ENC.\napply encode_val_shape.\nsplit.\nrewrite V', SIZE'.\napply decode_val_shape.\ndestruct (zeq ofs' ofs).\nsubst ofs'.\nleft; split.\nauto.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss.\nright.\ndestruct (zlt ofs ofs').\nleft; split.\nlia.\nunfold c'.\nsimpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia.\nright; split.\nlia.\nreplace mv1 with (ZMap.get ofs c').\napply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia.\nunfold c'.\nsimpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : shape_encoding chunk v (mv1 :: mvl).","proofString":"rewrite <- ENC.\napply encode_val_shape."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : shape_encoding chunk v (encode_val chunk v).","proofString":"apply encode_val_shape."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : shape_decoding chunk' (ZMap.get ofs' c' :: getN sz' (ofs' + 1) c') v'.","proofString":"rewrite V', SIZE'.\napply decode_val_shape."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : shape_decoding chunk' (ZMap.get ofs' c' :: getN sz' (ofs' + 1) c')\n  (decode_val chunk' (getN (S sz') ofs' c')).","proofString":"apply decode_val_shape."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H2 : ofs + size_chunk chunk > ofs) (H1 : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some v') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : ofs = ofs.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H2 : ofs + size_chunk chunk > ofs) (H1 : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some v') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : ZMap.get ofs (setN (mv1 :: mvl) ofs c) = mv1.","proofString":"simpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H2 : ofs + size_chunk chunk > ofs) (H1 : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some v') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : ZMap.get ofs (setN mvl (ofs + 1) (ZMap.set ofs mv1 c)) = mv1.","proofString":"rewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H2 : ofs + size_chunk chunk > ofs) (H1 : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some v') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') : ZMap.get ofs (ZMap.set ofs mv1 c) = mv1.","proofString":"apply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') : ofs' > ofs.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') : In (ZMap.get ofs' (setN (mv1 :: mvl) ofs c)) mvl.","proofString":"simpl.\napply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') : In (ZMap.get ofs' (setN mvl (ofs + 1) (ZMap.set ofs mv1 c))) mvl.","proofString":"apply setN_in.\nassert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') : ofs + 1 <= ofs' < ofs + 1 + Z.of_nat (Datatypes.length mvl).","proofString":"assert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).\nrewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto.\nsimpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') : Z.of_nat (Datatypes.length (mv1 :: mvl)) = size_chunk chunk.","proofString":"rewrite <- ENC; rewrite encode_val_length.\nrewrite size_chunk_conv; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') : Z.of_nat (size_chunk_nat chunk) = size_chunk chunk.","proofString":"rewrite size_chunk_conv; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') (H3 : Z.of_nat (Datatypes.length (mv1 :: mvl)) = size_chunk chunk) : ofs + 1 <= ofs' < ofs + 1 + Z.of_nat (Datatypes.length mvl).","proofString":"simpl length in H3.\nrewrite Nat2Z.inj_succ in H3.\nlia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') (H3 : Z.of_nat (S (Datatypes.length mvl)) = size_chunk chunk) : ofs + 1 <= ofs' < ofs + 1 + Z.of_nat (Datatypes.length mvl).","proofString":"rewrite Nat2Z.inj_succ in H3.\nlia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (l : ofs < ofs') (H3 : Z.succ (Z.of_nat (Datatypes.length mvl)) = size_chunk chunk) : ofs + 1 <= ofs' < ofs + 1 + Z.of_nat (Datatypes.length mvl).","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : ofs' < ofs.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : In (ZMap.get ofs c') (getN sz' (ofs' + 1) c').","proofString":"apply getN_in.\nassert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : ofs' + 1 <= ofs < ofs' + 1 + Z.of_nat sz'.","proofString":"assert (size_chunk chunk' = Z.succ (Z.of_nat sz')).\nrewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto.\nlia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : size_chunk chunk' = Z.succ (Z.of_nat sz').","proofString":"rewrite size_chunk_conv.\nrewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : Z.of_nat (size_chunk_nat chunk') = Z.succ (Z.of_nat sz').","proofString":"rewrite SIZE'.\nrewrite Nat2Z.inj_succ; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : Z.of_nat (S sz') = Z.succ (Z.of_nat sz').","proofString":"rewrite Nat2Z.inj_succ; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') (H3 : size_chunk chunk' = Z.succ (Z.of_nat sz')) : ofs' + 1 <= ofs < ofs' + 1 + Z.of_nat sz'.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : ZMap.get ofs (setN (mv1 :: mvl) ofs c) = mv1.","proofString":"simpl.\nrewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : ZMap.get ofs (setN mvl (ofs + 1) (ZMap.set ofs mv1 c)) = mv1.","proofString":"rewrite setN_outside by lia.\napply ZMap.gss."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some v') (H1 : ofs' + size_chunk chunk' > ofs) (H2 : ofs + size_chunk chunk > ofs') (c : ZMap.t memval) (mv1 : memval) (mvl : list memval) (ENC : encode_val chunk v = mv1 :: mvl) (c' : ZMap.t memval) (V' : v' = decode_val chunk' (getN (size_chunk_nat chunk') ofs' c')) (sz : nat) (SIZE : size_chunk_nat chunk = S sz) (sz' : nat) (SIZE' : size_chunk_nat chunk' = S sz') (n : ofs' <> ofs) (g : ofs >= ofs') : ZMap.get ofs (ZMap.set ofs mv1 c) = mv1.","proofString":"apply ZMap.gss."},{"statement":"(chunk1 chunk2 : memory_chunk) (H : chunk1 = Mint32 \\/ chunk1 = Many32 \\/ chunk1 = Mint64 \\/ chunk1 = Many64) (H0 : chunk2 = Mint32 \\/ chunk2 = Many32 \\/ chunk2 = Mint64 \\/ chunk2 = Many64) (H1 : quantity_chunk chunk1 = quantity_chunk chunk2) : compat_pointer_chunks chunk1 chunk2.","proofString":"destruct H as [P|[P|[P|P]]]; destruct H0 as [Q|[Q|[Q|Q]]];  subst; red; auto; discriminate."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (b' : block) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b' ofs' = Some (Vptr v_b v_o)) : v = Vptr v_b v_o /\\\ncompat_pointer_chunks chunk chunk' /\\ b' = b /\\ ofs' = ofs \\/\nb' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"destruct (peq b' b); auto.\nsubst b'.\ndestruct (zle (ofs' + size_chunk chunk') ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) ofs'); auto.\nexploit load_store_overlap; eauto.\nintros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ninv DEC; try contradiction.\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (b' : block) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b' ofs' = Some (Vptr v_b v_o)) (e : b' = b) : v = Vptr v_b v_o /\\\ncompat_pointer_chunks chunk chunk' /\\ b' = b /\\ ofs' = ofs \\/\nb' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"subst b'.\ndestruct (zle (ofs' + size_chunk chunk') ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) ofs'); auto.\nexploit load_store_overlap; eauto.\nintros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ninv DEC; try contradiction.\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) : v = Vptr v_b v_o /\\ compat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"destruct (zle (ofs' + size_chunk chunk') ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) ofs'); auto.\nexploit load_store_overlap; eauto.\nintros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ninv DEC; try contradiction.\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) : v = Vptr v_b v_o /\\ compat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"destruct (zle (ofs + size_chunk chunk) ofs'); auto.\nexploit load_store_overlap; eauto.\nintros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ninv DEC; try contradiction.\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') : v = Vptr v_b v_o /\\ compat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"exploit load_store_overlap; eauto.\nintros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ninv DEC; try contradiction.\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') : (exists\n   (mv1 : memval) (mvl : list memval) (mv1' : memval) \n (mvl' : list memval),\n   shape_encoding chunk v (mv1 :: mvl) /\\\n   shape_decoding chunk' (mv1' :: mvl') (Vptr v_b v_o) /\\\n   (ofs' = ofs /\\ mv1' = mv1 \\/\n    ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl')) ->\nv = Vptr v_b v_o /\\ compat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ninv DEC; try contradiction.\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk v (mv1 :: mvl)) (DEC : shape_decoding chunk' (mv1' :: mvl') (Vptr v_b v_o)) (CASES : ofs' = ofs /\\ mv1' = mv1 \\/\nofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl') : v = Vptr v_b v_o /\\ compat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"inv DEC; try contradiction.\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk v (mv1 :: mvl)) (v0 : val) (i : nat) (CASES : ofs' = ofs /\\ Fragment v0 (quantity_chunk chunk') i = mv1 \\/\nofs' > ofs /\\ In (Fragment v0 (quantity_chunk chunk') i) mvl \\/\nofs' < ofs /\\ In mv1 mvl') (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"destruct CASES as [(A & B) | [(A & B) | (A & B)]].\nsubst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto.\ninv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence.\nexploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk v (mv1 :: mvl)) (v0 : val) (i : nat) (A : ofs' = ofs) (B : Fragment v0 (quantity_chunk chunk') i = mv1) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"subst.\ninv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (v0 : val) (i : nat) (ENC : shape_encoding chunk v (Fragment v0 (quantity_chunk chunk') i :: mvl)) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs = ofs \\/\nb <> b \\/ ofs + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs.","proofString":"inv ENC.\nassert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (i : nat) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S i = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) : v0 = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs = ofs \\/\nb <> b \\/ ofs + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs.","proofString":"assert (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)  by (destruct chunk; auto || contradiction).\nleft; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (i : nat) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S i = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H1 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : v0 = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs = ofs \\/\nb <> b \\/ ofs + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs.","proofString":"left; split.\nrewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence.\nsplit.\napply compat_pointer_chunks_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (i : nat) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S i = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H1 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : v0 = Val.load_result chunk' v0.","proofString":"rewrite H3.\ndestruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (i : nat) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S i = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H1 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : v0 = Vptr v_b v_o.","proofString":"destruct H4 as [P|[P|[P|P]]]; subst chunk'; destruct v0; simpl in H3;  try congruence; destruct Archi.ptr64; congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (i : nat) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S i = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H1 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : compat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs = ofs.","proofString":"split.\napply compat_pointer_chunks_true; auto.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (i : nat) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S i = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H1 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : compat_pointer_chunks chunk chunk'.","proofString":"apply compat_pointer_chunks_true; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (g0 : ofs + size_chunk chunk > ofs) (g : ofs + size_chunk chunk' > ofs) (H0 : load chunk' m2 b ofs = Some (Vptr v_b v_o)) (mvl mvl' : list memval) (i : nat) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S i = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H1 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : b = b /\\ ofs = ofs.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk v (mv1 :: mvl)) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"inv ENC.\nexploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence.\nexploit H8; eauto.\nintros (n & P); congruence.\nexploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (i0 : nat) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H9 : S i0 = size_quantity_nat (quantity_chunk chunk)) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"exploit H10; eauto.\nintros (j & P & Q).\ninv P.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (i0 : nat) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H9 : S i0 = size_quantity_nat (quantity_chunk chunk)) : (exists j : nat,\n   Fragment v0 (quantity_chunk chunk') i =\n   Fragment v (quantity_chunk chunk) j /\\\n   S j <> size_quantity_nat (quantity_chunk chunk)) ->\nv = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"intros (j & P & Q).\ninv P.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (i0 : nat) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment v (quantity_chunk chunk) j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk)) (H9 : S i0 = size_quantity_nat (quantity_chunk chunk)) (j : nat) (P : Fragment v0 (quantity_chunk chunk') i = Fragment v (quantity_chunk chunk) j) (Q : S j <> size_quantity_nat (quantity_chunk chunk)) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"inv P.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (A : ofs' > ofs) (j : nat) (B : In (Fragment v (quantity_chunk chunk') j) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment v (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H6 : S j = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v = Vptr v_b v_o) (i0 : nat) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment v (quantity_chunk chunk) j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk)) (H9 : S i0 = size_quantity_nat (quantity_chunk chunk)) (Q : S j <> size_quantity_nat (quantity_chunk chunk)) (H8 : quantity_chunk chunk' = quantity_chunk chunk) : v = Val.load_result chunk' v /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (b0 : byte) (H5 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl -> exists b' : byte, mv = Byte b') : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"exploit H8; eauto.\nintros (n & P); congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (b0 : byte) (H5 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl -> exists b' : byte, mv = Byte b') : (exists b' : byte, Fragment v0 (quantity_chunk chunk') i = Byte b') ->\nv = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"intros (n & P); congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H2 : forall mv : memval, In mv mvl -> mv = Undef) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"exploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (i : nat) (A : ofs' > ofs) (B : In (Fragment v0 (quantity_chunk chunk') i) mvl) (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (H2 : forall mv : memval, In mv mvl -> mv = Undef) : Fragment v0 (quantity_chunk chunk') i = Undef ->\nv = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk v (mv1 :: mvl)) (v0 : val) (i : nat) (A : ofs' < ofs) (B : In mv1 mvl') (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"exploit H7; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk v (mv1 :: mvl)) (v0 : val) (i : nat) (A : ofs' < ofs) (B : In mv1 mvl') (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) : (exists j : nat,\n   mv1 = Fragment v0 (quantity_chunk chunk') j /\\\n   S j <> size_quantity_nat (quantity_chunk chunk')) ->\nv = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"intros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk v (mv1 :: mvl)) (v0 : val) (i : nat) (A : ofs' < ofs) (B : In mv1 mvl') (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (j : nat) (P : mv1 = Fragment v0 (quantity_chunk chunk') j) (Q : S j <> size_quantity_nat (quantity_chunk chunk')) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"subst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v : val) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (H : store chunk m1 b ofs v = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (v0 : val) (j : nat) (ENC : shape_encoding chunk v (Fragment v0 (quantity_chunk chunk') j :: mvl)) (i : nat) (A : ofs' < ofs) (B : In (Fragment v0 (quantity_chunk chunk') j) mvl') (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (Q : S j <> size_quantity_nat (quantity_chunk chunk')) : v = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"inv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v_b : block) (v_o : ptrofs) (v0 : val) (H : store chunk m1 b ofs v0 = Some m2) (H0 : load chunk' m2 b ofs' = Some (Vptr v_b v_o)) (g : ofs' + size_chunk chunk' > ofs) (g0 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (j i : nat) (A : ofs' < ofs) (B : In (Fragment v0 (quantity_chunk chunk') j) mvl') (H4 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H7 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H6 : S i = size_quantity_nat (quantity_chunk chunk')) (H3 : Val.load_result chunk' v0 = Vptr v_b v_o) (Q : S j <> size_quantity_nat (quantity_chunk chunk')) (H9 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H10 : quantity_chunk chunk' = quantity_chunk chunk) (H11 : S j = size_quantity_nat (quantity_chunk chunk')) (H12 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) : v0 = Val.load_result chunk' v0 /\\\ncompat_pointer_chunks chunk chunk' /\\ b = b /\\ ofs' = ofs \\/\nb <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') : v = Vundef.","proofString":"exploit load_store_overlap; eauto.\nintros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\ncongruence.\ninv ENC.\nexploit H9; eauto.\nintros (j & P & Q).\nsubst mv1'.\ninv DEC.\ncongruence.\nauto.\ncontradiction.\nexploit H5; eauto.\nintros; subst.\ninv DEC; auto.\ninv DEC.\nexploit H10; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence.\nexploit H8; eauto.\nintros (n & P).\nsubst mv1.\ninv ENC.\ncontradiction.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') : (exists\n   (mv1 : memval) (mvl : list memval) (mv1' : memval) \n (mvl' : list memval),\n   shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl) /\\\n   shape_decoding chunk' (mv1' :: mvl') v /\\\n   (ofs' = ofs /\\ mv1' = mv1 \\/\n    ofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl')) -> \nv = Vundef.","proofString":"intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]].\ncongruence.\ninv ENC.\nexploit H9; eauto.\nintros (j & P & Q).\nsubst mv1'.\ninv DEC.\ncongruence.\nauto.\ncontradiction.\nexploit H5; eauto.\nintros; subst.\ninv DEC; auto.\ninv DEC.\nexploit H10; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence.\nexploit H8; eauto.\nintros (n & P).\nsubst mv1.\ninv ENC.\ncontradiction.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (CASES : ofs' = ofs /\\ mv1' = mv1 \\/\nofs' > ofs /\\ In mv1' mvl \\/ ofs' < ofs /\\ In mv1 mvl') : v = Vundef.","proofString":"destruct CASES as [(A & B) | [(A & B) | (A & B)]].\ncongruence.\ninv ENC.\nexploit H9; eauto.\nintros (j & P & Q).\nsubst mv1'.\ninv DEC.\ncongruence.\nauto.\ncontradiction.\nexploit H5; eauto.\nintros; subst.\ninv DEC; auto.\ninv DEC.\nexploit H10; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence.\nexploit H8; eauto.\nintros (n & P).\nsubst mv1.\ninv ENC.\ncontradiction.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' = ofs) (B : mv1' = mv1) : v = Vundef.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' > ofs) (B : In mv1' mvl) : v = Vundef.","proofString":"inv ENC.\nexploit H9; eauto.\nintros (j & P & Q).\nsubst mv1'.\ninv DEC.\ncongruence.\nauto.\ncontradiction.\nexploit H5; eauto.\nintros; subst.\ninv DEC; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl : list memval) (mv1' : memval) (mvl' : list memval) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' > ofs) (B : In mv1' mvl) (i : nat) (H6 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H9 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H8 : S i = size_quantity_nat (quantity_chunk chunk)) : v = Vundef.","proofString":"exploit H9; eauto.\nintros (j & P & Q).\nsubst mv1'.\ninv DEC.\ncongruence.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl : list memval) (mv1' : memval) (mvl' : list memval) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' > ofs) (B : In mv1' mvl) (i : nat) (H6 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H9 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H8 : S i = size_quantity_nat (quantity_chunk chunk)) : (exists j : nat,\n   mv1' = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j /\\\n   S j <> size_quantity_nat (quantity_chunk chunk)) -> \nv = Vundef.","proofString":"intros (j & P & Q).\nsubst mv1'.\ninv DEC.\ncongruence.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl : list memval) (mv1' : memval) (mvl' : list memval) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' > ofs) (B : In mv1' mvl) (i : nat) (H6 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H9 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk)) (H8 : S i = size_quantity_nat (quantity_chunk chunk)) (j : nat) (P : mv1' = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j) (Q : S j <> size_quantity_nat (quantity_chunk chunk)) : v = Vundef.","proofString":"subst mv1'.\ninv DEC.\ncongruence.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (j : nat) (DEC : shape_decoding chunk'\n  (Fragment (Vptr v_b v_o) (quantity_chunk chunk) j :: mvl') v) (A : ofs' > ofs) (B : In (Fragment (Vptr v_b v_o) (quantity_chunk chunk) j) mvl) (i : nat) (H6 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H9 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk)) (H8 : S i = size_quantity_nat (quantity_chunk chunk)) (Q : S j <> size_quantity_nat (quantity_chunk chunk)) : v = Vundef.","proofString":"inv DEC.\ncongruence.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some (Val.load_result chunk' (Vptr v_b v_o))) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (j : nat) (A : ofs' > ofs) (B : In (Fragment (Vptr v_b v_o) (quantity_chunk chunk) j) mvl) (i : nat) (H6 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H9 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk)) (H8 : S i = size_quantity_nat (quantity_chunk chunk)) (Q : S j <> size_quantity_nat (quantity_chunk chunk)) (H11 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H13 : quantity_chunk chunk = quantity_chunk chunk') (H14 : S j = size_quantity_nat (quantity_chunk chunk)) (H15 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk)) : Val.load_result chunk' (Vptr v_b v_o) = Vundef.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some Vundef) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (j : nat) (A : ofs' > ofs) (B : In (Fragment (Vptr v_b v_o) (quantity_chunk chunk) j) mvl) (i : nat) (H6 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H9 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk)) (H8 : S i = size_quantity_nat (quantity_chunk chunk)) (Q : S j <> size_quantity_nat (quantity_chunk chunk)) : Vundef = Vundef.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl : list memval) (mv1' : memval) (mvl' : list memval) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' > ofs) (B : In mv1' mvl) (b0 : byte) (H6 : False) (H7 : forall mv : memval, In mv mvl -> exists b' : byte, mv = Byte b') : v = Vundef.","proofString":"contradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl : list memval) (mv1' : memval) (mvl' : list memval) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' > ofs) (B : In mv1' mvl) (H5 : forall mv : memval, In mv mvl -> mv = Undef) : v = Vundef.","proofString":"exploit H5; eauto.\nintros; subst.\ninv DEC; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl : list memval) (mv1' : memval) (mvl' : list memval) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' > ofs) (B : In mv1' mvl) (H5 : forall mv : memval, In mv mvl -> mv = Undef) : mv1' = Undef -> v = Vundef.","proofString":"intros; subst.\ninv DEC; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (DEC : shape_decoding chunk' (Undef :: mvl') v) (A : ofs' > ofs) (B : In Undef mvl) (H5 : forall mv : memval, In mv mvl -> mv = Undef) : v = Vundef.","proofString":"inv DEC; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs' < ofs) (B : In mv1 mvl') : v = Vundef.","proofString":"inv DEC.\nexploit H10; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence.\nexploit H8; eauto.\nintros (n & P).\nsubst mv1.\ninv ENC.\ncontradiction.\nauto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (v0 : val) (H0 : load chunk' m2 b ofs' = Some (Val.load_result chunk' v0)) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (A : ofs' < ofs) (B : In mv1 mvl') (i : nat) (H6 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H10 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H8 : S i = size_quantity_nat (quantity_chunk chunk')) : Val.load_result chunk' v0 = Vundef.","proofString":"exploit H10; eauto.\nintros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (v0 : val) (H0 : load chunk' m2 b ofs' = Some (Val.load_result chunk' v0)) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (A : ofs' < ofs) (B : In mv1 mvl') (i : nat) (H6 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H10 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk')) (H8 : S i = size_quantity_nat (quantity_chunk chunk')) : (exists j : nat,\n   mv1 = Fragment v0 (quantity_chunk chunk') j /\\\n   S j <> size_quantity_nat (quantity_chunk chunk')) ->\nVal.load_result chunk' v0 = Vundef.","proofString":"intros (j & P & Q).\nsubst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (v0 : val) (H0 : load chunk' m2 b ofs' = Some (Val.load_result chunk' v0)) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (A : ofs' < ofs) (B : In mv1 mvl') (i : nat) (H6 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H10 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H8 : S i = size_quantity_nat (quantity_chunk chunk')) (j : nat) (P : mv1 = Fragment v0 (quantity_chunk chunk') j) (Q : S j <> size_quantity_nat (quantity_chunk chunk')) : Val.load_result chunk' v0 = Vundef.","proofString":"subst mv1.\ninv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (v0 : val) (H0 : load chunk' m2 b ofs' = Some (Val.load_result chunk' v0)) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (j : nat) (ENC : shape_encoding chunk (Vptr v_b v_o)\n  (Fragment v0 (quantity_chunk chunk') j :: mvl)) (A : ofs' < ofs) (B : In (Fragment v0 (quantity_chunk chunk') j) mvl') (i : nat) (H6 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H10 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment v0 (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H8 : S i = size_quantity_nat (quantity_chunk chunk')) (Q : S j <> size_quantity_nat (quantity_chunk chunk')) : Val.load_result chunk' v0 = Vundef.","proofString":"inv ENC.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some (Val.load_result chunk' (Vptr v_b v_o))) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (j : nat) (A : ofs' < ofs) (B : In (Fragment (Vptr v_b v_o) (quantity_chunk chunk') j) mvl') (i : nat) (H6 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H10 : forall mv : memval,\nIn mv mvl' ->\nexists j0 : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) (H8 : S i = size_quantity_nat (quantity_chunk chunk')) (Q : S j <> size_quantity_nat (quantity_chunk chunk')) (H11 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H12 : quantity_chunk chunk' = quantity_chunk chunk) (H13 : S j = size_quantity_nat (quantity_chunk chunk')) (H14 : forall mv : memval,\nIn mv mvl ->\nexists j0 : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk') j0 /\\\n  S j0 <> size_quantity_nat (quantity_chunk chunk')) : Val.load_result chunk' (Vptr v_b v_o) = Vundef.","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (A : ofs' < ofs) (B : In mv1 mvl') (b0 : byte) (H6 : match v with\n| Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl' -> exists b' : byte, mv = Byte b') : v = Vundef.","proofString":"exploit H8; eauto.\nintros (n & P).\nsubst mv1.\ninv ENC.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (A : ofs' < ofs) (B : In mv1 mvl') (b0 : byte) (H6 : match v with\n| Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl' -> exists b' : byte, mv = Byte b') : (exists b' : byte, mv1 = Byte b') -> v = Vundef.","proofString":"intros (n & P).\nsubst mv1.\ninv ENC.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (A : ofs' < ofs) (B : In mv1 mvl') (b0 : byte) (H6 : match v with\n| Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl' -> exists b' : byte, mv = Byte b') (n : byte) (P : mv1 = Byte n) : v = Vundef.","proofString":"subst mv1.\ninv ENC.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (n : byte) (ENC : shape_encoding chunk (Vptr v_b v_o) (Byte n :: mvl)) (A : ofs' < ofs) (B : In (Byte n) mvl') (b0 : byte) (H6 : match v with\n| Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl' -> exists b' : byte, mv = Byte b') : v = Vundef.","proofString":"inv ENC.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some v) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mvl mvl' : list memval) (n : byte) (A : ofs' < ofs) (B : In (Byte n) mvl') (b0 : byte) (H6 : match v with\n| Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl' -> exists b' : byte, mv = Byte b') (H7 : False) (H9 : forall mv : memval, In mv mvl -> exists b' : byte, mv = Byte b') : v = Vundef.","proofString":"contradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (ofs' : Z) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs' = Some Vundef) (H1 : ofs' <> ofs) (H2 : ofs' + size_chunk chunk' > ofs) (H3 : ofs + size_chunk chunk > ofs') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (A : ofs' < ofs) (B : In mv1 mvl') : Vundef = Vundef.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some v) (H1 : ~ compat_pointer_chunks chunk chunk') : v = Vundef.","proofString":"exploit load_store_overlap; eauto.\ngeneralize (size_chunk_pos chunk'); lia.\ngeneralize (size_chunk_pos chunk); lia.\nintros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]]; try extlia.\ninv ENC; inv DEC; auto.\nelim H1.\napply compat_pointer_chunks_true; auto.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some v) (H1 : ~ compat_pointer_chunks chunk chunk') : ofs + size_chunk chunk' > ofs.","proofString":"generalize (size_chunk_pos chunk'); lia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some v) (H1 : ~ compat_pointer_chunks chunk chunk') : ofs + size_chunk chunk > ofs.","proofString":"generalize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some v) (H1 : ~ compat_pointer_chunks chunk chunk') : (exists\n   (mv1 : memval) (mvl : list memval) (mv1' : memval) \n (mvl' : list memval),\n   shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl) /\\\n   shape_decoding chunk' (mv1' :: mvl') v /\\\n   (ofs = ofs /\\ mv1' = mv1 \\/\n    ofs > ofs /\\ In mv1' mvl \\/ ofs < ofs /\\ In mv1 mvl')) -> \nv = Vundef.","proofString":"intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).\ndestruct CASES as [(A & B) | [(A & B) | (A & B)]]; try extlia.\ninv ENC; inv DEC; auto.\nelim H1.\napply compat_pointer_chunks_true; auto.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some v) (H1 : ~ compat_pointer_chunks chunk chunk') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (CASES : ofs = ofs /\\ mv1' = mv1 \\/\nofs > ofs /\\ In mv1' mvl \\/ ofs < ofs /\\ In mv1 mvl') : v = Vundef.","proofString":"destruct CASES as [(A & B) | [(A & B) | (A & B)]]; try extlia.\ninv ENC; inv DEC; auto.\nelim H1.\napply compat_pointer_chunks_true; auto.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some v) (H1 : ~ compat_pointer_chunks chunk chunk') (mv1 : memval) (mvl : list memval) (mv1' : memval) (mvl' : list memval) (ENC : shape_encoding chunk (Vptr v_b v_o) (mv1 :: mvl)) (DEC : shape_decoding chunk' (mv1' :: mvl') v) (A : ofs = ofs) (B : mv1' = mv1) : v = Vundef.","proofString":"inv ENC; inv DEC; auto.\nelim H1.\napply compat_pointer_chunks_true; auto.\ncontradiction."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some (Val.load_result chunk' (Vptr v_b v_o))) (H1 : ~ compat_pointer_chunks chunk chunk') (mvl mvl' : list memval) (i : nat) (A : ofs = ofs) (H4 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H7 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H6 : S i = size_quantity_nat (quantity_chunk chunk)) (H9 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H11 : quantity_chunk chunk = quantity_chunk chunk') (H12 : S i = size_quantity_nat (quantity_chunk chunk)) (H13 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) : Val.load_result chunk' (Vptr v_b v_o) = Vundef.","proofString":"elim H1.\napply compat_pointer_chunks_true; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some (Val.load_result chunk' (Vptr v_b v_o))) (H1 : ~ compat_pointer_chunks chunk chunk') (mvl mvl' : list memval) (i : nat) (A : ofs = ofs) (H4 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H7 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H6 : S i = size_quantity_nat (quantity_chunk chunk)) (H9 : chunk' = Mint32 \\/ chunk' = Many32 \\/ chunk' = Mint64 \\/ chunk' = Many64) (H11 : quantity_chunk chunk = quantity_chunk chunk') (H12 : S i = size_quantity_nat (quantity_chunk chunk)) (H13 : forall mv : memval,\nIn mv mvl' ->\nexists j : nat,\n  mv = Fragment (Vptr v_b v_o) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) : compat_pointer_chunks chunk chunk'.","proofString":"apply compat_pointer_chunks_true; auto."},{"statement":"(chunk : memory_chunk) (m1 : mem) (b : block) (ofs : Z) (v_b : block) (v_o : ptrofs) (m2 : mem) (chunk' : memory_chunk) (v : val) (H : store chunk m1 b ofs (Vptr v_b v_o) = Some m2) (H0 : load chunk' m2 b ofs = Some v) (H1 : ~ compat_pointer_chunks chunk chunk') (mvl mvl' : list memval) (b0 : byte) (A : ofs = ofs) (H4 : False) (H5 : forall mv : memval, In mv mvl -> exists b' : byte, mv = Byte b') (H6 : match v with\n| Vptr _ _ => False\n| _ => True\nend) (H8 : forall mv : memval, In mv mvl' -> exists b' : byte, mv = Byte b') : v = Vundef.","proofString":"contradiction."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) : store chunk1 m b ofs v1 = store chunk2 m b ofs v2.","proofString":"unfold store.\nassert (size_chunk chunk1 = size_chunk chunk2).\nrepeat rewrite size_chunk_conv.\nrewrite <- (encode_val_length chunk1 v1).\nrewrite <- (encode_val_length chunk2 v2).\ncongruence.\nunfold store.\ndestruct (valid_access_dec m chunk1 b ofs Writable);  destruct (valid_access_dec m chunk2 b ofs Writable); auto.\nf_equal.\napply mkmem_ext; auto.\ncongruence.\nelim n.\napply valid_access_compat with chunk1; auto.\nlia.\nelim n.\napply valid_access_compat with chunk2; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) : (if valid_access_dec m chunk1 b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk1 v1) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk1 m b ofs v1 b0\n    |}\n else None) =\n(if valid_access_dec m chunk2 b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk2 v2) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk2 m b ofs v2 b0\n    |}\n else None).","proofString":"assert (size_chunk chunk1 = size_chunk chunk2).\nrepeat rewrite size_chunk_conv.\nrewrite <- (encode_val_length chunk1 v1).\nrewrite <- (encode_val_length chunk2 v2).\ncongruence.\nunfold store.\ndestruct (valid_access_dec m chunk1 b ofs Writable);  destruct (valid_access_dec m chunk2 b ofs Writable); auto.\nf_equal.\napply mkmem_ext; auto.\ncongruence.\nelim n.\napply valid_access_compat with chunk1; auto.\nlia.\nelim n.\napply valid_access_compat with chunk2; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) : size_chunk chunk1 = size_chunk chunk2.","proofString":"repeat rewrite size_chunk_conv.\nrewrite <- (encode_val_length chunk1 v1).\nrewrite <- (encode_val_length chunk2 v2).\ncongruence."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) : Z.of_nat (size_chunk_nat chunk1) = Z.of_nat (size_chunk_nat chunk2).","proofString":"rewrite <- (encode_val_length chunk1 v1).\nrewrite <- (encode_val_length chunk2 v2).\ncongruence."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) : Z.of_nat (Datatypes.length (encode_val chunk1 v1)) =\nZ.of_nat (size_chunk_nat chunk2).","proofString":"rewrite <- (encode_val_length chunk2 v2).\ncongruence."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) : Z.of_nat (Datatypes.length (encode_val chunk1 v1)) =\nZ.of_nat (Datatypes.length (encode_val chunk2 v2)).","proofString":"congruence."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) : (if valid_access_dec m chunk1 b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk1 v1) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk1 m b ofs v1 b0\n    |}\n else None) =\n(if valid_access_dec m chunk2 b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk2 v2) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk2 m b ofs v2 b0\n    |}\n else None).","proofString":"unfold store.\ndestruct (valid_access_dec m chunk1 b ofs Writable);  destruct (valid_access_dec m chunk2 b ofs Writable); auto.\nf_equal.\napply mkmem_ext; auto.\ncongruence.\nelim n.\napply valid_access_compat with chunk1; auto.\nlia.\nelim n.\napply valid_access_compat with chunk2; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) : (if valid_access_dec m chunk1 b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk1 v1) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk1 m b ofs v1 b0\n    |}\n else None) =\n(if valid_access_dec m chunk2 b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk2 v2) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk2 m b ofs v2 b0\n    |}\n else None).","proofString":"destruct (valid_access_dec m chunk1 b ofs Writable);  destruct (valid_access_dec m chunk2 b ofs Writable); auto.\nf_equal.\napply mkmem_ext; auto.\ncongruence.\nelim n.\napply valid_access_compat with chunk1; auto.\nlia.\nelim n.\napply valid_access_compat with chunk2; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (v : valid_access m chunk1 b ofs Writable) (v0 : valid_access m chunk2 b ofs Writable) : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk1 v1) ofs (mem_contents m) # b)\n        (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk1 m b ofs v1 b0\n  |} =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk2 v2) ofs (mem_contents m) # b)\n        (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk2 m b ofs v2 b0\n  |}.","proofString":"f_equal.\napply mkmem_ext; auto.\ncongruence."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (v : valid_access m chunk1 b ofs Writable) (v0 : valid_access m chunk2 b ofs Writable) : {|\n  mem_contents :=\n    PMap.set b (setN (encode_val chunk1 v1) ofs (mem_contents m) # b)\n      (mem_contents m);\n  mem_access := mem_access m;\n  nextblock := nextblock m;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n  contents_default :=\n    fun b0 : positive => store_obligation_3 chunk1 m b ofs v1 b0\n|} =\n{|\n  mem_contents :=\n    PMap.set b (setN (encode_val chunk2 v2) ofs (mem_contents m) # b)\n      (mem_contents m);\n  mem_access := mem_access m;\n  nextblock := nextblock m;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n  contents_default :=\n    fun b0 : positive => store_obligation_3 chunk2 m b ofs v2 b0\n|}.","proofString":"apply mkmem_ext; auto.\ncongruence."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (v : valid_access m chunk1 b ofs Writable) (v0 : valid_access m chunk2 b ofs Writable) : PMap.set b (setN (encode_val chunk1 v1) ofs (mem_contents m) # b)\n  (mem_contents m) =\nPMap.set b (setN (encode_val chunk2 v2) ofs (mem_contents m) # b)\n  (mem_contents m).","proofString":"congruence."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (v : valid_access m chunk1 b ofs Writable) (n : ~ valid_access m chunk2 b ofs Writable) : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk1 v1) ofs (mem_contents m) # b)\n        (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk1 m b ofs v1 b0\n  |} = None.","proofString":"elim n.\napply valid_access_compat with chunk1; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (v : valid_access m chunk1 b ofs Writable) (n : ~ valid_access m chunk2 b ofs Writable) : valid_access m chunk2 b ofs Writable.","proofString":"apply valid_access_compat with chunk1; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (v : valid_access m chunk1 b ofs Writable) (n : ~ valid_access m chunk2 b ofs Writable) : align_chunk chunk2 <= align_chunk chunk1.","proofString":"lia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (n : ~ valid_access m chunk1 b ofs Writable) (v : valid_access m chunk2 b ofs Writable) : None =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk2 v2) ofs (mem_contents m) # b)\n        (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) => store_obligation_2 m b0 ofs0 k H2;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk2 m b ofs v2 b0\n  |}.","proofString":"elim n.\napply valid_access_compat with chunk2; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (n : ~ valid_access m chunk1 b ofs Writable) (v : valid_access m chunk2 b ofs Writable) : valid_access m chunk1 b ofs Writable.","proofString":"apply valid_access_compat with chunk2; auto.\nlia."},{"statement":"(chunk1 chunk2 : memory_chunk) (v1 v2 : val) (m : mem) (b : block) (ofs : Z) (H : encode_val chunk1 v1 = encode_val chunk2 v2) (H0 : align_chunk chunk1 = align_chunk chunk2) (H1 : size_chunk chunk1 = size_chunk chunk2) (n : ~ valid_access m chunk1 b ofs Writable) (v : valid_access m chunk2 b ofs Writable) : align_chunk chunk1 <= align_chunk chunk2.","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) : store Mbool m b ofs v = store Mint8unsigned m b ofs v.","proofString":"apply store_similar_chunks; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) : store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.","proofString":"apply store_similar_chunks.\napply encode_val_int8_signed_unsigned.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) : encode_val Mint8signed v = encode_val Mint8unsigned v.","proofString":"apply encode_val_int8_signed_unsigned."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) : align_chunk Mint8signed = align_chunk Mint8unsigned.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) : store Mint16signed m b ofs v = store Mint16unsigned m b ofs v.","proofString":"apply store_similar_chunks.\napply encode_val_int16_signed_unsigned.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) : encode_val Mint16signed v = encode_val Mint16unsigned v.","proofString":"apply encode_val_int16_signed_unsigned."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) : align_chunk Mint16signed = align_chunk Mint16unsigned.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : store Mint8unsigned m b ofs (Vint (Int.zero_ext 8 n)) =\nstore Mint8unsigned m b ofs (Vint n).","proofString":"apply store_similar_chunks.\napply encode_val_int8_zero_ext.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : encode_val Mint8unsigned (Vint (Int.zero_ext 8 n)) =\nencode_val Mint8unsigned (Vint n).","proofString":"apply encode_val_int8_zero_ext."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : align_chunk Mint8unsigned = align_chunk Mint8unsigned.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : store Mint8signed m b ofs (Vint (Int.sign_ext 8 n)) =\nstore Mint8signed m b ofs (Vint n).","proofString":"apply store_similar_chunks.\napply encode_val_int8_sign_ext.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : encode_val Mint8signed (Vint (Int.sign_ext 8 n)) =\nencode_val Mint8signed (Vint n).","proofString":"apply encode_val_int8_sign_ext."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : align_chunk Mint8signed = align_chunk Mint8signed.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : store Mint16unsigned m b ofs (Vint (Int.zero_ext 16 n)) =\nstore Mint16unsigned m b ofs (Vint n).","proofString":"apply store_similar_chunks.\napply encode_val_int16_zero_ext.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : encode_val Mint16unsigned (Vint (Int.zero_ext 16 n)) =\nencode_val Mint16unsigned (Vint n).","proofString":"apply encode_val_int16_zero_ext."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : align_chunk Mint16unsigned = align_chunk Mint16unsigned.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =\nstore Mint16signed m b ofs (Vint n).","proofString":"apply store_similar_chunks.\napply encode_val_int16_sign_ext.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : encode_val Mint16signed (Vint (Int.sign_ext 16 n)) =\nencode_val Mint16signed (Vint n).","proofString":"apply encode_val_int16_sign_ext."},{"statement":"(m : mem) (b : block) (ofs : Z) (n : int) : align_chunk Mint16signed = align_chunk Mint16signed.","proofString":"auto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (bytes : list memval) (H : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : {m2 : mem | storebytes m1 b ofs bytes = Some m2}.","proofString":"unfold storebytes.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable).\neconstructor; reflexivity.\ncontradiction."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (bytes : list memval) (H : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : {m2 : mem\n| (if\n    range_perm_dec m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur\n      Writable\n   then\n    Some\n      {|\n        mem_contents :=\n          PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n        mem_access := mem_access m1;\n        nextblock := nextblock m1;\n        access_max :=\n          fun (b0 : positive) (ofs0 : Z) =>\n          storebytes_obligation_1 m1 b0 ofs0;\n        nextblock_noaccess :=\n          fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n            (H0 : ~ Plt b0 (nextblock m1)) =>\n          storebytes_obligation_2 m1 b0 ofs0 k H0;\n        contents_default :=\n          fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n      |}\n   else None) = Some m2}.","proofString":"destruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable).\neconstructor; reflexivity.\ncontradiction."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (bytes : list memval) (H r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : {m2 : mem\n| Some\n    {|\n      mem_contents :=\n        PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H0 : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H0;\n      contents_default :=\n        fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n    |} = Some m2}.","proofString":"econstructor; reflexivity."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (bytes : list memval) (H : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) (n : ~ range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : {m2 : mem | None = Some m2}.","proofString":"contradiction."},{"statement":"forall (m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) \n  (v : val) (m2 : mem),\n(if\n  range_perm_dec m1 b ofs\n    (ofs + Z.of_nat (Datatypes.length (encode_val chunk v))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n    |}\n else None) = Some m2 ->\n(align_chunk chunk | ofs) ->\n(if valid_access_dec m1 chunk b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n    |}\n else None) = Some m2.","proofString":"intros.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length (encode_val chunk v))) Cur Writable); inv H.\ndestruct (valid_access_dec m1 chunk b ofs Writable).\nf_equal.\napply mkmem_ext; auto.\nelim n.\nconstructor; auto.\nrewrite encode_val_length in r.\nrewrite size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (m2 : mem) (H : (if\n  range_perm_dec m1 b ofs\n    (ofs + Z.of_nat (Datatypes.length (encode_val chunk v))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n    |}\n else None) = Some m2) (H0 : (align_chunk chunk | ofs)) : (if valid_access_dec m1 chunk b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m1)) =>\n        store_obligation_2 m1 b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n    |}\n else None) = Some m2.","proofString":"destruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length (encode_val chunk v))) Cur Writable); inv H.\ndestruct (valid_access_dec m1 chunk b ofs Writable).\nf_equal.\napply mkmem_ext; auto.\nelim n.\nconstructor; auto.\nrewrite encode_val_length in r.\nrewrite size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) (H0 : (align_chunk chunk | ofs)) : (if valid_access_dec m1 chunk b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n    |}\n else None) =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n  |}.","proofString":"destruct (valid_access_dec m1 chunk b ofs Writable).\nf_equal.\napply mkmem_ext; auto.\nelim n.\nconstructor; auto.\nrewrite encode_val_length in r.\nrewrite size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) (H0 : (align_chunk chunk | ofs)) (v0 : valid_access m1 chunk b ofs Writable) : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |} =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n  |}.","proofString":"f_equal.\napply mkmem_ext; auto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) (H0 : (align_chunk chunk | ofs)) (v0 : valid_access m1 chunk b ofs Writable) : {|\n  mem_contents :=\n    PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n      (mem_contents m1);\n  mem_access := mem_access m1;\n  nextblock := nextblock m1;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n  contents_default :=\n    fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n|} =\n{|\n  mem_contents :=\n    PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n      (mem_contents m1);\n  mem_access := mem_access m1;\n  nextblock := nextblock m1;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H : ~ Plt b0 (nextblock m1)) => storebytes_obligation_2 m1 b0 ofs0 k H;\n  contents_default :=\n    fun b0 : positive =>\n    storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n|}.","proofString":"apply mkmem_ext; auto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~ valid_access m1 chunk b ofs Writable) : None =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n  |}.","proofString":"elim n.\nconstructor; auto.\nrewrite encode_val_length in r.\nrewrite size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~ valid_access m1 chunk b ofs Writable) : valid_access m1 chunk b ofs Writable.","proofString":"constructor; auto.\nrewrite encode_val_length in r.\nrewrite size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~ valid_access m1 chunk b ofs Writable) : range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable.","proofString":"rewrite encode_val_length in r.\nrewrite size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (size_chunk_nat chunk)) Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~ valid_access m1 chunk b ofs Writable) : range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable.","proofString":"rewrite size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (r : range_perm m1 b ofs (ofs + Z.of_nat (size_chunk_nat chunk)) Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~ valid_access m1 chunk b ofs Writable) : range_perm m1 b ofs (ofs + Z.of_nat (size_chunk_nat chunk)) Cur Writable.","proofString":"auto."},{"statement":"forall (m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) \n  (v : val) (m2 : mem),\n(if valid_access_dec m1 chunk b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n    |}\n else None) = Some m2 ->\n(if\n  range_perm_dec m1 b ofs\n    (ofs + Z.of_nat (Datatypes.length (encode_val chunk v))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n    |}\n else None) = Some m2.","proofString":"intros.\ndestruct (valid_access_dec m1 chunk b ofs Writable); inv H.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length (encode_val chunk v))) Cur Writable).\nf_equal.\napply mkmem_ext; auto.\ndestruct v0.\nelim n.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (m2 : mem) (H : (if valid_access_dec m1 chunk b ofs Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H0 : ~ Plt b0 (nextblock m1)) =>\n        store_obligation_2 m1 b0 ofs0 k H0;\n      contents_default :=\n        fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n    |}\n else None) = Some m2) : (if\n  range_perm_dec m1 b ofs\n    (ofs + Z.of_nat (Datatypes.length (encode_val chunk v))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H0 : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H0;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n    |}\n else None) = Some m2.","proofString":"destruct (valid_access_dec m1 chunk b ofs Writable); inv H.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length (encode_val chunk v))) Cur Writable).\nf_equal.\napply mkmem_ext; auto.\ndestruct v0.\nelim n.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (v0 : valid_access m1 chunk b ofs Writable) : (if\n  range_perm_dec m1 b ofs\n    (ofs + Z.of_nat (Datatypes.length (encode_val chunk v))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n          (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n    |}\n else None) =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |}.","proofString":"destruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length (encode_val chunk v))) Cur Writable).\nf_equal.\napply mkmem_ext; auto.\ndestruct v0.\nelim n.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (v0 : valid_access m1 chunk b ofs Writable) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n  |} =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |}.","proofString":"f_equal.\napply mkmem_ext; auto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (v0 : valid_access m1 chunk b ofs Writable) (r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) : {|\n  mem_contents :=\n    PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n      (mem_contents m1);\n  mem_access := mem_access m1;\n  nextblock := nextblock m1;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H : ~ Plt b0 (nextblock m1)) => storebytes_obligation_2 m1 b0 ofs0 k H;\n  contents_default :=\n    fun b0 : positive =>\n    storebytes_obligation_3 m1 b ofs (encode_val chunk v) b0\n|} =\n{|\n  mem_contents :=\n    PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n      (mem_contents m1);\n  mem_access := mem_access m1;\n  nextblock := nextblock m1;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n  contents_default :=\n    fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n|}.","proofString":"apply mkmem_ext; auto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (v0 : valid_access m1 chunk b ofs Writable) (n : ~\nrange_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) : None =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |}.","proofString":"destruct v0.\nelim n.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (H : range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~\nrange_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) : None =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN (encode_val chunk v) ofs (mem_contents m1) # b)\n        (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => store_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m1)) => store_obligation_2 m1 b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => store_obligation_3 chunk m1 b ofs v b0\n  |}.","proofString":"elim n.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (H : range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~\nrange_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable.","proofString":"rewrite encode_val_length.\nrewrite <- size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (H : range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~\nrange_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) : range_perm m1 b ofs (ofs + Z.of_nat (size_chunk_nat chunk)) Cur Writable.","proofString":"rewrite <- size_chunk_conv.\nauto."},{"statement":"(m1 : mem) (b : block) (ofs : Z) (chunk : memory_chunk) (v : val) (H : range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (H0 : (align_chunk chunk | ofs)) (n : ~\nrange_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length (encode_val chunk v)))\n  Cur Writable) : range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable.","proofString":"auto."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : mem_access\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n  |} = mem_access m1.","proofString":"auto."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : mem_contents\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n  |} = PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1).","proofString":"auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm m1 b' ofs' k p) : perm m2 b' ofs' k p.","proofString":"unfold perm in *.\nrewrite storebytes_access; auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs' k) p) : perm_order' ((mem_access m2) # b' ofs' k) p.","proofString":"rewrite storebytes_access; auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm m2 b' ofs' k p) : perm m1 b' ofs' k p.","proofString":"unfold perm in *.\nrewrite storebytes_access in H; auto."},{"statement":"(b' : block) (ofs' : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m2) # b' ofs' k) p) : perm_order' ((mem_access m1) # b' ofs' k) p.","proofString":"rewrite storebytes_access in H; auto."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H : valid_access m1 chunk' b' ofs' p) : valid_access m2 chunk' b' ofs' p.","proofString":"inv H.\nconstructor; try red; auto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H0 : range_perm m1 b' ofs' (ofs' + size_chunk chunk') Cur p) (H1 : (align_chunk chunk' | ofs')) : valid_access m2 chunk' b' ofs' p.","proofString":"constructor; try red; auto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H : valid_access m2 chunk' b' ofs' p) : valid_access m1 chunk' b' ofs' p.","proofString":"inv H.\nconstructor; try red; auto with mem."},{"statement":"(chunk' : memory_chunk) (b' : block) (ofs' : Z) (p : permission) (H0 : range_perm m2 b' ofs' (ofs' + size_chunk chunk') Cur p) (H1 : (align_chunk chunk' | ofs')) : valid_access m1 chunk' b' ofs' p.","proofString":"constructor; try red; auto with mem."},{"statement":"nextblock m2 = nextblock m1.","proofString":"unfold storebytes in STORE.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable);  inv STORE.\nauto."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : nextblock\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n  |} = nextblock m1.","proofString":"auto."},{"statement":"(b' : block) (H : Plt b' (nextblock m1)) : Plt b' (nextblock m2).","proofString":"rewrite nextblock_storebytes; auto."},{"statement":"(b' : block) (H : Plt b' (nextblock m2)) : Plt b' (nextblock m1).","proofString":"rewrite nextblock_storebytes in H; auto."},{"statement":"range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable.","proofString":"unfold storebytes in STORE.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable);  inv STORE.\nauto."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable.","proofString":"auto."},{"statement":"loadbytes m2 b ofs (Z.of_nat (Datatypes.length bytes)) = Some bytes.","proofString":"assert (STORE2:=STORE).\nunfold storebytes in STORE2.\nunfold loadbytes.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable);  try discriminate.\nrewrite pred_dec_true.\ndecEq.\ninv STORE2; simpl.\nrewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same.\nred; eauto with mem."},{"statement":"(STORE2 : storebytes m1 b ofs bytes = Some m2) : loadbytes m2 b ofs (Z.of_nat (Datatypes.length bytes)) = Some bytes.","proofString":"unfold storebytes in STORE2.\nunfold loadbytes.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable);  try discriminate.\nrewrite pred_dec_true.\ndecEq.\ninv STORE2; simpl.\nrewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same.\nred; eauto with mem."},{"statement":"(STORE2 : (if\n  range_perm_dec m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur\n    Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n    |}\n else None) = Some m2) : loadbytes m2 b ofs (Z.of_nat (Datatypes.length bytes)) = Some bytes.","proofString":"unfold loadbytes.\ndestruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable);  try discriminate.\nrewrite pred_dec_true.\ndecEq.\ninv STORE2; simpl.\nrewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same.\nred; eauto with mem."},{"statement":"(STORE2 : (if\n  range_perm_dec m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur\n    Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H;\n      contents_default :=\n        fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n    |}\n else None) = Some m2) : (if\n  range_perm_dec m2 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur\n    Readable\n then\n  Some\n    (getN (Z.to_nat (Z.of_nat (Datatypes.length bytes))) ofs\n       (mem_contents m2) # b)\n else None) = Some bytes.","proofString":"destruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable);  try discriminate.\nrewrite pred_dec_true.\ndecEq.\ninv STORE2; simpl.\nrewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same.\nred; eauto with mem."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) (STORE2 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n  |} = Some m2) : (if\n  range_perm_dec m2 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur\n    Readable\n then\n  Some\n    (getN (Z.to_nat (Z.of_nat (Datatypes.length bytes))) ofs\n       (mem_contents m2) # b)\n else None) = Some bytes.","proofString":"rewrite pred_dec_true.\ndecEq.\ninv STORE2; simpl.\nrewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same.\nred; eauto with mem."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) (STORE2 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n  |} = Some m2) : Some\n  (getN (Z.to_nat (Z.of_nat (Datatypes.length bytes))) ofs\n     (mem_contents m2) # b) = Some bytes.","proofString":"decEq.\ninv STORE2; simpl.\nrewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) (STORE2 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n  |} = Some m2) : getN (Z.to_nat (Z.of_nat (Datatypes.length bytes))) ofs (mem_contents m2) # b =\nbytes.","proofString":"inv STORE2; simpl.\nrewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : getN (Z.to_nat (Z.of_nat (Datatypes.length bytes))) ofs\n  (PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1)) # b =\nbytes.","proofString":"rewrite PMap.gss.\nrewrite Nat2Z.id.\napply getN_setN_same."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : getN (Z.to_nat (Z.of_nat (Datatypes.length bytes))) ofs\n  (setN bytes ofs (mem_contents m1) # b) = bytes.","proofString":"rewrite Nat2Z.id.\napply getN_setN_same."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) : getN (Datatypes.length bytes) ofs (setN bytes ofs (mem_contents m1) # b) =\nbytes.","proofString":"apply getN_setN_same."},{"statement":"(r : range_perm m1 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Writable) (STORE2 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m1 b ofs bytes b0\n  |} = Some m2) : range_perm m2 b ofs (ofs + Z.of_nat (Datatypes.length bytes)) Cur Readable.","proofString":"red; eauto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) : loadbytes m2 b' ofs' len = loadbytes m1 b' ofs' len.","proofString":"unfold loadbytes.\ndestruct (range_perm_dec m1 b' ofs' (ofs' + len) Cur Readable).\nrewrite pred_dec_true.\nrewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence.\nauto.\nred; auto with mem.\napply pred_dec_false.\nred; intros; elim n.\nred; auto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) : (if range_perm_dec m2 b' ofs' (ofs' + len) Cur Readable\n then Some (getN (Z.to_nat len) ofs' (mem_contents m2) # b')\n else None) =\n(if range_perm_dec m1 b' ofs' (ofs' + len) Cur Readable\n then Some (getN (Z.to_nat len) ofs' (mem_contents m1) # b')\n else None).","proofString":"destruct (range_perm_dec m1 b' ofs' (ofs' + len) Cur Readable).\nrewrite pred_dec_true.\nrewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence.\nauto.\nred; auto with mem.\napply pred_dec_false.\nred; intros; elim n.\nred; auto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) : (if range_perm_dec m2 b' ofs' (ofs' + len) Cur Readable\n then Some (getN (Z.to_nat len) ofs' (mem_contents m2) # b')\n else None) = Some (getN (Z.to_nat len) ofs' (mem_contents m1) # b').","proofString":"rewrite pred_dec_true.\nrewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence.\nauto.\nred; auto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) : Some (getN (Z.to_nat len) ofs' (mem_contents m2) # b') =\nSome (getN (Z.to_nat len) ofs' (mem_contents m1) # b').","proofString":"rewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence.\nauto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) : Some\n  (getN (Z.to_nat len) ofs'\n     (PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1))\n     # b') = Some (getN (Z.to_nat len) ofs' (mem_contents m1) # b').","proofString":"decEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence.\nauto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) : getN (Z.to_nat len) ofs'\n  (PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1)) # b' =\ngetN (Z.to_nat len) ofs' (mem_contents m1) # b'.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence.\nauto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) : getN (Z.to_nat len) ofs'\n  (if peq b' b\n   then setN bytes ofs (mem_contents m1) # b\n   else (mem_contents m1) # b') =\ngetN (Z.to_nat len) ofs' (mem_contents m1) # b'.","proofString":"destruct (peq b' b).\nsubst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence.\nauto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) (e : b' = b) : getN (Z.to_nat len) ofs' (setN bytes ofs (mem_contents m1) # b) =\ngetN (Z.to_nat len) ofs' (mem_contents m1) # b'.","proofString":"subst b'.\napply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence."},{"statement":"(ofs' len : Z) (H : len >= 0) (r : range_perm m1 b ofs' (ofs' + len) Cur Readable) (H0 : b <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) : getN (Z.to_nat len) ofs' (setN bytes ofs (mem_contents m1) # b) =\ngetN (Z.to_nat len) ofs' (mem_contents m1) # b.","proofString":"apply getN_setN_disjoint.\nrewrite Z2Nat.id by lia.\nintuition congruence."},{"statement":"(ofs' len : Z) (H : len >= 0) (r : range_perm m1 b ofs' (ofs' + len) Cur Readable) (H0 : b <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) : Intv.disjoint (ofs', ofs' + Z.of_nat (Z.to_nat len))\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","proofString":"rewrite Z2Nat.id by lia.\nintuition congruence."},{"statement":"(ofs' len : Z) (H : len >= 0) (r : range_perm m1 b ofs' (ofs' + len) Cur Readable) (H0 : b <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) : Intv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","proofString":"intuition congruence."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) (n : b' <> b) : getN (Z.to_nat len) ofs' (mem_contents m1) # b' =\ngetN (Z.to_nat len) ofs' (mem_contents m1) # b'.","proofString":"auto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (r : range_perm m1 b' ofs' (ofs' + len) Cur Readable) : range_perm m2 b' ofs' (ofs' + len) Cur Readable.","proofString":"red; auto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (n : ~ range_perm m1 b' ofs' (ofs' + len) Cur Readable) : (if range_perm_dec m2 b' ofs' (ofs' + len) Cur Readable\n then Some (getN (Z.to_nat len) ofs' (mem_contents m2) # b')\n else None) = None.","proofString":"apply pred_dec_false.\nred; intros; elim n.\nred; auto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (n : ~ range_perm m1 b' ofs' (ofs' + len) Cur Readable) : ~ range_perm m2 b' ofs' (ofs' + len) Cur Readable.","proofString":"red; intros; elim n.\nred; auto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes))) (n : ~ range_perm m1 b' ofs' (ofs' + len) Cur Readable) (H1 : range_perm m2 b' ofs' (ofs' + len) Cur Readable) : range_perm m1 b' ofs' (ofs' + len) Cur Readable.","proofString":"red; auto with mem."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nofs' + len <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : loadbytes m2 b' ofs' len = loadbytes m1 b' ofs' len.","proofString":"apply loadbytes_storebytes_disjoint; auto.\ndestruct H0; auto.\nright.\napply Intv.disjoint_range; auto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : b' <> b \\/\nofs' + len <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","proofString":"destruct H0; auto.\nright.\napply Intv.disjoint_range; auto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : ofs' + len <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : b' <> b \\/\nIntv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","proofString":"right.\napply Intv.disjoint_range; auto."},{"statement":"(b' : block) (ofs' len : Z) (H : len >= 0) (H0 : ofs' + len <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : Intv.disjoint (ofs', ofs' + len)\n  (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","proofString":"apply Intv.disjoint_range; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') : load chunk m2 b' ofs' = load chunk m1 b' ofs'.","proofString":"unfold load.\ndestruct (valid_access_dec m1 chunk b' ofs' Readable).\nrewrite pred_dec_true.\nrewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence.\nauto.\ndestruct v; split; auto.\nred; auto with mem.\napply pred_dec_false.\nred; intros; elim n.\ndestruct H0.\nsplit; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') : (if valid_access_dec m2 chunk b' ofs' Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs' (mem_contents m2) # b'))\n else None) =\n(if valid_access_dec m1 chunk b' ofs' Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b'))\n else None).","proofString":"destruct (valid_access_dec m1 chunk b' ofs' Readable).\nrewrite pred_dec_true.\nrewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence.\nauto.\ndestruct v; split; auto.\nred; auto with mem.\napply pred_dec_false.\nred; intros; elim n.\ndestruct H0.\nsplit; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) : (if valid_access_dec m2 chunk b' ofs' Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs' (mem_contents m2) # b'))\n else None) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b')).","proofString":"rewrite pred_dec_true.\nrewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence.\nauto.\ndestruct v; split; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m2) # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b')).","proofString":"rewrite storebytes_mem_contents.\ndecEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence.\nauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) : Some\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) ofs'\n        (PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1))\n        # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b')).","proofString":"decEq.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence.\nauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) : decode_val chunk\n  (getN (size_chunk_nat chunk) ofs'\n     (PMap.set b (setN bytes ofs (mem_contents m1) # b) (mem_contents m1))\n     # b') =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b').","proofString":"rewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence.\nauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) : decode_val chunk\n  (getN (size_chunk_nat chunk) ofs'\n     (if peq b' b\n      then setN bytes ofs (mem_contents m1) # b\n      else (mem_contents m1) # b')) =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b').","proofString":"destruct (peq b' b).\nsubst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence.\nauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) (e : b' = b) : decode_val chunk\n  (getN (size_chunk_nat chunk) ofs' (setN bytes ofs (mem_contents m1) # b)) =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b').","proofString":"subst b'.\nrewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ofs' : Z) (v : valid_access m1 chunk b ofs' Readable) (H : b <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') : decode_val chunk\n  (getN (size_chunk_nat chunk) ofs' (setN bytes ofs (mem_contents m1) # b)) =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b).","proofString":"rewrite getN_setN_outside.\nauto.\nrewrite <- size_chunk_conv.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ofs' : Z) (v : valid_access m1 chunk b ofs' Readable) (H : b <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') : decode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b) =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b).","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ofs' : Z) (v : valid_access m1 chunk b ofs' Readable) (H : b <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') : ofs' + Z.of_nat (size_chunk_nat chunk) <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs'.","proofString":"rewrite <- size_chunk_conv.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ofs' : Z) (v : valid_access m1 chunk b ofs' Readable) (H : b <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') : ofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs'.","proofString":"intuition congruence."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) (n : b' <> b) : decode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b') =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs' (mem_contents m1) # b').","proofString":"auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (v : valid_access m1 chunk b' ofs' Readable) : valid_access m2 chunk b' ofs' Readable.","proofString":"destruct v; split; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (H0 : range_perm m1 b' ofs' (ofs' + size_chunk chunk) Cur Readable) (H1 : (align_chunk chunk | ofs')) : range_perm m2 b' ofs' (ofs' + size_chunk chunk) Cur Readable.","proofString":"red; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (n : ~ valid_access m1 chunk b' ofs' Readable) : (if valid_access_dec m2 chunk b' ofs' Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs' (mem_contents m2) # b'))\n else None) = None.","proofString":"apply pred_dec_false.\nred; intros; elim n.\ndestruct H0.\nsplit; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (n : ~ valid_access m1 chunk b' ofs' Readable) : ~ valid_access m2 chunk b' ofs' Readable.","proofString":"red; intros; elim n.\ndestruct H0.\nsplit; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (n : ~ valid_access m1 chunk b' ofs' Readable) (H0 : valid_access m2 chunk b' ofs' Readable) : valid_access m1 chunk b' ofs' Readable.","proofString":"destruct H0.\nsplit; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (n : ~ valid_access m1 chunk b' ofs' Readable) (H0 : range_perm m2 b' ofs' (ofs' + size_chunk chunk) Cur Readable) (H1 : (align_chunk chunk | ofs')) : valid_access m1 chunk b' ofs' Readable.","proofString":"split; auto.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs' : Z) (H : b' <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs') (n : ~ valid_access m1 chunk b' ofs' Readable) (H0 : range_perm m2 b' ofs' (ofs' + size_chunk chunk) Cur Readable) (H1 : (align_chunk chunk | ofs')) : range_perm m1 b' ofs' (ofs' + size_chunk chunk) Cur Readable.","proofString":"red; auto with mem."},{"statement":"(bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : setN bytes2 ofs c = setN bytes2 (ofs + 0) c.","proofString":"decEq.\nlia."},{"statement":"(bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : ofs = ofs + 0.","proofString":"lia."},{"statement":"(a : memval) (bytes1 : list memval) (IHbytes1 : forall (bytes0 : list memval) (ofs0 : Z) (c0 : ZMap.t memval),\nsetN (bytes1 ++ bytes0) ofs0 c0 =\nsetN bytes0 (ofs0 + Z.of_nat (Datatypes.length bytes1)) (setN bytes1 ofs0 c0)) (bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : setN ((a :: bytes1) ++ bytes2) ofs c =\nsetN bytes2 (ofs + Z.of_nat (Datatypes.length (a :: bytes1)))\n  (setN (a :: bytes1) ofs c).","proofString":"simpl length.\nrewrite Nat2Z.inj_succ.\nsimpl.\nrewrite IHbytes1.\ndecEq.\nlia."},{"statement":"(a : memval) (bytes1 : list memval) (IHbytes1 : forall (bytes0 : list memval) (ofs0 : Z) (c0 : ZMap.t memval),\nsetN (bytes1 ++ bytes0) ofs0 c0 =\nsetN bytes0 (ofs0 + Z.of_nat (Datatypes.length bytes1)) (setN bytes1 ofs0 c0)) (bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : setN ((a :: bytes1) ++ bytes2) ofs c =\nsetN bytes2 (ofs + Z.of_nat (S (Datatypes.length bytes1)))\n  (setN (a :: bytes1) ofs c).","proofString":"rewrite Nat2Z.inj_succ.\nsimpl.\nrewrite IHbytes1.\ndecEq.\nlia."},{"statement":"(a : memval) (bytes1 : list memval) (IHbytes1 : forall (bytes0 : list memval) (ofs0 : Z) (c0 : ZMap.t memval),\nsetN (bytes1 ++ bytes0) ofs0 c0 =\nsetN bytes0 (ofs0 + Z.of_nat (Datatypes.length bytes1)) (setN bytes1 ofs0 c0)) (bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : setN ((a :: bytes1) ++ bytes2) ofs c =\nsetN bytes2 (ofs + Z.succ (Z.of_nat (Datatypes.length bytes1)))\n  (setN (a :: bytes1) ofs c).","proofString":"simpl.\nrewrite IHbytes1.\ndecEq.\nlia."},{"statement":"(a : memval) (bytes1 : list memval) (IHbytes1 : forall (bytes0 : list memval) (ofs0 : Z) (c0 : ZMap.t memval),\nsetN (bytes1 ++ bytes0) ofs0 c0 =\nsetN bytes0 (ofs0 + Z.of_nat (Datatypes.length bytes1)) (setN bytes1 ofs0 c0)) (bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : setN (bytes1 ++ bytes2) (ofs + 1) (ZMap.set ofs a c) =\nsetN bytes2 (ofs + Z.succ (Z.of_nat (Datatypes.length bytes1)))\n  (setN bytes1 (ofs + 1) (ZMap.set ofs a c)).","proofString":"rewrite IHbytes1.\ndecEq.\nlia."},{"statement":"(a : memval) (bytes1 : list memval) (IHbytes1 : forall (bytes0 : list memval) (ofs0 : Z) (c0 : ZMap.t memval),\nsetN (bytes1 ++ bytes0) ofs0 c0 =\nsetN bytes0 (ofs0 + Z.of_nat (Datatypes.length bytes1)) (setN bytes1 ofs0 c0)) (bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : setN bytes2 (ofs + 1 + Z.of_nat (Datatypes.length bytes1))\n  (setN bytes1 (ofs + 1) (ZMap.set ofs a c)) =\nsetN bytes2 (ofs + Z.succ (Z.of_nat (Datatypes.length bytes1)))\n  (setN bytes1 (ofs + 1) (ZMap.set ofs a c)).","proofString":"decEq.\nlia."},{"statement":"(a : memval) (bytes1 : list memval) (IHbytes1 : forall (bytes0 : list memval) (ofs0 : Z) (c0 : ZMap.t memval),\nsetN (bytes1 ++ bytes0) ofs0 c0 =\nsetN bytes0 (ofs0 + Z.of_nat (Datatypes.length bytes1)) (setN bytes1 ofs0 c0)) (bytes2 : list memval) (ofs : Z) (c : ZMap.t memval) : ofs + 1 + Z.of_nat (Datatypes.length bytes1) =\nofs + Z.succ (Z.of_nat (Datatypes.length bytes1)).","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) : storebytes m b ofs (bytes1 ++ bytes2) = Some m2.","proofString":"generalize H; intro ST1.\ngeneralize H0; intro ST2.\nunfold storebytes; unfold storebytes in ST1; unfold storebytes in ST2.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat(length bytes1)) Cur Writable); try congruence.\ndestruct (range_perm_dec m1 b (ofs + Z.of_nat(length bytes1)) (ofs + Z.of_nat(length bytes1) + Z.of_nat(length bytes2)) Cur Writable); try congruence.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat (length (bytes1 ++ bytes2))) Cur Writable).\ninv ST1; inv ST2; simpl.\ndecEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2.\nelim n.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (ST1 : storebytes m b ofs bytes1 = Some m1) : storebytes m b ofs (bytes1 ++ bytes2) = Some m2.","proofString":"generalize H0; intro ST2.\nunfold storebytes; unfold storebytes in ST1; unfold storebytes in ST2.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat(length bytes1)) Cur Writable); try congruence.\ndestruct (range_perm_dec m1 b (ofs + Z.of_nat(length bytes1)) (ofs + Z.of_nat(length bytes1) + Z.of_nat(length bytes2)) Cur Writable); try congruence.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat (length (bytes1 ++ bytes2))) Cur Writable).\ninv ST1; inv ST2; simpl.\ndecEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2.\nelim n.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (ST1 : storebytes m b ofs bytes1 = Some m1) (ST2 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) : storebytes m b ofs (bytes1 ++ bytes2) = Some m2.","proofString":"unfold storebytes; unfold storebytes in ST1; unfold storebytes in ST2.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat(length bytes1)) Cur Writable); try congruence.\ndestruct (range_perm_dec m1 b (ofs + Z.of_nat(length bytes1)) (ofs + Z.of_nat(length bytes1) + Z.of_nat(length bytes2)) Cur Writable); try congruence.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat (length (bytes1 ++ bytes2))) Cur Writable).\ninv ST1; inv ST2; simpl.\ndecEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2.\nelim n.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (ST1 : (if\n  range_perm_dec m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur\n    Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m)) =>\n        storebytes_obligation_2 m b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n    |}\n else None) = Some m1) (ST2 : (if\n  range_perm_dec m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n    (ofs + Z.of_nat (Datatypes.length bytes1) +\n     Z.of_nat (Datatypes.length bytes2)) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b\n          (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n             (mem_contents m1) # b) (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m1 b\n          (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n    |}\n else None) = Some m2) : (if\n  range_perm_dec m b ofs\n    (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m)) =>\n        storebytes_obligation_2 m b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m b ofs (bytes1 ++ bytes2) b0\n    |}\n else None) = Some m2.","proofString":"destruct (range_perm_dec m b ofs (ofs + Z.of_nat(length bytes1)) Cur Writable); try congruence.\ndestruct (range_perm_dec m1 b (ofs + Z.of_nat(length bytes1)) (ofs + Z.of_nat(length bytes1) + Z.of_nat(length bytes2)) Cur Writable); try congruence.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat (length (bytes1 ++ bytes2))) Cur Writable).\ninv ST1; inv ST2; simpl.\ndecEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2.\nelim n.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (ST2 : (if\n  range_perm_dec m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n    (ofs + Z.of_nat (Datatypes.length bytes1) +\n     Z.of_nat (Datatypes.length bytes2)) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b\n          (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n             (mem_contents m1) # b) (mem_contents m1);\n      mem_access := mem_access m1;\n      nextblock := nextblock m1;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m1)) =>\n        storebytes_obligation_2 m1 b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m1 b\n          (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n    |}\n else None) = Some m2) : (if\n  range_perm_dec m b ofs\n    (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m)) =>\n        storebytes_obligation_2 m b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m b ofs (bytes1 ++ bytes2) b0\n    |}\n else None) = Some m2.","proofString":"destruct (range_perm_dec m1 b (ofs + Z.of_nat(length bytes1)) (ofs + Z.of_nat(length bytes1) + Z.of_nat(length bytes2)) Cur Writable); try congruence.\ndestruct (range_perm_dec m b ofs (ofs + Z.of_nat (length (bytes1 ++ bytes2))) Cur Writable).\ninv ST1; inv ST2; simpl.\ndecEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2.\nelim n.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) : (if\n  range_perm_dec m b ofs\n    (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur Writable\n then\n  Some\n    {|\n      mem_contents :=\n        PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n          (mem_contents m);\n      mem_access := mem_access m;\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n          (H1 : ~ Plt b0 (nextblock m)) =>\n        storebytes_obligation_2 m b0 ofs0 k H1;\n      contents_default :=\n        fun b0 : positive =>\n        storebytes_obligation_3 m b ofs (bytes1 ++ bytes2) b0\n    |}\n else None) = Some m2.","proofString":"destruct (range_perm_dec m b ofs (ofs + Z.of_nat (length (bytes1 ++ bytes2))) Cur Writable).\ninv ST1; inv ST2; simpl.\ndecEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2.\nelim n.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (r1 : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n        (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m b ofs (bytes1 ++ bytes2) b0\n  |} = Some m2.","proofString":"inv ST1; inv ST2; simpl.\ndecEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (H0 : storebytes\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m)) # b)\n        (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      storebytes_obligation_1\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n              (H2 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k0 H2;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs0 : Z) =>\n            storebytes_obligation_1 m b1 ofs0;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs0 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n  |}) (H : storebytes m b ofs bytes1 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |}) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (r0 : range_perm\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (r1 : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n        (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m b ofs (bytes1 ++ bytes2) b0\n  |} =\nSome\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m)) # b)\n        (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      storebytes_obligation_1\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n              (H2 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k0 H2;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs0 : Z) =>\n            storebytes_obligation_1 m b1 ofs0;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs0 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n  |}.","proofString":"decEq.\napply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (H0 : storebytes\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m)) # b)\n        (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      storebytes_obligation_1\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n              (H2 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k0 H2;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs0 : Z) =>\n            storebytes_obligation_1 m b1 ofs0;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs0 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n  |}) (H : storebytes m b ofs bytes1 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |}) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (r0 : range_perm\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (r1 : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : {|\n  mem_contents :=\n    PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n      (mem_contents m);\n  mem_access := mem_access m;\n  nextblock := nextblock m;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H1 : ~ Plt b0 (nextblock m)) => storebytes_obligation_2 m b0 ofs0 k H1;\n  contents_default :=\n    fun b0 : positive =>\n    storebytes_obligation_3 m b ofs (bytes1 ++ bytes2) b0\n|} =\n{|\n  mem_contents :=\n    PMap.set b\n      (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n         (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m))\n         # b)\n      (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n  mem_access := mem_access m;\n  nextblock := nextblock m;\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) =>\n    storebytes_obligation_1\n      {|\n        mem_contents :=\n          PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n        mem_access := mem_access m;\n        nextblock := nextblock m;\n        access_max :=\n          fun (b1 : positive) (ofs1 : Z) => storebytes_obligation_1 m b1 ofs1;\n        nextblock_noaccess :=\n          fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n            (H1 : ~ Plt b1 (nextblock m)) =>\n          storebytes_obligation_2 m b1 ofs1 k H1;\n        contents_default :=\n          fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n      |} b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H1 : ~ Plt b0 (nextblock m)) =>\n    storebytes_obligation_2\n      {|\n        mem_contents :=\n          PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n        mem_access := mem_access m;\n        nextblock := nextblock m;\n        access_max :=\n          fun (b1 : positive) (ofs1 : Z) => storebytes_obligation_1 m b1 ofs1;\n        nextblock_noaccess :=\n          fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n            (H2 : ~ Plt b1 (nextblock m)) =>\n          storebytes_obligation_2 m b1 ofs1 k0 H2;\n        contents_default :=\n          fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n      |} b0 ofs0 k H1;\n  contents_default :=\n    fun b0 : positive =>\n    storebytes_obligation_3\n      {|\n        mem_contents :=\n          PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n        mem_access := mem_access m;\n        nextblock := nextblock m;\n        access_max :=\n          fun (b1 : positive) (ofs0 : Z) => storebytes_obligation_1 m b1 ofs0;\n        nextblock_noaccess :=\n          fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n            (H1 : ~ Plt b1 (nextblock m)) =>\n          storebytes_obligation_2 m b1 ofs0 k H1;\n        contents_default :=\n          fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n      |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n|}.","proofString":"apply mkmem_ext; auto.\nrewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (H0 : storebytes\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m)) # b)\n        (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      storebytes_obligation_1\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n              (H2 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k0 H2;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs0 : Z) =>\n            storebytes_obligation_1 m b1 ofs0;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs0 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n  |}) (H : storebytes m b ofs bytes1 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |}) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (r0 : range_perm\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (r1 : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n  (mem_contents m) =\nPMap.set b\n  (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n     (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m)) # b)\n  (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m)).","proofString":"rewrite PMap.gss.\nrewrite setN_concat.\nsymmetry.\napply PMap.set2."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (H0 : storebytes\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m)) # b)\n        (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      storebytes_obligation_1\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n              (H2 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k0 H2;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs0 : Z) =>\n            storebytes_obligation_1 m b1 ofs0;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs0 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n  |}) (H : storebytes m b ofs bytes1 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |}) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (r0 : range_perm\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (r1 : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : PMap.set b (setN (bytes1 ++ bytes2) ofs (mem_contents m) # b)\n  (mem_contents m) =\nPMap.set b\n  (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n     (setN bytes1 ofs (mem_contents m) # b))\n  (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m)).","proofString":"rewrite setN_concat.\nsymmetry.\napply PMap.set2."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (H0 : storebytes\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m)) # b)\n        (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      storebytes_obligation_1\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n              (H2 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k0 H2;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs0 : Z) =>\n            storebytes_obligation_1 m b1 ofs0;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs0 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n  |}) (H : storebytes m b ofs bytes1 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |}) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (r0 : range_perm\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (r1 : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : PMap.set b\n  (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n     (setN bytes1 ofs (mem_contents m) # b)) (mem_contents m) =\nPMap.set b\n  (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n     (setN bytes1 ofs (mem_contents m) # b))\n  (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m)).","proofString":"symmetry.\napply PMap.set2."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (H0 : storebytes\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m)) # b)\n        (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m));\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      storebytes_obligation_1\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs1 : Z) =>\n            storebytes_obligation_1 m b1 ofs1;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs1 : Z) (k0 : perm_kind)\n              (H2 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs1 k0 H2;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3\n        {|\n          mem_contents :=\n            PMap.set b (setN bytes1 ofs (mem_contents m) # b)\n              (mem_contents m);\n          mem_access := mem_access m;\n          nextblock := nextblock m;\n          access_max :=\n            fun (b1 : positive) (ofs0 : Z) =>\n            storebytes_obligation_1 m b1 ofs0;\n          nextblock_noaccess :=\n            fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n              (H1 : ~ Plt b1 (nextblock m)) =>\n            storebytes_obligation_2 m b1 ofs0 k H1;\n          contents_default :=\n            fun b1 : positive => storebytes_obligation_3 m b ofs bytes1 b1\n        |} b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 b0\n  |}) (H : storebytes m b ofs bytes1 =\nSome\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |}) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (r0 : range_perm\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (r1 : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : PMap.set b\n  (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n     (setN bytes1 ofs (mem_contents m) # b))\n  (PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m)) =\nPMap.set b\n  (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n     (setN bytes1 ofs (mem_contents m) # b)) (mem_contents m).","proofString":"apply PMap.set2."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : None = Some m2.","proofString":"elim n.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable.","proofString":"rewrite app_length.\nrewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : range_perm m b ofs\n  (ofs + Z.of_nat (Datatypes.length bytes1 + Datatypes.length bytes2)) Cur\n  Writable.","proofString":"rewrite Nat2Z.inj_add.\nred; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) => storebytes_obligation_1 m1 b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs0 k H1;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) : range_perm m b ofs\n  (ofs +\n   (Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)))\n  Cur Writable.","proofString":"red; intros.\ndestruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m1 b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) (ofs0 : Z) (H1 : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2))) : perm m b ofs0 Cur Writable.","proofString":"destruct (zlt ofs0 (ofs + Z.of_nat(length bytes1))).\napply r.\nlia.\neapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m1 b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) (ofs0 : Z) (H1 : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2))) (l : ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : perm m b ofs0 Cur Writable.","proofString":"apply r.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m1 b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) (ofs0 : Z) (H1 : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2))) (l : ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1).","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m1 b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) (ofs0 : Z) (H1 : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2))) (g : ofs0 >= ofs + Z.of_nat (Datatypes.length bytes1)) : perm m b ofs0 Cur Writable.","proofString":"eapply perm_storebytes_2; eauto.\napply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m1 b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) (ofs0 : Z) (H1 : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2))) (g : ofs0 >= ofs + Z.of_nat (Datatypes.length bytes1)) : perm m1 b ofs0 Cur Writable.","proofString":"apply r0.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1 : mem) (bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs bytes1 = Some m1) (H0 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2) (r : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable) (ST1 : Some\n  {|\n    mem_contents :=\n      PMap.set b (setN bytes1 ofs (mem_contents m) # b) (mem_contents m);\n    mem_access := mem_access m;\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m)) =>\n      storebytes_obligation_2 m b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive => storebytes_obligation_3 m b ofs bytes1 b0\n  |} = Some m1) (r0 : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable) (ST2 : Some\n  {|\n    mem_contents :=\n      PMap.set b\n        (setN bytes2 (ofs + Z.of_nat (Datatypes.length bytes1))\n           (mem_contents m1) # b) (mem_contents m1);\n    mem_access := mem_access m1;\n    nextblock := nextblock m1;\n    access_max :=\n      fun (b0 : positive) (ofs1 : Z) => storebytes_obligation_1 m1 b0 ofs1;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n        (H2 : ~ Plt b0 (nextblock m1)) =>\n      storebytes_obligation_2 m1 b0 ofs1 k H2;\n    contents_default :=\n      fun b0 : positive =>\n      storebytes_obligation_3 m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n        bytes2 b0\n  |} = Some m2) (n : ~\nrange_perm m b ofs (ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2))) Cur\n  Writable) (ofs0 : Z) (H1 : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2))) (g : ofs0 >= ofs + Z.of_nat (Datatypes.length bytes1)) : ofs + Z.of_nat (Datatypes.length bytes1) <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2).","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) : exists m1 : mem,\n  storebytes m b ofs bytes1 = Some m1 /\\\n  storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2.","proofString":"destruct (range_perm_storebytes m b ofs bytes1) as [m1 ST1].\nred; intros.\nexploit storebytes_range_perm; eauto.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia.\ndestruct (range_perm_storebytes m1 b (ofs + Z.of_nat (length bytes1)) bytes2) as [m2' ST2].\nred; intros.\neapply perm_storebytes_1; eauto.\nexploit storebytes_range_perm.\neexact H.\ninstantiate (1 := ofs0).\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia.\nauto.\nassert (Some m2 = Some m2').\nrewrite <- H.\neapply storebytes_concat; eauto.\ninv H0.\nexists m1; split; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) : range_perm m b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable.","proofString":"red; intros.\nexploit storebytes_range_perm; eauto.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : perm m b ofs0 Cur Writable.","proofString":"exploit storebytes_range_perm; eauto.\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2)).","proofString":"rewrite app_length.\nrewrite Nat2Z.inj_add.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : ofs <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1 + Datatypes.length bytes2).","proofString":"rewrite Nat2Z.inj_add.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)).","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) : exists m0 : mem,\n  storebytes m b ofs bytes1 = Some m0 /\\\n  storebytes m0 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2.","proofString":"destruct (range_perm_storebytes m1 b (ofs + Z.of_nat (length bytes1)) bytes2) as [m2' ST2].\nred; intros.\neapply perm_storebytes_1; eauto.\nexploit storebytes_range_perm.\neexact H.\ninstantiate (1 := ofs0).\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia.\nauto.\nassert (Some m2 = Some m2').\nrewrite <- H.\neapply storebytes_concat; eauto.\ninv H0.\nexists m1; split; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) : range_perm m1 b (ofs + Z.of_nat (Datatypes.length bytes1))\n  (ofs + Z.of_nat (Datatypes.length bytes1) +\n   Z.of_nat (Datatypes.length bytes2)) Cur Writable.","proofString":"red; intros.\neapply perm_storebytes_1; eauto.\nexploit storebytes_range_perm.\neexact H.\ninstantiate (1 := ofs0).\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (ofs0 : Z) (H0 : ofs + Z.of_nat (Datatypes.length bytes1) <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)) : perm m1 b ofs0 Cur Writable.","proofString":"eapply perm_storebytes_1; eauto.\nexploit storebytes_range_perm.\neexact H.\ninstantiate (1 := ofs0).\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (ofs0 : Z) (H0 : ofs + Z.of_nat (Datatypes.length bytes1) <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)) : perm m b ofs0 Cur Writable.","proofString":"exploit storebytes_range_perm.\neexact H.\ninstantiate (1 := ofs0).\nrewrite app_length.\nrewrite Nat2Z.inj_add.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (ofs0 : Z) (H0 : ofs + Z.of_nat (Datatypes.length bytes1) <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)) : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length (bytes1 ++ bytes2)).","proofString":"rewrite app_length.\nrewrite Nat2Z.inj_add.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (ofs0 : Z) (H0 : ofs + Z.of_nat (Datatypes.length bytes1) <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)) : ofs <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1 + Datatypes.length bytes2).","proofString":"rewrite Nat2Z.inj_add.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (ofs0 : Z) (H0 : ofs + Z.of_nat (Datatypes.length bytes1) <= ofs0 <\nofs + Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)) : ofs <= ofs0 <\nofs +\n(Z.of_nat (Datatypes.length bytes1) + Z.of_nat (Datatypes.length bytes2)).","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (m2' : mem) (ST2 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2') : exists m0 : mem,\n  storebytes m b ofs bytes1 = Some m0 /\\\n  storebytes m0 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2.","proofString":"assert (Some m2 = Some m2').\nrewrite <- H.\neapply storebytes_concat; eauto.\ninv H0.\nexists m1; split; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (m2' : mem) (ST2 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2') : Some m2 = Some m2'.","proofString":"rewrite <- H.\neapply storebytes_concat; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (m2' : mem) (ST2 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2') : storebytes m b ofs (bytes1 ++ bytes2) = Some m2'.","proofString":"eapply storebytes_concat; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2 : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2) (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (m2' : mem) (ST2 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2') (H0 : Some m2 = Some m2') : exists m0 : mem,\n  storebytes m b ofs bytes1 = Some m0 /\\\n  storebytes m0 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2.","proofString":"inv H0.\nexists m1; split; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes1 bytes2 : list memval) (m2' : mem) (H : storebytes m b ofs (bytes1 ++ bytes2) = Some m2') (m1 : mem) (ST1 : storebytes m b ofs bytes1 = Some m1) (ST2 : storebytes m1 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 = Some m2') : exists m0 : mem,\n  storebytes m b ofs bytes1 = Some m0 /\\\n  storebytes m0 b (ofs + Z.of_nat (Datatypes.length bytes1)) bytes2 =\n  Some m2'.","proofString":"exists m1; split; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) : exists m1 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  store Mint32 m1 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"exploit store_valid_access_3; eauto.\nintros [A B].\nsimpl in *.\nexploit store_storebytes.\neexact H.\nintros SB.\nrewrite encode_val_int64 in SB by auto.\nexploit storebytes_split.\neexact SB.\nintros [m1 [SB1 SB2]].\nrewrite encode_val_length in SB2.\nsimpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) : valid_access m Mint64 b ofs Writable ->\nexists m1 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  store Mint32 m1 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"intros [A B].\nsimpl in *.\nexploit store_storebytes.\neexact H.\nintros SB.\nrewrite encode_val_int64 in SB by auto.\nexploit storebytes_split.\neexact SB.\nintros [m1 [SB1 SB2]].\nrewrite encode_val_length in SB2.\nsimpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + size_chunk Mint64) Cur Writable) (B : (align_chunk Mint64 | ofs)) : exists m1 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  store Mint32 m1 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"simpl in *.\nexploit store_storebytes.\neexact H.\nintros SB.\nrewrite encode_val_int64 in SB by auto.\nexploit storebytes_split.\neexact SB.\nintros [m1 [SB1 SB2]].\nrewrite encode_val_length in SB2.\nsimpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) : exists m1 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  store Mint32 m1 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"exploit store_storebytes.\neexact H.\nintros SB.\nrewrite encode_val_int64 in SB by auto.\nexploit storebytes_split.\neexact SB.\nintros [m1 [SB1 SB2]].\nrewrite encode_val_length in SB2.\nsimpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs (encode_val Mint64 v) = Some m') : exists m1 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  store Mint32 m1 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"rewrite encode_val_int64 in SB by auto.\nexploit storebytes_split.\neexact SB.\nintros [m1 [SB1 SB2]].\nrewrite encode_val_length in SB2.\nsimpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : exists m1 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  store Mint32 m1 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"exploit storebytes_split.\neexact SB.\nintros [m1 [SB1 SB2]].\nrewrite encode_val_length in SB2.\nsimpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b\n  (ofs +\n   Z.of_nat\n     (Datatypes.length\n        (encode_val Mint32\n           (if Archi.big_endian then Val.hiword v else Val.loword v))))\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : exists m0 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m0 /\\\n  store Mint32 m0 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"rewrite encode_val_length in SB2.\nsimpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + Z.of_nat (size_chunk_nat Mint32))\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : exists m0 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m0 /\\\n  store Mint32 m0 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"simpl in SB2.\nexists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : exists m0 : mem,\n  store Mint32 m b ofs\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m0 /\\\n  store Mint32 m0 b (ofs + 4)\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"exists m1; split.\napply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\napply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : store Mint32 m b ofs\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1.","proofString":"apply storebytes_store.\nexact SB1.\nsimpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1.","proofString":"exact SB1."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (align_chunk Mint32 | ofs).","proofString":"simpl.\napply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (4 | ofs).","proofString":"apply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (4 | 8).","proofString":"exists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : store Mint32 m1 b (ofs + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m'.","proofString":"apply storebytes_store.\nexact SB2.\nsimpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m'.","proofString":"exact SB2."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (align_chunk Mint32 | ofs + 4).","proofString":"simpl.\napply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (4 | ofs + 4).","proofString":"apply Z.divide_add_r.\napply Z.divide_trans with 8; auto.\nexists 2; auto.\nexists 1; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (4 | ofs).","proofString":"apply Z.divide_trans with 8; auto.\nexists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (4 | 8).","proofString":"exists 2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store Mint64 m b ofs v = Some m') (H0 : Archi.ptr64 = false) (A : range_perm m b ofs (ofs + 8) Cur Writable) (B : (8 | ofs)) (SB : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v) ++\n   encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') (m1 : mem) (SB1 : storebytes m b ofs\n  (encode_val Mint32\n     (if Archi.big_endian then Val.hiword v else Val.loword v)) = \nSome m1) (SB2 : storebytes m1 b (ofs + 4)\n  (encode_val Mint32\n     (if Archi.big_endian then Val.loword v else Val.hiword v)) = \nSome m') : (4 | 4).","proofString":"exists 1; auto."},{"statement":"(m : mem) (a v : val) (m' : mem) (H : storev Mint64 m a v = Some m') (H0 : Archi.ptr64 = false) : exists m1 : mem,\n  storev Mint32 m a (if Archi.big_endian then Val.hiword v else Val.loword v) =\n  Some m1 /\\\n  storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"destruct a; simpl in H; inv H.\nrewrite H2.\nexploit store_int64_split; eauto.\nintros [m1 [A B]].\nexists m1; split.\nexact A.\nunfold storev, Val.add.\nrewrite H0.\nrewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') : exists m1 : mem,\n  storev Mint32 m (Vptr b i)\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  storev Mint32 m1 (Val.add (Vptr b i) (Vint (Int.repr 4)))\n    (if Archi.big_endian then Val.loword v else Val.hiword v) =\n  store Mint64 m b (Ptrofs.unsigned i) v.","proofString":"rewrite H2.\nexploit store_int64_split; eauto.\nintros [m1 [A B]].\nexists m1; split.\nexact A.\nunfold storev, Val.add.\nrewrite H0.\nrewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') : exists m1 : mem,\n  storev Mint32 m (Vptr b i)\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  storev Mint32 m1 (Val.add (Vptr b i) (Vint (Int.repr 4)))\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"exploit store_int64_split; eauto.\nintros [m1 [A B]].\nexists m1; split.\nexact A.\nunfold storev, Val.add.\nrewrite H0.\nrewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') : (exists m1 : mem,\n   store Mint32 m b (Ptrofs.unsigned i)\n     (if Archi.big_endian then Val.hiword v else Val.loword v) = \n   Some m1 /\\\n   store Mint32 m1 b (Ptrofs.unsigned i + 4)\n     (if Archi.big_endian then Val.loword v else Val.hiword v) = \n   Some m') ->\nexists m1 : mem,\n  storev Mint32 m (Vptr b i)\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m1 /\\\n  storev Mint32 m1 (Val.add (Vptr b i) (Vint (Int.repr 4)))\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"intros [m1 [A B]].\nexists m1; split.\nexact A.\nunfold storev, Val.add.\nrewrite H0.\nrewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') (m1 : mem) (A : store Mint32 m b (Ptrofs.unsigned i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1) (B : store Mint32 m1 b (Ptrofs.unsigned i + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m') : exists m0 : mem,\n  storev Mint32 m (Vptr b i)\n    (if Archi.big_endian then Val.hiword v else Val.loword v) = \n  Some m0 /\\\n  storev Mint32 m0 (Val.add (Vptr b i) (Vint (Int.repr 4)))\n    (if Archi.big_endian then Val.loword v else Val.hiword v) = \n  Some m'.","proofString":"exists m1; split.\nexact A.\nunfold storev, Val.add.\nrewrite H0.\nrewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') (m1 : mem) (A : store Mint32 m b (Ptrofs.unsigned i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1) (B : store Mint32 m1 b (Ptrofs.unsigned i + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m') : storev Mint32 m (Vptr b i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1.","proofString":"exact A."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') (m1 : mem) (A : store Mint32 m b (Ptrofs.unsigned i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1) (B : store Mint32 m1 b (Ptrofs.unsigned i + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m') : storev Mint32 m1 (Val.add (Vptr b i) (Vint (Int.repr 4)))\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m'.","proofString":"unfold storev, Val.add.\nrewrite H0.\nrewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') (m1 : mem) (A : store Mint32 m b (Ptrofs.unsigned i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1) (B : store Mint32 m1 b (Ptrofs.unsigned i + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m') : match\n  (if Archi.ptr64\n   then Vundef\n   else Vptr b (Ptrofs.add i (Ptrofs.of_int (Int.repr 4))))\nwith\n| Vptr b0 ofs =>\n    store Mint32 m1 b0 (Ptrofs.unsigned ofs)\n      (if Archi.big_endian then Val.loword v else Val.hiword v)\n| _ => None\nend = Some m'.","proofString":"rewrite H0.\nrewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') (m1 : mem) (A : store Mint32 m b (Ptrofs.unsigned i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1) (B : store Mint32 m1 b (Ptrofs.unsigned i + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m') : store Mint32 m1 b\n  (Ptrofs.unsigned (Ptrofs.add i (Ptrofs.of_int (Int.repr 4))))\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m'.","proofString":"rewrite addressing_int64_split; auto.\nexploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') (m1 : mem) (A : store Mint32 m b (Ptrofs.unsigned i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1) (B : store Mint32 m1 b (Ptrofs.unsigned i + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m') : (8 | Ptrofs.unsigned i).","proofString":"exploit store_valid_access_3.\neexact H2.\nintros [P Q].\nexact Q."},{"statement":"(m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H0 : Archi.ptr64 = false) (H2 : store Mint64 m b (Ptrofs.unsigned i) v = Some m') (m1 : mem) (A : store Mint32 m b (Ptrofs.unsigned i)\n  (if Archi.big_endian then Val.hiword v else Val.loword v) = \nSome m1) (B : store Mint32 m1 b (Ptrofs.unsigned i + 4)\n  (if Archi.big_endian then Val.loword v else Val.hiword v) = \nSome m') (P : range_perm m b (Ptrofs.unsigned i) (Ptrofs.unsigned i + size_chunk Mint64)\n  Cur Writable) (Q : (align_chunk Mint64 | Ptrofs.unsigned i)) : (8 | Ptrofs.unsigned i).","proofString":"exact Q."},{"statement":"(H : nextblock m1 = b) (H0 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs : Z) => alloc_obligation_1 m1 lo hi b0 ofs;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs k H1;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : nextblock m2 = Pos.succ (nextblock m1).","proofString":"rewrite <- H0; auto."},{"statement":"(b' : block) (H : Plt b' (nextblock m1)) : Plt b' (nextblock m2).","proofString":"rewrite nextblock_alloc.\napply Plt_trans_succ; auto."},{"statement":"(b' : block) (H : Plt b' (nextblock m1)) : Plt b' (Pos.succ (nextblock m1)).","proofString":"apply Plt_trans_succ; auto."},{"statement":"~ Plt b (nextblock m1).","proofString":"rewrite alloc_result.\napply Plt_strict."},{"statement":"~ Plt (nextblock m1) (nextblock m1).","proofString":"apply Plt_strict."},{"statement":"Plt b (nextblock m2).","proofString":"rewrite alloc_result.\nrewrite nextblock_alloc.\napply Plt_succ."},{"statement":"Plt (nextblock m1) (nextblock m2).","proofString":"rewrite nextblock_alloc.\napply Plt_succ."},{"statement":"Plt (nextblock m1) (Pos.succ (nextblock m1)).","proofString":"apply Plt_succ."},{"statement":"(b' : block) (H : Plt b' (nextblock m2)) : b' = b \\/ Plt b' (nextblock m1).","proofString":"rewrite nextblock_alloc in H.\nrewrite alloc_result.\nexploit Plt_succ_inv; eauto.\ntauto."},{"statement":"(b' : block) (H : Plt b' (Pos.succ (nextblock m1))) : b' = b \\/ Plt b' (nextblock m1).","proofString":"rewrite alloc_result.\nexploit Plt_succ_inv; eauto.\ntauto."},{"statement":"(b' : block) (H : Plt b' (Pos.succ (nextblock m1))) : b' = nextblock m1 \\/ Plt b' (nextblock m1).","proofString":"exploit Plt_succ_inv; eauto.\ntauto."},{"statement":"(b' : block) (H : Plt b' (Pos.succ (nextblock m1))) : Plt b' (nextblock m1) \\/ b' = nextblock m1 ->\nb' = nextblock m1 \\/ Plt b' (nextblock m1).","proofString":"tauto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs k) p) : perm_order' ((mem_access m2) # b' ofs k) p.","proofString":"injection ALLOC; intros.\nrewrite <- H1; simpl.\nsubst b.\nrewrite PMap.gsspec.\ndestruct (peq b' (nextblock m1)); auto.\nrewrite nextblock_noaccess in H.\ncontradiction.\nsubst b'.\napply Plt_strict."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs k) p) (H0 : nextblock m1 = b) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H2 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k0 H2;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : perm_order' ((mem_access m2) # b' ofs k) p.","proofString":"rewrite <- H1; simpl.\nsubst b.\nrewrite PMap.gsspec.\ndestruct (peq b' (nextblock m1)); auto.\nrewrite nextblock_noaccess in H.\ncontradiction.\nsubst b'.\napply Plt_strict."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs k) p) (H0 : nextblock m1 = b) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H2 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k0 H2;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : perm_order'\n  ((PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1)) # b' ofs k) p.","proofString":"subst b.\nrewrite PMap.gsspec.\ndestruct (peq b' (nextblock m1)); auto.\nrewrite nextblock_noaccess in H.\ncontradiction.\nsubst b'.\napply Plt_strict."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs k) p) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order'\n  ((PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1)) # b' ofs k) p.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b' (nextblock m1)); auto.\nrewrite nextblock_noaccess in H.\ncontradiction.\nsubst b'.\napply Plt_strict."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs k) p) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order'\n  ((if peq b' (nextblock m1)\n    then\n     fun (ofs0 : Z) (_ : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None\n    else (mem_access m1) # b') ofs k) p.","proofString":"destruct (peq b' (nextblock m1)); auto.\nrewrite nextblock_noaccess in H.\ncontradiction.\nsubst b'.\napply Plt_strict."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs k) p) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) (e : b' = nextblock m1) : perm_order' (if zle lo ofs && zlt ofs hi then Some Freeable else None) p.","proofString":"rewrite nextblock_noaccess in H.\ncontradiction.\nsubst b'.\napply Plt_strict."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' None p) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) (e : b' = nextblock m1) : perm_order' (if zle lo ofs && zlt ofs hi then Some Freeable else None) p.","proofString":"contradiction."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # b' ofs k) p) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) (e : b' = nextblock m1) : ~ Plt b' (nextblock m1).","proofString":"subst b'.\napply Plt_strict."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : perm_order' ((mem_access m1) # (nextblock m1) ofs k) p) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : ~ Plt (nextblock m1) (nextblock m1).","proofString":"apply Plt_strict."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order' ((mem_access m2) # b ofs k) Freeable.","proofString":"injection ALLOC; intros.\nrewrite <- H1; simpl.\nsubst b.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto with mem.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H0 : nextblock m1 = b) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H2 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k0 H2;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : perm_order' ((mem_access m2) # b ofs k) Freeable.","proofString":"rewrite <- H1; simpl.\nsubst b.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto with mem.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H0 : nextblock m1 = b) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H2 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k0 H2;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : perm_order'\n  ((PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1)) # b ofs k) Freeable.","proofString":"subst b.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto with mem.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order'\n  ((PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1)) # (nextblock m1) ofs k) Freeable.","proofString":"rewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto with mem.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order' (if zle lo ofs && zlt ofs hi then Some Freeable else None)\n  Freeable.","proofString":"unfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto with mem.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order'\n  (if\n    (if zle lo ofs then true else false) &&\n    (if zlt ofs hi then true else false)\n   then Some Freeable\n   else None) Freeable.","proofString":"rewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto with mem.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order'\n  (if true && (if zlt ofs hi then true else false)\n   then Some Freeable\n   else None) Freeable.","proofString":"rewrite zlt_true.\nsimpl.\nauto with mem.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order' (if true && true then Some Freeable else None) Freeable.","proofString":"simpl.\nauto with mem."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : perm_order Freeable Freeable.","proofString":"auto with mem."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : ofs < hi.","proofString":"lia."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) (H1 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H0 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k0 H0;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m2) : lo <= ofs.","proofString":"lia."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) : perm_order' ((mem_access m2) # b' ofs k) p ->\nif eq_block b' b\nthen lo <= ofs < hi\nelse perm_order' ((mem_access m1) # b' ofs k) p.","proofString":"inv ALLOC.\nsimpl.\nrewrite PMap.gsspec.\nunfold eq_block.\ndestruct (peq b' (nextblock m1)); intros.\ndestruct (zle lo ofs); try contradiction.\ndestruct (zlt ofs hi); try contradiction.\nsplit; auto.\nauto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) : perm_order'\n  ((mem_access\n      {|\n        mem_contents :=\n          PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n        mem_access :=\n          PMap.set (nextblock m1)\n            (fun (ofs0 : Z) (_ : perm_kind) =>\n             if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n            (mem_access m1);\n        nextblock := Pos.succ (nextblock m1);\n        access_max :=\n          fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n        nextblock_noaccess :=\n          fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n            (H : ~ Plt b (Pos.succ (nextblock m1))) =>\n          alloc_obligation_2 m1 lo hi b ofs0 k0 H;\n        contents_default := fun b : positive => alloc_obligation_3 m1 b\n      |}) # b' ofs k) p ->\nif eq_block b' (nextblock m1)\nthen lo <= ofs < hi\nelse perm_order' ((mem_access m1) # b' ofs k) p.","proofString":"simpl.\nrewrite PMap.gsspec.\nunfold eq_block.\ndestruct (peq b' (nextblock m1)); intros.\ndestruct (zle lo ofs); try contradiction.\ndestruct (zlt ofs hi); try contradiction.\nsplit; auto.\nauto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) : perm_order'\n  ((PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1)) # b' ofs k) p ->\nif eq_block b' (nextblock m1)\nthen lo <= ofs < hi\nelse perm_order' ((mem_access m1) # b' ofs k) p.","proofString":"rewrite PMap.gsspec.\nunfold eq_block.\ndestruct (peq b' (nextblock m1)); intros.\ndestruct (zle lo ofs); try contradiction.\ndestruct (zlt ofs hi); try contradiction.\nsplit; auto.\nauto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) : perm_order'\n  ((if peq b' (nextblock m1)\n    then\n     fun (ofs0 : Z) (_ : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None\n    else (mem_access m1) # b') ofs k) p ->\nif eq_block b' (nextblock m1)\nthen lo <= ofs < hi\nelse perm_order' ((mem_access m1) # b' ofs k) p.","proofString":"unfold eq_block.\ndestruct (peq b' (nextblock m1)); intros.\ndestruct (zle lo ofs); try contradiction.\ndestruct (zlt ofs hi); try contradiction.\nsplit; auto.\nauto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) : perm_order'\n  ((if peq b' (nextblock m1)\n    then\n     fun (ofs0 : Z) (_ : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None\n    else (mem_access m1) # b') ofs k) p ->\nif peq b' (nextblock m1)\nthen lo <= ofs < hi\nelse perm_order' ((mem_access m1) # b' ofs k) p.","proofString":"destruct (peq b' (nextblock m1)); intros.\ndestruct (zle lo ofs); try contradiction.\ndestruct (zlt ofs hi); try contradiction.\nsplit; auto.\nauto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (e : b' = nextblock m1) (H : perm_order' (if zle lo ofs && zlt ofs hi then Some Freeable else None) p) : lo <= ofs < hi.","proofString":"destruct (zle lo ofs); try contradiction.\ndestruct (zlt ofs hi); try contradiction.\nsplit; auto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (n : b' <> nextblock m1) (H : perm_order' ((mem_access m1) # b' ofs k) p) : perm_order' ((mem_access m1) # b' ofs k) p.","proofString":"auto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b ofs k p) : lo <= ofs < hi.","proofString":"exploit perm_alloc_inv; eauto.\nrewrite dec_eq_true; auto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b ofs k p) : (if eq_block b b then lo <= ofs < hi else perm m1 b ofs k p) ->\nlo <= ofs < hi.","proofString":"rewrite dec_eq_true; auto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b' ofs k p) (H0 : b' <> b) : perm m1 b' ofs k p.","proofString":"exploit perm_alloc_inv; eauto.\nrewrite dec_eq_false; auto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b' ofs k p) (H0 : b' <> b) : (if eq_block b' b then lo <= ofs < hi else perm m1 b' ofs k p) ->\nperm m1 b' ofs k p.","proofString":"rewrite dec_eq_false; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H : valid_access m1 chunk b' ofs p) : valid_access m2 chunk b' ofs p.","proofString":"inv H.\nconstructor; auto with mem.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m1 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) : valid_access m2 chunk b' ofs p.","proofString":"constructor; auto with mem.\nred; auto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m1 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) : range_perm m2 b' ofs (ofs + size_chunk chunk) Cur p.","proofString":"red; auto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) : valid_access m2 chunk b ofs Freeable.","proofString":"constructor; auto with mem.\nred; intros.\napply perm_alloc_2.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) : range_perm m2 b ofs (ofs + size_chunk chunk) Cur Freeable.","proofString":"red; intros.\napply perm_alloc_2.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m2 b ofs0 Cur Freeable.","proofString":"apply perm_alloc_2.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : lo <= ofs0 < hi.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H : valid_access m2 chunk b' ofs p) : if eq_block b' b\nthen lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs)\nelse valid_access m1 chunk b' ofs p.","proofString":"inv H.\ngeneralize (size_chunk_pos chunk); intro.\ndestruct (eq_block b' b).\nsubst b'.\nassert (perm m2 b ofs Cur p).\napply H0.\nlia.\nassert (perm m2 b (ofs + size_chunk chunk - 1) Cur p).\napply H0.\nlia.\nexploit perm_alloc_inv.\neexact H2.\nrewrite dec_eq_true.\nintro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia.\nsplit; auto.\nred; intros.\nexploit perm_alloc_inv.\napply H0.\neauto.\nrewrite dec_eq_false; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m2 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) : if eq_block b' b\nthen lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs)\nelse valid_access m1 chunk b' ofs p.","proofString":"generalize (size_chunk_pos chunk); intro.\ndestruct (eq_block b' b).\nsubst b'.\nassert (perm m2 b ofs Cur p).\napply H0.\nlia.\nassert (perm m2 b (ofs + size_chunk chunk - 1) Cur p).\napply H0.\nlia.\nexploit perm_alloc_inv.\neexact H2.\nrewrite dec_eq_true.\nintro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia.\nsplit; auto.\nred; intros.\nexploit perm_alloc_inv.\napply H0.\neauto.\nrewrite dec_eq_false; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m2 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) : if eq_block b' b\nthen lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs)\nelse valid_access m1 chunk b' ofs p.","proofString":"destruct (eq_block b' b).\nsubst b'.\nassert (perm m2 b ofs Cur p).\napply H0.\nlia.\nassert (perm m2 b (ofs + size_chunk chunk - 1) Cur p).\napply H0.\nlia.\nexploit perm_alloc_inv.\neexact H2.\nrewrite dec_eq_true.\nintro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia.\nsplit; auto.\nred; intros.\nexploit perm_alloc_inv.\napply H0.\neauto.\nrewrite dec_eq_false; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m2 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (e : b' = b) : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"subst b'.\nassert (perm m2 b ofs Cur p).\napply H0.\nlia.\nassert (perm m2 b (ofs + size_chunk chunk - 1) Cur p).\napply H0.\nlia.\nexploit perm_alloc_inv.\neexact H2.\nrewrite dec_eq_true.\nintro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"assert (perm m2 b ofs Cur p).\napply H0.\nlia.\nassert (perm m2 b (ofs + size_chunk chunk - 1) Cur p).\napply H0.\nlia.\nexploit perm_alloc_inv.\neexact H2.\nrewrite dec_eq_true.\nintro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) : perm m2 b ofs Cur p.","proofString":"apply H0.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) : ofs <= ofs < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"assert (perm m2 b (ofs + size_chunk chunk - 1) Cur p).\napply H0.\nlia.\nexploit perm_alloc_inv.\neexact H2.\nrewrite dec_eq_true.\nintro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) : perm m2 b (ofs + size_chunk chunk - 1) Cur p.","proofString":"apply H0.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) : ofs <= ofs + size_chunk chunk - 1 < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) (H3 : perm m2 b (ofs + size_chunk chunk - 1) Cur p) : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"exploit perm_alloc_inv.\neexact H2.\nrewrite dec_eq_true.\nintro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) (H3 : perm m2 b (ofs + size_chunk chunk - 1) Cur p) : lo <= ofs < hi ->\nlo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"intro.\nexploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) (H3 : perm m2 b (ofs + size_chunk chunk - 1) Cur p) (H4 : lo <= ofs < hi) : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"exploit perm_alloc_inv.\neexact H3.\nrewrite dec_eq_true.\nintro.\nintuition lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) (H3 : perm m2 b (ofs + size_chunk chunk - 1) Cur p) (H4 : lo <= ofs < hi) : lo <= ofs + size_chunk chunk - 1 < hi ->\nlo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"intro.\nintuition lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (H2 : perm m2 b ofs Cur p) (H3 : perm m2 b (ofs + size_chunk chunk - 1) Cur p) (H4 : lo <= ofs < hi) (H5 : lo <= ofs + size_chunk chunk - 1 < hi) : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs).","proofString":"intuition lia."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m2 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (n : b' <> b) : valid_access m1 chunk b' ofs p.","proofString":"split; auto.\nred; intros.\nexploit perm_alloc_inv.\napply H0.\neauto.\nrewrite dec_eq_false; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m2 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (n : b' <> b) : range_perm m1 b' ofs (ofs + size_chunk chunk) Cur p.","proofString":"red; intros.\nexploit perm_alloc_inv.\napply H0.\neauto.\nrewrite dec_eq_false; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p : permission) (H0 : range_perm m2 b' ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (H : size_chunk chunk > 0) (n : b' <> b) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m1 b' ofs0 Cur p.","proofString":"exploit perm_alloc_inv.\napply H0.\neauto.\nrewrite dec_eq_false; auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') : load chunk m2 b' ofs = load chunk m1 b' ofs.","proofString":"unfold load.\ndestruct (valid_access_dec m2 chunk b' ofs Readable).\nexploit valid_access_alloc_inv; eauto.\ndestruct (eq_block b' b); intros.\nsubst b'.\nexfalso.\neauto with mem.\nrewrite pred_dec_true; auto.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem.\nrewrite pred_dec_false.\nauto.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') : (if valid_access_dec m2 chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b'))\n else None) =\n(if valid_access_dec m1 chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b'))\n else None).","proofString":"destruct (valid_access_dec m2 chunk b' ofs Readable).\nexploit valid_access_alloc_inv; eauto.\ndestruct (eq_block b' b); intros.\nsubst b'.\nexfalso.\neauto with mem.\nrewrite pred_dec_true; auto.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem.\nrewrite pred_dec_false.\nauto.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b')) =\n(if valid_access_dec m1 chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b'))\n else None).","proofString":"exploit valid_access_alloc_inv; eauto.\ndestruct (eq_block b' b); intros.\nsubst b'.\nexfalso.\neauto with mem.\nrewrite pred_dec_true; auto.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) : (if eq_block b' b\n then lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs)\n else valid_access m1 chunk b' ofs Readable) ->\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b')) =\n(if valid_access_dec m1 chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b'))\n else None).","proofString":"destruct (eq_block b' b); intros.\nsubst b'.\nexfalso.\neauto with mem.\nrewrite pred_dec_true; auto.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (e : b' = b) (H0 : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs)) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b')) =\n(if valid_access_dec m1 chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b'))\n else None).","proofString":"subst b'.\nexfalso.\neauto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : valid_access m2 chunk b ofs Readable) (H : valid_block m1 b) (H0 : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs)) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) =\n(if valid_access_dec m1 chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b))\n else None).","proofString":"exfalso.\neauto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : valid_access m2 chunk b ofs Readable) (H : valid_block m1 b) (H0 : lo <= ofs /\\ ofs + size_chunk chunk <= hi /\\ (align_chunk chunk | ofs)) : False.","proofString":"eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (n : b' <> b) (H0 : valid_access m1 chunk b' ofs Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b')) =\n(if valid_access_dec m1 chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b'))\n else None).","proofString":"rewrite pred_dec_true; auto.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (n : b' <> b) (H0 : valid_access m1 chunk b' ofs Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b')).","proofString":"injection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (n : b' <> b) (H0 : valid_access m1 chunk b' ofs Readable) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b')).","proofString":"rewrite <- H2; simpl.\nrewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (n : b' <> b) (H0 : valid_access m1 chunk b' ofs Readable) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : Some\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) ofs\n        (PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1)) # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b')).","proofString":"rewrite PMap.gso.\nauto.\nrewrite H1.\napply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (n : b' <> b) (H0 : valid_access m1 chunk b' ofs Readable) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b')).","proofString":"auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (n : b' <> b) (H0 : valid_access m1 chunk b' ofs Readable) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : b' <> nextblock m1.","proofString":"rewrite H1.\napply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (v : valid_access m2 chunk b' ofs Readable) (n : b' <> b) (H0 : valid_access m1 chunk b' ofs Readable) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : b' <> b.","proofString":"apply not_eq_sym; eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (n : ~ valid_access m2 chunk b' ofs Readable) : None =\n(if valid_access_dec m1 chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b'))\n else None).","proofString":"rewrite pred_dec_false.\nauto.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : valid_block m1 b') (n : ~ valid_access m2 chunk b' ofs Readable) : ~ valid_access m1 chunk b' ofs Readable.","proofString":"eauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (v : val) (H : load chunk m1 b' ofs = Some v) : load chunk m2 b' ofs = Some v.","proofString":"rewrite <- H.\napply load_alloc_unchanged.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (v : val) (H : load chunk m1 b' ofs = Some v) : load chunk m2 b' ofs = load chunk m1 b' ofs.","proofString":"apply load_alloc_unchanged.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (v : val) (H : load chunk m1 b' ofs = Some v) : valid_block m1 b'.","proofString":"eauto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : v = Vundef.","proofString":"exploit load_result; eauto.\nintro.\nrewrite H0.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite <- H1.\nrewrite PMap.gss.\ndestruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b) ->\nv = Vundef.","proofString":"intro.\nrewrite H0.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite <- H1.\nrewrite PMap.gss.\ndestruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) : v = Vundef.","proofString":"rewrite H0.\ninjection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite <- H1.\nrewrite PMap.gss.\ndestruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) : decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b) =\nVundef.","proofString":"injection ALLOC; intros.\nrewrite <- H2; simpl.\nrewrite <- H1.\nrewrite PMap.gss.\ndestruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b) =\nVundef.","proofString":"rewrite <- H2; simpl.\nrewrite <- H1.\nrewrite PMap.gss.\ndestruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : decode_val chunk\n  (getN (size_chunk_nat chunk) ofs\n     (PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1)) # b) =\nVundef.","proofString":"rewrite <- H1.\nrewrite PMap.gss.\ndestruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : decode_val chunk\n  (getN (size_chunk_nat chunk) ofs\n     (PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1))\n     # (nextblock m1)) = Vundef.","proofString":"rewrite PMap.gss.\ndestruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : decode_val chunk (getN (size_chunk_nat chunk) ofs (ZMap.init Undef)) = Vundef.","proofString":"destruct (size_chunk_nat_pos chunk) as [n E].\nrewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) (n : nat) (E : size_chunk_nat chunk = S n) : decode_val chunk (getN (size_chunk_nat chunk) ofs (ZMap.init Undef)) = Vundef.","proofString":"rewrite E.\nsimpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) (n : nat) (E : size_chunk_nat chunk = S n) : decode_val chunk (getN (S n) ofs (ZMap.init Undef)) = Vundef.","proofString":"simpl.\nrewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) (n : nat) (E : size_chunk_nat chunk = S n) : decode_val chunk\n  (ZMap.get ofs (ZMap.init Undef) :: getN n (ofs + 1) (ZMap.init Undef)) =\nVundef.","proofString":"rewrite ZMap.gi.\napply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) (H0 : v = decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) (H1 : nextblock m1 = b) (H2 : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H3;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) (n : nat) (E : size_chunk_nat chunk = S n) : decode_val chunk (Undef :: getN n (ofs + 1) (ZMap.init Undef)) = Vundef.","proofString":"apply decode_val_undef."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) : load chunk m2 b ofs = Some Vundef.","proofString":"assert (exists v, load chunk m2 b ofs = Some v).\napply valid_access_load.\nconstructor; auto.\nred; intros.\neapply perm_implies.\napply perm_alloc_2.\nlia.\nauto with mem.\ndestruct H2 as [v LOAD].\nrewrite LOAD.\ndecEq.\neapply load_alloc_same; eauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) : exists v : val, load chunk m2 b ofs = Some v.","proofString":"apply valid_access_load.\nconstructor; auto.\nred; intros.\neapply perm_implies.\napply perm_alloc_2.\nlia.\nauto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) : valid_access m2 chunk b ofs Readable.","proofString":"constructor; auto.\nred; intros.\neapply perm_implies.\napply perm_alloc_2.\nlia.\nauto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) : range_perm m2 b ofs (ofs + size_chunk chunk) Cur Readable.","proofString":"red; intros.\neapply perm_implies.\napply perm_alloc_2.\nlia.\nauto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m2 b ofs0 Cur Readable.","proofString":"eapply perm_implies.\napply perm_alloc_2.\nlia.\nauto with mem."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : lo <= ofs0 < hi.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (H2 : exists v : val, load chunk m2 b ofs = Some v) : load chunk m2 b ofs = Some Vundef.","proofString":"destruct H2 as [v LOAD].\nrewrite LOAD.\ndecEq.\neapply load_alloc_same; eauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (v : val) (LOAD : load chunk m2 b ofs = Some v) : load chunk m2 b ofs = Some Vundef.","proofString":"rewrite LOAD.\ndecEq.\neapply load_alloc_same; eauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (v : val) (LOAD : load chunk m2 b ofs = Some v) : Some v = Some Vundef.","proofString":"decEq.\neapply load_alloc_same; eauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (H : lo <= ofs) (H0 : ofs + size_chunk chunk <= hi) (H1 : (align_chunk chunk | ofs)) (v : val) (LOAD : load chunk m2 b ofs = Some v) : v = Vundef.","proofString":"eapply load_alloc_same; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') : loadbytes m2 b' ofs n = loadbytes m1 b' ofs n.","proofString":"unfold loadbytes.\ndestruct (range_perm_dec m1 b' ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\ninjection ALLOC; intros A B.\nrewrite <- B; simpl.\nrewrite PMap.gso.\nauto.\nrewrite A.\neauto with mem.\nred; intros.\neapply perm_alloc_1; eauto.\nrewrite pred_dec_false; auto.\nred; intros; elim n0.\nred; intros.\neapply perm_alloc_4; eauto.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') : (if range_perm_dec m2 b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m2) # b')\n else None) =\n(if range_perm_dec m1 b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m1) # b')\n else None).","proofString":"destruct (range_perm_dec m1 b' ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\ninjection ALLOC; intros A B.\nrewrite <- B; simpl.\nrewrite PMap.gso.\nauto.\nrewrite A.\neauto with mem.\nred; intros.\neapply perm_alloc_1; eauto.\nrewrite pred_dec_false; auto.\nred; intros; elim n0.\nred; intros.\neapply perm_alloc_4; eauto.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) : (if range_perm_dec m2 b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m2) # b')\n else None) = Some (getN (Z.to_nat n) ofs (mem_contents m1) # b').","proofString":"rewrite pred_dec_true.\ninjection ALLOC; intros A B.\nrewrite <- B; simpl.\nrewrite PMap.gso.\nauto.\nrewrite A.\neauto with mem.\nred; intros.\neapply perm_alloc_1; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) : Some (getN (Z.to_nat n) ofs (mem_contents m2) # b') =\nSome (getN (Z.to_nat n) ofs (mem_contents m1) # b').","proofString":"injection ALLOC; intros A B.\nrewrite <- B; simpl.\nrewrite PMap.gso.\nauto.\nrewrite A.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H0 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H0;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : Some (getN (Z.to_nat n) ofs (mem_contents m2) # b') =\nSome (getN (Z.to_nat n) ofs (mem_contents m1) # b').","proofString":"rewrite <- B; simpl.\nrewrite PMap.gso.\nauto.\nrewrite A.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H0 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H0;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : Some\n  (getN (Z.to_nat n) ofs\n     (PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1)) # b') =\nSome (getN (Z.to_nat n) ofs (mem_contents m1) # b').","proofString":"rewrite PMap.gso.\nauto.\nrewrite A.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H0 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H0;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : Some (getN (Z.to_nat n) ofs (mem_contents m1) # b') =\nSome (getN (Z.to_nat n) ofs (mem_contents m1) # b').","proofString":"auto."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H0 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H0;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : b' <> nextblock m1.","proofString":"rewrite A.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b0 ofs0;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n      (H0 : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs0 k H0;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) : b' <> b.","proofString":"eauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) : range_perm m2 b' ofs (ofs + n) Cur Readable.","proofString":"red; intros.\neapply perm_alloc_1; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (r : range_perm m1 b' ofs (ofs + n) Cur Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) : perm m2 b' ofs0 Cur Readable.","proofString":"eapply perm_alloc_1; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (n0 : ~ range_perm m1 b' ofs (ofs + n) Cur Readable) : (if range_perm_dec m2 b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m2) # b')\n else None) = None.","proofString":"rewrite pred_dec_false; auto.\nred; intros; elim n0.\nred; intros.\neapply perm_alloc_4; eauto.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (n0 : ~ range_perm m1 b' ofs (ofs + n) Cur Readable) : ~ range_perm m2 b' ofs (ofs + n) Cur Readable.","proofString":"red; intros; elim n0.\nred; intros.\neapply perm_alloc_4; eauto.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (n0 : ~ range_perm m1 b' ofs (ofs + n) Cur Readable) (H0 : range_perm m2 b' ofs (ofs + n) Cur Readable) : range_perm m1 b' ofs (ofs + n) Cur Readable.","proofString":"red; intros.\neapply perm_alloc_4; eauto.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (n0 : ~ range_perm m1 b' ofs (ofs + n) Cur Readable) (H0 : range_perm m2 b' ofs (ofs + n) Cur Readable) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + n) : perm m1 b' ofs0 Cur Readable.","proofString":"eapply perm_alloc_4; eauto.\neauto with mem."},{"statement":"(b' : block) (ofs n : Z) (H : valid_block m1 b') (n0 : ~ range_perm m1 b' ofs (ofs + n) Cur Readable) (H0 : range_perm m2 b' ofs (ofs + n) Cur Readable) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + n) : b' <> b.","proofString":"eauto with mem."},{"statement":"(n ofs : Z) (bytes : list memval) (byte : memval) (H : (if range_perm_dec m2 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m2) # b)\n else None) = Some bytes) (H0 : In byte bytes) : byte = Undef.","proofString":"destruct (range_perm_dec m2 b ofs (ofs + n) Cur Readable); inv H.\nrevert H0.\ninjection ALLOC; intros A B.\nrewrite <- A; rewrite <- B; simpl.\nrewrite PMap.gss.\ngeneralize (Z.to_nat n) ofs.\ninduction n0; simpl; intros.\ncontradiction.\nrewrite ZMap.gi in H0.\ndestruct H0; eauto."},{"statement":"(n ofs : Z) (byte : memval) (r : range_perm m2 b ofs (ofs + n) Cur Readable) (H0 : In byte (getN (Z.to_nat n) ofs (mem_contents m2) # b)) : byte = Undef.","proofString":"revert H0.\ninjection ALLOC; intros A B.\nrewrite <- A; rewrite <- B; simpl.\nrewrite PMap.gss.\ngeneralize (Z.to_nat n) ofs.\ninduction n0; simpl; intros.\ncontradiction.\nrewrite ZMap.gi in H0.\ndestruct H0; eauto."},{"statement":"(n ofs : Z) (byte : memval) (r : range_perm m2 b ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs1 : Z) (_ : perm_kind) =>\n       if zle lo ofs1 && zlt ofs1 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs1 : Z) => alloc_obligation_1 m1 lo hi b0 ofs1;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n      (H : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs1 k H;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) (ofs0 : Z) (H0 : False) : byte = Undef.","proofString":"contradiction."},{"statement":"(n ofs : Z) (byte : memval) (r : range_perm m2 b ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs1 : Z) (_ : perm_kind) =>\n       if zle lo ofs1 && zlt ofs1 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs1 : Z) => alloc_obligation_1 m1 lo hi b0 ofs1;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n      (H : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs1 k H;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) (n0 : nat) (IHn0 : forall ofs1 : Z, In byte (getN n0 ofs1 (ZMap.init Undef)) -> byte = Undef) (ofs0 : Z) (H0 : ZMap.get ofs0 (ZMap.init Undef) = byte \\/\nIn byte (getN n0 (ofs0 + 1) (ZMap.init Undef))) : byte = Undef.","proofString":"rewrite ZMap.gi in H0.\ndestruct H0; eauto."},{"statement":"(n ofs : Z) (byte : memval) (r : range_perm m2 b ofs (ofs + n) Cur Readable) (A : nextblock m1 = b) (B : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs1 : Z) (_ : perm_kind) =>\n       if zle lo ofs1 && zlt ofs1 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b0 : positive) (ofs1 : Z) => alloc_obligation_1 m1 lo hi b0 ofs1;\n  nextblock_noaccess :=\n    fun (b0 : positive) (ofs1 : Z) (k : perm_kind)\n      (H : ~ Plt b0 (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b0 ofs1 k H;\n  contents_default := fun b0 : positive => alloc_obligation_3 m1 b0\n|} = m2) (n0 : nat) (IHn0 : forall ofs1 : Z, In byte (getN n0 ofs1 (ZMap.init Undef)) -> byte = Undef) (ofs0 : Z) (H0 : Undef = byte \\/ In byte (getN n0 (ofs0 + 1) (ZMap.init Undef))) : byte = Undef.","proofString":"destruct H0; eauto."},{"statement":"(m1 : mem) (b : block) (lo hi : Z) (H : range_perm m1 b lo hi Cur Freeable) : {m2 : mem\n| (if range_perm_dec m1 b lo hi Cur Freeable\n   then Some (unchecked_free m1 b lo hi)\n   else None) = Some m2}.","proofString":"rewrite pred_dec_true; auto.\neconstructor; eauto."},{"statement":"(m1 : mem) (b : block) (lo hi : Z) (H : range_perm m1 b lo hi Cur Freeable) : {m2 : mem | Some (unchecked_free m1 b lo hi) = Some m2}.","proofString":"econstructor; eauto."},{"statement":"(b : block) (H : valid_block m1 b) : valid_block m2 b.","proofString":"rewrite free_result.\nassumption."},{"statement":"(b : block) (H : valid_block m1 b) : valid_block (unchecked_free m1 bf lo hi) b.","proofString":"assumption."},{"statement":"(b : block) (H : valid_block m2 b) : valid_block m1 b.","proofString":"rewrite free_result in H.\nassumption."},{"statement":"(b : block) (H : valid_block (unchecked_free m1 bf lo hi) b) : valid_block m1 b.","proofString":"assumption."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : b <> bf \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m1 b ofs k p) : perm m2 b ofs k p.","proofString":"rewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\nexfalso; intuition auto with zarith.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : b <> bf \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m1 b ofs k p) : perm (unchecked_free m1 bf lo hi) b ofs k p.","proofString":"unfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\nexfalso; intuition auto with zarith.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : b <> bf \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m1 b ofs k p) : perm_order'\n  ((PMap.set bf\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then None\n       else (mem_access m1) # bf ofs0 k0) (mem_access m1)) # b ofs k) p.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\nexfalso; intuition auto with zarith.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : b <> bf \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m1 b ofs k p) : perm_order'\n  ((if peq b bf\n    then\n     fun (ofs0 : Z) (k0 : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi\n     then None\n     else (mem_access m1) # bf ofs0 k0\n    else (mem_access m1) # b) ofs k) p.","proofString":"destruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\nexfalso; intuition auto with zarith.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : b <> bf \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m1 b ofs k p) (e : b = bf) : perm_order'\n  (if zle lo ofs && zlt ofs hi then None else (mem_access m1) # bf ofs k) p.","proofString":"subst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\nexfalso; intuition auto with zarith.\nauto.\nauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m1 bf ofs k p) (H : bf <> bf \\/ ofs < lo \\/ hi <= ofs) : perm_order'\n  (if zle lo ofs && zlt ofs hi then None else (mem_access m1) # bf ofs k) p.","proofString":"destruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\nexfalso; intuition auto with zarith.\nauto.\nauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m1 bf ofs k p) (H : bf <> bf \\/ ofs < lo \\/ hi <= ofs) (l : lo <= ofs) : perm_order'\n  (if proj_sumbool (zlt ofs hi) then None else (mem_access m1) # bf ofs k) p.","proofString":"destruct (zlt ofs hi); simpl.\nexfalso; intuition auto with zarith.\nauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m1 bf ofs k p) (H : bf <> bf \\/ ofs < lo \\/ hi <= ofs) (l : lo <= ofs) (l0 : ofs < hi) : False.","proofString":"exfalso; intuition auto with zarith."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m1 bf ofs k p) (H : bf <> bf \\/ ofs < lo \\/ hi <= ofs) (l : lo <= ofs) (g : ofs >= hi) : perm_order' ((mem_access m1) # bf ofs k) p.","proofString":"auto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m1 bf ofs k p) (H : bf <> bf \\/ ofs < lo \\/ hi <= ofs) (g : lo > ofs) : perm_order' ((mem_access m1) # bf ofs k) p.","proofString":"auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : b <> bf \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m1 b ofs k p) (n : b <> bf) : perm_order' ((mem_access m1) # b ofs k) p.","proofString":"auto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~ perm m2 bf ofs k p.","proofString":"rewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\ntauto.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~ perm (unchecked_free m1 bf lo hi) bf ofs k p.","proofString":"unfold perm, unchecked_free; simpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\ntauto.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~\nperm_order'\n  ((PMap.set bf\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then None\n       else (mem_access m1) # bf ofs0 k0) (mem_access m1)) # bf ofs k) p.","proofString":"rewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\ntauto.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~\nperm_order'\n  (if zle lo ofs && zlt ofs hi then None else (mem_access m1) # bf ofs k) p.","proofString":"unfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\ntauto.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~\nperm_order'\n  (if\n    (if zle lo ofs then true else false) &&\n    (if zlt ofs hi then true else false)\n   then None\n   else (mem_access m1) # bf ofs k) p.","proofString":"rewrite zle_true.\nrewrite zlt_true.\nsimpl.\ntauto.\nlia.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~\nperm_order'\n  (if true && (if zlt ofs hi then true else false)\n   then None\n   else (mem_access m1) # bf ofs k) p.","proofString":"rewrite zlt_true.\nsimpl.\ntauto.\nlia."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~ perm_order' (if true && true then None else (mem_access m1) # bf ofs k) p.","proofString":"simpl.\ntauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ~ False.","proofString":"tauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : ofs < hi.","proofString":"lia."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : lo <= ofs < hi) : lo <= ofs.","proofString":"lia."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) : perm m2 b ofs k p -> perm m1 b ofs k p.","proofString":"rewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) : perm (unchecked_free m1 bf lo hi) b ofs k p -> perm m1 b ofs k p.","proofString":"unfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) : perm_order'\n  ((PMap.set bf\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then None\n       else (mem_access m1) # bf ofs0 k0) (mem_access m1)) # b ofs k) p ->\nperm_order' ((mem_access m1) # b ofs k) p.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) : perm_order'\n  ((if peq b bf\n    then\n     fun (ofs0 : Z) (k0 : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi\n     then None\n     else (mem_access m1) # bf ofs0 k0\n    else (mem_access m1) # b) ofs k) p ->\nperm_order' ((mem_access m1) # b ofs k) p.","proofString":"destruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (e : b = bf) : perm_order'\n  (if zle lo ofs && zlt ofs hi then None else (mem_access m1) # bf ofs k) p ->\nperm_order' ((mem_access m1) # b ofs k) p.","proofString":"subst b.\ndestruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\ntauto.\nauto.\nauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) : perm_order'\n  (if zle lo ofs && zlt ofs hi then None else (mem_access m1) # bf ofs k) p ->\nperm_order' ((mem_access m1) # bf ofs k) p.","proofString":"destruct (zle lo ofs); simpl.\ndestruct (zlt ofs hi); simpl.\ntauto.\nauto.\nauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (l : lo <= ofs) : perm_order'\n  (if proj_sumbool (zlt ofs hi) then None else (mem_access m1) # bf ofs k) p ->\nperm_order' ((mem_access m1) # bf ofs k) p.","proofString":"destruct (zlt ofs hi); simpl.\ntauto.\nauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (l : lo <= ofs) (l0 : ofs < hi) : False -> perm_order' ((mem_access m1) # bf ofs k) p.","proofString":"tauto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (l : lo <= ofs) (g : ofs >= hi) : perm_order' ((mem_access m1) # bf ofs k) p ->\nperm_order' ((mem_access m1) # bf ofs k) p.","proofString":"auto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (g : lo > ofs) : perm_order' ((mem_access m1) # bf ofs k) p ->\nperm_order' ((mem_access m1) # bf ofs k) p.","proofString":"auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (n : b <> bf) : perm_order' ((mem_access m1) # b ofs k) p ->\nperm_order' ((mem_access m1) # b ofs k) p.","proofString":"auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m1 b ofs k p) : b = bf /\\ lo <= ofs < hi \\/ perm m2 b ofs k p.","proofString":"rewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf); auto.\nsubst b.\ndestruct (zle lo ofs); simpl; auto.\ndestruct (zlt ofs hi); simpl; auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m1 b ofs k p) : b = bf /\\ lo <= ofs < hi \\/ perm (unchecked_free m1 bf lo hi) b ofs k p.","proofString":"unfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf); auto.\nsubst b.\ndestruct (zle lo ofs); simpl; auto.\ndestruct (zlt ofs hi); simpl; auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m1 b ofs k p) : b = bf /\\ lo <= ofs < hi \\/\nperm_order'\n  ((PMap.set bf\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then None\n       else (mem_access m1) # bf ofs0 k0) (mem_access m1)) # b ofs k) p.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b bf); auto.\nsubst b.\ndestruct (zle lo ofs); simpl; auto.\ndestruct (zlt ofs hi); simpl; auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m1 b ofs k p) : b = bf /\\ lo <= ofs < hi \\/\nperm_order'\n  ((if peq b bf\n    then\n     fun (ofs0 : Z) (k0 : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi\n     then None\n     else (mem_access m1) # bf ofs0 k0\n    else (mem_access m1) # b) ofs k) p.","proofString":"destruct (peq b bf); auto.\nsubst b.\ndestruct (zle lo ofs); simpl; auto.\ndestruct (zlt ofs hi); simpl; auto."},{"statement":"(b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m1 b ofs k p) (e : b = bf) : b = bf /\\ lo <= ofs < hi \\/\nperm_order'\n  (if zle lo ofs && zlt ofs hi then None else (mem_access m1) # bf ofs k) p.","proofString":"subst b.\ndestruct (zle lo ofs); simpl; auto.\ndestruct (zlt ofs hi); simpl; auto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : perm m1 bf ofs k p) : bf = bf /\\ lo <= ofs < hi \\/\nperm_order'\n  (if zle lo ofs && zlt ofs hi then None else (mem_access m1) # bf ofs k) p.","proofString":"destruct (zle lo ofs); simpl; auto.\ndestruct (zlt ofs hi); simpl; auto."},{"statement":"(ofs : Z) (k : perm_kind) (p : permission) (H : perm m1 bf ofs k p) (l : lo <= ofs) : bf = bf /\\ lo <= ofs < hi \\/\nperm_order'\n  (if proj_sumbool (zlt ofs hi) then None else (mem_access m1) # bf ofs k) p.","proofString":"destruct (zlt ofs hi); simpl; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : valid_access m1 chunk b ofs p) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) : valid_access m2 chunk b ofs p.","proofString":"inv H.\nconstructor; auto with mem.\nred; intros.\neapply perm_free_1; eauto.\ndestruct (zlt lo hi).\nintuition auto with zarith.\nright.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (H1 : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H2 : (align_chunk chunk | ofs)) : valid_access m2 chunk b ofs p.","proofString":"constructor; auto with mem.\nred; intros.\neapply perm_free_1; eauto.\ndestruct (zlt lo hi).\nintuition auto with zarith.\nright.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (H1 : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H2 : (align_chunk chunk | ofs)) : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p.","proofString":"red; intros.\neapply perm_free_1; eauto.\ndestruct (zlt lo hi).\nintuition auto with zarith.\nright.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (H1 : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H2 : (align_chunk chunk | ofs)) (ofs0 : Z) (H : ofs <= ofs0 < ofs + size_chunk chunk) : perm m2 b ofs0 Cur p.","proofString":"eapply perm_free_1; eauto.\ndestruct (zlt lo hi).\nintuition auto with zarith.\nright.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (H1 : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H2 : (align_chunk chunk | ofs)) (ofs0 : Z) (H : ofs <= ofs0 < ofs + size_chunk chunk) : b <> bf \\/ ofs0 < lo \\/ hi <= ofs0.","proofString":"destruct (zlt lo hi).\nintuition auto with zarith.\nright.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (H1 : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H2 : (align_chunk chunk | ofs)) (ofs0 : Z) (H : ofs <= ofs0 < ofs + size_chunk chunk) (l : lo < hi) : b <> bf \\/ ofs0 < lo \\/ hi <= ofs0.","proofString":"intuition auto with zarith."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (H1 : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H2 : (align_chunk chunk | ofs)) (ofs0 : Z) (H : ofs <= ofs0 < ofs + size_chunk chunk) (g : lo >= hi) : b <> bf \\/ ofs0 < lo \\/ hi <= ofs0.","proofString":"right.\nlia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (H1 : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H2 : (align_chunk chunk | ofs)) (ofs0 : Z) (H : ofs <= ofs0 < ofs + size_chunk chunk) (g : lo >= hi) : ofs0 < lo \\/ hi <= ofs0.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H2 : valid_access m2 chunk bf ofs p) : False.","proofString":"inv H2.\ngeneralize (size_chunk_pos chunk); intros.\ndestruct (zlt ofs lo).\nelim (perm_free_2 lo Cur p).\nlia.\napply H3.\nlia.\nelim (perm_free_2 ofs Cur p).\nlia.\napply H3.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) : False.","proofString":"generalize (size_chunk_pos chunk); intros.\ndestruct (zlt ofs lo).\nelim (perm_free_2 lo Cur p).\nlia.\napply H3.\nlia.\nelim (perm_free_2 ofs Cur p).\nlia.\napply H3.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) : False.","proofString":"destruct (zlt ofs lo).\nelim (perm_free_2 lo Cur p).\nlia.\napply H3.\nlia.\nelim (perm_free_2 ofs Cur p).\nlia.\napply H3.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (l : ofs < lo) : False.","proofString":"elim (perm_free_2 lo Cur p).\nlia.\napply H3.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (l : ofs < lo) : lo <= lo < hi.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (l : ofs < lo) : perm m2 bf lo Cur p.","proofString":"apply H3.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (l : ofs < lo) : ofs <= lo < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (g : ofs >= lo) : False.","proofString":"elim (perm_free_2 ofs Cur p).\nlia.\napply H3.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (g : ofs >= lo) : lo <= ofs < hi.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (g : ofs >= lo) : perm m2 bf ofs Cur p.","proofString":"apply H3.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : lo < hi) (H0 : ofs + size_chunk chunk > lo) (H1 : ofs < hi) (H3 : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H4 : (align_chunk chunk | ofs)) (H2 : size_chunk chunk > 0) (g : ofs >= lo) : ofs <= ofs < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : valid_access m2 chunk b ofs p) : valid_access m1 chunk b ofs p.","proofString":"destruct H.\nsplit; auto.\nred; intros.\ngeneralize (H ofs0 H1).\nrewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) : valid_access m1 chunk b ofs p.","proofString":"split; auto.\nred; intros.\ngeneralize (H ofs0 H1).\nrewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) : range_perm m1 b ofs (ofs + size_chunk chunk) Cur p.","proofString":"red; intros.\ngeneralize (H ofs0 H1).\nrewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m1 b ofs0 Cur p.","proofString":"generalize (H ofs0 H1).\nrewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m2 b ofs0 Cur p -> perm m1 b ofs0 Cur p.","proofString":"rewrite free_result.\nunfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) : perm (unchecked_free m1 bf lo hi) b ofs0 Cur p -> perm m1 b ofs0 Cur p.","proofString":"unfold perm, unchecked_free; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) : perm_order'\n  ((PMap.set bf\n      (fun (ofs1 : Z) (k : perm_kind) =>\n       if zle lo ofs1 && zlt ofs1 hi\n       then None\n       else (mem_access m1) # bf ofs1 k) (mem_access m1)) # b ofs0 Cur) p ->\nperm_order' ((mem_access m1) # b ofs0 Cur) p.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) : perm_order'\n  ((if peq b bf\n    then\n     fun (ofs1 : Z) (k : perm_kind) =>\n     if zle lo ofs1 && zlt ofs1 hi then None else (mem_access m1) # bf ofs1 k\n    else (mem_access m1) # b) ofs0 Cur) p ->\nperm_order' ((mem_access m1) # b ofs0 Cur) p.","proofString":"destruct (peq b bf).\nsubst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) (e : b = bf) : perm_order'\n  (if zle lo ofs0 && zlt ofs0 hi then None else (mem_access m1) # bf ofs0 Cur)\n  p -> perm_order' ((mem_access m1) # b ofs0 Cur) p.","proofString":"subst b.\ndestruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) : perm_order'\n  (if zle lo ofs0 && zlt ofs0 hi then None else (mem_access m1) # bf ofs0 Cur)\n  p -> perm_order' ((mem_access m1) # bf ofs0 Cur) p.","proofString":"destruct (zle lo ofs0); simpl.\ndestruct (zlt ofs0 hi); simpl.\ntauto.\nauto.\nauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) (l : lo <= ofs0) : perm_order'\n  (if proj_sumbool (zlt ofs0 hi) then None else (mem_access m1) # bf ofs0 Cur)\n  p -> perm_order' ((mem_access m1) # bf ofs0 Cur) p.","proofString":"destruct (zlt ofs0 hi); simpl.\ntauto.\nauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) (l : lo <= ofs0) (l0 : ofs0 < hi) : False -> perm_order' ((mem_access m1) # bf ofs0 Cur) p.","proofString":"tauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) (l : lo <= ofs0) (g : ofs0 >= hi) : perm_order' ((mem_access m1) # bf ofs0 Cur) p ->\nperm_order' ((mem_access m1) # bf ofs0 Cur) p.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : range_perm m2 bf ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) (g : lo > ofs0) : perm_order' ((mem_access m1) # bf ofs0 Cur) p ->\nperm_order' ((mem_access m1) # bf ofs0 Cur) p.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : range_perm m2 b ofs (ofs + size_chunk chunk) Cur p) (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) (n : b <> bf) : perm_order' ((mem_access m1) # b ofs0 Cur) p ->\nperm_order' ((mem_access m1) # b ofs0 Cur) p.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : valid_access m2 chunk bf ofs p) : lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs.","proofString":"destruct (zlt lo hi); auto.\ndestruct (zle (ofs + size_chunk chunk) lo); auto.\ndestruct (zle hi ofs); auto.\nelim (valid_access_free_2 chunk ofs p); auto.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : valid_access m2 chunk bf ofs p) (l : lo < hi) : lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs.","proofString":"destruct (zle (ofs + size_chunk chunk) lo); auto.\ndestruct (zle hi ofs); auto.\nelim (valid_access_free_2 chunk ofs p); auto.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : valid_access m2 chunk bf ofs p) (l : lo < hi) (g : ofs + size_chunk chunk > lo) : lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs.","proofString":"destruct (zle hi ofs); auto.\nelim (valid_access_free_2 chunk ofs p); auto.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : valid_access m2 chunk bf ofs p) (l : lo < hi) (g : ofs + size_chunk chunk > lo) (g0 : hi > ofs) : lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs.","proofString":"elim (valid_access_free_2 chunk ofs p); auto.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p : permission) (H : valid_access m2 chunk bf ofs p) (l : lo < hi) (g : ofs + size_chunk chunk > lo) (g0 : hi > ofs) : ofs < hi.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) : load chunk m2 b ofs = load chunk m1 b ofs.","proofString":"unfold load.\ndestruct (valid_access_dec m2 chunk b ofs Readable).\nrewrite pred_dec_true.\nrewrite free_result; auto.\neapply valid_access_free_inv_1; eauto.\nrewrite pred_dec_false; auto.\nred; intro; elim n.\neapply valid_access_free_1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) : (if valid_access_dec m2 chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b))\n else None) =\n(if valid_access_dec m1 chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b))\n else None).","proofString":"destruct (valid_access_dec m2 chunk b ofs Readable).\nrewrite pred_dec_true.\nrewrite free_result; auto.\neapply valid_access_free_inv_1; eauto.\nrewrite pred_dec_false; auto.\nred; intro; elim n.\neapply valid_access_free_1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (v : valid_access m2 chunk b ofs Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) =\n(if valid_access_dec m1 chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b))\n else None).","proofString":"rewrite pred_dec_true.\nrewrite free_result; auto.\neapply valid_access_free_inv_1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (v : valid_access m2 chunk b ofs Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b)).","proofString":"rewrite free_result; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (v : valid_access m2 chunk b ofs Readable) : valid_access m1 chunk b ofs Readable.","proofString":"eapply valid_access_free_inv_1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (n : ~ valid_access m2 chunk b ofs Readable) : None =\n(if valid_access_dec m1 chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b))\n else None).","proofString":"rewrite pred_dec_false; auto.\nred; intro; elim n.\neapply valid_access_free_1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (n : ~ valid_access m2 chunk b ofs Readable) : ~ valid_access m1 chunk b ofs Readable.","proofString":"red; intro; elim n.\neapply valid_access_free_1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs) (n : ~ valid_access m2 chunk b ofs Readable) (H0 : valid_access m1 chunk b ofs Readable) : valid_access m2 chunk b ofs Readable.","proofString":"eapply valid_access_free_1; eauto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : load chunk m1 b ofs = Some v.","proofString":"unfold load.\nrewrite pred_dec_true.\nrewrite (load_result _ _ _ _ _ H).\nrewrite free_result; auto.\napply valid_access_free_inv_1.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : (if valid_access_dec m1 chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b))\n else None) = Some v.","proofString":"rewrite pred_dec_true.\nrewrite (load_result _ _ _ _ _ H).\nrewrite free_result; auto.\napply valid_access_free_inv_1.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b)) =\nSome v.","proofString":"rewrite (load_result _ _ _ _ _ H).\nrewrite free_result; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b)) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m2) # b)).","proofString":"rewrite free_result; auto."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : valid_access m1 chunk b ofs Readable.","proofString":"apply valid_access_free_inv_1.\neauto with mem."},{"statement":"(chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : load chunk m2 b ofs = Some v) : valid_access m2 chunk b ofs Readable.","proofString":"eauto with mem."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) : loadbytes m2 b ofs n = loadbytes m1 b ofs n.","proofString":"unfold loadbytes.\ndestruct (range_perm_dec m2 b ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nrewrite free_result; auto.\nred; intros.\neapply perm_free_3; eauto.\nrewrite pred_dec_false; auto.\nred; intros.\nelim n0; red; intros.\neapply perm_free_1; eauto.\ndestruct H; auto.\nright; lia."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) : (if range_perm_dec m2 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m2) # b)\n else None) =\n(if range_perm_dec m1 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m1) # b)\n else None).","proofString":"destruct (range_perm_dec m2 b ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nrewrite free_result; auto.\nred; intros.\neapply perm_free_3; eauto.\nrewrite pred_dec_false; auto.\nred; intros.\nelim n0; red; intros.\neapply perm_free_1; eauto.\ndestruct H; auto.\nright; lia."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (r : range_perm m2 b ofs (ofs + n) Cur Readable) : Some (getN (Z.to_nat n) ofs (mem_contents m2) # b) =\n(if range_perm_dec m1 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m1) # b)\n else None).","proofString":"rewrite pred_dec_true.\nrewrite free_result; auto.\nred; intros.\neapply perm_free_3; eauto."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (r : range_perm m2 b ofs (ofs + n) Cur Readable) : Some (getN (Z.to_nat n) ofs (mem_contents m2) # b) =\nSome (getN (Z.to_nat n) ofs (mem_contents m1) # b).","proofString":"rewrite free_result; auto."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (r : range_perm m2 b ofs (ofs + n) Cur Readable) : range_perm m1 b ofs (ofs + n) Cur Readable.","proofString":"red; intros.\neapply perm_free_3; eauto."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (r : range_perm m2 b ofs (ofs + n) Cur Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) : perm m1 b ofs0 Cur Readable.","proofString":"eapply perm_free_3; eauto."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (n0 : ~ range_perm m2 b ofs (ofs + n) Cur Readable) : None =\n(if range_perm_dec m1 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m1) # b)\n else None).","proofString":"rewrite pred_dec_false; auto.\nred; intros.\nelim n0; red; intros.\neapply perm_free_1; eauto.\ndestruct H; auto.\nright; lia."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (n0 : ~ range_perm m2 b ofs (ofs + n) Cur Readable) : ~ range_perm m1 b ofs (ofs + n) Cur Readable.","proofString":"red; intros.\nelim n0; red; intros.\neapply perm_free_1; eauto.\ndestruct H; auto.\nright; lia."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (n0 : ~ range_perm m2 b ofs (ofs + n) Cur Readable) (H0 : range_perm m1 b ofs (ofs + n) Cur Readable) : False.","proofString":"elim n0; red; intros.\neapply perm_free_1; eauto.\ndestruct H; auto.\nright; lia."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (n0 : ~ range_perm m2 b ofs (ofs + n) Cur Readable) (H0 : range_perm m1 b ofs (ofs + n) Cur Readable) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + n) : perm m2 b ofs0 Cur Readable.","proofString":"eapply perm_free_1; eauto.\ndestruct H; auto.\nright; lia."},{"statement":"(b : block) (ofs n : Z) (H : b <> bf \\/ lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (n0 : ~ range_perm m2 b ofs (ofs + n) Cur Readable) (H0 : range_perm m1 b ofs (ofs + n) Cur Readable) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + n) : b <> bf \\/ ofs0 < lo \\/ hi <= ofs0.","proofString":"destruct H; auto.\nright; lia."},{"statement":"(b : block) (ofs n : Z) (H : lo >= hi \\/ ofs + n <= lo \\/ hi <= ofs) (n0 : ~ range_perm m2 b ofs (ofs + n) Cur Readable) (H0 : range_perm m1 b ofs (ofs + n) Cur Readable) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + n) : b <> bf \\/ ofs0 < lo \\/ hi <= ofs0.","proofString":"right; lia."},{"statement":"(b : block) (ofs n : Z) (bytes : list memval) (H : loadbytes m2 b ofs n = Some bytes) : loadbytes m1 b ofs n = Some bytes.","proofString":"unfold loadbytes in *.\ndestruct (range_perm_dec m2 b ofs (ofs + n) Cur Readable); inv H.\nrewrite pred_dec_true.\nrewrite free_result; auto.\nred; intros.\napply perm_free_3; auto."},{"statement":"(b : block) (ofs n : Z) (bytes : list memval) (H : (if range_perm_dec m2 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m2) # b)\n else None) = Some bytes) : (if range_perm_dec m1 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m1) # b)\n else None) = Some bytes.","proofString":"destruct (range_perm_dec m2 b ofs (ofs + n) Cur Readable); inv H.\nrewrite pred_dec_true.\nrewrite free_result; auto.\nred; intros.\napply perm_free_3; auto."},{"statement":"(b : block) (ofs n : Z) (r : range_perm m2 b ofs (ofs + n) Cur Readable) : (if range_perm_dec m1 b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m1) # b)\n else None) = Some (getN (Z.to_nat n) ofs (mem_contents m2) # b).","proofString":"rewrite pred_dec_true.\nrewrite free_result; auto.\nred; intros.\napply perm_free_3; auto."},{"statement":"(b : block) (ofs n : Z) (r : range_perm m2 b ofs (ofs + n) Cur Readable) : Some (getN (Z.to_nat n) ofs (mem_contents m1) # b) =\nSome (getN (Z.to_nat n) ofs (mem_contents m2) # b).","proofString":"rewrite free_result; auto."},{"statement":"(b : block) (ofs n : Z) (r : range_perm m2 b ofs (ofs + n) Cur Readable) : range_perm m1 b ofs (ofs + n) Cur Readable.","proofString":"red; intros.\napply perm_free_3; auto."},{"statement":"(b : block) (ofs n : Z) (r : range_perm m2 b ofs (ofs + n) Cur Readable) (ofs0 : Z) (H : ofs <= ofs0 < ofs + n) : perm m1 b ofs0 Cur Readable.","proofString":"apply perm_free_3; auto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : match range_perm_dec m b lo hi Cur Freeable with\n| left H0 =>\n    Some\n      {|\n        mem_contents := mem_contents m;\n        mem_access :=\n          PMap.set b\n            (fun (ofs : Z) (k : perm_kind) =>\n             if zle lo ofs && zlt ofs hi\n             then Some p\n             else (mem_access m) # b ofs k) (mem_access m);\n        nextblock := nextblock m;\n        access_max :=\n          fun (b0 : positive) (ofs : Z) =>\n          drop_perm_obligation_1 m b lo hi p b0 ofs;\n        nextblock_noaccess :=\n          fun (b0 : positive) (ofs : Z) (k : perm_kind)\n            (H1 : ~ Plt b0 (nextblock m)) =>\n          drop_perm_obligation_2 m b lo hi p H0 b0 ofs k H1;\n        contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n      |}\n| right _ => None\nend = Some m') : range_perm m b lo hi Cur Freeable.","proofString":"destruct (range_perm_dec m b lo hi Cur Freeable).\nauto.\ndiscriminate."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (r : range_perm m b lo hi Cur Freeable) (H : Some\n  {|\n    mem_contents := mem_contents m;\n    mem_access :=\n      PMap.set b\n        (fun (ofs : Z) (k : perm_kind) =>\n         if zle lo ofs && zlt ofs hi\n         then Some p\n         else (mem_access m) # b ofs k) (mem_access m);\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs : Z) =>\n      drop_perm_obligation_1 m b lo hi p b0 ofs;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs : Z) (k : perm_kind)\n        (H0 : ~ Plt b0 (nextblock m)) =>\n      drop_perm_obligation_2 m b lo hi p r b0 ofs k H0;\n    contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n  |} = Some m') : range_perm m b lo hi Cur Freeable.","proofString":"auto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (n : ~ range_perm m b lo hi Cur Freeable) (H : None = Some m') : range_perm m b lo hi Cur Freeable.","proofString":"discriminate."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (H : range_perm m b lo hi Cur Freeable) : {m' : mem\n| match range_perm_dec m b lo hi Cur Freeable with\n  | left H0 =>\n      Some\n        {|\n          mem_contents := mem_contents m;\n          mem_access :=\n            PMap.set b\n              (fun (ofs : Z) (k : perm_kind) =>\n               if zle lo ofs && zlt ofs hi\n               then Some p\n               else (mem_access m) # b ofs k) (mem_access m);\n          nextblock := nextblock m;\n          access_max :=\n            fun (b0 : positive) (ofs : Z) =>\n            drop_perm_obligation_1 m b lo hi p b0 ofs;\n          nextblock_noaccess :=\n            fun (b0 : positive) (ofs : Z) (k : perm_kind)\n              (H1 : ~ Plt b0 (nextblock m)) =>\n            drop_perm_obligation_2 m b lo hi p H0 b0 ofs k H1;\n          contents_default :=\n            fun b0 : positive => drop_perm_obligation_3 m b0\n        |}\n  | right _ => None\n  end = Some m'}.","proofString":"destruct (range_perm_dec m b lo hi Cur Freeable).\neconstructor.\neauto.\ncontradiction."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (H r : range_perm m b lo hi Cur Freeable) : {m' : mem\n| Some\n    {|\n      mem_contents := mem_contents m;\n      mem_access :=\n        PMap.set b\n          (fun (ofs : Z) (k : perm_kind) =>\n           if zle lo ofs && zlt ofs hi\n           then Some p\n           else (mem_access m) # b ofs k) (mem_access m);\n      nextblock := nextblock m;\n      access_max :=\n        fun (b0 : positive) (ofs : Z) =>\n        drop_perm_obligation_1 m b lo hi p b0 ofs;\n      nextblock_noaccess :=\n        fun (b0 : positive) (ofs : Z) (k : perm_kind)\n          (H0 : ~ Plt b0 (nextblock m)) =>\n        drop_perm_obligation_2 m b lo hi p r b0 ofs k H0;\n      contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n    |} = Some m'}.","proofString":"econstructor.\neauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (H : range_perm m b lo hi Cur Freeable) (n : ~ range_perm m b lo hi Cur Freeable) : {m' : mem | None = Some m'}.","proofString":"contradiction."},{"statement":"(ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm m' b ofs k p.","proofString":"unfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nunfold perm.\nsimpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nconstructor.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm\n  {|\n    mem_contents := mem_contents m;\n    mem_access :=\n      PMap.set b\n        (fun (ofs0 : Z) (k0 : perm_kind) =>\n         if zle lo ofs0 && zlt ofs0 hi\n         then Some p\n         else (mem_access m) # b ofs0 k0) (mem_access m);\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      drop_perm_obligation_1 m b lo hi p b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n        (H0 : ~ Plt b0 (nextblock m)) =>\n      drop_perm_obligation_2 m b lo hi p r b0 ofs0 k0 H0;\n    contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n  |} b ofs k p.","proofString":"unfold perm.\nsimpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nconstructor.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order'\n  ((mem_access\n      {|\n        mem_contents := mem_contents m;\n        mem_access :=\n          PMap.set b\n            (fun (ofs0 : Z) (k0 : perm_kind) =>\n             if zle lo ofs0 && zlt ofs0 hi\n             then Some p\n             else (mem_access m) # b ofs0 k0) (mem_access m);\n        nextblock := nextblock m;\n        access_max :=\n          fun (b0 : positive) (ofs0 : Z) =>\n          drop_perm_obligation_1 m b lo hi p b0 ofs0;\n        nextblock_noaccess :=\n          fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n            (H0 : ~ Plt b0 (nextblock m)) =>\n          drop_perm_obligation_2 m b lo hi p r b0 ofs0 k0 H0;\n        contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n      |}) # b ofs k) p.","proofString":"simpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nconstructor.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order'\n  ((PMap.set b\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then Some p\n       else (mem_access m) # b ofs0 k0) (mem_access m)) # b ofs k) p.","proofString":"rewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nconstructor.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order'\n  (if zle lo ofs && zlt ofs hi then Some p else (mem_access m) # b ofs k) p.","proofString":"unfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nconstructor.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order'\n  (if\n    (if zle lo ofs then true else false) &&\n    (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p.","proofString":"rewrite zle_true.\nrewrite zlt_true.\nsimpl.\nconstructor.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order'\n  (if true && (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p.","proofString":"rewrite zlt_true.\nsimpl.\nconstructor.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order' (if true && true then Some p else (mem_access m) # b ofs k) p.","proofString":"simpl.\nconstructor."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : perm_order p p.","proofString":"constructor."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : ofs < hi.","proofString":"lia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (H : lo <= ofs < hi) : lo <= ofs.","proofString":"lia."},{"statement":"(ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) (H0 : perm m' b ofs k p') : perm_order p p'.","proofString":"unfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nrevert H0.\nunfold perm; simpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) (H0 : perm\n  {|\n    mem_contents := mem_contents m;\n    mem_access :=\n      PMap.set b\n        (fun (ofs0 : Z) (k0 : perm_kind) =>\n         if zle lo ofs0 && zlt ofs0 hi\n         then Some p\n         else (mem_access m) # b ofs0 k0) (mem_access m);\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      drop_perm_obligation_1 m b lo hi p b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      drop_perm_obligation_2 m b lo hi p r b0 ofs0 k0 H1;\n    contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n  |} b ofs k p') : perm_order p p'.","proofString":"revert H0.\nunfold perm; simpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : perm\n  {|\n    mem_contents := mem_contents m;\n    mem_access :=\n      PMap.set b\n        (fun (ofs0 : Z) (k0 : perm_kind) =>\n         if zle lo ofs0 && zlt ofs0 hi\n         then Some p\n         else (mem_access m) # b ofs0 k0) (mem_access m);\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      drop_perm_obligation_1 m b lo hi p b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n        (H0 : ~ Plt b0 (nextblock m)) =>\n      drop_perm_obligation_2 m b lo hi p r b0 ofs0 k0 H0;\n    contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n  |} b ofs k p' -> perm_order p p'.","proofString":"unfold perm; simpl.\nrewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : perm_order'\n  ((PMap.set b\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then Some p\n       else (mem_access m) # b ofs0 k0) (mem_access m)) # b ofs k) p' ->\nperm_order p p'.","proofString":"rewrite PMap.gss.\nunfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : perm_order'\n  (if zle lo ofs && zlt ofs hi then Some p else (mem_access m) # b ofs k) p' ->\nperm_order p p'.","proofString":"unfold proj_sumbool.\nrewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : perm_order'\n  (if\n    (if zle lo ofs then true else false) &&\n    (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p' -> perm_order p p'.","proofString":"rewrite zle_true.\nrewrite zlt_true.\nsimpl.\nauto.\nlia.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : perm_order'\n  (if true && (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p' -> perm_order p p'.","proofString":"rewrite zlt_true.\nsimpl.\nauto.\nlia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : perm_order' (if true && true then Some p else (mem_access m) # b ofs k) p' ->\nperm_order p p'.","proofString":"simpl.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : perm_order p p' -> perm_order p p'.","proofString":"auto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : ofs < hi.","proofString":"lia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H : lo <= ofs < hi) : lo <= ofs.","proofString":"lia."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : b' <> b \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m b' ofs k p') : perm m' b' ofs k p'.","proofString":"unfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nunfold perm; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : b' <> b \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m b' ofs k p') : perm\n  {|\n    mem_contents := mem_contents m;\n    mem_access :=\n      PMap.set b\n        (fun (ofs0 : Z) (k0 : perm_kind) =>\n         if zle lo ofs0 && zlt ofs0 hi\n         then Some p\n         else (mem_access m) # b ofs0 k0) (mem_access m);\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      drop_perm_obligation_1 m b lo hi p b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n        (H1 : ~ Plt b0 (nextblock m)) =>\n      drop_perm_obligation_2 m b lo hi p r b0 ofs0 k0 H1;\n    contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n  |} b' ofs k p'.","proofString":"unfold perm; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : b' <> b \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m b' ofs k p') : perm_order'\n  ((PMap.set b\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then Some p\n       else (mem_access m) # b ofs0 k0) (mem_access m)) # b' ofs k) p'.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : b' <> b \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m b' ofs k p') : perm_order'\n  ((if peq b' b\n    then\n     fun (ofs0 : Z) (k0 : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi\n     then Some p\n     else (mem_access m) # b ofs0 k0\n    else (mem_access m) # b') ofs k) p'.","proofString":"destruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : b' <> b \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m b' ofs k p') (e : b' = b) : perm_order'\n  (if zle lo ofs && zlt ofs hi then Some p else (mem_access m) # b ofs k) p'.","proofString":"subst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H0 : perm m b ofs k p') (H : b <> b \\/ ofs < lo \\/ hi <= ofs) : perm_order'\n  (if zle lo ofs && zlt ofs hi then Some p else (mem_access m) # b ofs k) p'.","proofString":"unfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H0 : perm m b ofs k p') (H : b <> b \\/ ofs < lo \\/ hi <= ofs) : perm_order'\n  (if\n    (if zle lo ofs then true else false) &&\n    (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p'.","proofString":"destruct (zle lo ofs).\ndestruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H0 : perm m b ofs k p') (H : b <> b \\/ ofs < lo \\/ hi <= ofs) (l : lo <= ofs) : perm_order'\n  (if true && (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p'.","proofString":"destruct (zlt ofs hi).\nbyContradiction.\nintuition lia.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H0 : perm m b ofs k p') (H : b <> b \\/ ofs < lo \\/ hi <= ofs) (l : lo <= ofs) (l0 : ofs < hi) : perm_order' (if true && true then Some p else (mem_access m) # b ofs k) p'.","proofString":"byContradiction.\nintuition lia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H0 : perm m b ofs k p') (H : b <> b \\/ ofs < lo \\/ hi <= ofs) (l : lo <= ofs) (l0 : ofs < hi) : False.","proofString":"intuition lia."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H0 : perm m b ofs k p') (H : b <> b \\/ ofs < lo \\/ hi <= ofs) (l : lo <= ofs) (g : ofs >= hi) : perm_order' (if true && false then Some p else (mem_access m) # b ofs k) p'.","proofString":"auto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (H0 : perm m b ofs k p') (H : b <> b \\/ ofs < lo \\/ hi <= ofs) (g : lo > ofs) : perm_order'\n  (if false && (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p'.","proofString":"auto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : b' <> b \\/ ofs < lo \\/ hi <= ofs) (H0 : perm m b' ofs k p') (n : b' <> b) : perm_order' ((mem_access m) # b' ofs k) p'.","proofString":"auto."},{"statement":"(b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : perm m' b' ofs k p') : perm m b' ofs k p'.","proofString":"unfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nrevert H.\nunfold perm; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (H : perm\n  {|\n    mem_contents := mem_contents m;\n    mem_access :=\n      PMap.set b\n        (fun (ofs0 : Z) (k0 : perm_kind) =>\n         if zle lo ofs0 && zlt ofs0 hi\n         then Some p\n         else (mem_access m) # b ofs0 k0) (mem_access m);\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      drop_perm_obligation_1 m b lo hi p b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n        (H0 : ~ Plt b0 (nextblock m)) =>\n      drop_perm_obligation_2 m b lo hi p r b0 ofs0 k0 H0;\n    contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n  |} b' ofs k p') : perm m b' ofs k p'.","proofString":"revert H.\nunfold perm; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) : perm\n  {|\n    mem_contents := mem_contents m;\n    mem_access :=\n      PMap.set b\n        (fun (ofs0 : Z) (k0 : perm_kind) =>\n         if zle lo ofs0 && zlt ofs0 hi\n         then Some p\n         else (mem_access m) # b ofs0 k0) (mem_access m);\n    nextblock := nextblock m;\n    access_max :=\n      fun (b0 : positive) (ofs0 : Z) =>\n      drop_perm_obligation_1 m b lo hi p b0 ofs0;\n    nextblock_noaccess :=\n      fun (b0 : positive) (ofs0 : Z) (k0 : perm_kind)\n        (H : ~ Plt b0 (nextblock m)) =>\n      drop_perm_obligation_2 m b lo hi p r b0 ofs0 k0 H;\n    contents_default := fun b0 : positive => drop_perm_obligation_3 m b0\n  |} b' ofs k p' -> perm m b' ofs k p'.","proofString":"unfold perm; simpl.\nrewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) : perm_order'\n  ((PMap.set b\n      (fun (ofs0 : Z) (k0 : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi\n       then Some p\n       else (mem_access m) # b ofs0 k0) (mem_access m)) # b' ofs k) p' ->\nperm_order' ((mem_access m) # b' ofs k) p'.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) : perm_order'\n  ((if peq b' b\n    then\n     fun (ofs0 : Z) (k0 : perm_kind) =>\n     if zle lo ofs0 && zlt ofs0 hi\n     then Some p\n     else (mem_access m) # b ofs0 k0\n    else (mem_access m) # b') ofs k) p' ->\nperm_order' ((mem_access m) # b' ofs k) p'.","proofString":"destruct (peq b' b).\nsubst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (e : b' = b) : perm_order'\n  (if zle lo ofs && zlt ofs hi then Some p else (mem_access m) # b ofs k) p' ->\nperm_order' ((mem_access m) # b' ofs k) p'.","proofString":"subst b'.\nunfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) : perm_order'\n  (if zle lo ofs && zlt ofs hi then Some p else (mem_access m) # b ofs k) p' ->\nperm_order' ((mem_access m) # b ofs k) p'.","proofString":"unfold proj_sumbool.\ndestruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) : perm_order'\n  (if\n    (if zle lo ofs then true else false) &&\n    (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p' ->\nperm_order' ((mem_access m) # b ofs k) p'.","proofString":"destruct (zle lo ofs).\ndestruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) : perm_order'\n  (if true && (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p' ->\nperm_order' ((mem_access m) # b ofs k) p'.","proofString":"destruct (zlt ofs hi).\nsimpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) : perm_order' (if true && true then Some p else (mem_access m) # b ofs k) p' ->\nperm_order' ((mem_access m) # b ofs k) p'.","proofString":"simpl.\nintros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) : perm_order p p' -> perm_order' ((mem_access m) # b ofs k) p'.","proofString":"intros.\napply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) (H : perm_order p p') : perm_order' ((mem_access m) # b ofs k) p'.","proofString":"apply perm_implies with p.\napply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) (H : perm_order p p') : perm m b ofs k p.","proofString":"apply perm_implies with Freeable.\napply perm_cur.\napply r.\ntauto.\nauto with mem."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) (H : perm_order p p') : perm m b ofs k Freeable.","proofString":"apply perm_cur.\napply r.\ntauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) (H : perm_order p p') : perm m b ofs Cur Freeable.","proofString":"apply r.\ntauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) (H : perm_order p p') : lo <= ofs < hi.","proofString":"tauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) (H : perm_order p p') : perm_order Freeable p.","proofString":"auto with mem."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (l0 : ofs < hi) (H : perm_order p p') : perm_order p p'.","proofString":"auto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (l : lo <= ofs) (g : ofs >= hi) : perm_order' (if true && false then Some p else (mem_access m) # b ofs k) p' ->\nperm_order' ((mem_access m) # b ofs k) p'.","proofString":"auto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (ofs : Z) (k : perm_kind) (p' : permission) (g : lo > ofs) : perm_order'\n  (if false && (if zlt ofs hi then true else false)\n   then Some p\n   else (mem_access m) # b ofs k) p' ->\nperm_order' ((mem_access m) # b ofs k) p'.","proofString":"auto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (b' : block) (ofs : Z) (k : perm_kind) (p' : permission) (n : b' <> b) : perm_order' ((mem_access m) # b' ofs k) p' ->\nperm_order' ((mem_access m) # b' ofs k) p'.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H0 : valid_access m chunk b' ofs p') : valid_access m' chunk b' ofs p'.","proofString":"destruct H0.\nsplit; auto.\nred; intros.\ndestruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H0 : range_perm m b' ofs (ofs + size_chunk chunk) Cur p') (H1 : (align_chunk chunk | ofs)) : valid_access m' chunk b' ofs p'.","proofString":"split; auto.\nred; intros.\ndestruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H0 : range_perm m b' ofs (ofs + size_chunk chunk) Cur p') (H1 : (align_chunk chunk | ofs)) : range_perm m' b' ofs (ofs + size_chunk chunk) Cur p'.","proofString":"red; intros.\ndestruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H0 : range_perm m b' ofs (ofs + size_chunk chunk) Cur p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m' b' ofs0 Cur p'.","proofString":"destruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H0 : range_perm m b' ofs (ofs + size_chunk chunk) Cur p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (e : b' = b) : perm m' b' ofs0 Cur p'.","proofString":"subst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m' b ofs0 Cur p'.","proofString":"destruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (l : ofs0 < lo) : perm m' b ofs0 Cur p'.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (g : ofs0 >= lo) : perm m' b ofs0 Cur p'.","proofString":"destruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (g : ofs0 >= lo) (l : hi <= ofs0) : perm m' b ofs0 Cur p'.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (g : ofs0 >= lo) (g0 : hi > ofs0) : perm m' b ofs0 Cur p'.","proofString":"apply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\ngeneralize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (g : ofs0 >= lo) (g0 : hi > ofs0) : perm m' b ofs0 Cur p.","proofString":"eapply perm_drop_1; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (g : ofs0 >= lo) (g0 : hi > ofs0) : lo <= ofs0 < hi.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (g : ofs0 >= lo) (g0 : hi > ofs0) : perm_order p p'.","proofString":"generalize (size_chunk_pos chunk); intros.\nintuition auto with zarith exfalso."},{"statement":"(chunk : memory_chunk) (ofs : Z) (p' : permission) (H0 : range_perm m b ofs (ofs + size_chunk chunk) Cur p') (H : b <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (g : ofs0 >= lo) (g0 : hi > ofs0) (H3 : size_chunk chunk > 0) : perm_order p p'.","proofString":"intuition auto with zarith exfalso."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p p') (H0 : range_perm m b' ofs (ofs + size_chunk chunk) Cur p') (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) (n : b' <> b) : perm m' b' ofs0 Cur p'.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : valid_access m' chunk b' ofs p') : valid_access m chunk b' ofs p'.","proofString":"destruct H; split; auto.\nred; intros.\neapply perm_drop_4; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : range_perm m' b' ofs (ofs + size_chunk chunk) Cur p') (H0 : (align_chunk chunk | ofs)) : range_perm m b' ofs (ofs + size_chunk chunk) Cur p'.","proofString":"red; intros.\neapply perm_drop_4; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (p' : permission) (H : range_perm m' b' ofs (ofs + size_chunk chunk) Cur p') (H0 : (align_chunk chunk | ofs)) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m b' ofs0 Cur p'.","proofString":"eapply perm_drop_4; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) : load chunk m' b' ofs = load chunk m b' ofs.","proofString":"unfold load.\ndestruct (valid_access_dec m chunk b' ofs Readable).\nrewrite pred_dec_true.\nunfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto.\neapply valid_access_drop_1; eauto.\nrewrite pred_dec_false.\nauto.\nred; intros; elim n.\neapply valid_access_drop_2; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) : (if valid_access_dec m' chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m') # b'))\n else None) =\n(if valid_access_dec m chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b'))\n else None).","proofString":"destruct (valid_access_dec m chunk b' ofs Readable).\nrewrite pred_dec_true.\nunfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto.\neapply valid_access_drop_1; eauto.\nrewrite pred_dec_false.\nauto.\nred; intros; elim n.\neapply valid_access_drop_2; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (v : valid_access m chunk b' ofs Readable) : (if valid_access_dec m' chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m') # b'))\n else None) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b')).","proofString":"rewrite pred_dec_true.\nunfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto.\neapply valid_access_drop_1; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (v : valid_access m chunk b' ofs Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b')).","proofString":"unfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (v : valid_access m chunk b' ofs Readable) : Some\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) ofs\n        (mem_contents\n           {|\n             mem_contents := mem_contents m;\n             mem_access :=\n               PMap.set b\n                 (fun (ofs0 : Z) (k : perm_kind) =>\n                  if zle lo ofs0 && zlt ofs0 hi\n                  then Some p\n                  else (mem_access m) # b ofs0 k) \n                 (mem_access m);\n             nextblock := nextblock m;\n             access_max :=\n               fun (b0 : positive) (ofs0 : Z) =>\n               drop_perm_obligation_1 m b lo hi p b0 ofs0;\n             nextblock_noaccess :=\n               fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n                 (H0 : ~ Plt b0 (nextblock m)) =>\n               drop_perm_obligation_2 m b lo hi p r b0 ofs0 k H0;\n             contents_default :=\n               fun b0 : positive => drop_perm_obligation_3 m b0\n           |}) # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b')).","proofString":"simpl.\nauto."},{"statement":"(r : range_perm m b lo hi Cur Freeable) (chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (v : valid_access m chunk b' ofs Readable) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b')) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b')).","proofString":"auto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (v : valid_access m chunk b' ofs Readable) : valid_access m' chunk b' ofs Readable.","proofString":"eapply valid_access_drop_1; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (n : ~ valid_access m chunk b' ofs Readable) : (if valid_access_dec m' chunk b' ofs Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) ofs (mem_contents m') # b'))\n else None) = None.","proofString":"rewrite pred_dec_false.\nauto.\nred; intros; elim n.\neapply valid_access_drop_2; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (n : ~ valid_access m chunk b' ofs Readable) : ~ valid_access m' chunk b' ofs Readable.","proofString":"red; intros; elim n.\neapply valid_access_drop_2; eauto."},{"statement":"(chunk : memory_chunk) (b' : block) (ofs : Z) (H : b' <> b \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs \\/ perm_order p Readable) (n : ~ valid_access m chunk b' ofs Readable) (H0 : valid_access m' chunk b' ofs Readable) : valid_access m chunk b' ofs Readable.","proofString":"eapply valid_access_drop_2; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) : loadbytes m' b' ofs n = loadbytes m b' ofs n.","proofString":"unfold loadbytes.\ndestruct (range_perm_dec m b' ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nunfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto.\nred; intros.\ndestruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto.\nrewrite pred_dec_false; eauto.\nred; intros; elim n0; red; intros.\neapply perm_drop_4; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) : (if range_perm_dec m' b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m') # b')\n else None) =\n(if range_perm_dec m b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m) # b')\n else None).","proofString":"destruct (range_perm_dec m b' ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nunfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto.\nred; intros.\ndestruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto.\nrewrite pred_dec_false; eauto.\nred; intros; elim n0; red; intros.\neapply perm_drop_4; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) : (if range_perm_dec m' b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m') # b')\n else None) = Some (getN (Z.to_nat n) ofs (mem_contents m) # b').","proofString":"rewrite pred_dec_true.\nunfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto.\nred; intros.\ndestruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) : Some (getN (Z.to_nat n) ofs (mem_contents m') # b') =\nSome (getN (Z.to_nat n) ofs (mem_contents m) # b').","proofString":"unfold drop_perm in DROP.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv DROP.\nsimpl.\nauto."},{"statement":"(r0 : range_perm m b lo hi Cur Freeable) (b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) : Some\n  (getN (Z.to_nat n) ofs\n     (mem_contents\n        {|\n          mem_contents := mem_contents m;\n          mem_access :=\n            PMap.set b\n              (fun (ofs0 : Z) (k : perm_kind) =>\n               if zle lo ofs0 && zlt ofs0 hi\n               then Some p\n               else (mem_access m) # b ofs0 k) (mem_access m);\n          nextblock := nextblock m;\n          access_max :=\n            fun (b0 : positive) (ofs0 : Z) =>\n            drop_perm_obligation_1 m b lo hi p b0 ofs0;\n          nextblock_noaccess :=\n            fun (b0 : positive) (ofs0 : Z) (k : perm_kind)\n              (H0 : ~ Plt b0 (nextblock m)) =>\n            drop_perm_obligation_2 m b lo hi p r0 b0 ofs0 k H0;\n          contents_default :=\n            fun b0 : positive => drop_perm_obligation_3 m b0\n        |}) # b') = Some (getN (Z.to_nat n) ofs (mem_contents m) # b').","proofString":"simpl.\nauto."},{"statement":"(r0 : range_perm m b lo hi Cur Freeable) (b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) : Some (getN (Z.to_nat n) ofs (mem_contents m) # b') =\nSome (getN (Z.to_nat n) ofs (mem_contents m) # b').","proofString":"auto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) : range_perm m' b' ofs (ofs + n) Cur Readable.","proofString":"red; intros.\ndestruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) : perm m' b' ofs0 Cur Readable.","proofString":"destruct (eq_block b' b).\nsubst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso.\neapply perm_drop_3; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (e : b' = b) : perm m' b' ofs0 Cur Readable.","proofString":"subst b'.\ndestruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) : perm m' b ofs0 Cur Readable.","proofString":"destruct (zlt ofs0 lo).\neapply perm_drop_3; eauto.\ndestruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (l : ofs0 < lo) : perm m' b ofs0 Cur Readable.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (g : ofs0 >= lo) : perm m' b ofs0 Cur Readable.","proofString":"destruct (zle hi ofs0).\neapply perm_drop_3; eauto.\napply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (g : ofs0 >= lo) (l : hi <= ofs0) : perm m' b ofs0 Cur Readable.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (g : ofs0 >= lo) (g0 : hi > ofs0) : perm m' b ofs0 Cur Readable.","proofString":"apply perm_implies with p.\neapply perm_drop_1; eauto.\nlia.\nintuition auto with zarith exfalso."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (g : ofs0 >= lo) (g0 : hi > ofs0) : perm m' b ofs0 Cur p.","proofString":"eapply perm_drop_1; eauto.\nlia."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (g : ofs0 >= lo) (g0 : hi > ofs0) : lo <= ofs0 < hi.","proofString":"lia."},{"statement":"(ofs n : Z) (r : range_perm m b ofs (ofs + n) Cur Readable) (H : b <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (g : ofs0 >= lo) (g0 : hi > ofs0) : perm_order p Readable.","proofString":"intuition auto with zarith exfalso."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (r : range_perm m b' ofs (ofs + n) Cur Readable) (ofs0 : Z) (H0 : ofs <= ofs0 < ofs + n) (n0 : b' <> b) : perm m' b' ofs0 Cur Readable.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (n0 : ~ range_perm m b' ofs (ofs + n) Cur Readable) : (if range_perm_dec m' b' ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m') # b')\n else None) = None.","proofString":"rewrite pred_dec_false; eauto.\nred; intros; elim n0; red; intros.\neapply perm_drop_4; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (n0 : ~ range_perm m b' ofs (ofs + n) Cur Readable) : ~ range_perm m' b' ofs (ofs + n) Cur Readable.","proofString":"red; intros; elim n0; red; intros.\neapply perm_drop_4; eauto."},{"statement":"(b' : block) (ofs n : Z) (H : b' <> b \\/ ofs + n <= lo \\/ hi <= ofs \\/ perm_order p Readable) (n0 : ~ range_perm m b' ofs (ofs + n) Cur Readable) (H0 : range_perm m' b' ofs (ofs + n) Cur Readable) (ofs0 : Z) (H1 : ofs <= ofs0 < ofs + n) : perm m b' ofs0 Cur Readable.","proofString":"eapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs : Z) (k : perm_kind) (p : permission) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : perm m1 b1 ofs k p) (H1 : f b1 = Some (b2, delta)) : perm m2 b2 (ofs + delta) k p.","proofString":"eapply mi_perm; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (k : perm_kind) (p : permission) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : range_perm m1 b1 lo hi k p) (H1 : f b1 = Some (b2, delta)) (ofs : Z) (H2 : lo + delta <= ofs < hi + delta) : perm m2 b2 ofs k p.","proofString":"replace ofs with ((ofs - delta) + delta) by lia.\neapply perm_inj; eauto.\napply H0.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (k : perm_kind) (p : permission) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : range_perm m1 b1 lo hi k p) (H1 : f b1 = Some (b2, delta)) (ofs : Z) (H2 : lo + delta <= ofs < hi + delta) : perm m2 b2 (ofs - delta + delta) k p.","proofString":"eapply perm_inj; eauto.\napply H0.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (k : perm_kind) (p : permission) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : range_perm m1 b1 lo hi k p) (H1 : f b1 = Some (b2, delta)) (ofs : Z) (H2 : lo + delta <= ofs < hi + delta) : perm m1 b1 (ofs - delta) k p.","proofString":"apply H0.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (k : perm_kind) (p : permission) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : range_perm m1 b1 lo hi k p) (H1 : f b1 = Some (b2, delta)) (ofs : Z) (H2 : lo + delta <= ofs < hi + delta) : lo <= ofs - delta < hi.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (H1 : valid_access m1 chunk b1 ofs p) : valid_access m2 chunk b2 (ofs + delta) p.","proofString":"destruct H1 as [A B].\nconstructor.\nreplace (ofs + delta + size_chunk chunk)     with ((ofs + size_chunk chunk) + delta) by lia.\neapply range_perm_inj; eauto.\napply Z.divide_add_r; auto.\neapply mi_align; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur p) (B : (align_chunk chunk | ofs)) : valid_access m2 chunk b2 (ofs + delta) p.","proofString":"constructor.\nreplace (ofs + delta + size_chunk chunk)     with ((ofs + size_chunk chunk) + delta) by lia.\neapply range_perm_inj; eauto.\napply Z.divide_add_r; auto.\neapply mi_align; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur p) (B : (align_chunk chunk | ofs)) : range_perm m2 b2 (ofs + delta) (ofs + delta + size_chunk chunk) Cur p.","proofString":"replace (ofs + delta + size_chunk chunk)     with ((ofs + size_chunk chunk) + delta) by lia.\neapply range_perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur p) (B : (align_chunk chunk | ofs)) : range_perm m2 b2 (ofs + delta) (ofs + size_chunk chunk + delta) Cur p.","proofString":"eapply range_perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur p) (B : (align_chunk chunk | ofs)) : (align_chunk chunk | ofs + delta).","proofString":"apply Z.divide_add_r; auto.\neapply mi_align; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur p) (B : (align_chunk chunk | ofs)) : (align_chunk chunk | delta).","proofString":"eapply mi_align; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.of_nat 0) Cur Readable) : list_forall2 (memval_inject f) nil nil.","proofString":"constructor."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.of_nat (S n)) Cur Readable) : list_forall2 (memval_inject f)\n  (ZMap.get ofs (mem_contents m1) # b1\n   :: getN n (ofs + 1) (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2\n   :: getN n (ofs + delta + 1) (mem_contents m2) # b2).","proofString":"rewrite Nat2Z.inj_succ in H1.\nconstructor.\neapply mi_memval; eauto.\napply H1.\nlia.\nreplace (ofs + delta + 1) with ((ofs + 1) + delta) by lia.\napply IHn.\nred; intros; apply H1; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.succ (Z.of_nat n)) Cur Readable) : list_forall2 (memval_inject f)\n  (ZMap.get ofs (mem_contents m1) # b1\n   :: getN n (ofs + 1) (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2\n   :: getN n (ofs + delta + 1) (mem_contents m2) # b2).","proofString":"constructor.\neapply mi_memval; eauto.\napply H1.\nlia.\nreplace (ofs + delta + 1) with ((ofs + 1) + delta) by lia.\napply IHn.\nred; intros; apply H1; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.succ (Z.of_nat n)) Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"eapply mi_memval; eauto.\napply H1.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.succ (Z.of_nat n)) Cur Readable) : perm m1 b1 ofs Cur Readable.","proofString":"apply H1.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.succ (Z.of_nat n)) Cur Readable) : ofs <= ofs < ofs + Z.succ (Z.of_nat n).","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.succ (Z.of_nat n)) Cur Readable) : list_forall2 (memval_inject f) (getN n (ofs + 1) (mem_contents m1) # b1)\n  (getN n (ofs + delta + 1) (mem_contents m2) # b2).","proofString":"replace (ofs + delta + 1) with ((ofs + 1) + delta) by lia.\napply IHn.\nred; intros; apply H1; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.succ (Z.of_nat n)) Cur Readable) : list_forall2 (memval_inject f) (getN n (ofs + 1) (mem_contents m1) # b1)\n  (getN n (ofs + 1 + delta) (mem_contents m2) # b2).","proofString":"apply IHn.\nred; intros; apply H1; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : f b1 = Some (b2, delta)) (n : nat) (IHn : forall ofs0 : Z,\nrange_perm m1 b1 ofs0 (ofs0 + Z.of_nat n) Cur Readable ->\nlist_forall2 (memval_inject f) (getN n ofs0 (mem_contents m1) # b1)\n  (getN n (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (H1 : range_perm m1 b1 ofs (ofs + Z.succ (Z.of_nat n)) Cur Readable) : range_perm m1 b1 (ofs + 1) (ofs + 1 + Z.of_nat n) Cur Readable.","proofString":"red; intros; apply H1; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : exists v2 : val,\n  load chunk m2 b2 (ofs + delta) = Some v2 /\\ Val.inject f v1 v2.","proofString":"exists (decode_val chunk (getN (size_chunk_nat chunk) (ofs + delta) (m2.(mem_contents)#b2))).\nsplit.\nunfold load.\napply pred_dec_true.\neapply valid_access_inj; eauto with mem.\nexploit load_result; eauto.\nintro.\nrewrite H2.\napply decode_val_inject.\napply getN_inj; auto.\nrewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : load chunk m2 b2 (ofs + delta) =\nSome\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)) /\\\nVal.inject f v1\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)).","proofString":"split.\nunfold load.\napply pred_dec_true.\neapply valid_access_inj; eauto with mem.\nexploit load_result; eauto.\nintro.\nrewrite H2.\napply decode_val_inject.\napply getN_inj; auto.\nrewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : load chunk m2 b2 (ofs + delta) =\nSome\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)).","proofString":"unfold load.\napply pred_dec_true.\neapply valid_access_inj; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : (if valid_access_dec m2 chunk b2 (ofs + delta) Readable\n then\n  Some\n    (decode_val chunk\n       (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2))\n else None) =\nSome\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)).","proofString":"apply pred_dec_true.\neapply valid_access_inj; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : valid_access m2 chunk b2 (ofs + delta) Readable.","proofString":"eapply valid_access_inj; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : Val.inject f v1\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)).","proofString":"exploit load_result; eauto.\nintro.\nrewrite H2.\napply decode_val_inject.\napply getN_inj; auto.\nrewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1) ->\nVal.inject f v1\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)).","proofString":"intro.\nrewrite H2.\napply decode_val_inject.\napply getN_inj; auto.\nrewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (H2 : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)) : Val.inject f v1\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)).","proofString":"rewrite H2.\napply decode_val_inject.\napply getN_inj; auto.\nrewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (H2 : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)) : Val.inject f\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1))\n  (decode_val chunk\n     (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2)).","proofString":"apply decode_val_inject.\napply getN_inj; auto.\nrewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (H2 : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)) : list_forall2 (memval_inject f)\n  (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)\n  (getN (size_chunk_nat chunk) (ofs + delta) (mem_contents m2) # b2).","proofString":"apply getN_inj; auto.\nrewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (H2 : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)) : range_perm m1 b1 ofs (ofs + Z.of_nat (size_chunk_nat chunk)) Cur Readable.","proofString":"rewrite <- size_chunk_conv.\nexploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (H2 : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)) : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur Readable.","proofString":"exploit load_valid_access; eauto.\nintros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (H2 : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)) : valid_access m1 chunk b1 ofs Readable ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Cur Readable.","proofString":"intros [A B].\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : mem_inj f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (H2 : v1 =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m1) # b1)) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur Readable.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (bytes1 : list memval) (H : mem_inj f m1 m2) (H0 : loadbytes m1 b1 ofs len = Some bytes1) (H1 : f b1 = Some (b2, delta)) : exists bytes2 : list memval,\n  loadbytes m2 b2 (ofs + delta) len = Some bytes2 /\\\n  list_forall2 (memval_inject f) bytes1 bytes2.","proofString":"unfold loadbytes in *.\ndestruct (range_perm_dec m1 b1 ofs (ofs + len) Cur Readable); inv H0.\nexists (getN (Z.to_nat len) (ofs + delta) (m2.(mem_contents)#b2)).\nsplit.\napply pred_dec_true.\nreplace (ofs + delta + len) with ((ofs + len) + delta) by lia.\neapply range_perm_inj; eauto with mem.\napply getN_inj; auto.\ndestruct (zle 0 len).\nrewrite Z2Nat.id by lia.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (bytes1 : list memval) (H : mem_inj f m1 m2) (H0 : (if range_perm_dec m1 b1 ofs (ofs + len) Cur Readable\n then Some (getN (Z.to_nat len) ofs (mem_contents m1) # b1)\n else None) = Some bytes1) (H1 : f b1 = Some (b2, delta)) : exists bytes2 : list memval,\n  (if range_perm_dec m2 b2 (ofs + delta) (ofs + delta + len) Cur Readable\n   then Some (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2)\n   else None) = Some bytes2 /\\ list_forall2 (memval_inject f) bytes1 bytes2.","proofString":"destruct (range_perm_dec m1 b1 ofs (ofs + len) Cur Readable); inv H0.\nexists (getN (Z.to_nat len) (ofs + delta) (m2.(mem_contents)#b2)).\nsplit.\napply pred_dec_true.\nreplace (ofs + delta + len) with ((ofs + len) + delta) by lia.\neapply range_perm_inj; eauto with mem.\napply getN_inj; auto.\ndestruct (zle 0 len).\nrewrite Z2Nat.id by lia.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) : exists bytes2 : list memval,\n  (if range_perm_dec m2 b2 (ofs + delta) (ofs + delta + len) Cur Readable\n   then Some (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2)\n   else None) = Some bytes2 /\\\n  list_forall2 (memval_inject f)\n    (getN (Z.to_nat len) ofs (mem_contents m1) # b1) bytes2.","proofString":"exists (getN (Z.to_nat len) (ofs + delta) (m2.(mem_contents)#b2)).\nsplit.\napply pred_dec_true.\nreplace (ofs + delta + len) with ((ofs + len) + delta) by lia.\neapply range_perm_inj; eauto with mem.\napply getN_inj; auto.\ndestruct (zle 0 len).\nrewrite Z2Nat.id by lia.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) : (if range_perm_dec m2 b2 (ofs + delta) (ofs + delta + len) Cur Readable\n then Some (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2)\n else None) = Some (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2) /\\\nlist_forall2 (memval_inject f)\n  (getN (Z.to_nat len) ofs (mem_contents m1) # b1)\n  (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2).","proofString":"split.\napply pred_dec_true.\nreplace (ofs + delta + len) with ((ofs + len) + delta) by lia.\neapply range_perm_inj; eauto with mem.\napply getN_inj; auto.\ndestruct (zle 0 len).\nrewrite Z2Nat.id by lia.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) : (if range_perm_dec m2 b2 (ofs + delta) (ofs + delta + len) Cur Readable\n then Some (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2)\n else None) = Some (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2).","proofString":"apply pred_dec_true.\nreplace (ofs + delta + len) with ((ofs + len) + delta) by lia.\neapply range_perm_inj; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) : range_perm m2 b2 (ofs + delta) (ofs + delta + len) Cur Readable.","proofString":"replace (ofs + delta + len) with ((ofs + len) + delta) by lia.\neapply range_perm_inj; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) : range_perm m2 b2 (ofs + delta) (ofs + len + delta) Cur Readable.","proofString":"eapply range_perm_inj; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) : list_forall2 (memval_inject f)\n  (getN (Z.to_nat len) ofs (mem_contents m1) # b1)\n  (getN (Z.to_nat len) (ofs + delta) (mem_contents m2) # b2).","proofString":"apply getN_inj; auto.\ndestruct (zle 0 len).\nrewrite Z2Nat.id by lia.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) : range_perm m1 b1 ofs (ofs + Z.of_nat (Z.to_nat len)) Cur Readable.","proofString":"destruct (zle 0 len).\nrewrite Z2Nat.id by lia.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) (l : 0 <= len) : range_perm m1 b1 ofs (ofs + Z.of_nat (Z.to_nat len)) Cur Readable.","proofString":"rewrite Z2Nat.id by lia.\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) (l : 0 <= len) : range_perm m1 b1 ofs (ofs + len) Cur Readable.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) (g : 0 > len) : range_perm m1 b1 ofs (ofs + Z.of_nat (Z.to_nat len)) Cur Readable.","proofString":"rewrite Z_to_nat_neg by lia.\nsimpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) (g : 0 > len) : range_perm m1 b1 ofs (ofs + Z.of_nat 0) Cur Readable.","proofString":"simpl.\nred; intros; extlia."},{"statement":"(f : meminj) (m1 m2 : mem) (len : Z) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : mem_inj f m1 m2) (r : range_perm m1 b1 ofs (ofs + len) Cur Readable) (H1 : f b1 = Some (b2, delta)) (g : 0 > len) : range_perm m1 b1 ofs (ofs + 0) Cur Readable.","proofString":"red; intros; extlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (p : Z) (c1 c2 : ZMap.t memval) (H : forall q0 : Z,\naccess q0 -> memval_inject f (ZMap.get q0 c1) (ZMap.get (q0 + delta) c2)) (q : Z) (H0 : access q) : memval_inject f (ZMap.get q c1) (ZMap.get (q + delta) c2).","proofString":"auto."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q0 : Z,\n access q0 -> memval_inject f (ZMap.get q0 c0) (ZMap.get (q0 + delta) c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_inject f (ZMap.get q0 (setN al p0 c0))\n  (ZMap.get (q0 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q0 : Z,\naccess q0 -> memval_inject f (ZMap.get q0 c1) (ZMap.get (q0 + delta) c2)) (q : Z) (H2 : access q) : memval_inject f (ZMap.get q (setN al (p + 1) (ZMap.set p a1 c1)))\n  (ZMap.get (q + delta)\n     (setN bl (p + delta + 1) (ZMap.set (p + delta) b1 c2))).","proofString":"replace (p + delta + 1) with ((p + 1) + delta) by lia.\napply IHlist_forall2; auto.\nintros.\nrewrite ZMap.gsspec at 1.\ndestruct (ZIndexed.eq q0 p).\nsubst q0.\nrewrite ZMap.gss.\nauto.\nrewrite ZMap.gso.\nauto.\nunfold ZIndexed.t in *.\nlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q0 : Z,\n access q0 -> memval_inject f (ZMap.get q0 c0) (ZMap.get (q0 + delta) c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_inject f (ZMap.get q0 (setN al p0 c0))\n  (ZMap.get (q0 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q0 : Z,\naccess q0 -> memval_inject f (ZMap.get q0 c1) (ZMap.get (q0 + delta) c2)) (q : Z) (H2 : access q) : memval_inject f (ZMap.get q (setN al (p + 1) (ZMap.set p a1 c1)))\n  (ZMap.get (q + delta)\n     (setN bl (p + 1 + delta) (ZMap.set (p + delta) b1 c2))).","proofString":"apply IHlist_forall2; auto.\nintros.\nrewrite ZMap.gsspec at 1.\ndestruct (ZIndexed.eq q0 p).\nsubst q0.\nrewrite ZMap.gss.\nauto.\nrewrite ZMap.gso.\nauto.\nunfold ZIndexed.t in *.\nlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q0 : Z,\n access q0 -> memval_inject f (ZMap.get q0 c0) (ZMap.get (q0 + delta) c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_inject f (ZMap.get q0 (setN al p0 c0))\n  (ZMap.get (q0 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q0 : Z,\naccess q0 -> memval_inject f (ZMap.get q0 c1) (ZMap.get (q0 + delta) c2)) (q : Z) (H2 : access q) : forall q0 : Z,\naccess q0 ->\nmemval_inject f (ZMap.get q0 (ZMap.set p a1 c1))\n  (ZMap.get (q0 + delta) (ZMap.set (p + delta) b1 c2)).","proofString":"intros.\nrewrite ZMap.gsspec at 1.\ndestruct (ZIndexed.eq q0 p).\nsubst q0.\nrewrite ZMap.gss.\nauto.\nrewrite ZMap.gso.\nauto.\nunfold ZIndexed.t in *.\nlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q1 : Z,\n access q1 -> memval_inject f (ZMap.get q1 c0) (ZMap.get (q1 + delta) c3)) ->\nforall q1 : Z,\naccess q1 ->\nmemval_inject f (ZMap.get q1 (setN al p0 c0))\n  (ZMap.get (q1 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q1 : Z,\naccess q1 -> memval_inject f (ZMap.get q1 c1) (ZMap.get (q1 + delta) c2)) (q : Z) (H2 : access q) (q0 : Z) (H3 : access q0) : memval_inject f (ZMap.get q0 (ZMap.set p a1 c1))\n  (ZMap.get (q0 + delta) (ZMap.set (p + delta) b1 c2)).","proofString":"rewrite ZMap.gsspec at 1.\ndestruct (ZIndexed.eq q0 p).\nsubst q0.\nrewrite ZMap.gss.\nauto.\nrewrite ZMap.gso.\nauto.\nunfold ZIndexed.t in *.\nlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q1 : Z,\n access q1 -> memval_inject f (ZMap.get q1 c0) (ZMap.get (q1 + delta) c3)) ->\nforall q1 : Z,\naccess q1 ->\nmemval_inject f (ZMap.get q1 (setN al p0 c0))\n  (ZMap.get (q1 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q1 : Z,\naccess q1 -> memval_inject f (ZMap.get q1 c1) (ZMap.get (q1 + delta) c2)) (q : Z) (H2 : access q) (q0 : Z) (H3 : access q0) : memval_inject f (if ZIndexed.eq q0 p then a1 else ZMap.get q0 c1)\n  (ZMap.get (q0 + delta) (ZMap.set (p + delta) b1 c2)).","proofString":"destruct (ZIndexed.eq q0 p).\nsubst q0.\nrewrite ZMap.gss.\nauto.\nrewrite ZMap.gso.\nauto.\nunfold ZIndexed.t in *.\nlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q1 : Z,\n access q1 -> memval_inject f (ZMap.get q1 c0) (ZMap.get (q1 + delta) c3)) ->\nforall q1 : Z,\naccess q1 ->\nmemval_inject f (ZMap.get q1 (setN al p0 c0))\n  (ZMap.get (q1 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q1 : Z,\naccess q1 -> memval_inject f (ZMap.get q1 c1) (ZMap.get (q1 + delta) c2)) (q : Z) (H2 : access q) (q0 : Z) (H3 : access q0) (e : q0 = p) : memval_inject f a1 (ZMap.get (q0 + delta) (ZMap.set (p + delta) b1 c2)).","proofString":"subst q0.\nrewrite ZMap.gss.\nauto."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q0 : Z,\n access q0 -> memval_inject f (ZMap.get q0 c0) (ZMap.get (q0 + delta) c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_inject f (ZMap.get q0 (setN al p0 c0))\n  (ZMap.get (q0 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q0 : Z,\naccess q0 -> memval_inject f (ZMap.get q0 c1) (ZMap.get (q0 + delta) c2)) (q : Z) (H2 : access q) (H3 : access p) : memval_inject f a1 (ZMap.get (p + delta) (ZMap.set (p + delta) b1 c2)).","proofString":"rewrite ZMap.gss.\nauto."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q0 : Z,\n access q0 -> memval_inject f (ZMap.get q0 c0) (ZMap.get (q0 + delta) c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_inject f (ZMap.get q0 (setN al p0 c0))\n  (ZMap.get (q0 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q0 : Z,\naccess q0 -> memval_inject f (ZMap.get q0 c1) (ZMap.get (q0 + delta) c2)) (q : Z) (H2 : access q) (H3 : access p) : memval_inject f a1 b1.","proofString":"auto."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q1 : Z,\n access q1 -> memval_inject f (ZMap.get q1 c0) (ZMap.get (q1 + delta) c3)) ->\nforall q1 : Z,\naccess q1 ->\nmemval_inject f (ZMap.get q1 (setN al p0 c0))\n  (ZMap.get (q1 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q1 : Z,\naccess q1 -> memval_inject f (ZMap.get q1 c1) (ZMap.get (q1 + delta) c2)) (q : Z) (H2 : access q) (q0 : Z) (H3 : access q0) (n : q0 <> p) : memval_inject f (ZMap.get q0 c1)\n  (ZMap.get (q0 + delta) (ZMap.set (p + delta) b1 c2)).","proofString":"rewrite ZMap.gso.\nauto.\nunfold ZIndexed.t in *.\nlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q1 : Z,\n access q1 -> memval_inject f (ZMap.get q1 c0) (ZMap.get (q1 + delta) c3)) ->\nforall q1 : Z,\naccess q1 ->\nmemval_inject f (ZMap.get q1 (setN al p0 c0))\n  (ZMap.get (q1 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q1 : Z,\naccess q1 -> memval_inject f (ZMap.get q1 c1) (ZMap.get (q1 + delta) c2)) (q : Z) (H2 : access q) (q0 : Z) (H3 : access q0) (n : q0 <> p) : memval_inject f (ZMap.get q0 c1) (ZMap.get (q0 + delta) c2).","proofString":"auto."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q1 : Z,\n access q1 -> memval_inject f (ZMap.get q1 c0) (ZMap.get (q1 + delta) c3)) ->\nforall q1 : Z,\naccess q1 ->\nmemval_inject f (ZMap.get q1 (setN al p0 c0))\n  (ZMap.get (q1 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q1 : Z,\naccess q1 -> memval_inject f (ZMap.get q1 c1) (ZMap.get (q1 + delta) c2)) (q : Z) (H2 : access q) (q0 : Z) (H3 : access q0) (n : q0 <> p) : q0 + delta <> p + delta.","proofString":"unfold ZIndexed.t in *.\nlia."},{"statement":"(access : Z -> Prop) (delta : Z) (f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall q1 : Z,\n access q1 -> memval_inject f (ZMap.get q1 c0) (ZMap.get (q1 + delta) c3)) ->\nforall q1 : Z,\naccess q1 ->\nmemval_inject f (ZMap.get q1 (setN al p0 c0))\n  (ZMap.get (q1 + delta) (setN bl (p0 + delta) c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall q1 : Z,\naccess q1 -> memval_inject f (ZMap.get q1 c1) (ZMap.get (q1 + delta) c2)) (q : Z) (H2 : access q) (q0 : Z) (H3 : access q0) (n : q0 <> p) : q0 + delta <> p + delta.","proofString":"lia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) : exists n2 : mem,\n  store chunk m2 b2 (ofs + delta) v2 = Some n2 /\\ mem_inj f n1 n2.","proofString":"assert (valid_access m2 chunk b2 (ofs + delta) Writable).\neapply valid_access_inj; eauto with mem.\ndestruct (valid_access_store _ _ _ _ v2 H4) as [n2 STORE].\nexists n2; split.\nauto.\nconstructor.\nintros.\neapply perm_store_1; [eexact STORE|].\neapply mi_perm; eauto.\neapply perm_store_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem.\nintros.\nrewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite (store_mem_contents _ _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) : valid_access m2 chunk b2 (ofs + delta) Writable.","proofString":"eapply valid_access_inj; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) : exists n2 : mem,\n  store chunk m2 b2 (ofs + delta) v2 = Some n2 /\\ mem_inj f n1 n2.","proofString":"destruct (valid_access_store _ _ _ _ v2 H4) as [n2 STORE].\nexists n2; split.\nauto.\nconstructor.\nintros.\neapply perm_store_1; [eexact STORE|].\neapply mi_perm; eauto.\neapply perm_store_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem.\nintros.\nrewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite (store_mem_contents _ _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) : exists n0 : mem,\n  store chunk m2 b2 (ofs + delta) v2 = Some n0 /\\ mem_inj f n1 n0.","proofString":"exists n2; split.\nauto.\nconstructor.\nintros.\neapply perm_store_1; [eexact STORE|].\neapply mi_perm; eauto.\neapply perm_store_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem.\nintros.\nrewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite (store_mem_contents _ _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) : store chunk m2 b2 (ofs + delta) v2 = Some n2.","proofString":"auto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) : mem_inj f n1 n2.","proofString":"constructor.\nintros.\neapply perm_store_1; [eexact STORE|].\neapply mi_perm; eauto.\neapply perm_store_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem.\nintros.\nrewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite (store_mem_contents _ _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm n1 b0 ofs0 k p -> perm n2 b3 (ofs0 + delta0) k p.","proofString":"intros.\neapply perm_store_1; [eexact STORE|].\neapply mi_perm; eauto.\neapply perm_store_2; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 k p) : perm n2 b3 (ofs0 + delta0) k p.","proofString":"eapply perm_store_1; [eexact STORE|].\neapply mi_perm; eauto.\neapply perm_store_2; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 k p) : perm m2 b3 (ofs0 + delta0) k p.","proofString":"eapply mi_perm; eauto.\neapply perm_store_2; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 k p) : perm m1 b0 ofs0 k p.","proofString":"eapply perm_store_2; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm n1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0).","proofString":"intros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) (ofs0 : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p) : (align_chunk chunk0 | delta0).","proofString":"eapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) (ofs0 : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p) : range_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p.","proofString":"red; intros; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm n1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents n2) # b3).","proofString":"intros.\nrewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite (store_mem_contents _ _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents n2) # b3).","proofString":"rewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite (store_mem_contents _ _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (PMap.set b1 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1)\n        (mem_contents m1)) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents n2) # b3).","proofString":"rewrite (store_mem_contents _ _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (PMap.set b1 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1)\n        (mem_contents m1)) # b0)\n  (ZMap.get (ofs0 + delta0)\n     (PMap.set b2\n        (setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2)\n        (mem_contents m2)) # b3).","proofString":"rewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (if peq b0 b1\n      then setN (encode_val chunk v1) ofs (mem_contents m1) # b1\n      else (mem_contents m1) # b0))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"destruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (e : b0 = b1) : memval_inject f\n  (ZMap.get ofs0 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"subst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (b3 : block) (delta0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b3, delta0)) : memval_inject f\n  (ZMap.get ofs0 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"assert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (b3 : block) (delta0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b3, delta0)) (H7 : b3 = b2) : memval_inject f\n  (ZMap.get ofs0 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"subst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 delta0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta0)) : memval_inject f\n  (ZMap.get ofs0 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b2 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b2)).","proofString":"assert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 delta0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta0)) (H7 : delta0 = delta) : memval_inject f\n  (ZMap.get ofs0 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b2 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b2)).","proofString":"subst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) : memval_inject f\n  (ZMap.get ofs0 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta)\n     (if peq b2 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b2)).","proofString":"rewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) : memval_inject f\n  (ZMap.get ofs0 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta)\n     (setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2)).","proofString":"apply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable).\napply encode_val_inject; auto.\nintros.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) : list_forall2 (memval_inject f) (encode_val chunk v1) (encode_val chunk v2).","proofString":"apply encode_val_inject; auto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) : forall q : Z,\nperm m1 b1 q Cur Readable ->\nmemval_inject f (ZMap.get q (mem_contents m1) # b1)\n  (ZMap.get (q + delta) (mem_contents m2) # b2).","proofString":"intros.\neapply mi_memval; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) (q : Z) (H7 : perm m1 b1 q Cur Readable) : memval_inject f (ZMap.get q (mem_contents m1) # b1)\n  (ZMap.get (q + delta) (mem_contents m2) # b2).","proofString":"eapply mi_memval; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (ofs0 : Z) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) : perm m1 b1 ofs0 Cur Readable.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"destruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia.\neapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (e : b3 = b2) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0)\n     (setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2)).","proofString":"subst b3.\nrewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0)\n     (setN (encode_val chunk v2) (ofs + delta) (mem_contents m2) # b2)).","proofString":"rewrite setN_other.\neapply mi_memval; eauto.\neauto with mem.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2).","proofString":"eapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) : perm m1 b0 ofs0 Cur Readable.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) : forall r : Z,\nofs + delta <= r <\nofs + delta + Z.of_nat (Datatypes.length (encode_val chunk v2)) ->\nr <> ofs0 + delta0.","proofString":"rewrite encode_val_length.\nrewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) : forall r : Z,\nofs + delta <= r < ofs + delta + Z.of_nat (size_chunk_nat chunk) ->\nr <> ofs0 + delta0.","proofString":"rewrite <- size_chunk_conv.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) : forall r : Z,\nofs + delta <= r < ofs + delta + size_chunk chunk -> r <> ofs0 + delta0.","proofString":"intros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) : r <> ofs0 + delta0.","proofString":"assert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem.\ndestruct H8.\ncongruence.\nlia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) : b2 <> b2 \\/ ofs0 + delta0 <> r - delta + delta.","proofString":"eapply H1; eauto.\neauto 6 with mem.\nexploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) : perm m1 b0 ofs0 Max Nonempty.","proofString":"eauto 6 with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) : perm m1 b1 (r - delta) Max Nonempty.","proofString":"exploit store_valid_access_3.\neexact H0.\nintros [A B].\neapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) : perm m1 b1 (r - delta) Max Nonempty.","proofString":"eapply perm_implies.\napply perm_cur_max.\napply A.\nlia.\nauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) (A : range_perm m1 b1 ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) : ofs <= r - delta < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) (H8 : b2 <> b2 \\/ ofs0 + delta0 <> r - delta + delta) : r <> ofs0 + delta0.","proofString":"destruct H8.\ncongruence.\nlia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) (H8 : b2 <> b2) : r <> ofs0 + delta0.","proofString":"congruence."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H7 : ofs + delta <= r < ofs + delta + size_chunk chunk) (H8 : ofs0 + delta0 <> r - delta + delta) : r <> ofs0 + delta0.","proofString":"lia."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (n0 : b3 <> b2) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3).","proofString":"eapply mi_memval; eauto.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : Val.inject f v1 v2) (H4 : valid_access m2 chunk b2 (ofs + delta) Writable) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (n : b0 <> b1) (n0 : b3 <> b2) : perm m1 b0 ofs0 Cur Readable.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) : mem_inj f n1 m2.","proofString":"constructor.\nintros.\neapply mi_perm; eauto with mem.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem.\nintros.\nrewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite PMap.gso.\neapply mi_memval; eauto with mem.\ncongruence."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) : forall (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm n1 b0 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p.","proofString":"intros.\neapply mi_perm; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 k p) : perm m2 b2 (ofs0 + delta) k p.","proofString":"eapply mi_perm; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) : forall (b0 b2 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm n1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta).","proofString":"intros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (b0 b2 : block) (delta : Z) (chunk0 : memory_chunk) (ofs0 : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p) : (align_chunk chunk0 | delta).","proofString":"eapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (b0 b2 : block) (delta : Z) (chunk0 : memory_chunk) (ofs0 : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p) : range_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p.","proofString":"red; intros; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm n1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"intros.\nrewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite PMap.gso.\neapply mi_memval; eauto with mem.\ncongruence."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"rewrite (store_mem_contents _ _ _ _ _ _ H0).\nrewrite PMap.gso.\neapply mi_memval; eauto with mem.\ncongruence."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (PMap.set b1 (setN (encode_val chunk v1) ofs (mem_contents m1) # b1)\n        (mem_contents m1)) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"rewrite PMap.gso.\neapply mi_memval; eauto with mem.\ncongruence."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"eapply mi_memval; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : b0 <> b1.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') : mem_inj f m1 m2'.","proofString":"inv H.\nconstructor.\neauto with mem.\nintros; eapply mi_align0; eauto.\nintros.\nrewrite (store_mem_contents _ _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : mem_inj f m1 m2'.","proofString":"constructor.\neauto with mem.\nintros; eapply mi_align0; eauto.\nintros.\nrewrite (store_mem_contents _ _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2' b2 (ofs0 + delta) k p.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta).","proofString":"intros; eapply mi_align0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2') # b2).","proofString":"intros.\nrewrite (store_mem_contents _ _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2') # b2).","proofString":"rewrite (store_mem_contents _ _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta)\n     (PMap.set b (setN (encode_val chunk v) ofs (mem_contents m2) # b)\n        (mem_contents m2)) # b2).","proofString":"rewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta)\n     (if peq b2 b\n      then setN (encode_val chunk v) ofs (mem_contents m2) # b\n      else (mem_contents m2) # b2)).","proofString":"destruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) (e : b2 = b) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta)\n     (setN (encode_val chunk v) ofs (mem_contents m2) # b)).","proofString":"subst b2.\nrewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta)\n     (setN (encode_val chunk v) ofs (mem_contents m2) # b)).","proofString":"rewrite setN_outside.\nauto.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b).","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : ofs0 + delta < ofs \\/\nofs0 + delta >= ofs + Z.of_nat (Datatypes.length (encode_val chunk v)).","proofString":"rewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : ofs0 + delta < ofs \\/ ofs0 + delta >= ofs + Z.of_nat (size_chunk_nat chunk).","proofString":"rewrite <- size_chunk_conv.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) : ofs0 + delta < ofs \\/ ofs0 + delta >= ofs + size_chunk chunk.","proofString":"destruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) : ofs0 + delta < ofs \\/ ofs0 + delta >= ofs + size_chunk chunk.","proofString":"destruct (zle (ofs + size_chunk chunk) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (l : ofs + size_chunk chunk <= ofs0 + delta) : ofs0 + delta < ofs \\/ ofs0 + delta >= ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (g0 : ofs + size_chunk chunk > ofs0 + delta) : ofs0 + delta < ofs \\/ ofs0 + delta >= ofs + size_chunk chunk.","proofString":"byContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (g0 : ofs + size_chunk chunk > ofs0 + delta) : False.","proofString":"eapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (g0 : ofs + size_chunk chunk > ofs0 + delta) : ofs <= ofs0 + delta < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs0 Cur Readable) (n : b2 <> b) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) : exists n2 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n2 /\\ mem_inj f n1 n2.","proofString":"inversion H.\nassert (range_perm m2 b2 (ofs + delta) (ofs + delta + Z.of_nat (length bytes2)) Cur Writable).\nreplace (ofs + delta + Z.of_nat (length bytes2))       with ((ofs + Z.of_nat (length bytes1)) + delta).\neapply range_perm_inj; eauto with mem.\neapply storebytes_range_perm; eauto.\nrewrite (list_forall2_length H3).\nlia.\ndestruct (range_perm_storebytes _ _ _ _ H4) as [n2 STORE].\nexists n2; split.\neauto.\nconstructor.\nintros.\neapply perm_storebytes_1; [apply STORE |].\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nassert (perm m1 b0 ofs0 Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) : exists n2 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n2 /\\ mem_inj f n1 n2.","proofString":"assert (range_perm m2 b2 (ofs + delta) (ofs + delta + Z.of_nat (length bytes2)) Cur Writable).\nreplace (ofs + delta + Z.of_nat (length bytes2))       with ((ofs + Z.of_nat (length bytes1)) + delta).\neapply range_perm_inj; eauto with mem.\neapply storebytes_range_perm; eauto.\nrewrite (list_forall2_length H3).\nlia.\ndestruct (range_perm_storebytes _ _ _ _ H4) as [n2 STORE].\nexists n2; split.\neauto.\nconstructor.\nintros.\neapply perm_storebytes_1; [apply STORE |].\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nassert (perm m1 b0 ofs0 Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable.","proofString":"replace (ofs + delta + Z.of_nat (length bytes2))       with ((ofs + Z.of_nat (length bytes1)) + delta).\neapply range_perm_inj; eauto with mem.\neapply storebytes_range_perm; eauto.\nrewrite (list_forall2_length H3).\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) : range_perm m2 b2 (ofs + delta)\n  (ofs + Z.of_nat (Datatypes.length bytes1) + delta) Cur Writable.","proofString":"eapply range_perm_inj; eauto with mem.\neapply storebytes_range_perm; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) : range_perm m1 b1 ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur Writable.","proofString":"eapply storebytes_range_perm; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) : ofs + Z.of_nat (Datatypes.length bytes1) + delta =\nofs + delta + Z.of_nat (Datatypes.length bytes2).","proofString":"rewrite (list_forall2_length H3).\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) : ofs + Z.of_nat (Datatypes.length bytes2) + delta =\nofs + delta + Z.of_nat (Datatypes.length bytes2).","proofString":"lia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) : exists n2 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n2 /\\ mem_inj f n1 n2.","proofString":"destruct (range_perm_storebytes _ _ _ _ H4) as [n2 STORE].\nexists n2; split.\neauto.\nconstructor.\nintros.\neapply perm_storebytes_1; [apply STORE |].\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nassert (perm m1 b0 ofs0 Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) : exists n0 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n0 /\\ mem_inj f n1 n0.","proofString":"exists n2; split.\neauto.\nconstructor.\nintros.\neapply perm_storebytes_1; [apply STORE |].\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nassert (perm m1 b0 ofs0 Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) : storebytes m2 b2 (ofs + delta) bytes2 = Some n2.","proofString":"eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) : mem_inj f n1 n2.","proofString":"constructor.\nintros.\neapply perm_storebytes_1; [apply STORE |].\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nassert (perm m1 b0 ofs0 Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm n1 b0 ofs0 k p -> perm n2 b3 (ofs0 + delta0) k p.","proofString":"intros.\neapply perm_storebytes_1; [apply STORE |].\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k0 p0 -> perm m2 b5 (ofs1 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 k p) : perm n2 b3 (ofs0 + delta0) k p.","proofString":"eapply perm_storebytes_1; [apply STORE |].\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k0 p0 -> perm m2 b5 (ofs1 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 k p) : perm m2 b3 (ofs0 + delta0) k p.","proofString":"eapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k0 p0 -> perm m2 b5 (ofs1 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 k p) : perm m1 b0 ofs0 k p.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0).","proofString":"intros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p0 -> perm m2 b5 (ofs1 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs0 : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p) : (align_chunk chunk | delta0).","proofString":"eapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p0 -> perm m2 b5 (ofs1 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs0 : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p) : range_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p.","proofString":"red; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs2 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs2 k p0 -> perm m2 b5 (ofs2 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs2 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs2 (ofs2 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs2 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs2 Cur Readable ->\nmemval_inject f (ZMap.get ofs2 (mem_contents m1) # b4)\n  (ZMap.get (ofs2 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs0 : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p) (ofs1 : Z) (H7 : ofs0 <= ofs1 < ofs0 + size_chunk chunk) : perm m1 b0 ofs1 Max p.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm n1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents n2) # b3).","proofString":"intros.\nassert (perm m1 b0 ofs0 Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents n2) # b3).","proofString":"assert (perm m1 b0 ofs0 Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) : perm m1 b0 ofs0 Cur Readable.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents n2) # b3).","proofString":"rewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (PMap.set b1 (setN bytes1 ofs (mem_contents m1) # b1) (mem_contents m1))\n     # b0) (ZMap.get (ofs0 + delta0) (mem_contents n2) # b3).","proofString":"rewrite (storebytes_mem_contents _ _ _ _ _ STORE).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (PMap.set b1 (setN bytes1 ofs (mem_contents m1) # b1) (mem_contents m1))\n     # b0)\n  (ZMap.get (ofs0 + delta0)\n     (PMap.set b2 (setN bytes2 (ofs + delta) (mem_contents m2) # b2)\n        (mem_contents m2)) # b3).","proofString":"rewrite ! PMap.gsspec.\ndestruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (if peq b0 b1\n      then setN bytes1 ofs (mem_contents m1) # b1\n      else (mem_contents m1) # b0))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"destruct (peq b0 b1).\nsubst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto.\ndestruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (e : b0 = b1) : memval_inject f (ZMap.get ofs0 (setN bytes1 ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"subst b0.\nassert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b0 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b4, delta1) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (ofs0 : Z) (b3 : block) (delta0 : Z) (H7 : perm m1 b1 ofs0 Cur Readable) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b3, delta0)) : memval_inject f (ZMap.get ofs0 (setN bytes1 ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"assert (b3 = b2) by congruence.\nsubst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b0 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b4, delta1) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (ofs0 : Z) (b3 : block) (delta0 : Z) (H7 : perm m1 b1 ofs0 Cur Readable) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b3, delta0)) (H8 : b3 = b2) : memval_inject f (ZMap.get ofs0 (setN bytes1 ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"subst b3.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta1) k p) (mi_align0 : forall (b0 b3 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta1) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta1 : Z),\nf b0 = Some (b3, delta1) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (ofs0 delta0 : Z) (H7 : perm m1 b1 ofs0 Cur Readable) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta0)) : memval_inject f (ZMap.get ofs0 (setN bytes1 ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b2 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b2)).","proofString":"assert (delta0 = delta) by congruence.\nsubst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta1) k p) (mi_align0 : forall (b0 b3 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta1) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta1 : Z),\nf b0 = Some (b3, delta1) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (ofs0 delta0 : Z) (H7 : perm m1 b1 ofs0 Cur Readable) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta0)) (H8 : delta0 = delta) : memval_inject f (ZMap.get ofs0 (setN bytes1 ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta0)\n     (if peq b2 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b2)).","proofString":"subst delta0.\nrewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (ofs0 : Z) (H7 : perm m1 b1 ofs0 Cur Readable) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) : memval_inject f (ZMap.get ofs0 (setN bytes1 ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta)\n     (if peq b2 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b2)).","proofString":"rewrite peq_true.\napply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (ofs0 : Z) (H7 : perm m1 b1 ofs0 Cur Readable) (H6 : perm n1 b1 ofs0 Cur Readable) (H5 : f b1 = Some (b2, delta)) : memval_inject f (ZMap.get ofs0 (setN bytes1 ofs (mem_contents m1) # b1))\n  (ZMap.get (ofs0 + delta) (setN bytes2 (ofs + delta) (mem_contents m2) # b2)).","proofString":"apply setN_inj with (access := fun ofs => perm m1 b1 ofs Cur Readable); auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0)\n     (if peq b3 b2\n      then setN bytes2 (ofs + delta) (mem_contents m2) # b2\n      else (mem_contents m2) # b3)).","proofString":"destruct (peq b3 b2).\nsubst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia.\neauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (e : b3 = b2) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0)\n     (setN bytes2 (ofs + delta) (mem_contents m2) # b2)).","proofString":"subst b3.\nrewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0)\n     (setN bytes2 (ofs + delta) (mem_contents m2) # b2)).","proofString":"rewrite setN_other.\nauto.\nintros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2).","proofString":"auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) : forall r : Z,\nofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2) ->\nr <> ofs0 + delta0.","proofString":"intros.\nassert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) : r <> ofs0 + delta0.","proofString":"assert (b2 <> b2 \\/ ofs0 + delta0 <> (r - delta) + delta).\neapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem.\ndestruct H9.\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) : b2 <> b2 \\/ ofs0 + delta0 <> r - delta + delta.","proofString":"eapply H1; eauto 6 with mem.\nexploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) : perm m1 b1 (r - delta) Max Nonempty.","proofString":"exploit storebytes_range_perm.\neexact H0.\ninstantiate (1 := r - delta).\nrewrite (list_forall2_length H3).\nlia.\neauto 6 with mem."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) : ofs <= r - delta < ofs + Z.of_nat (Datatypes.length bytes1).","proofString":"rewrite (list_forall2_length H3).\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) : ofs <= r - delta < ofs + Z.of_nat (Datatypes.length bytes2).","proofString":"lia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) (H9 : b2 <> b2 \\/ ofs0 + delta0 <> r - delta + delta) : r <> ofs0 + delta0.","proofString":"destruct H9.\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) (H9 : b2 <> b2) : r <> ofs0 + delta0.","proofString":"congruence."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b3 b4 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta1) k p) (mi_align0 : forall (b3 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta1) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta1 : Z),\nf b3 = Some (b4, delta1) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b4)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 delta0 : Z) (H5 : f b0 = Some (b2, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (r : Z) (H8 : ofs + delta <= r < ofs + delta + Z.of_nat (Datatypes.length bytes2)) (H9 : ofs0 + delta0 <> r - delta + delta) : r <> ofs0 + delta0.","proofString":"lia."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (H3 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p -> perm m2 b5 (ofs1 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (H4 : range_perm m2 b2 (ofs + delta)\n  (ofs + delta + Z.of_nat (Datatypes.length bytes2)) Cur Writable) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm n1 b0 ofs0 Cur Readable) (H7 : perm m1 b0 ofs0 Cur Readable) (n : b0 <> b1) (n0 : b3 <> b2) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3).","proofString":"eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) : mem_inj f n1 m2.","proofString":"inversion H.\nconstructor.\nintros.\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite PMap.gso.\neapply mi_memval0; eauto.\neapply perm_storebytes_2; eauto.\ncongruence."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : mem_inj f n1 m2.","proofString":"constructor.\nintros.\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite PMap.gso.\neapply mi_memval0; eauto.\neapply perm_storebytes_2; eauto.\ncongruence."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm n1 b0 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p.","proofString":"intros.\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k0 p0 -> perm m2 b4 (ofs1 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 k p) : perm m2 b2 (ofs0 + delta) k p.","proofString":"eapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k0 p0 -> perm m2 b4 (ofs1 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 k p) : perm m1 b0 ofs0 k p.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"intros.\neapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p0 -> perm m2 b4 (ofs1 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs0 : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"eapply mi_align with (ofs := ofs0) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p0 -> perm m2 b4 (ofs1 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs0 : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p) : range_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p.","proofString":"red; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs2 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs2 k p0 -> perm m2 b4 (ofs2 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs2 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs2 (ofs2 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs2 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs2 Cur Readable ->\nmemval_inject f (ZMap.get ofs2 (mem_contents m1) # b3)\n  (ZMap.get (ofs2 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs0 : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm n1 b0 ofs0 (ofs0 + size_chunk chunk) Max p) (ofs1 : Z) (H4 : ofs0 <= ofs1 < ofs0 + size_chunk chunk) : perm m1 b0 ofs1 Max p.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm n1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"intros.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite PMap.gso.\neapply mi_memval0; eauto.\neapply perm_storebytes_2; eauto.\ncongruence."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents n1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"rewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite PMap.gso.\neapply mi_memval0; eauto.\neapply perm_storebytes_2; eauto.\ncongruence."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : memval_inject f\n  (ZMap.get ofs0\n     (PMap.set b1 (setN bytes1 ofs (mem_contents m1) # b1) (mem_contents m1))\n     # b0) (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"rewrite PMap.gso.\neapply mi_memval0; eauto.\neapply perm_storebytes_2; eauto.\ncongruence."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"eapply mi_memval0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : perm m1 b0 ofs0 Cur Readable.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p -> perm m2 b4 (ofs1 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm n1 b0 ofs0 Cur Readable) : b0 <> b1.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') : mem_inj f m1 m2'.","proofString":"inversion H.\nconstructor.\nintros.\neapply perm_storebytes_1; eauto with mem.\neauto.\nintros.\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : mem_inj f m1 m2'.","proofString":"constructor.\nintros.\neapply perm_storebytes_1; eauto with mem.\neauto.\nintros.\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2' b2 (ofs0 + delta) k p.","proofString":"intros.\neapply perm_storebytes_1; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k0 p0 -> perm m2 b3 (ofs1 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs0 k p) : perm m2' b2 (ofs0 + delta) k p.","proofString":"eapply perm_storebytes_1; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 k p -> perm m2 b2 (ofs0 + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2') # b2).","proofString":"intros.\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2') # b2).","proofString":"rewrite (storebytes_mem_contents _ _ _ _ _ H1).\nrewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta)\n     (PMap.set b (setN bytes2 ofs (mem_contents m2) # b) (mem_contents m2))\n     # b2).","proofString":"rewrite PMap.gsspec.\ndestruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta)\n     (if peq b2 b\n      then setN bytes2 ofs (mem_contents m2) # b\n      else (mem_contents m2) # b2)).","proofString":"destruct (peq b2 b).\nsubst b2.\nrewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) (e : b2 = b) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (setN bytes2 ofs (mem_contents m2) # b)).","proofString":"subst b2.\nrewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (setN bytes2 ofs (mem_contents m2) # b)).","proofString":"rewrite setN_outside.\nauto.\ndestruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b).","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) : ofs0 + delta < ofs \\/\nofs0 + delta >= ofs + Z.of_nat (Datatypes.length bytes2).","proofString":"destruct (zlt (ofs0 + delta) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) : ofs0 + delta < ofs \\/\nofs0 + delta >= ofs + Z.of_nat (Datatypes.length bytes2).","proofString":"destruct (zle (ofs + Z.of_nat (length bytes2)) (ofs0 + delta)).\nlia.\nbyContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (l : ofs + Z.of_nat (Datatypes.length bytes2) <= ofs0 + delta) : ofs0 + delta < ofs \\/\nofs0 + delta >= ofs + Z.of_nat (Datatypes.length bytes2).","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes2) > ofs0 + delta) : ofs0 + delta < ofs \\/\nofs0 + delta >= ofs + Z.of_nat (Datatypes.length bytes2).","proofString":"byContradiction.\neapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes2) > ofs0 + delta) : False.","proofString":"eapply H0; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b2 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b2)) (b1 : block) (ofs0 delta : Z) (H2 : f b1 = Some (b, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) (g : ofs0 + delta >= ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes2) > ofs0 + delta) : ofs <= ofs0 + delta < ofs + Z.of_nat (Datatypes.length bytes2).","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : mem_inj f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs1 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 k p -> perm m2 b3 (ofs1 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs1 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs0 Cur Readable) (n : b2 <> b) : memval_inject f (ZMap.get ofs0 (mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2).","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') : mem_inj f m1' m2'.","proofString":"destruct H.\nconstructor.\nintros.\neapply perm_storebytes_1; eauto.\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nassert (perm m1 b0 ofs Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nsimpl.\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) -> perm m1 b0 ofs k p -> perm m2 b3 (ofs + delta) k p) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b3)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') : mem_inj f m1' m2'.","proofString":"constructor.\nintros.\neapply perm_storebytes_1; eauto.\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto.\nintros.\nassert (perm m1 b0 ofs Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nsimpl.\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) -> perm m1 b0 ofs k p -> perm m2 b3 (ofs + delta) k p) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b3)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') : forall (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m1' b0 ofs k p -> perm m2' b3 (ofs + delta) k p.","proofString":"intros.\neapply perm_storebytes_1; eauto.\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs k p) : perm m2' b3 (ofs + delta) k p.","proofString":"eapply perm_storebytes_1; eauto.\neapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs k p) : perm m2 b3 (ofs + delta) k p.","proofString":"eapply mi_perm0; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs k p) : perm m1 b0 ofs k p.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) -> perm m1 b0 ofs k p -> perm m2 b3 (ofs + delta) k p) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b3)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1' b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"intros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta0) k p0) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 b3 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : f b0 = Some (b3, delta)) (H2 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p.","proofString":"red; intros.\neapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs3 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs3 k p0 -> perm m2 b5 (ofs3 + delta0) k p0) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs3 : Z) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs3 (ofs3 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b4 : block) (ofs3 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs3 Cur Readable ->\nmemval_inject f (ZMap.get ofs3 (mem_contents m1) # b4)\n  (ZMap.get (ofs3 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 b3 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : f b0 = Some (b3, delta)) (H2 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H3 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m1 b0 ofs0 Max p.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) -> perm m1 b0 ofs k p -> perm m2 b3 (ofs + delta) k p) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b3)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1' b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b3).","proofString":"intros.\nassert (perm m1 b0 ofs Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nsimpl.\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta0) k p) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b3).","proofString":"assert (perm m1 b0 ofs Cur Readable).\neapply perm_storebytes_2; eauto.\nrewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nsimpl.\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta0) k p) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs Cur Readable) : perm m1 b0 ofs Cur Readable.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta0) k p) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs Cur Readable) (H3 : perm m1 b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b3).","proofString":"rewrite (storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (storebytes_mem_contents _ _ _ _ _ H1).\nsimpl.\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta0) k p) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs Cur Readable) (H3 : perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (PMap.set b1 (setN nil ofs1 (mem_contents m1) # b1) (mem_contents m1))\n     # b0) (ZMap.get (ofs + delta) (mem_contents m2') # b3).","proofString":"rewrite (storebytes_mem_contents _ _ _ _ _ H1).\nsimpl.\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta0) k p) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs Cur Readable) (H3 : perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (PMap.set b1 (setN nil ofs1 (mem_contents m1) # b1) (mem_contents m1))\n     # b0)\n  (ZMap.get (ofs + delta)\n     (PMap.set b2 (setN nil ofs2 (mem_contents m2) # b2) (mem_contents m2))\n     # b3).","proofString":"simpl.\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta0) k p) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs Cur Readable) (H3 : perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs (PMap.set b1 (mem_contents m1) # b1 (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta)\n     (PMap.set b2 (mem_contents m2) # b2 (mem_contents m2)) # b3).","proofString":"rewrite ! PMap.gsspec.\ndestruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (mi_perm0 : forall (b4 b5 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta0) k p) (mi_align0 : forall (b4 b5 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta0) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z),\nf b4 = Some (b5, delta0) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b5)) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (H : f b0 = Some (b3, delta)) (H2 : perm m1' b0 ofs Cur Readable) (H3 : perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (if peq b0 b1 then (mem_contents m1) # b1 else (mem_contents m1) # b0))\n  (ZMap.get (ofs + delta)\n     (if peq b3 b2 then (mem_contents m2) # b2 else (mem_contents m2) # b3)).","proofString":"destruct (peq b0 b1); destruct (peq b3 b2); subst; eapply mi_memval0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) : mem_inj f m1 m2'.","proofString":"injection H0.\nintros NEXT MEM.\ninversion H.\nconstructor.\nintros.\neapply perm_alloc_1; eauto.\neauto.\nintros.\nassert (perm m2 b0 (ofs + delta) Cur Readable).\neapply mi_perm0; eauto.\nassert (valid_block m2 b0) by eauto with mem.\nrewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) : nextblock m2 = b2 ->\n{|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2' -> mem_inj f m1 m2'.","proofString":"intros NEXT MEM.\ninversion H.\nconstructor.\nintros.\neapply perm_alloc_1; eauto.\neauto.\nintros.\nassert (perm m2 b0 (ofs + delta) Cur Readable).\neapply mi_perm0; eauto.\nassert (valid_block m2 b0) by eauto with mem.\nrewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') : mem_inj f m1 m2'.","proofString":"inversion H.\nconstructor.\nintros.\neapply perm_alloc_1; eauto.\neauto.\nintros.\nassert (perm m2 b0 (ofs + delta) Cur Readable).\neapply mi_perm0; eauto.\nassert (valid_block m2 b0) by eauto with mem.\nrewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b1 b0 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) -> perm m1 b1 ofs k p -> perm m2 b0 (ofs + delta) k p) (mi_align0 : forall (b1 b0 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b0, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b0)) : mem_inj f m1 m2'.","proofString":"constructor.\nintros.\neapply perm_alloc_1; eauto.\neauto.\nintros.\nassert (perm m2 b0 (ofs + delta) Cur Readable).\neapply mi_perm0; eauto.\nassert (valid_block m2 b0) by eauto with mem.\nrewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b1 b0 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) -> perm m1 b1 ofs k p -> perm m2 b0 (ofs + delta) k p) (mi_align0 : forall (b1 b0 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b0, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b0)) : forall (b1 b0 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m1 b1 ofs k p -> perm m2' b0 (ofs + delta) k p.","proofString":"intros.\neapply perm_alloc_1; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k0 H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 b0 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs k p) : perm m2' b0 (ofs + delta) k p.","proofString":"eapply perm_alloc_1; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b1 b0 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) -> perm m1 b1 ofs k p -> perm m2 b0 (ofs + delta) k p) (mi_align0 : forall (b1 b0 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b0, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b0)) : forall (b1 b0 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b0, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b1 b0 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) -> perm m1 b1 ofs k p -> perm m2 b0 (ofs + delta) k p) (mi_align0 : forall (b1 b0 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b0, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b0)) : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b0).","proofString":"intros.\nassert (perm m2 b0 (ofs + delta) Cur Readable).\neapply mi_perm0; eauto.\nassert (valid_block m2 b0) by eauto with mem.\nrewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b0).","proofString":"assert (perm m2 b0 (ofs + delta) Cur Readable).\neapply mi_perm0; eauto.\nassert (valid_block m2 b0) by eauto with mem.\nrewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) : perm m2 b0 (ofs + delta) Cur Readable.","proofString":"eapply mi_perm0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H4 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H4;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) (H3 : perm m2 b0 (ofs + delta) Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b0).","proofString":"assert (valid_block m2 b0) by eauto with mem.\nrewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) (H3 : perm m2 b0 (ofs + delta) Cur Readable) (H4 : valid_block m2 b0) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b0).","proofString":"rewrite <- MEM; simpl.\nrewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) (H3 : perm m2 b0 (ofs + delta) Cur Readable) (H4 : valid_block m2 b0) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta)\n     (PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2)) # b0).","proofString":"rewrite PMap.gso.\neauto with mem.\nrewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) (H3 : perm m2 b0 (ofs + delta) Cur Readable) (H4 : valid_block m2 b0) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b0).","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) (H3 : perm m2 b0 (ofs + delta) Cur Readable) (H4 : valid_block m2 b0) : b0 <> nextblock m2.","proofString":"rewrite NEXT.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : mem_inj f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (H1 : f b1 = Some (b0, delta)) (H2 : perm m1 b1 ofs Cur Readable) (H3 : perm m2 b0 (ofs + delta) Cur Readable) (H4 : valid_block m2 b0) : b0 <> b2.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) : mem_inj f m1' m2.","proofString":"inversion H.\nconstructor.\nintros.\nexploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\nexploit perm_alloc_inv; eauto.\ndestruct (eq_block b0 b1); auto.\ncongruence.\ninjection H0; intros NEXT MEM.\nintros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) -> perm m1 b0 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : mem_inj f m1' m2.","proofString":"constructor.\nintros.\nexploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\nexploit perm_alloc_inv; eauto.\ndestruct (eq_block b0 b1); auto.\ncongruence.\ninjection H0; intros NEXT MEM.\nintros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) -> perm m1 b0 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m1' b0 ofs k p -> perm m2 b2 (ofs + delta) k p.","proofString":"intros.\nexploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"exploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs k p) : (if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs k p) ->\nperm m2 b2 (ofs + delta) k p.","proofString":"intros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs k p) (H4 : if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"destruct (eq_block b0 b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs k p) (e : b0 = b1) (H4 : lo <= ofs < hi) : perm m2 b2 (ofs + delta) k p.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs k p) (n : b0 <> b1) (H4 : perm m1 b0 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) -> perm m1 b0 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1' b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"intros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\nexploit perm_alloc_inv; eauto.\ndestruct (eq_block b0 b1); auto.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p.","proofString":"red; intros.\nexploit perm_alloc_inv; eauto.\ndestruct (eq_block b0 b1); auto.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p0 -> perm m2 b4 (ofs1 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H4 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m1 b0 ofs0 Max p.","proofString":"exploit perm_alloc_inv; eauto.\ndestruct (eq_block b0 b1); auto.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p0 -> perm m2 b4 (ofs1 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H4 : ofs <= ofs0 < ofs + size_chunk chunk) : (if eq_block b0 b1 then lo <= ofs0 < hi else perm m1 b0 ofs0 Max p) ->\nperm m1 b0 ofs0 Max p.","proofString":"destruct (eq_block b0 b1); auto.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 k p0 -> perm m2 b4 (ofs1 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b3)\n  (ZMap.get (ofs1 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H4 : ofs <= ofs0 < ofs + size_chunk chunk) (e : b0 = b1) : lo <= ofs0 < hi -> perm m1 b0 ofs0 Max p.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) -> perm m1 b0 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1' b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"injection H0; intros NEXT MEM.\nintros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) -> perm m1 b0 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m1 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H2 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs k H2;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1' b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"intros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H4 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H4;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"rewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H4 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H4;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"rewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H4 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H4;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs (PMap.set b1 (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"exploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H4 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H4;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) : (if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) ->\nmemval_inject f\n  (ZMap.get ofs (PMap.set b1 (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"intros.\nrewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) (H4 : if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs (PMap.set b1 (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"rewrite PMap.gsspec.\nunfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) (H4 : if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (if peq b0 b1 then ZMap.init Undef else (mem_contents m1) # b0))\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"unfold eq_block in H4.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) (H4 : if peq b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (if peq b0 b1 then ZMap.init Undef else (mem_contents m1) # b0))\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"destruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) (e : b0 = b1) (H4 : lo <= ofs < hi) : memval_inject f (ZMap.get ofs (ZMap.init Undef))\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"rewrite ZMap.gi.\nconstructor."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) (e : b0 = b1) (H4 : lo <= ofs < hi) : memval_inject f Undef (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"constructor."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : f b1 = None) (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1' b0 ofs Cur Readable) (n : b0 <> b1) (H4 : perm m1 b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H4 : f b1 = Some (b2, delta)) : mem_inj f m1' m2.","proofString":"inversion H.\nconstructor.\nintros.\nexploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H4 in H5; inv H5.\neauto.\neauto.\nintros.\ndestruct (eq_block b0 b1).\nsubst b0.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nassert (lo <= ofs < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\nassert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\neapply perm_alloc_4; eauto.\ninjection H0; intros NEXT MEM.\nintros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs k p -> perm m2 b3 (ofs + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3)) : mem_inj f m1' m2.","proofString":"constructor.\nintros.\nexploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H4 in H5; inv H5.\neauto.\neauto.\nintros.\ndestruct (eq_block b0 b1).\nsubst b0.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nassert (lo <= ofs < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\nassert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\neapply perm_alloc_4; eauto.\ninjection H0; intros NEXT MEM.\nintros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs k p -> perm m2 b3 (ofs + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3)) : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1' b0 ofs k p -> perm m2 b3 (ofs + delta0) k p.","proofString":"intros.\nexploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H4 in H5; inv H5.\neauto.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs k p) : perm m2 b3 (ofs + delta0) k p.","proofString":"exploit perm_alloc_inv; eauto.\nintros.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H4 in H5; inv H5.\neauto.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs k p) : (if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs k p) ->\nperm m2 b3 (ofs + delta0) k p.","proofString":"intros.\ndestruct (eq_block b0 b1).\nsubst b0.\nrewrite H4 in H5; inv H5.\neauto.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs k p) (H7 : if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs k p) : perm m2 b3 (ofs + delta0) k p.","proofString":"destruct (eq_block b0 b1).\nsubst b0.\nrewrite H4 in H5; inv H5.\neauto.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs k p) (e : b0 = b1) (H7 : lo <= ofs < hi) : perm m2 b3 (ofs + delta0) k p.","proofString":"subst b0.\nrewrite H4 in H5; inv H5.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b0 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta1) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta1 : Z),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b4)) (b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H6 : perm m1' b1 ofs k p) (H5 : f b1 = Some (b3, delta0)) (H7 : lo <= ofs < hi) : perm m2 b3 (ofs + delta0) k p.","proofString":"rewrite H4 in H5; inv H5.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (b3 : block) (H1 : valid_block m2 b3) (delta0 : Z) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b3 (ofs0 + delta0) k0 p0) (H4 : f b1 = Some (b3, delta0)) (H2 : inj_offset_aligned delta0 (hi - lo)) (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b2 (ofs0 + delta) k0 p0) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p : permission) (H6 : perm m1' b1 ofs k p) (H7 : lo <= ofs < hi) : perm m2 b3 (ofs + delta0) k p.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs k p) (n : b0 <> b1) (H7 : perm m1 b0 ofs k p) : perm m2 b3 (ofs + delta0) k p.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs k p -> perm m2 b3 (ofs + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3)) : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1' b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0).","proofString":"intros.\ndestruct (eq_block b0 b1).\nsubst b0.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nassert (lo <= ofs < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\nassert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros.\neapply perm_alloc_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) (e : b0 = b1) : (align_chunk chunk | delta0).","proofString":"subst b0.\nassert (delta0 = delta) by congruence.\nsubst delta0.\nassert (lo <= ofs < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\nassert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta1) k p0) (mi_align0 : forall (b0 b4 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta1) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta1 : Z),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b4)) (b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta0)) : (align_chunk chunk | delta0).","proofString":"assert (delta0 = delta) by congruence.\nsubst delta0.\nassert (lo <= ofs < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\nassert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta1) k p0) (mi_align0 : forall (b0 b4 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta1) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta1 : Z),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b4)) (b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta0)) (H7 : delta0 = delta) : (align_chunk chunk | delta0).","proofString":"subst delta0.\nassert (lo <= ofs < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\nassert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) : (align_chunk chunk | delta).","proofString":"assert (lo <= ofs < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\nassert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) : lo <= ofs < hi.","proofString":"eapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) : ofs <= ofs < ofs + size_chunk chunk.","proofString":"generalize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) (H7 : lo <= ofs < hi) : (align_chunk chunk | delta).","proofString":"assert (lo <= ofs + size_chunk chunk - 1 < hi).\neapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia.\napply H2.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) (H7 : lo <= ofs < hi) : lo <= ofs + size_chunk chunk - 1 < hi.","proofString":"eapply perm_alloc_3; eauto.\napply H6.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) (H7 : lo <= ofs < hi) : ofs <= ofs + size_chunk chunk - 1 < ofs + size_chunk chunk.","proofString":"generalize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) (H7 : lo <= ofs < hi) (H8 : lo <= ofs + size_chunk chunk - 1 < hi) : (align_chunk chunk | delta).","proofString":"apply H2.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b4, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b0 = Some (b4, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b3 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H6 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) (H5 : f b1 = Some (b3, delta)) (H7 : lo <= ofs < hi) (H8 : lo <= ofs + size_chunk chunk - 1 < hi) : size_chunk chunk <= hi - lo.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) (n : b0 <> b1) : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p.","proofString":"red; intros.\neapply perm_alloc_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs1 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs1 < hi -> perm m2 b2 (ofs1 + delta) k p0) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 k p0 -> perm m2 b5 (ofs1 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b4)\n  (ZMap.get (ofs1 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H5 : f b0 = Some (b3, delta0)) (H6 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p) (n : b0 <> b1) (ofs0 : Z) (H7 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m1 b0 ofs0 Max p.","proofString":"eapply perm_alloc_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs k p -> perm m2 b3 (ofs + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3)) : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1' b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"injection H0; intros NEXT MEM.\nintros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs k p -> perm m2 b3 (ofs + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m1 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H5 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs k H5;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1' b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"intros.\nrewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H7 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H7;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"rewrite <- MEM; simpl.\nrewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H7 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H7;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"rewrite NEXT.\nexploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H7 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H7;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs (PMap.set b1 (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"exploit perm_alloc_inv; eauto.\nintros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H7 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H7;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) : (if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) ->\nmemval_inject f\n  (ZMap.get ofs (PMap.set b1 (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"intros.\nrewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H8 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H8;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) (H7 : if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs (PMap.set b1 (ZMap.init Undef) (mem_contents m1)) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"rewrite PMap.gsspec.\nunfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H8 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H8;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) (H7 : if eq_block b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (if peq b0 b1 then ZMap.init Undef else (mem_contents m1) # b0))\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"unfold eq_block in H7.\ndestruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H8 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H8;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) (H7 : if peq b0 b1 then lo <= ofs < hi else perm m1 b0 ofs Cur Readable) : memval_inject f\n  (ZMap.get ofs\n     (if peq b0 b1 then ZMap.init Undef else (mem_contents m1) # b0))\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"destruct (peq b0 b1).\nrewrite ZMap.gi.\nconstructor.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H8 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H8;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) (e : b0 = b1) (H7 : lo <= ofs < hi) : memval_inject f (ZMap.get ofs (ZMap.init Undef))\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"rewrite ZMap.gi.\nconstructor."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H8 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H8;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) (e : b0 = b1) (H7 : lo <= ofs < hi) : memval_inject f Undef (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"constructor."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : mem_inj f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : inj_offset_aligned delta (hi - lo)) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H4 : f b1 = Some (b2, delta)) (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (NEXT : nextblock m1 = b1) (MEM : {|\n  mem_contents := PMap.set (nextblock m1) (ZMap.init Undef) (mem_contents m1);\n  mem_access :=\n    PMap.set (nextblock m1)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m1);\n  nextblock := Pos.succ (nextblock m1);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m1 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k : perm_kind)\n      (H8 : ~ Plt b (Pos.succ (nextblock m1))) =>\n    alloc_obligation_2 m1 lo hi b ofs0 k H8;\n  contents_default := fun b : positive => alloc_obligation_3 m1 b\n|} = m1') (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H5 : f b0 = Some (b3, delta0)) (H6 : perm m1' b0 ofs Cur Readable) (n : b0 <> b1) (H7 : perm m1 b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') : mem_inj f m1' m2.","proofString":"exploit free_result; eauto.\nintro FREE.\ninversion H.\nconstructor.\nintros.\neauto with mem.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros; eapply perm_free_3; eauto.\nintros.\nrewrite FREE; simpl.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') : m1' = unchecked_free m1 b lo hi -> mem_inj f m1' m2.","proofString":"intro FREE.\ninversion H.\nconstructor.\nintros.\neauto with mem.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros; eapply perm_free_3; eauto.\nintros.\nrewrite FREE; simpl.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) : mem_inj f m1' m2.","proofString":"inversion H.\nconstructor.\nintros.\neauto with mem.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros; eapply perm_free_3; eauto.\nintros.\nrewrite FREE; simpl.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : mem_inj f m1' m2.","proofString":"constructor.\nintros.\neauto with mem.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros; eapply perm_free_3; eauto.\nintros.\nrewrite FREE; simpl.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1' b1 ofs k p -> perm m2 b2 (ofs + delta) k p.","proofString":"intros.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1' b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"intros.\neapply mi_align0 with (ofs := ofs) (p := p); eauto.\nred; intros; eapply perm_free_3; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p) : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p.","proofString":"red; intros; eapply perm_free_3; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1' b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"intros.\nrewrite FREE; simpl.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1') # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"rewrite FREE; simpl.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : mem_inj f m1 m2) (H0 : free m1 b lo hi = Some m1') (FREE : m1' = unchecked_free m1 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) : mem_inj f m1 m2'.","proofString":"exploit free_result; eauto.\nintro FREE.\ninversion H.\nassert (PERM:    forall b1 b2 delta ofs k p,    f b1 = Some (b2, delta) ->    perm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p).\nintros.\nintros.\neapply perm_free_1; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia.\nconstructor.\nauto.\neapply mi_align0; eauto.\nintros.\nrewrite FREE; simpl.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) : m2' = unchecked_free m2 b lo hi -> mem_inj f m1 m2'.","proofString":"intro FREE.\ninversion H.\nassert (PERM:    forall b1 b2 delta ofs k p,    f b1 = Some (b2, delta) ->    perm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p).\nintros.\nintros.\neapply perm_free_1; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia.\nconstructor.\nauto.\neapply mi_align0; eauto.\nintros.\nrewrite FREE; simpl.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) : mem_inj f m1 m2'.","proofString":"inversion H.\nassert (PERM:    forall b1 b2 delta ofs k p,    f b1 = Some (b2, delta) ->    perm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p).\nintros.\nintros.\neapply perm_free_1; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia.\nconstructor.\nauto.\neapply mi_align0; eauto.\nintros.\nrewrite FREE; simpl.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : mem_inj f m1 m2'.","proofString":"assert (PERM:    forall b1 b2 delta ofs k p,    f b1 = Some (b2, delta) ->    perm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p).\nintros.\nintros.\neapply perm_free_1; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia.\nconstructor.\nauto.\neapply mi_align0; eauto.\nintros.\nrewrite FREE; simpl.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p.","proofString":"intros.\nintros.\neapply perm_free_1; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) : perm m2' b2 (ofs + delta) k p.","proofString":"intros.\neapply perm_free_1; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) : perm m2' b2 (ofs + delta) k p.","proofString":"eapply perm_free_1; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) : b2 <> b \\/ ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"destruct (eq_block b2 b); auto.\nsubst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) (e : b2 = b) : b2 <> b \\/ ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"subst b.\nright.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (b2 : block) (FREE : m2' = unchecked_free m2 b2 lo hi) (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b2, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (H0 : free m2 b2 lo hi = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) : b2 <> b2 \\/ ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"right.\nassert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (b2 : block) (FREE : m2' = unchecked_free m2 b2 lo hi) (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b2, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (H0 : free m2 b2 lo hi = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) : ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"assert (~ (lo <= ofs + delta < hi)).\nred; intros; eapply H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (b2 : block) (FREE : m2' = unchecked_free m2 b2 lo hi) (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b2, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (H0 : free m2 b2 lo hi = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) : ~ lo <= ofs + delta < hi.","proofString":"red; intros; eapply H1; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (b2 : block) (FREE : m2' = unchecked_free m2 b2 lo hi) (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b' = Some (b2, delta0) ->\nperm m1 b' ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (H0 : free m2 b2 lo hi = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs k p) (H4 : ~ lo <= ofs + delta < hi) : ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) (PERM : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p) : mem_inj f m1 m2'.","proofString":"constructor.\nauto.\neapply mi_align0; eauto.\nintros.\nrewrite FREE; simpl.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) (PERM : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p) : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) (PERM : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p) : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"eapply mi_align0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) (PERM : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p -> perm m2' b2 (ofs + delta) k p) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b2).","proofString":"intros.\nrewrite FREE; simpl.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs0 k p -> lo <= ofs0 + delta0 < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (PERM : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2' b3 (ofs0 + delta0) k p) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b2).","proofString":"rewrite FREE; simpl.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : mem_inj f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b' : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs0 k p -> lo <= ofs0 + delta0 < hi -> False) (FREE : m2' = unchecked_free m2 b lo hi) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (PERM : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2' b3 (ofs0 + delta0) k p) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (H3 : perm m1 b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) : mem_inj f m1' m2.","proofString":"inv H.\nconstructor.\nintros.\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p0); eauto.\nred; intros; eapply perm_drop_4; eauto.\nintros.\nreplace (ZMap.get ofs m1'.(mem_contents)#b1) with (ZMap.get ofs m1.(mem_contents)#b1).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p0 -> perm m2 b2 (ofs + delta) k p0) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1' b1 ofs k p0 -> perm m2 b2 (ofs + delta) k p0.","proofString":"intros.\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b3 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs k p0) : perm m2 b2 (ofs + delta) k p0.","proofString":"eapply mi_perm0; eauto.\neapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b3 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs k p0) : perm m1 b1 ofs k p0.","proofString":"eapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p1 -> perm m2 b3 (ofs0 + delta0) k p1) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p1 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p0 : permission) (H : f b1 = Some (b2, delta)) (H2 : range_perm m1' b1 ofs (ofs + size_chunk chunk) Max p0) : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0.","proofString":"red; intros; eapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p0 -> perm m2 b2 (ofs + delta) k p0) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1' b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"intros.\nreplace (ZMap.get ofs m1'.(mem_contents)#b1) with (ZMap.get ofs m1.(mem_contents)#b1).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1') # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"replace (ZMap.get ofs m1'.(mem_contents)#b1) with (ZMap.get ofs m1.(mem_contents)#b1).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"apply mi_memval0; auto.\neapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs Cur Readable) : perm m1 b1 ofs Cur Readable.","proofString":"eapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b lo hi p = Some m1') (H1 : f b = None) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1' b1 ofs Cur Readable) : ZMap.get ofs (mem_contents m1) # b1 = ZMap.get ofs (mem_contents m1') # b1.","proofString":"unfold drop_perm in H0; destruct (range_perm_dec m1 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) : exists m2' : mem,\n  drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2' /\\ mem_inj f m1' m2'.","proofString":"assert ({ m2' | drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2' }).\napply range_perm_drop_2.\nred; intros.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply perm_inj; eauto.\neapply range_perm_drop_1; eauto.\nlia.\ndestruct X as [m2' DROP].\nexists m2'; split; auto.\ninv H.\nconstructor.\nintros.\nassert (perm m2 b3 (ofs + delta0) k p0).\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto.\ndestruct (eq_block b1 b0).\nsubst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia.\neapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p0); eauto.\nred; intros; eapply perm_drop_4; eauto.\nintros.\nreplace (m1'.(mem_contents)#b0) with (m1.(mem_contents)#b0).\nreplace (m2'.(mem_contents)#b3) with (m2.(mem_contents)#b3).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b1 lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) : {m2' : mem | drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'}.","proofString":"apply range_perm_drop_2.\nred; intros.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply perm_inj; eauto.\neapply range_perm_drop_1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) : range_perm m2 b2 (lo + delta) (hi + delta) Cur Freeable.","proofString":"red; intros.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply perm_inj; eauto.\neapply range_perm_drop_1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (ofs : Z) (H3 : lo + delta <= ofs < hi + delta) : perm m2 b2 ofs Cur Freeable.","proofString":"replace ofs with ((ofs - delta) + delta) by lia.\neapply perm_inj; eauto.\neapply range_perm_drop_1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (ofs : Z) (H3 : lo + delta <= ofs < hi + delta) : perm m2 b2 (ofs - delta + delta) Cur Freeable.","proofString":"eapply perm_inj; eauto.\neapply range_perm_drop_1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (ofs : Z) (H3 : lo + delta <= ofs < hi + delta) : perm m1 b1 (ofs - delta) Cur Freeable.","proofString":"eapply range_perm_drop_1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (ofs : Z) (H3 : lo + delta <= ofs < hi + delta) : lo <= ofs - delta < hi.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (X : {m2' : mem | drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'}) : exists m2' : mem,\n  drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2' /\\ mem_inj f m1' m2'.","proofString":"destruct X as [m2' DROP].\nexists m2'; split; auto.\ninv H.\nconstructor.\nintros.\nassert (perm m2 b3 (ofs + delta0) k p0).\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto.\ndestruct (eq_block b1 b0).\nsubst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia.\neapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p0); eauto.\nred; intros; eapply perm_drop_4; eauto.\nintros.\nreplace (m1'.(mem_contents)#b0) with (m1.(mem_contents)#b0).\nreplace (m2'.(mem_contents)#b3) with (m2.(mem_contents)#b3).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b1 lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') : exists m2'0 : mem,\n  drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'0 /\\\n  mem_inj f m1' m2'0.","proofString":"exists m2'; split; auto.\ninv H.\nconstructor.\nintros.\nassert (perm m2 b3 (ofs + delta0) k p0).\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto.\ndestruct (eq_block b1 b0).\nsubst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia.\neapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p0); eauto.\nred; intros; eapply perm_drop_4; eauto.\nintros.\nreplace (m1'.(mem_contents)#b0) with (m1.(mem_contents)#b0).\nreplace (m2'.(mem_contents)#b3) with (m2.(mem_contents)#b3).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b1 lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') : mem_inj f m1' m2'.","proofString":"inv H.\nconstructor.\nintros.\nassert (perm m2 b3 (ofs + delta0) k p0).\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto.\ndestruct (eq_block b1 b0).\nsubst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia.\neapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith.\nintros.\neapply mi_align0 with (ofs := ofs) (p := p0); eauto.\nred; intros; eapply perm_drop_4; eauto.\nintros.\nreplace (m1'.(mem_contents)#b0) with (m1.(mem_contents)#b0).\nreplace (m2'.(mem_contents)#b3) with (m2.(mem_contents)#b3).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b1 lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs k p0 -> perm m2 b3 (ofs + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3)) : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1' b0 ofs k p0 -> perm m2' b3 (ofs + delta0) k p0.","proofString":"intros.\nassert (perm m2 b3 (ofs + delta0) k p0).\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto.\ndestruct (eq_block b1 b0).\nsubst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia.\neapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"assert (perm m2 b3 (ofs + delta0) k p0).\neapply mi_perm0; eauto.\neapply perm_drop_4; eauto.\ndestruct (eq_block b1 b0).\nsubst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia.\neapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) : perm m2 b3 (ofs + delta0) k p0.","proofString":"eapply mi_perm0; eauto.\neapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) : perm m1 b0 ofs k p0.","proofString":"eapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"destruct (eq_block b1 b0).\nsubst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia.\neapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (e : b1 = b0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"subst b0.\nrewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b0 b4 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b4 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b0 b4 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b4, delta1) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b4 : block) (delta1 : Z),\nf b0 = Some (b4, delta1) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b4)) (b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H : f b1 = Some (b3, delta0)) (H4 : perm m2 b3 (ofs + delta0) k p0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"rewrite H2 in H; inv H.\ndestruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"destruct (zlt (ofs + delta0) (lo + delta0)).\neapply perm_drop_3; eauto.\ndestruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (l : ofs + delta0 < lo + delta0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (g : ofs + delta0 >= lo + delta0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"destruct (zle (hi + delta0) (ofs + delta0)).\neapply perm_drop_3; eauto.\nassert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (g : ofs + delta0 >= lo + delta0) (l : hi + delta0 <= ofs + delta0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"eapply perm_drop_3; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (g : ofs + delta0 >= lo + delta0) (g0 : hi + delta0 > ofs + delta0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"assert (perm_order p p0).\neapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto.\napply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (g : ofs + delta0 >= lo + delta0) (g0 : hi + delta0 > ofs + delta0) : perm_order p p0.","proofString":"eapply perm_drop_2.\neexact H0.\ninstantiate (1 := ofs).\nlia.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (g : ofs + delta0 >= lo + delta0) (g0 : hi + delta0 > ofs + delta0) : lo <= ofs < hi.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (g : ofs + delta0 >= lo + delta0) (g0 : hi + delta0 > ofs + delta0) (H : perm_order p p0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"apply perm_implies with p; auto.\neapply perm_drop_1.\neauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (b3 : block) (delta0 : Z) (H2 : f b1 = Some (b3, delta0)) (m2' : mem) (DROP : drop_perm m2 b3 (lo + delta0) (hi + delta0) p = Some m2') (mi_perm0 : forall (b0 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z),\nf b0 = Some (b2, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b2)) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m1' b1 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (g : ofs + delta0 >= lo + delta0) (g0 : hi + delta0 > ofs + delta0) (H : perm_order p p0) : perm m2' b3 (ofs + delta0) k p.","proofString":"eapply perm_drop_1.\neauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) : perm m2' b3 (ofs + delta0) k p0.","proofString":"eapply perm_drop_3; eauto.\ndestruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) : b3 <> b2 \\/ ofs + delta0 < lo + delta \\/ hi + delta <= ofs + delta0.","proofString":"destruct (eq_block b3 b2); auto.\ndestruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) : b3 <> b2 \\/ ofs + delta0 < lo + delta \\/ hi + delta <= ofs + delta0.","proofString":"destruct (zlt (ofs + delta0) (lo + delta)); auto.\ndestruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) : b3 <> b2 \\/ ofs + delta0 < lo + delta \\/ hi + delta <= ofs + delta0.","proofString":"destruct (zle (hi + delta) (ofs + delta0)); auto.\nexploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) (g0 : hi + delta > ofs + delta0) : b3 <> b2 \\/ ofs + delta0 < lo + delta \\/ hi + delta <= ofs + delta0.","proofString":"exploit H1; eauto.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem.\neapply perm_drop_4; eauto.\neapply perm_max.\napply perm_implies with p0.\neauto.\neauto with mem.\nintuition auto with zarith."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) (g0 : hi + delta > ofs + delta0) : perm m1 b1 (ofs + delta0 - delta) Max Nonempty.","proofString":"apply perm_cur_max.\napply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) (g0 : hi + delta > ofs + delta0) : perm m1 b1 (ofs + delta0 - delta) Cur Nonempty.","proofString":"apply perm_implies with Freeable.\neapply range_perm_drop_1; eauto.\nlia.\nauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) (g0 : hi + delta > ofs + delta0) : perm m1 b1 (ofs + delta0 - delta) Cur Freeable.","proofString":"eapply range_perm_drop_1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) (g0 : hi + delta > ofs + delta0) : lo <= ofs + delta0 - delta < hi.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) (g0 : hi + delta > ofs + delta0) : perm_order Freeable Nonempty.","proofString":"auto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p1 -> perm m2 b5 (ofs0 + delta1) k0 p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs k p0) (H4 : perm m2 b3 (ofs + delta0) k p0) (n : b1 <> b0) (e : b3 = b2) (g : ofs + delta0 >= lo + delta) (g0 : hi + delta > ofs + delta0) : perm_order p0 Nonempty.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p1 -> perm m2 b5 (ofs0 + delta1) k p1) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p1 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p0 : permission) (H : f b0 = Some (b3, delta0)) (H3 : range_perm m1' b0 ofs (ofs + size_chunk chunk) Max p0) : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p0.","proofString":"red; intros; eapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs k p0 -> perm m2 b3 (ofs + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3)) : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1' b0 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2') # b3).","proofString":"intros.\nreplace (m1'.(mem_contents)#b0) with (m1.(mem_contents)#b0).\nreplace (m2'.(mem_contents)#b3) with (m2.(mem_contents)#b3).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b1 lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1') # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2') # b3).","proofString":"replace (m1'.(mem_contents)#b0) with (m1.(mem_contents)#b0).\nreplace (m2'.(mem_contents)#b3) with (m2.(mem_contents)#b3).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m1 b1 lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2') # b3).","proofString":"replace (m2'.(mem_contents)#b3) with (m2.(mem_contents)#b3).\napply mi_memval0; auto.\neapply perm_drop_4; eauto.\nunfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"apply mi_memval0; auto.\neapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs Cur Readable) : perm m1 b0 ofs Cur Readable.","proofString":"eapply perm_drop_4; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs Cur Readable) : (mem_contents m2) # b3 = (mem_contents m2') # b3.","proofString":"unfold drop_perm in DROP; destruct (range_perm_dec m2 b2 (lo + delta) (hi + delta) Cur Freeable); inv DROP; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (p : permission) (m1' : mem) (H0 : drop_perm m1 b1 lo hi p = Some m1') (H1 : meminj_no_overlap f m1) (H2 : f b1 = Some (b2, delta)) (m2' : mem) (DROP : drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (H : f b0 = Some (b3, delta0)) (H3 : perm m1' b0 ofs Cur Readable) : (mem_contents m1) # b0 = (mem_contents m1') # b0.","proofString":"unfold drop_perm in H0; destruct (range_perm_dec m1 b1 lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H : mem_inj f m1 m2) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta < hi -> False) : mem_inj f m1 m2'.","proofString":"inv H.\nconstructor.\nintros.\neapply perm_drop_3; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b2.\nright.\ndestruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia.\neapply mi_align0; eauto.\nintros.\nreplace (m2'.(mem_contents)#b2) with (m2.(mem_contents)#b2).\napply mi_memval0; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m2 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta < hi -> False) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p0 -> perm m2 b2 (ofs + delta) k p0) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : mem_inj f m1 m2'.","proofString":"constructor.\nintros.\neapply perm_drop_3; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b2.\nright.\ndestruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia.\neapply mi_align0; eauto.\nintros.\nreplace (m2'.(mem_contents)#b2) with (m2.(mem_contents)#b2).\napply mi_memval0; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m2 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta < hi -> False) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p0 -> perm m2 b2 (ofs + delta) k p0) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p0 -> perm m2' b2 (ofs + delta) k p0.","proofString":"intros.\neapply perm_drop_3; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b2.\nright.\ndestruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b3 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs k p0) : perm m2' b2 (ofs + delta) k p0.","proofString":"eapply perm_drop_3; eauto.\ndestruct (eq_block b2 b); auto.\nsubst b2.\nright.\ndestruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b3 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs k p0) : b2 <> b \\/ ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"destruct (eq_block b2 b); auto.\nsubst b2.\nright.\ndestruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b3 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs k p0) (e : b2 = b) : b2 <> b \\/ ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"subst b2.\nright.\ndestruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b2 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs k p0) : b <> b \\/ ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"right.\ndestruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b2 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs k p0) : ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"destruct (zlt (ofs + delta) lo); auto.\ndestruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b2 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs k p0) (g : ofs + delta >= lo) : ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"destruct (zle hi (ofs + delta)); auto.\nbyContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b2 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs k p0) (g : ofs + delta >= lo) (g0 : hi > ofs + delta) : ofs + delta < lo \\/ hi <= ofs + delta.","proofString":"byContradiction.\nexploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b2 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs k p0) (g : ofs + delta >= lo) (g0 : hi > ofs + delta) : False.","proofString":"exploit H1; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k0 p1 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b2 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 k0 p1 -> perm m2 b2 (ofs0 + delta0) k0 p1) (mi_align0 : forall (b0 b2 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p1 : permission),\nf b0 = Some (b2, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p1 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b2)) (b1 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b, delta)) (H2 : perm m1 b1 ofs k p0) (g : ofs + delta >= lo) (g0 : hi > ofs + delta) : lo <= ofs + delta < hi.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta < hi -> False) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p0 -> perm m2 b2 (ofs + delta) k p0) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta).","proofString":"eapply mi_align0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta < hi -> False) (mi_perm0 : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs k p0 -> perm m2 b2 (ofs + delta) k p0) (mi_align0 : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p0 : permission),\nf b1 = Some (b2, delta) ->\nrange_perm m1 b1 ofs (ofs + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2)) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nperm m1 b1 ofs Cur Readable ->\nmemval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b2).","proofString":"intros.\nreplace (m2'.(mem_contents)#b2) with (m2.(mem_contents)#b2).\napply mi_memval0; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m2 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2') # b2).","proofString":"replace (m2'.(mem_contents)#b2) with (m2.(mem_contents)#b2).\napply mi_memval0; auto.\nunfold drop_perm in H0; destruct (range_perm_dec m2 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs Cur Readable) : memval_inject f (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"apply mi_memval0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs' : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' k p0 -> lo <= ofs' + delta0 < hi -> False) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H2 : perm m1 b1 ofs Cur Readable) : (mem_contents m2) # b2 = (mem_contents m2') # b2.","proofString":"unfold drop_perm in H0; destruct (range_perm_dec m2 b lo hi Cur Freeable); inv H0; auto."},{"statement":"(m : mem) : extends m m.","proofString":"constructor.\nauto.\nconstructor.\nintros.\nunfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\nauto.\nintros.\nunfold inject_id in H; inv H.\napply Z.divide_0_r.\nintros.\nunfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\napply memval_lessdef_refl.\ntauto."},{"statement":"(m : mem) : nextblock m = nextblock m.","proofString":"auto."},{"statement":"(m : mem) : mem_inj inject_id m m.","proofString":"constructor.\nintros.\nunfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\nauto.\nintros.\nunfold inject_id in H; inv H.\napply Z.divide_0_r.\nintros.\nunfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\napply memval_lessdef_refl."},{"statement":"(m : mem) : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nperm m b1 ofs k p -> perm m b2 (ofs + delta) k p.","proofString":"intros.\nunfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\nauto."},{"statement":"(m : mem) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : inject_id b1 = Some (b2, delta)) (H0 : perm m b1 ofs k p) : perm m b2 (ofs + delta) k p.","proofString":"unfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\nauto."},{"statement":"(m : mem) (b2 : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m b2 ofs k p) : perm m b2 (ofs + 0) k p.","proofString":"replace (ofs + 0) with ofs by lia.\nauto."},{"statement":"(m : mem) (b2 : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m b2 ofs k p) : perm m b2 ofs k p.","proofString":"auto."},{"statement":"(m : mem) : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nrange_perm m b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"intros.\nunfold inject_id in H; inv H.\napply Z.divide_0_r."},{"statement":"(m : mem) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : inject_id b1 = Some (b2, delta)) (H0 : range_perm m b1 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"unfold inject_id in H; inv H.\napply Z.divide_0_r."},{"statement":"(m : mem) (b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm m b2 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(m : mem) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nperm m b1 ofs Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs (mem_contents m) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m) # b2).","proofString":"intros.\nunfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\napply memval_lessdef_refl."},{"statement":"(m : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : inject_id b1 = Some (b2, delta)) (H0 : perm m b1 ofs Cur Readable) : memval_inject inject_id (ZMap.get ofs (mem_contents m) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m) # b2).","proofString":"unfold inject_id in H; inv H.\nreplace (ofs + 0) with ofs by lia.\napply memval_lessdef_refl."},{"statement":"(m : mem) (ofs : Z) (b2 : block) (H0 : perm m b2 ofs Cur Readable) : memval_inject inject_id (ZMap.get ofs (mem_contents m) # b2)\n  (ZMap.get (ofs + 0) (mem_contents m) # b2).","proofString":"replace (ofs + 0) with ofs by lia.\napply memval_lessdef_refl."},{"statement":"(m : mem) (ofs : Z) (b2 : block) (H0 : perm m b2 ofs Cur Readable) : memval_inject inject_id (ZMap.get ofs (mem_contents m) # b2)\n  (ZMap.get ofs (mem_contents m) # b2).","proofString":"apply memval_lessdef_refl."},{"statement":"(m : mem) : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m b ofs k p -> perm m b ofs k p \\/ ~ perm m b ofs Max Nonempty.","proofString":"tauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (H : extends m1 m2) (H0 : load chunk m1 b ofs = Some v1) : exists v2 : val, load chunk m2 b ofs = Some v2 /\\ Val.lessdef v1 v2.","proofString":"inv H.\nexploit load_inj; eauto.\nunfold inject_id; reflexivity.\nintros [v2 [A B]].\nexists v2; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nrewrite val_inject_id in B.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (H0 : load chunk m1 b ofs = Some v1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists v2 : val, load chunk m2 b ofs = Some v2 /\\ Val.lessdef v1 v2.","proofString":"exploit load_inj; eauto.\nunfold inject_id; reflexivity.\nintros [v2 [A B]].\nexists v2; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nrewrite val_inject_id in B.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (H0 : load chunk m1 b ofs = Some v1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (v2 : val) (A : load chunk m2 b (ofs + 0) = Some v2) (B : Val.inject inject_id v1 v2) : exists v0 : val, load chunk m2 b ofs = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nrewrite val_inject_id in B.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (H0 : load chunk m1 b ofs = Some v1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (v2 : val) (A : load chunk m2 b (ofs + 0) = Some v2) (B : Val.inject inject_id v1 v2) : load chunk m2 b ofs = Some v2.","proofString":"replace (ofs + 0) with ofs in A by lia.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (H0 : load chunk m1 b ofs = Some v1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (v2 : val) (A : load chunk m2 b ofs = Some v2) (B : Val.inject inject_id v1 v2) : load chunk m2 b ofs = Some v2.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (H0 : load chunk m1 b ofs = Some v1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (v2 : val) (A : load chunk m2 b (ofs + 0) = Some v2) (B : Val.inject inject_id v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_id in B.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (H0 : load chunk m1 b ofs = Some v1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (v2 : val) (A : load chunk m2 b (ofs + 0) = Some v2) (B : Val.lessdef v1 v2) : Val.lessdef v1 v2.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (addr1 addr2 v1 : val) (H : extends m1 m2) (H0 : match addr1 with\n| Vptr b ofs => load chunk m1 b (Ptrofs.unsigned ofs)\n| _ => None\nend = Some v1) (H1 : Val.lessdef addr1 addr2) : exists v2 : val,\n  match addr2 with\n  | Vptr b ofs => load chunk m2 b (Ptrofs.unsigned ofs)\n  | _ => None\n  end = Some v2 /\\ Val.lessdef v1 v2.","proofString":"inv H1.\ndestruct addr2; try congruence.\neapply load_extends; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (addr2 v1 : val) (H : extends m1 m2) (H0 : match addr2 with\n| Vptr b ofs => load chunk m1 b (Ptrofs.unsigned ofs)\n| _ => None\nend = Some v1) : exists v2 : val,\n  match addr2 with\n  | Vptr b ofs => load chunk m2 b (Ptrofs.unsigned ofs)\n  | _ => None\n  end = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct addr2; try congruence.\neapply load_extends; eauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (i : ptrofs) (v1 : val) (H : extends m1 m2) (H0 : load chunk m1 b (Ptrofs.unsigned i) = Some v1) : exists v2 : val,\n  load chunk m2 b (Ptrofs.unsigned i) = Some v2 /\\ Val.lessdef v1 v2.","proofString":"eapply load_extends; eauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (addr2 v1 : val) (H : extends m1 m2) (H0 : None = Some v1) : exists v2 : val,\n  match addr2 with\n  | Vptr b ofs => load chunk m2 b (Ptrofs.unsigned ofs)\n  | _ => None\n  end = Some v2 /\\ Val.lessdef v1 v2.","proofString":"congruence."},{"statement":"(m1 m2 : mem) (b : block) (ofs len : Z) (bytes1 : list memval) (H : extends m1 m2) (H0 : loadbytes m1 b ofs len = Some bytes1) : exists bytes2 : list memval,\n  loadbytes m2 b ofs len = Some bytes2 /\\\n  list_forall2 memval_lessdef bytes1 bytes2.","proofString":"inv H.\nreplace ofs with (ofs + 0) by lia.\neapply loadbytes_inj; eauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs len : Z) (bytes1 : list memval) (H0 : loadbytes m1 b ofs len = Some bytes1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists bytes2 : list memval,\n  loadbytes m2 b ofs len = Some bytes2 /\\\n  list_forall2 memval_lessdef bytes1 bytes2.","proofString":"replace ofs with (ofs + 0) by lia.\neapply loadbytes_inj; eauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs len : Z) (bytes1 : list memval) (H0 : loadbytes m1 b ofs len = Some bytes1) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists bytes2 : list memval,\n  loadbytes m2 b (ofs + 0) len = Some bytes2 /\\\n  list_forall2 memval_lessdef bytes1 bytes2.","proofString":"eapply loadbytes_inj; eauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) : exists m2' : mem, store chunk m2 b ofs v2 = Some m2' /\\ extends m1' m2'.","proofString":"inversion H.\nexploit store_mapped_inj; eauto.\nunfold inject_id; red; intros.\ninv H3; inv H4.\nauto.\nunfold inject_id; reflexivity.\nrewrite val_inject_id.\neauto.\nintros [m2' [A B]].\nexists m2'; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nconstructor; auto.\nrewrite (nextblock_store _ _ _ _ _ _ H0).\nrewrite (nextblock_store _ _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_store_1, perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists m2' : mem, store chunk m2 b ofs v2 = Some m2' /\\ extends m1' m2'.","proofString":"exploit store_mapped_inj; eauto.\nunfold inject_id; red; intros.\ninv H3; inv H4.\nauto.\nunfold inject_id; reflexivity.\nrewrite val_inject_id.\neauto.\nintros [m2' [A B]].\nexists m2'; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nconstructor; auto.\nrewrite (nextblock_store _ _ _ _ _ _ H0).\nrewrite (nextblock_store _ _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_store_1, perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : meminj_no_overlap inject_id m1.","proofString":"unfold inject_id; red; intros.\ninv H3; inv H4.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H2 : b1 <> b2) (H3 : Some (b1, 0) = Some (b1', delta1)) (H4 : Some (b2, 0) = Some (b2', delta2)) (H5 : perm m1 b1 ofs1 Max Nonempty) (H6 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"inv H3; inv H4.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1' b2' : block) (ofs1 ofs2 : Z) (H2 : b1' <> b2') (H5 : perm m1 b1' ofs1 Max Nonempty) (H6 : perm m1 b2' ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + 0 <> ofs2 + 0.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') : exists m2'0 : mem, store chunk m2 b ofs v2 = Some m2'0 /\\ extends m1' m2'0.","proofString":"exists m2'; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nconstructor; auto.\nrewrite (nextblock_store _ _ _ _ _ _ H0).\nrewrite (nextblock_store _ _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_store_1, perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') : store chunk m2 b ofs v2 = Some m2'.","proofString":"replace (ofs + 0) with ofs in A by lia.\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b ofs v2 = Some m2') (B : mem_inj inject_id m1' m2') : store chunk m2 b ofs v2 = Some m2'.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') : extends m1' m2'.","proofString":"constructor; auto.\nrewrite (nextblock_store _ _ _ _ _ _ H0).\nrewrite (nextblock_store _ _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_store_1, perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') : nextblock m1' = nextblock m2'.","proofString":"rewrite (nextblock_store _ _ _ _ _ _ H0).\nrewrite (nextblock_store _ _ _ _ _ _ A).\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') : nextblock m1 = nextblock m2'.","proofString":"rewrite (nextblock_store _ _ _ _ _ _ A).\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') : nextblock m1 = nextblock m2.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2' b0 ofs0 k p ->\nperm m1' b0 ofs0 k p \\/ ~ perm m1' b0 ofs0 Max Nonempty.","proofString":"intros.\nexploit mext_perm_inv0; intuition eauto using perm_store_1, perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b ofs v1 = Some m1') (H1 : Val.lessdef v1 v2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs1 k0 p0 ->\nperm m1 b1 ofs1 k0 p0 \\/ ~ perm m1 b1 ofs1 Max Nonempty) (m2' : mem) (A : store chunk m2 b (ofs + 0) v2 = Some m2') (B : mem_inj inject_id m1' m2') (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : perm m2' b0 ofs0 k p) : perm m1' b0 ofs0 k p \\/ ~ perm m1' b0 ofs0 Max Nonempty.","proofString":"exploit mext_perm_inv0; intuition eauto using perm_store_1, perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) : extends m1 m2'.","proofString":"inversion H.\nconstructor.\nrewrite (nextblock_store _ _ _ _ _ _ H0).\nauto.\neapply store_outside_inj; eauto.\nunfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia.\nintros.\neauto using perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : extends m1 m2'.","proofString":"constructor.\nrewrite (nextblock_store _ _ _ _ _ _ H0).\nauto.\neapply store_outside_inj; eauto.\nunfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia.\nintros.\neauto using perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : nextblock m1 = nextblock m2'.","proofString":"rewrite (nextblock_store _ _ _ _ _ _ H0).\nauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : nextblock m1 = nextblock m2.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : mem_inj inject_id m1 m2'.","proofString":"eapply store_outside_inj; eauto.\nunfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b' : block) (delta ofs' : Z),\ninject_id b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False.","proofString":"unfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs'0 : Z,\nperm m1 b ofs'0 Cur Readable ->\nofs <= ofs'0 < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b' : block) (delta ofs' : Z) (H2 : Some (b', 0) = Some (b, delta)) (H3 : perm m1 b' ofs' Cur Readable) (H4 : ofs <= ofs' + delta < ofs + size_chunk chunk) : False.","proofString":"inv H2.\neapply H1; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs'0 : Z,\nperm m1 b ofs'0 Cur Readable ->\nofs <= ofs'0 < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs' : Z) (H3 : perm m1 b ofs' Cur Readable) (H4 : ofs <= ofs' + 0 < ofs + size_chunk chunk) : False.","proofString":"eapply H1; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs'0 : Z,\nperm m1 b ofs'0 Cur Readable ->\nofs <= ofs'0 < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs' : Z) (H3 : perm m1 b ofs' Cur Readable) (H4 : ofs <= ofs' + 0 < ofs + size_chunk chunk) : ofs <= ofs' < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2' b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty.","proofString":"intros.\neauto using perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : extends m1 m2) (H0 : store chunk m2 b ofs v = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs1 k0 p0 ->\nperm m1 b1 ofs1 k0 p0 \\/ ~ perm m1 b1 ofs1 Max Nonempty) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : perm m2' b0 ofs0 k p) : perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty.","proofString":"eauto using perm_store_2."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (addr1 v1 : val) (m1' : mem) (addr2 v2 : val) (H : extends m1 m2) (H0 : match addr1 with\n| Vptr b ofs => store chunk m1 b (Ptrofs.unsigned ofs) v1\n| _ => None\nend = Some m1') (H1 : Val.lessdef addr1 addr2) (H2 : Val.lessdef v1 v2) : exists m2' : mem,\n  match addr2 with\n  | Vptr b ofs => store chunk m2 b (Ptrofs.unsigned ofs) v2\n  | _ => None\n  end = Some m2' /\\ extends m1' m2'.","proofString":"inv H1.\ndestruct addr2; try congruence.\neapply store_within_extends; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (v1 : val) (m1' : mem) (addr2 v2 : val) (H : extends m1 m2) (H0 : match addr2 with\n| Vptr b ofs => store chunk m1 b (Ptrofs.unsigned ofs) v1\n| _ => None\nend = Some m1') (H2 : Val.lessdef v1 v2) : exists m2' : mem,\n  match addr2 with\n  | Vptr b ofs => store chunk m2 b (Ptrofs.unsigned ofs) v2\n  | _ => None\n  end = Some m2' /\\ extends m1' m2'.","proofString":"destruct addr2; try congruence.\neapply store_within_extends; eauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (v1 : val) (m1' : mem) (b : block) (i : ptrofs) (v2 : val) (H : extends m1 m2) (H0 : store chunk m1 b (Ptrofs.unsigned i) v1 = Some m1') (H2 : Val.lessdef v1 v2) : exists m2' : mem,\n  store chunk m2 b (Ptrofs.unsigned i) v2 = Some m2' /\\ extends m1' m2'.","proofString":"eapply store_within_extends; eauto."},{"statement":"(chunk : memory_chunk) (m1 m2 : mem) (v1 : val) (m1' : mem) (addr2 v2 : val) (H : extends m1 m2) (H0 : None = Some m1') (H2 : Val.lessdef v1 v2) : exists m2' : mem,\n  match addr2 with\n  | Vptr b ofs => store chunk m2 b (Ptrofs.unsigned ofs) v2\n  | _ => None\n  end = Some m2' /\\ extends m1' m2'.","proofString":"congruence."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) : exists m2' : mem, storebytes m2 b ofs bytes2 = Some m2' /\\ extends m1' m2'.","proofString":"inversion H.\nexploit storebytes_mapped_inj; eauto.\nunfold inject_id; red; intros.\ninv H3; inv H4.\nauto.\nunfold inject_id; reflexivity.\nintros [m2' [A B]].\nexists m2'; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nconstructor; auto.\nrewrite (nextblock_storebytes _ _ _ _ _ H0).\nrewrite (nextblock_storebytes _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists m2' : mem, storebytes m2 b ofs bytes2 = Some m2' /\\ extends m1' m2'.","proofString":"exploit storebytes_mapped_inj; eauto.\nunfold inject_id; red; intros.\ninv H3; inv H4.\nauto.\nunfold inject_id; reflexivity.\nintros [m2' [A B]].\nexists m2'; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nconstructor; auto.\nrewrite (nextblock_storebytes _ _ _ _ _ H0).\nrewrite (nextblock_storebytes _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : meminj_no_overlap inject_id m1.","proofString":"unfold inject_id; red; intros.\ninv H3; inv H4.\nauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H2 : b1 <> b2) (H3 : Some (b1, 0) = Some (b1', delta1)) (H4 : Some (b2, 0) = Some (b2', delta2)) (H5 : perm m1 b1 ofs1 Max Nonempty) (H6 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"inv H3; inv H4.\nauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1' b2' : block) (ofs1 ofs2 : Z) (H2 : b1' <> b2') (H5 : perm m1 b1' ofs1 Max Nonempty) (H6 : perm m1 b2' ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + 0 <> ofs2 + 0.","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : exists m2'0 : mem, storebytes m2 b ofs bytes2 = Some m2'0 /\\ extends m1' m2'0.","proofString":"exists m2'; split.\nreplace (ofs + 0) with ofs in A by lia.\nauto.\nconstructor; auto.\nrewrite (nextblock_storebytes _ _ _ _ _ H0).\nrewrite (nextblock_storebytes _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : storebytes m2 b ofs bytes2 = Some m2'.","proofString":"replace (ofs + 0) with ofs in A by lia.\nauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b ofs bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : storebytes m2 b ofs bytes2 = Some m2'.","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : extends m1' m2'.","proofString":"constructor; auto.\nrewrite (nextblock_storebytes _ _ _ _ _ H0).\nrewrite (nextblock_storebytes _ _ _ _ _ A).\nauto.\nintros.\nexploit mext_perm_inv0; intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : nextblock m1' = nextblock m2'.","proofString":"rewrite (nextblock_storebytes _ _ _ _ _ H0).\nrewrite (nextblock_storebytes _ _ _ _ _ A).\nauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : nextblock m1 = nextblock m2'.","proofString":"rewrite (nextblock_storebytes _ _ _ _ _ A).\nauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : nextblock m1 = nextblock m2.","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2' b0 ofs0 k p ->\nperm m1' b0 ofs0 k p \\/ ~ perm m1' b0 ofs0 Max Nonempty.","proofString":"intros.\nexploit mext_perm_inv0; intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : extends m1 m2) (H0 : storebytes m1 b ofs bytes1 = Some m1') (H1 : list_forall2 memval_lessdef bytes1 bytes2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs1 k0 p0 ->\nperm m1 b1 ofs1 k0 p0 \\/ ~ perm m1 b1 ofs1 Max Nonempty) (m2' : mem) (A : storebytes m2 b (ofs + 0) bytes2 = Some m2') (B : mem_inj inject_id m1' m2') (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : perm m2' b0 ofs0 k p) : perm m1' b0 ofs0 k p \\/ ~ perm m1' b0 ofs0 Max Nonempty.","proofString":"exploit mext_perm_inv0; intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) : extends m1 m2'.","proofString":"inversion H.\nconstructor.\nrewrite (nextblock_storebytes _ _ _ _ _ H0).\nauto.\neapply storebytes_outside_inj; eauto.\nunfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia.\nintros.\neauto using perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : extends m1 m2'.","proofString":"constructor.\nrewrite (nextblock_storebytes _ _ _ _ _ H0).\nauto.\neapply storebytes_outside_inj; eauto.\nunfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia.\nintros.\neauto using perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : nextblock m1 = nextblock m2'.","proofString":"rewrite (nextblock_storebytes _ _ _ _ _ H0).\nauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : nextblock m1 = nextblock m2.","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : mem_inj inject_id m1 m2'.","proofString":"eapply storebytes_outside_inj; eauto.\nunfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b' : block) (delta ofs' : Z),\ninject_id b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False.","proofString":"unfold inject_id; intros.\ninv H2.\neapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs'0 : Z,\nperm m1 b ofs'0 Cur Readable ->\nofs <= ofs'0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b' : block) (delta ofs' : Z) (H2 : Some (b', 0) = Some (b, delta)) (H3 : perm m1 b' ofs' Cur Readable) (H4 : ofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2)) : False.","proofString":"inv H2.\neapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs'0 : Z,\nperm m1 b ofs'0 Cur Readable ->\nofs <= ofs'0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs' : Z) (H3 : perm m1 b ofs' Cur Readable) (H4 : ofs <= ofs' + 0 < ofs + Z.of_nat (Datatypes.length bytes2)) : False.","proofString":"eapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs'0 : Z,\nperm m1 b ofs'0 Cur Readable ->\nofs <= ofs'0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs' : Z) (H3 : perm m1 b ofs' Cur Readable) (H4 : ofs <= ofs' + 0 < ofs + Z.of_nat (Datatypes.length bytes2)) : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2).","proofString":"lia."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2' b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty.","proofString":"intros.\neauto using perm_storebytes_2."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : extends m1 m2) (H0 : storebytes m2 b ofs bytes2 = Some m2') (H1 : forall ofs' : Z,\nperm m1 b ofs' Cur Readable ->\nofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs1 k0 p0 ->\nperm m1 b1 ofs1 k0 p0 \\/ ~ perm m1 b1 ofs1 Max Nonempty) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : perm m2' b0 ofs0 k p) : perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty.","proofString":"eauto using perm_storebytes_2."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H : extends m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) : exists m2' : mem', alloc m2 lo2 hi2 = (m2', b) /\\ extends m1' m2'.","proofString":"inv H.\ncase_eq (alloc m2 lo2 hi2); intros m2' b' ALLOC.\nassert (b' = b).\nrewrite (alloc_result _ _ _ _ _ H0).\nrewrite (alloc_result _ _ _ _ _ ALLOC).\nauto.\nsubst b'.\nexists m2'; split; auto.\nconstructor.\nrewrite (nextblock_alloc _ _ _ _ _ H0).\nrewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence.\neapply alloc_left_mapped_inj with (m1 := m1) (m2 := m2') (b2 := b) (delta := 0); eauto.\neapply alloc_right_inj; eauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nintros.\neapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : exists m2' : mem', alloc m2 lo2 hi2 = (m2', b) /\\ extends m1' m2'.","proofString":"case_eq (alloc m2 lo2 hi2); intros m2' b' ALLOC.\nassert (b' = b).\nrewrite (alloc_result _ _ _ _ _ H0).\nrewrite (alloc_result _ _ _ _ _ ALLOC).\nauto.\nsubst b'.\nexists m2'; split; auto.\nconstructor.\nrewrite (nextblock_alloc _ _ _ _ _ H0).\nrewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence.\neapply alloc_left_mapped_inj with (m1 := m1) (m2 := m2') (b2 := b) (delta := 0); eauto.\neapply alloc_right_inj; eauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nintros.\neapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (b' : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b')) : exists m2'0 : mem', (m2', b') = (m2'0, b) /\\ extends m1' m2'0.","proofString":"assert (b' = b).\nrewrite (alloc_result _ _ _ _ _ H0).\nrewrite (alloc_result _ _ _ _ _ ALLOC).\nauto.\nsubst b'.\nexists m2'; split; auto.\nconstructor.\nrewrite (nextblock_alloc _ _ _ _ _ H0).\nrewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence.\neapply alloc_left_mapped_inj with (m1 := m1) (m2 := m2') (b2 := b) (delta := 0); eauto.\neapply alloc_right_inj; eauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nintros.\neapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (b' : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b')) : b' = b.","proofString":"rewrite (alloc_result _ _ _ _ _ H0).\nrewrite (alloc_result _ _ _ _ _ ALLOC).\nauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (b' : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b')) : b' = nextblock m1.","proofString":"rewrite (alloc_result _ _ _ _ _ ALLOC).\nauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (b' : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b')) : nextblock m2 = nextblock m1.","proofString":"auto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (b' : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b')) (H : b' = b) : exists m2'0 : mem', (m2', b') = (m2'0, b) /\\ extends m1' m2'0.","proofString":"subst b'.\nexists m2'; split; auto.\nconstructor.\nrewrite (nextblock_alloc _ _ _ _ _ H0).\nrewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence.\neapply alloc_left_mapped_inj with (m1 := m1) (m2 := m2') (b2 := b) (delta := 0); eauto.\neapply alloc_right_inj; eauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nintros.\neapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : exists m2'0 : mem', (m2', b) = (m2'0, b) /\\ extends m1' m2'0.","proofString":"exists m2'; split; auto.\nconstructor.\nrewrite (nextblock_alloc _ _ _ _ _ H0).\nrewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence.\neapply alloc_left_mapped_inj with (m1 := m1) (m2 := m2') (b2 := b) (delta := 0); eauto.\neapply alloc_right_inj; eauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nintros.\neapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : extends m1' m2'.","proofString":"constructor.\nrewrite (nextblock_alloc _ _ _ _ _ H0).\nrewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence.\neapply alloc_left_mapped_inj with (m1 := m1) (m2 := m2') (b2 := b) (delta := 0); eauto.\neapply alloc_right_inj; eauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nintros.\neapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : nextblock m1' = nextblock m2'.","proofString":"rewrite (nextblock_alloc _ _ _ _ _ H0).\nrewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : Pos.succ (nextblock m1) = nextblock m2'.","proofString":"rewrite (nextblock_alloc _ _ _ _ _ ALLOC).\ncongruence."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : Pos.succ (nextblock m1) = Pos.succ (nextblock m2).","proofString":"congruence."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : mem_inj inject_id m1' m2'.","proofString":"eapply alloc_left_mapped_inj with (m1 := m1) (m2 := m2') (b2 := b) (delta := 0); eauto.\neapply alloc_right_inj; eauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : mem_inj inject_id m1 m2'.","proofString":"eapply alloc_right_inj; eauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : valid_block m2' b.","proofString":"eauto with mem."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : inj_offset_aligned 0 (hi1 - lo1).","proofString":"red.\nintros.\napply Z.divide_0_r."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : forall chunk : memory_chunk,\nsize_chunk chunk <= hi1 - lo1 -> (align_chunk chunk | 0).","proofString":"intros.\napply Z.divide_0_r."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (chunk : memory_chunk) (H : size_chunk chunk <= hi1 - lo1) : (align_chunk chunk | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo1 <= ofs < hi1 -> perm m2' b (ofs + 0) k p.","proofString":"intros.\neapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo1 <= ofs < hi1) : perm m2' b (ofs + 0) k p.","proofString":"eapply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo1 <= ofs < hi1) : perm m2' b (ofs + 0) k Freeable.","proofString":"eapply perm_alloc_2; eauto.\nlia."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo1 <= ofs < hi1) : lo2 <= ofs + 0 < hi2.","proofString":"lia."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2' b0 ofs k p -> perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intros.\neapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2' b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"eapply perm_alloc_inv in H; eauto.\ngeneralize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : if eq_block b0 b then lo2 <= ofs < hi2 else perm m2 b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"generalize (perm_alloc_inv _ _ _ _ _ H0 b0 ofs Max Nonempty); intros PERM.\ndestruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : if eq_block b0 b then lo2 <= ofs < hi2 else perm m2 b0 ofs k p) (PERM : perm m1' b0 ofs Max Nonempty ->\nif eq_block b0 b then lo1 <= ofs < hi1 else perm m1 b0 ofs Max Nonempty) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"destruct (eq_block b0 b).\nsubst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto.\nexploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (e : b0 = b) (H : lo2 <= ofs < hi2) (PERM : perm m1' b0 ofs Max Nonempty -> lo1 <= ofs < hi1) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"subst b0.\nassert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo2 <= ofs < hi2) (PERM : perm m1' b ofs Max Nonempty -> lo1 <= ofs < hi1) : perm m1' b ofs k p \\/ ~ perm m1' b ofs Max Nonempty.","proofString":"assert (EITHER: lo1 <= ofs < hi1 \\/ ~(lo1 <= ofs < hi1)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo2 <= ofs < hi2) (PERM : perm m1' b ofs Max Nonempty -> lo1 <= ofs < hi1) (EITHER : lo1 <= ofs < hi1 \\/ ~ lo1 <= ofs < hi1) : perm m1' b ofs k p \\/ ~ perm m1' b ofs Max Nonempty.","proofString":"destruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; tauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo2 <= ofs < hi2) (PERM : perm m1' b ofs Max Nonempty -> lo1 <= ofs < hi1) (H3 : lo1 <= ofs < hi1) : perm m1' b ofs k p \\/ ~ perm m1' b ofs Max Nonempty.","proofString":"left.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo2 <= ofs < hi2) (PERM : perm m1' b ofs Max Nonempty -> lo1 <= ofs < hi1) (H3 : lo1 <= ofs < hi1) : perm m1' b ofs k p.","proofString":"apply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo2 <= ofs < hi2) (PERM : perm m1' b ofs Max Nonempty -> lo1 <= ofs < hi1) (H3 : lo1 <= ofs < hi1) : perm m1' b ofs k Freeable.","proofString":"eapply perm_alloc_2; eauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (ofs : Z) (k : perm_kind) (p : permission) (H : lo2 <= ofs < hi2) (PERM : perm m1' b ofs Max Nonempty -> lo1 <= ofs < hi1) (H3 : ~ lo1 <= ofs < hi1) : perm m1' b ofs k p \\/ ~ perm m1' b ofs Max Nonempty.","proofString":"right; tauto."},{"statement":"(m1 m2 : mem) (lo1 hi1 : Z) (b : block) (m1' : mem') (lo2 hi2 : Z) (H0 : alloc m1 lo1 hi1 = (m1', b)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem') (ALLOC : alloc m2 lo2 hi2 = (m2', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (n : b0 <> b) (H : perm m2 b0 ofs k p) (PERM : perm m1' b0 ofs Max Nonempty -> perm m1 b0 ofs Max Nonempty) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"exploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') : extends m1' m2.","proofString":"inv H.\nconstructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nauto.\neapply free_left_inj; eauto.\nintros.\nexploit mext_perm_inv0; eauto.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nintuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : extends m1' m2.","proofString":"constructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nauto.\neapply free_left_inj; eauto.\nintros.\nexploit mext_perm_inv0; eauto.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nintuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : nextblock m1' = nextblock m2.","proofString":"rewrite (nextblock_free _ _ _ _ _ H0).\nauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : nextblock m1 = nextblock m2.","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : mem_inj inject_id m1' m2.","proofString":"eapply free_left_inj; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intros.\nexploit mext_perm_inv0; eauto.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nintuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"exploit mext_perm_inv0; eauto.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nintuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b0 ofs k p) : perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty ->\nperm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nintuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b0 ofs k p) (A : perm m1 b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"eapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b0 ofs k p) (A : b0 = b /\\ lo <= ofs < hi \\/ perm m1' b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"destruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b0 ofs k p) (A : b0 = b) (B : lo <= ofs < hi) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"subst b0.\nright; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b ofs k p) (B : lo <= ofs < hi) : perm m1' b ofs k p \\/ ~ perm m1' b ofs Max Nonempty.","proofString":"right; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2 b0 ofs k p) (A : ~ perm m1 b0 ofs Max Nonempty) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : extends m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m1 b ofs k p -> lo <= ofs < hi -> False) : extends m1 m2'.","proofString":"inv H.\nconstructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nauto.\neapply free_right_inj; eauto.\nunfold inject_id; intros.\ninv H.\neapply H1; eauto.\nlia.\nintros.\neauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m1 b ofs k p -> lo <= ofs < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : extends m1 m2'.","proofString":"constructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nauto.\neapply free_right_inj; eauto.\nunfold inject_id; intros.\ninv H.\neapply H1; eauto.\nlia.\nintros.\neauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m1 b ofs k p -> lo <= ofs < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : nextblock m1 = nextblock m2'.","proofString":"rewrite (nextblock_free _ _ _ _ _ H0).\nauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m1 b ofs k p -> lo <= ofs < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : nextblock m1 = nextblock m2.","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m1 b ofs k p -> lo <= ofs < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : mem_inj inject_id m1 m2'.","proofString":"eapply free_right_inj; eauto.\nunfold inject_id; intros.\ninv H.\neapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m1 b ofs k p -> lo <= ofs < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\ninject_id b' = Some (b, delta) ->\nperm m1 b' ofs k p -> lo <= ofs + delta < hi -> False.","proofString":"unfold inject_id; intros.\ninv H.\neapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m1 b ofs0 k0 p0 -> lo <= ofs0 < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : Some (b', 0) = Some (b, delta)) (H2 : perm m1 b' ofs k p) (H3 : lo <= ofs + delta < hi) : False.","proofString":"inv H.\neapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m1 b ofs0 k0 p0 -> lo <= ofs0 < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs : Z) (k : perm_kind) (p : permission) (H2 : perm m1 b ofs k p) (H3 : lo <= ofs + 0 < hi) : False.","proofString":"eapply H1; eauto.\nlia."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m1 b ofs0 k0 p0 -> lo <= ofs0 < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs : Z) (k : perm_kind) (p : permission) (H2 : perm m1 b ofs k p) (H3 : lo <= ofs + 0 < hi) : lo <= ofs < hi.","proofString":"lia."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m1 b ofs k p -> lo <= ofs < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2' b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty.","proofString":"intros.\neauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H0 : free m2 b lo hi = Some m2') (H1 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m1 b ofs0 k0 p0 -> lo <= ofs0 < hi -> False) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H : perm m2' b0 ofs k p) : perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty.","proofString":"eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') : exists m2' : mem, free m2 b lo hi = Some m2' /\\ extends m1' m2'.","proofString":"inversion H.\nassert ({ m2': mem | free m2 b lo hi = Some m2' }).\napply range_perm_free.\nred; intros.\nreplace ofs with (ofs + 0) by lia.\neapply perm_inj with (b1 := b); eauto.\neapply free_range_perm; eauto.\ndestruct X as [m2' FREE].\nexists m2'; split; auto.\nconstructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nrewrite (nextblock_free _ _ _ _ _ FREE).\nauto.\neapply free_right_inj with (m1 := m1'); eauto.\neapply free_left_inj; eauto.\nunfold inject_id; intros.\ninv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto.\nintros.\nexploit mext_perm_inv0; eauto using perm_free_3.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : exists m2' : mem, free m2 b lo hi = Some m2' /\\ extends m1' m2'.","proofString":"assert ({ m2': mem | free m2 b lo hi = Some m2' }).\napply range_perm_free.\nred; intros.\nreplace ofs with (ofs + 0) by lia.\neapply perm_inj with (b1 := b); eauto.\neapply free_range_perm; eauto.\ndestruct X as [m2' FREE].\nexists m2'; split; auto.\nconstructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nrewrite (nextblock_free _ _ _ _ _ FREE).\nauto.\neapply free_right_inj with (m1 := m1'); eauto.\neapply free_left_inj; eauto.\nunfold inject_id; intros.\ninv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto.\nintros.\nexploit mext_perm_inv0; eauto using perm_free_3.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : {m2' : mem | free m2 b lo hi = Some m2'}.","proofString":"apply range_perm_free.\nred; intros.\nreplace ofs with (ofs + 0) by lia.\neapply perm_inj with (b1 := b); eauto.\neapply free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : range_perm m2 b lo hi Cur Freeable.","proofString":"red; intros.\nreplace ofs with (ofs + 0) by lia.\neapply perm_inj with (b1 := b); eauto.\neapply free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs : Z) (H1 : lo <= ofs < hi) : perm m2 b ofs Cur Freeable.","proofString":"replace ofs with (ofs + 0) by lia.\neapply perm_inj with (b1 := b); eauto.\neapply free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs : Z) (H1 : lo <= ofs < hi) : perm m2 b (ofs + 0) Cur Freeable.","proofString":"eapply perm_inj with (b1 := b); eauto.\neapply free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (ofs : Z) (H1 : lo <= ofs < hi) : perm m1 b ofs Cur Freeable.","proofString":"eapply free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (X : {m2' : mem | free m2 b lo hi = Some m2'}) : exists m2' : mem, free m2 b lo hi = Some m2' /\\ extends m1' m2'.","proofString":"destruct X as [m2' FREE].\nexists m2'; split; auto.\nconstructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nrewrite (nextblock_free _ _ _ _ _ FREE).\nauto.\neapply free_right_inj with (m1 := m1'); eauto.\neapply free_left_inj; eauto.\nunfold inject_id; intros.\ninv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto.\nintros.\nexploit mext_perm_inv0; eauto using perm_free_3.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : exists m2'0 : mem, free m2 b lo hi = Some m2'0 /\\ extends m1' m2'0.","proofString":"exists m2'; split; auto.\nconstructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nrewrite (nextblock_free _ _ _ _ _ FREE).\nauto.\neapply free_right_inj with (m1 := m1'); eauto.\neapply free_left_inj; eauto.\nunfold inject_id; intros.\ninv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto.\nintros.\nexploit mext_perm_inv0; eauto using perm_free_3.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : extends m1' m2'.","proofString":"constructor.\nrewrite (nextblock_free _ _ _ _ _ H0).\nrewrite (nextblock_free _ _ _ _ _ FREE).\nauto.\neapply free_right_inj with (m1 := m1'); eauto.\neapply free_left_inj; eauto.\nunfold inject_id; intros.\ninv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto.\nintros.\nexploit mext_perm_inv0; eauto using perm_free_3.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : nextblock m1' = nextblock m2'.","proofString":"rewrite (nextblock_free _ _ _ _ _ H0).\nrewrite (nextblock_free _ _ _ _ _ FREE).\nauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : nextblock m1 = nextblock m2'.","proofString":"rewrite (nextblock_free _ _ _ _ _ FREE).\nauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : nextblock m1 = nextblock m2.","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : mem_inj inject_id m1' m2'.","proofString":"eapply free_right_inj with (m1 := m1'); eauto.\neapply free_left_inj; eauto.\nunfold inject_id; intros.\ninv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : mem_inj inject_id m1' m2.","proofString":"eapply free_left_inj; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission),\ninject_id b' = Some (b, delta) ->\nperm m1' b' ofs k p -> lo <= ofs + delta < hi -> False.","proofString":"unfold inject_id; intros.\ninv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (b' : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H1 : Some (b', 0) = Some (b, delta)) (H2 : perm m1' b' ofs k p) (H3 : lo <= ofs + delta < hi) : False.","proofString":"inv H1.\neapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (ofs : Z) (k : perm_kind) (p : permission) (H2 : perm m1' b ofs k p) (H3 : lo <= ofs + 0 < hi) : False.","proofString":"eapply perm_free_2.\neexact H0.\ninstantiate (1 := ofs); lia.\neauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2' b0 ofs k p -> perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intros.\nexploit mext_perm_inv0; eauto using perm_free_3.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : perm m2' b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"exploit mext_perm_inv0; eauto using perm_free_3.\nintros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : perm m2' b0 ofs k p) : perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty ->\nperm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intros [A|A].\neapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto.\nright; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : perm m2' b0 ofs k p) (A : perm m1 b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"eapply perm_free_inv in A; eauto.\ndestruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : perm m2' b0 ofs k p) (A : b0 = b /\\ lo <= ofs < hi \\/ perm m1' b0 ofs k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"destruct A as [[A B]|A]; auto.\nsubst b0.\nright; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : perm m2' b0 ofs k p) (A : b0 = b) (B : lo <= ofs < hi) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"subst b0.\nright; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (ofs : Z) (k : perm_kind) (p : permission) (H1 : perm m2' b ofs k p) (B : lo <= ofs < hi) : perm m1' b ofs k p \\/ ~ perm m1' b ofs Max Nonempty.","proofString":"right; eapply perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : extends m1 m2) (H0 : free m1 b lo hi = Some m1') (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b1 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b1 ofs0 k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ ~ perm m1 b1 ofs0 Max Nonempty) (m2' : mem) (FREE : free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : perm m2' b0 ofs k p) (A : ~ perm m1 b0 ofs Max Nonempty) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"right; intuition eauto using perm_free_3."},{"statement":"(m1 m2 : mem) (b : block) (H : extends m1 m2) : valid_block m1 b <-> valid_block m2 b.","proofString":"inv H.\nunfold valid_block.\nrewrite mext_next0.\ntauto."},{"statement":"(m1 m2 : mem) (b : block) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : valid_block m1 b <-> valid_block m2 b.","proofString":"unfold valid_block.\nrewrite mext_next0.\ntauto."},{"statement":"(m1 m2 : mem) (b : block) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : Plt b (nextblock m1) <-> Plt b (nextblock m2).","proofString":"rewrite mext_next0.\ntauto."},{"statement":"(m1 m2 : mem) (b : block) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : Plt b (nextblock m2) <-> Plt b (nextblock m2).","proofString":"tauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : extends m1 m2) (H0 : perm m1 b ofs k p) : perm m2 b ofs k p.","proofString":"inv H.\nreplace ofs with (ofs + 0) by lia.\neapply perm_inj; eauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m1 b ofs k p) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) : perm m2 b ofs k p.","proofString":"replace ofs with (ofs + 0) by lia.\neapply perm_inj; eauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m1 b ofs k p) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) : perm m2 b (ofs + 0) k p.","proofString":"eapply perm_inj; eauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : extends m1 m2) (H0 : perm m2 b ofs k p) : perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty.","proofString":"inv H; eauto."},{"statement":"(m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : extends m1 m2) (H0 : valid_access m1 chunk b ofs p) : valid_access m2 chunk b ofs p.","proofString":"inv H.\nreplace ofs with (ofs + 0) by lia.\neapply valid_access_inj; eauto.\nauto."},{"statement":"(m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : valid_access m1 chunk b ofs p) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k p0 ->\nperm m1 b0 ofs0 k p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) : valid_access m2 chunk b ofs p.","proofString":"replace ofs with (ofs + 0) by lia.\neapply valid_access_inj; eauto.\nauto."},{"statement":"(m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : valid_access m1 chunk b ofs p) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k p0 ->\nperm m1 b0 ofs0 k p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) : valid_access m2 chunk b (ofs + 0) p.","proofString":"eapply valid_access_inj; eauto.\nauto."},{"statement":"(m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H0 : valid_access m1 chunk b ofs p) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k p0 ->\nperm m1 b0 ofs0 k p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) : inject_id b = Some (b, 0).","proofString":"auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (H : extends m1 m2) (H0 : valid_pointer m1 b ofs = true) : valid_pointer m2 b ofs = true.","proofString":"rewrite valid_pointer_valid_access in *.\neapply valid_access_extends; eauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (H : extends m1 m2) (H0 : valid_access m1 Mint8unsigned b ofs Nonempty) : valid_access m2 Mint8unsigned b ofs Nonempty.","proofString":"eapply valid_access_extends; eauto."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (H : extends m1 m2) : weak_valid_pointer m1 b ofs = true -> weak_valid_pointer m2 b ofs = true.","proofString":"unfold weak_valid_pointer.\nrewrite !orb_true_iff.\nintros []; eauto using valid_pointer_extends."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (H : extends m1 m2) : valid_pointer m1 b ofs || valid_pointer m1 b (ofs - 1) = true ->\nvalid_pointer m2 b ofs || valid_pointer m2 b (ofs - 1) = true.","proofString":"rewrite !orb_true_iff.\nintros []; eauto using valid_pointer_extends."},{"statement":"(m1 m2 : mem) (b : block) (ofs : Z) (H : extends m1 m2) : valid_pointer m1 b ofs = true \\/ valid_pointer m1 b (ofs - 1) = true ->\nvalid_pointer m2 b ofs = true \\/ valid_pointer m2 b (ofs - 1) = true.","proofString":"intros []; eauto using valid_pointer_extends."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) : valid_block m1 b1.","proofString":"inv H.\ndestruct (plt b1 (nextblock m1)).\nauto.\nassert (f b1 = None).\neapply mi_freeblocks; eauto.\ncongruence."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H0 : inject f m1 m2) (H2 : f b1 = Some (b2, delta)) : valid_block m1 b1.","proofString":"destruct (plt b1 (nextblock m1)).\nauto.\nassert (f b1 = None).\neapply mi_freeblocks; eauto.\ncongruence."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H0 : inject f m1 m2) (H2 : f b1 = Some (b2, delta)) (p : Plt b1 (nextblock m1)) : valid_block m1 b1.","proofString":"auto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H0 : inject f m1 m2) (H2 : f b1 = Some (b2, delta)) (n : ~ Plt b1 (nextblock m1)) : valid_block m1 b1.","proofString":"assert (f b1 = None).\neapply mi_freeblocks; eauto.\ncongruence."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H0 : inject f m1 m2) (H2 : f b1 = Some (b2, delta)) (n : ~ Plt b1 (nextblock m1)) : f b1 = None.","proofString":"eapply mi_freeblocks; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H0 : inject f m1 m2) (H2 : f b1 = Some (b2, delta)) (n : ~ Plt b1 (nextblock m1)) (H : f b1 = None) : valid_block m1 b1.","proofString":"congruence."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) : valid_block m2 b2.","proofString":"eapply mi_mappedblocks; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) (H1 : perm m1 b1 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"inv H0.\neapply perm_inj; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H1 : perm m1 b1 ofs k p) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) : perm m2 b2 (ofs + delta) k p.","proofString":"eapply perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H : inject f m1 m2) (H0 : f b1 = Some (b2, delta)) (H1 : perm m2 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eapply mi_perm_inv; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) (H1 : range_perm m1 b1 lo hi k p) : range_perm m2 b2 (lo + delta) (hi + delta) k p.","proofString":"inv H0.\neapply range_perm_inj; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 b2 : block) (delta lo hi : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H1 : range_perm m1 b1 lo hi k p) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k0 p0 ->\nperm m1 b0 ofs k0 p0 \\/ ~ perm m1 b0 ofs Max Nonempty) : range_perm m2 b2 (lo + delta) (hi + delta) k p.","proofString":"eapply range_perm_inj; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (p : permission) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) (H1 : valid_access m1 chunk b1 ofs p) : valid_access m2 chunk b2 (ofs + delta) p.","proofString":"eapply valid_access_inj; eauto.\napply mi_inj; auto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (p : permission) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) (H1 : valid_access m1 chunk b1 ofs p) : mem_inj f m1 m2.","proofString":"apply mi_inj; auto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) (H1 : valid_pointer m1 b1 ofs = true) : valid_pointer m2 b2 (ofs + delta) = true.","proofString":"rewrite valid_pointer_valid_access in H1.\nrewrite valid_pointer_valid_access.\neapply valid_access_inject; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) (H1 : valid_access m1 Mint8unsigned b1 ofs Nonempty) : valid_pointer m2 b2 (ofs + delta) = true.","proofString":"rewrite valid_pointer_valid_access.\neapply valid_access_inject; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) (H1 : valid_access m1 Mint8unsigned b1 ofs Nonempty) : valid_access m2 Mint8unsigned b2 (ofs + delta) Nonempty.","proofString":"eapply valid_access_inject; eauto."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) : weak_valid_pointer m1 b1 ofs = true ->\nweak_valid_pointer m2 b2 (ofs + delta) = true.","proofString":"unfold weak_valid_pointer.\nrewrite !orb_true_iff.\nreplace (ofs + delta - 1) with ((ofs - 1) + delta) by lia.\nintros []; eauto using valid_pointer_inject."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) : valid_pointer m1 b1 ofs || valid_pointer m1 b1 (ofs - 1) = true ->\nvalid_pointer m2 b2 (ofs + delta) || valid_pointer m2 b2 (ofs + delta - 1) =\ntrue.","proofString":"rewrite !orb_true_iff.\nreplace (ofs + delta - 1) with ((ofs - 1) + delta) by lia.\nintros []; eauto using valid_pointer_inject."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) : valid_pointer m1 b1 ofs = true \\/ valid_pointer m1 b1 (ofs - 1) = true ->\nvalid_pointer m2 b2 (ofs + delta) = true \\/\nvalid_pointer m2 b2 (ofs + delta - 1) = true.","proofString":"replace (ofs + delta - 1) with ((ofs - 1) + delta) by lia.\nintros []; eauto using valid_pointer_inject."},{"statement":"(f : block -> option (block * Z)) (m1 m2 : mem) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H0 : inject f m1 m2) : valid_pointer m1 b1 ofs = true \\/ valid_pointer m1 b1 (ofs - 1) = true ->\nvalid_pointer m2 b2 (ofs + delta) = true \\/\nvalid_pointer m2 b2 (ofs - 1 + delta) = true.","proofString":"intros []; eauto using valid_pointer_inject."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"assert (perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty       \\/ perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty)  by (destruct H0; eauto with mem).\nexploit mi_representable; eauto.\nintros [A B].\nassert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"exploit mi_representable; eauto.\nintros [A B].\nassert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned ->\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"intros [A B].\nassert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"assert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) : 0 <= delta <= Ptrofs.max_unsigned.","proofString":"generalize (Ptrofs.unsigned_range ofs1).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) : 0 <= Ptrofs.unsigned ofs1 < Ptrofs.modulus ->\n0 <= delta <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) (H3 : 0 <= delta <= Ptrofs.max_unsigned) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"unfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1) Cur p \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) (H3 : 0 <= delta <= Ptrofs.max_unsigned) : Ptrofs.unsigned\n  (Ptrofs.repr (Ptrofs.unsigned ofs1 + Ptrofs.unsigned (Ptrofs.repr delta))) =\nPtrofs.unsigned ofs1 + delta.","proofString":"repeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"assert (perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) by eauto with mem.\nexploit mi_representable; eauto.\nintros [A B].\nassert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"exploit mi_representable; eauto.\nintros [A B].\nassert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned ->\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"intros [A B].\nassert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"assert (0 <= delta <= Ptrofs.max_unsigned).\ngeneralize (Ptrofs.unsigned_range ofs1).\nlia.\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) : 0 <= delta <= Ptrofs.max_unsigned.","proofString":"generalize (Ptrofs.unsigned_range ofs1).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) : 0 <= Ptrofs.unsigned ofs1 < Ptrofs.modulus ->\n0 <= delta <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) (H3 : 0 <= delta <= Ptrofs.max_unsigned) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"unfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (p : permission) (H : inject f m1 m2) (H0 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Cur p) (H1 : f b1 = Some (b2, delta)) (H2 : perm m1 b1 (Ptrofs.unsigned ofs1 - 1) Max Nonempty) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs1 + delta <= Ptrofs.max_unsigned) (H3 : 0 <= delta <= Ptrofs.max_unsigned) : Ptrofs.unsigned\n  (Ptrofs.repr (Ptrofs.unsigned ofs1 + Ptrofs.unsigned (Ptrofs.repr delta))) =\nPtrofs.unsigned ofs1 + delta.","proofString":"repeat rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Nonempty) (H1 : f b1 = Some (b2, delta)) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"destruct H0.\neapply address_inject; eauto.\napply H0.\ngeneralize (size_chunk_pos chunk).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk) Cur Nonempty) (H2 : (align_chunk chunk | Ptrofs.unsigned ofs1)) (H1 : f b1 = Some (b2, delta)) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"eapply address_inject; eauto.\napply H0.\ngeneralize (size_chunk_pos chunk).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk) Cur Nonempty) (H2 : (align_chunk chunk | Ptrofs.unsigned ofs1)) (H1 : f b1 = Some (b2, delta)) : Ptrofs.unsigned ofs1 <= Ptrofs.unsigned ofs1 <\nPtrofs.unsigned ofs1 + size_chunk chunk.","proofString":"generalize (size_chunk_pos chunk).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk) Cur Nonempty) (H2 : (align_chunk chunk | Ptrofs.unsigned ofs1)) (H1 : f b1 = Some (b2, delta)) : size_chunk chunk > 0 ->\nPtrofs.unsigned ofs1 <= Ptrofs.unsigned ofs1 <\nPtrofs.unsigned ofs1 + size_chunk chunk.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (H1 : f b = Some (b', delta)) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"rewrite weak_valid_pointer_spec in H0.\nrewrite ! valid_pointer_nonempty_perm in H0.\nexploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nrewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : valid_pointer m1 b (Ptrofs.unsigned ofs) = true \\/\nvalid_pointer m1 b (Ptrofs.unsigned ofs - 1) = true) (H1 : f b = Some (b', delta)) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"rewrite ! valid_pointer_nonempty_perm in H0.\nexploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nrewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Cur Nonempty) (H1 : f b = Some (b', delta)) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"exploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nrewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Cur Nonempty) (H1 : f b = Some (b', delta)) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"pose proof (Ptrofs.unsigned_range ofs).\nrewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Cur Nonempty) (H1 : f b = Some (b', delta)) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (H2 : 0 <= Ptrofs.unsigned ofs < Ptrofs.modulus) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"rewrite Ptrofs.unsigned_repr; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (H : inject f m1 m2) (H0 : valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (H1 : Val.inject f (Vptr b ofs) (Vptr b' ofs')) : valid_pointer m2 b' (Ptrofs.unsigned ofs') = true.","proofString":"inv H1.\nerewrite address_inject'; eauto.\neapply valid_pointer_inject; eauto.\nrewrite valid_pointer_valid_access in H0.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (delta : Z) (H5 : f b = Some (b', delta)) : valid_pointer m2 b' (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) =\ntrue.","proofString":"erewrite address_inject'; eauto.\neapply valid_pointer_inject; eauto.\nrewrite valid_pointer_valid_access in H0.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (delta : Z) (H5 : f b = Some (b', delta)) : valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true.","proofString":"eapply valid_pointer_inject; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (H : inject f m1 m2) (H0 : weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (H1 : Val.inject f (Vptr b ofs) (Vptr b' ofs')) : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs') = true.","proofString":"inv H1.\nexploit weak_valid_pointer_inject; eauto.\nintros W.\nrewrite weak_valid_pointer_spec in H0.\nrewrite ! valid_pointer_nonempty_perm in H0.\nexploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (delta : Z) (H5 : f b = Some (b', delta)) : weak_valid_pointer m2 b'\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"exploit weak_valid_pointer_inject; eauto.\nintros W.\nrewrite weak_valid_pointer_spec in H0.\nrewrite ! valid_pointer_nonempty_perm in H0.\nexploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (delta : Z) (H5 : f b = Some (b', delta)) : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true ->\nweak_valid_pointer m2 b'\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros W.\nrewrite weak_valid_pointer_spec in H0.\nrewrite ! valid_pointer_nonempty_perm in H0.\nexploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true) (delta : Z) (H5 : f b = Some (b', delta)) (W : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true) : weak_valid_pointer m2 b'\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"rewrite weak_valid_pointer_spec in H0.\nrewrite ! valid_pointer_nonempty_perm in H0.\nexploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : valid_pointer m1 b (Ptrofs.unsigned ofs) = true \\/\nvalid_pointer m1 b (Ptrofs.unsigned ofs - 1) = true) (delta : Z) (H5 : f b = Some (b', delta)) (W : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true) : weak_valid_pointer m2 b'\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"rewrite ! valid_pointer_nonempty_perm in H0.\nexploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Cur Nonempty) (delta : Z) (H5 : f b = Some (b', delta)) (W : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true) : weak_valid_pointer m2 b'\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"exploit mi_representable; eauto.\ndestruct H0; eauto with mem.\nintros [A B].\npose proof (Ptrofs.unsigned_range ofs).\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Cur Nonempty) (delta : Z) (H5 : f b = Some (b', delta)) (W : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) : weak_valid_pointer m2 b'\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"pose proof (Ptrofs.unsigned_range ofs).\nunfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Cur Nonempty) (delta : Z) (H5 : f b = Some (b', delta)) (W : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (H1 : 0 <= Ptrofs.unsigned ofs < Ptrofs.modulus) : weak_valid_pointer m2 b'\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"unfold Ptrofs.add.\nrepeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : ptrofs) (b' : block) (H : inject f m1 m2) (H0 : perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Cur Nonempty) (delta : Z) (H5 : f b = Some (b', delta)) (W : weak_valid_pointer m2 b' (Ptrofs.unsigned ofs + delta) = true) (A : delta >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (H1 : 0 <= Ptrofs.unsigned ofs < Ptrofs.modulus) : weak_valid_pointer m2 b'\n  (Ptrofs.unsigned\n     (Ptrofs.repr (Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta)))) =\ntrue.","proofString":"repeat rewrite Ptrofs.unsigned_repr; auto; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 b1' b2' : block) (delta1 delta2 ofs1 ofs2 : Z) (H : inject f m1 m2) (H0 : b1 <> b2) (H1 : f b1 = Some (b1', delta1)) (H2 : f b2 = Some (b2', delta2)) (H3 : perm m1 b1 ofs1 Max Nonempty) (H4 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"inv H.\neapply mi_no_overlap0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 b2 b1' b2' : block) (delta1 delta2 ofs1 ofs2 : Z) (H0 : b1 <> b2) (H1 : f b1 = Some (b1', delta1)) (H2 : f b2 = Some (b2', delta2)) (H3 : perm m1 b1 ofs1 Max Nonempty) (H4 : perm m1 b2 ofs2 Max Nonempty) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eapply mi_no_overlap0; eauto."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H1 : valid_pointer m b1 (Ptrofs.unsigned ofs1) = true) (H2 : valid_pointer m b2 (Ptrofs.unsigned ofs2) = true) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"rewrite valid_pointer_valid_access in H1.\nrewrite valid_pointer_valid_access in H2.\nrewrite (address_inject' _ _ _ _ _ _ _ _ H H1 H3).\nrewrite (address_inject' _ _ _ _ _ _ _ _ H H2 H4).\ninv H1.\nsimpl in H5.\ninv H2.\nsimpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H1 : valid_access m Mint8unsigned b1 (Ptrofs.unsigned ofs1) Nonempty) (H2 : valid_pointer m b2 (Ptrofs.unsigned ofs2) = true) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"rewrite valid_pointer_valid_access in H2.\nrewrite (address_inject' _ _ _ _ _ _ _ _ H H1 H3).\nrewrite (address_inject' _ _ _ _ _ _ _ _ H H2 H4).\ninv H1.\nsimpl in H5.\ninv H2.\nsimpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H1 : valid_access m Mint8unsigned b1 (Ptrofs.unsigned ofs1) Nonempty) (H2 : valid_access m Mint8unsigned b2 (Ptrofs.unsigned ofs2) Nonempty) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"rewrite (address_inject' _ _ _ _ _ _ _ _ H H1 H3).\nrewrite (address_inject' _ _ _ _ _ _ _ _ H H2 H4).\ninv H1.\nsimpl in H5.\ninv H2.\nsimpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H1 : valid_access m Mint8unsigned b1 (Ptrofs.unsigned ofs1) Nonempty) (H2 : valid_access m Mint8unsigned b2 (Ptrofs.unsigned ofs2) Nonempty) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned ofs1 + delta1 <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"rewrite (address_inject' _ _ _ _ _ _ _ _ H H2 H4).\ninv H1.\nsimpl in H5.\ninv H2.\nsimpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H1 : valid_access m Mint8unsigned b1 (Ptrofs.unsigned ofs1) Nonempty) (H2 : valid_access m Mint8unsigned b2 (Ptrofs.unsigned ofs2) Nonempty) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) : b1' <> b2' \\/ Ptrofs.unsigned ofs1 + delta1 <> Ptrofs.unsigned ofs2 + delta2.","proofString":"inv H1.\nsimpl in H5.\ninv H2.\nsimpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H2 : valid_access m Mint8unsigned b2 (Ptrofs.unsigned ofs2) Nonempty) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk Mint8unsigned) Cur Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) : b1' <> b2' \\/ Ptrofs.unsigned ofs1 + delta1 <> Ptrofs.unsigned ofs2 + delta2.","proofString":"simpl in H5.\ninv H2.\nsimpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H2 : valid_access m Mint8unsigned b2 (Ptrofs.unsigned ofs2) Nonempty) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) : b1' <> b2' \\/ Ptrofs.unsigned ofs1 + delta1 <> Ptrofs.unsigned ofs2 + delta2.","proofString":"inv H2.\nsimpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2)\n  (Ptrofs.unsigned ofs2 + size_chunk Mint8unsigned) Cur Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : b1' <> b2' \\/ Ptrofs.unsigned ofs1 + delta1 <> Ptrofs.unsigned ofs2 + delta2.","proofString":"simpl in H1.\neapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2) (Ptrofs.unsigned ofs2 + 1) Cur\n  Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : b1' <> b2' \\/ Ptrofs.unsigned ofs1 + delta1 <> Ptrofs.unsigned ofs2 + delta2.","proofString":"eapply mi_no_overlap; eauto.\napply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia.\napply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2) (Ptrofs.unsigned ofs2 + 1) Cur\n  Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : perm m b1 (Ptrofs.unsigned ofs1) Max Nonempty.","proofString":"apply perm_cur_max.\napply (H5 (Ptrofs.unsigned ofs1)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2) (Ptrofs.unsigned ofs2 + 1) Cur\n  Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : perm m b1 (Ptrofs.unsigned ofs1) Cur Nonempty.","proofString":"apply (H5 (Ptrofs.unsigned ofs1)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2) (Ptrofs.unsigned ofs2 + 1) Cur\n  Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : Ptrofs.unsigned ofs1 <= Ptrofs.unsigned ofs1 < Ptrofs.unsigned ofs1 + 1.","proofString":"lia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2) (Ptrofs.unsigned ofs2 + 1) Cur\n  Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : perm m b2 (Ptrofs.unsigned ofs2) Max Nonempty.","proofString":"apply perm_cur_max.\napply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2) (Ptrofs.unsigned ofs2 + 1) Cur\n  Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : perm m b2 (Ptrofs.unsigned ofs2) Cur Nonempty.","proofString":"apply (H1 (Ptrofs.unsigned ofs2)).\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : inject f m m') (H0 : b1 <> b2) (H3 : f b1 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : range_perm m b1 (Ptrofs.unsigned ofs1) (Ptrofs.unsigned ofs1 + 1) Cur\n  Nonempty) (H6 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs1)) (H1 : range_perm m b2 (Ptrofs.unsigned ofs2) (Ptrofs.unsigned ofs2 + 1) Cur\n  Nonempty) (H7 : (align_chunk Mint8unsigned | Ptrofs.unsigned ofs2)) : Ptrofs.unsigned ofs2 <= Ptrofs.unsigned ofs2 < Ptrofs.unsigned ofs2 + 1.","proofString":"lia."},{"statement":"(f : meminj) (m m' : mem) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b1', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) : b1' <> b2' \\/\nofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"destruct (eq_block b1 b2).\nassert (b1' = b2') by congruence.\nassert (delta1 = delta2) by congruence.\nsubst.\ndestruct H5.\ncongruence.\nright.\ndestruct H5.\nleft; congruence.\nright.\nlia.\ndestruct (eq_block b1' b2'); auto.\nsubst.\nright.\nright.\nset (i1 := (ofs1 + delta1, ofs1 + delta1 + sz)).\nset (i2 := (ofs2 + delta2, ofs2 + delta2 + sz)).\nchange (snd i1 <= fst i2 \\/ snd i2 <= fst i1).\napply Intv.range_disjoint'; simpl; try lia.\nunfold Intv.disjoint, Intv.In; simpl; intros.\nred; intros.\nexploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b1', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (e : b1 = b2) : b1' <> b2' \\/\nofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"assert (b1' = b2') by congruence.\nassert (delta1 = delta2) by congruence.\nsubst.\ndestruct H5.\ncongruence.\nright.\ndestruct H5.\nleft; congruence.\nright.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b1', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (e : b1 = b2) (H6 : b1' = b2') : b1' <> b2' \\/\nofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"assert (delta1 = delta2) by congruence.\nsubst.\ndestruct H5.\ncongruence.\nright.\ndestruct H5.\nleft; congruence.\nright.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b1', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (e : b1 = b2) (H6 : b1' = b2') (H7 : delta1 = delta2) : b1' <> b2' \\/\nofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"subst.\ndestruct H5.\ncongruence.\nright.\ndestruct H5.\nleft; congruence.\nright.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b2 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b2 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) : b2' <> b2' \\/\nofs1 + delta2 = ofs2 + delta2 \\/\nofs1 + delta2 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta2.","proofString":"destruct H5.\ncongruence.\nright.\ndestruct H5.\nleft; congruence.\nright.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b2 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b2 <> b2) : b2' <> b2' \\/\nofs1 + delta2 = ofs2 + delta2 \\/\nofs1 + delta2 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta2.","proofString":"congruence."},{"statement":"(f : meminj) (m m' : mem) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b2 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) : b2' <> b2' \\/\nofs1 + delta2 = ofs2 + delta2 \\/\nofs1 + delta2 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta2.","proofString":"right.\ndestruct H5.\nleft; congruence.\nright.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b2 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) : ofs1 + delta2 = ofs2 + delta2 \\/\nofs1 + delta2 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta2.","proofString":"destruct H5.\nleft; congruence.\nright.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b2 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : ofs1 = ofs2) : ofs1 + delta2 = ofs2 + delta2 \\/\nofs1 + delta2 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta2.","proofString":"left; congruence."},{"statement":"(f : meminj) (m m' : mem) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b2 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) : ofs1 + delta2 = ofs2 + delta2 \\/\nofs1 + delta2 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta2.","proofString":"right.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b2 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) : ofs1 + delta2 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta2.","proofString":"lia."},{"statement":"(f : meminj) (m m' : mem) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b1', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) : b1' <> b2' \\/\nofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"destruct (eq_block b1' b2'); auto.\nsubst.\nright.\nright.\nset (i1 := (ofs1 + delta1, ofs1 + delta1 + sz)).\nset (i2 := (ofs2 + delta2, ofs2 + delta2 + sz)).\nchange (snd i1 <= fst i2 \\/ snd i2 <= fst i1).\napply Intv.range_disjoint'; simpl; try lia.\nunfold Intv.disjoint, Intv.In; simpl; intros.\nred; intros.\nexploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b1', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) (e : b1' = b2') : b1' <> b2' \\/\nofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"subst.\nright.\nright.\nset (i1 := (ofs1 + delta1, ofs1 + delta1 + sz)).\nset (i2 := (ofs2 + delta2, ofs2 + delta2 + sz)).\nchange (snd i1 <= fst i2 \\/ snd i2 <= fst i1).\napply Intv.range_disjoint'; simpl; try lia.\nunfold Intv.disjoint, Intv.In; simpl; intros.\nred; intros.\nexploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) : b2' <> b2' \\/\nofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"right.\nright.\nset (i1 := (ofs1 + delta1, ofs1 + delta1 + sz)).\nset (i2 := (ofs2 + delta2, ofs2 + delta2 + sz)).\nchange (snd i1 <= fst i2 \\/ snd i2 <= fst i1).\napply Intv.range_disjoint'; simpl; try lia.\nunfold Intv.disjoint, Intv.In; simpl; intros.\nred; intros.\nexploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) : ofs1 + delta1 = ofs2 + delta2 \\/\nofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"right.\nset (i1 := (ofs1 + delta1, ofs1 + delta1 + sz)).\nset (i2 := (ofs2 + delta2, ofs2 + delta2 + sz)).\nchange (snd i1 <= fst i2 \\/ snd i2 <= fst i1).\napply Intv.range_disjoint'; simpl; try lia.\nunfold Intv.disjoint, Intv.In; simpl; intros.\nred; intros.\nexploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) : ofs1 + delta1 + sz <= ofs2 + delta2 \\/ ofs2 + delta2 + sz <= ofs1 + delta1.","proofString":"set (i1 := (ofs1 + delta1, ofs1 + delta1 + sz)).\nset (i2 := (ofs2 + delta2, ofs2 + delta2 + sz)).\nchange (snd i1 <= fst i2 \\/ snd i2 <= fst i1).\napply Intv.range_disjoint'; simpl; try lia.\nunfold Intv.disjoint, Intv.In; simpl; intros.\nred; intros.\nexploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) (i1 : Z * Z) (i2 : Z * Z) (x : Z) (H6 : ofs1 + delta1 <= x < ofs1 + delta1 + sz) : ~ ofs2 + delta2 <= x < ofs2 + delta2 + sz.","proofString":"red; intros.\nexploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) (i1 : Z * Z) (i2 : Z * Z) (x : Z) (H6 : ofs1 + delta1 <= x < ofs1 + delta1 + sz) (H7 : ofs2 + delta2 <= x < ofs2 + delta2 + sz) : False.","proofString":"exploit mi_no_overlap; eauto.\ninstantiate (1 := x - delta1).\napply H2.\nlia.\ninstantiate (1 := x - delta2).\napply H3.\nlia.\nintuition auto with zarith."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) (i1 : Z * Z) (i2 : Z * Z) (x : Z) (H6 : ofs1 + delta1 <= x < ofs1 + delta1 + sz) (H7 : ofs2 + delta2 <= x < ofs2 + delta2 + sz) : perm m b1 (x - delta1) Max Nonempty.","proofString":"apply H2.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) (i1 : Z * Z) (i2 : Z * Z) (x : Z) (H6 : ofs1 + delta1 <= x < ofs1 + delta1 + sz) (H7 : ofs2 + delta2 <= x < ofs2 + delta2 + sz) : ofs1 <= x - delta1 < ofs1 + sz.","proofString":"lia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) (i1 : Z * Z) (i2 : Z * Z) (x : Z) (H6 : ofs1 + delta1 <= x < ofs1 + delta1 + sz) (H7 : ofs2 + delta2 <= x < ofs2 + delta2 + sz) : perm m b2 (x - delta2) Max Nonempty.","proofString":"apply H3.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b1 : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 sz : Z) (H : inject f m m') (H0 : f b1 = Some (b2', delta1)) (H1 : f b2 = Some (b2', delta2)) (H2 : range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty) (H3 : range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty) (H4 : sz > 0) (H5 : b1 <> b2 \\/ ofs1 = ofs2 \\/ ofs1 + sz <= ofs2 \\/ ofs2 + sz <= ofs1) (n : b1 <> b2) (i1 : Z * Z) (i2 : Z * Z) (x : Z) (H6 : ofs1 + delta1 <= x < ofs1 + delta1 + sz) (H7 : ofs2 + delta2 <= x < ofs2 + delta2 + sz) : ofs2 <= x - delta2 < ofs2 + sz.","proofString":"lia."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) : (al | ofs + delta).","proofString":"assert (P: al > 0) by lia.\nassert (Q: Z.abs al <= Z.abs sz).\napply Zdivide_bounds; auto.\nlia.\nrewrite Z.abs_eq in Q; try lia.\nrewrite Z.abs_eq in Q; try lia.\nassert (R: exists chunk, al = align_chunk chunk /\\ al = size_chunk chunk).\ndestruct H0.\nsubst; exists Mint8unsigned; auto.\ndestruct H0.\nsubst; exists Mint16unsigned; auto.\ndestruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto.\ndestruct R as [chunk [A B]].\nassert (valid_access m chunk b ofs Nonempty).\nsplit.\nred; intros; apply H3.\nlia.\ncongruence.\nexploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) : (al | ofs + delta).","proofString":"assert (Q: Z.abs al <= Z.abs sz).\napply Zdivide_bounds; auto.\nlia.\nrewrite Z.abs_eq in Q; try lia.\nrewrite Z.abs_eq in Q; try lia.\nassert (R: exists chunk, al = align_chunk chunk /\\ al = size_chunk chunk).\ndestruct H0.\nsubst; exists Mint8unsigned; auto.\ndestruct H0.\nsubst; exists Mint16unsigned; auto.\ndestruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto.\ndestruct R as [chunk [A B]].\nassert (valid_access m chunk b ofs Nonempty).\nsplit.\nred; intros; apply H3.\nlia.\ncongruence.\nexploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) : Z.abs al <= Z.abs sz.","proofString":"apply Zdivide_bounds; auto.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) : sz <> 0.","proofString":"lia."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : Z.abs al <= Z.abs sz) : (al | ofs + delta).","proofString":"rewrite Z.abs_eq in Q; try lia.\nrewrite Z.abs_eq in Q; try lia.\nassert (R: exists chunk, al = align_chunk chunk /\\ al = size_chunk chunk).\ndestruct H0.\nsubst; exists Mint8unsigned; auto.\ndestruct H0.\nsubst; exists Mint16unsigned; auto.\ndestruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto.\ndestruct R as [chunk [A B]].\nassert (valid_access m chunk b ofs Nonempty).\nsplit.\nred; intros; apply H3.\nlia.\ncongruence.\nexploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= Z.abs sz) : (al | ofs + delta).","proofString":"rewrite Z.abs_eq in Q; try lia.\nassert (R: exists chunk, al = align_chunk chunk /\\ al = size_chunk chunk).\ndestruct H0.\nsubst; exists Mint8unsigned; auto.\ndestruct H0.\nsubst; exists Mint16unsigned; auto.\ndestruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto.\ndestruct R as [chunk [A B]].\nassert (valid_access m chunk b ofs Nonempty).\nsplit.\nred; intros; apply H3.\nlia.\ncongruence.\nexploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : (al | ofs + delta).","proofString":"assert (R: exists chunk, al = align_chunk chunk /\\ al = size_chunk chunk).\ndestruct H0.\nsubst; exists Mint8unsigned; auto.\ndestruct H0.\nsubst; exists Mint16unsigned; auto.\ndestruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto.\ndestruct R as [chunk [A B]].\nassert (valid_access m chunk b ofs Nonempty).\nsplit.\nred; intros; apply H3.\nlia.\ncongruence.\nexploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk.","proofString":"destruct H0.\nsubst; exists Mint8unsigned; auto.\ndestruct H0.\nsubst; exists Mint16unsigned; auto.\ndestruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk.","proofString":"subst; exists Mint8unsigned; auto."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk.","proofString":"destruct H0.\nsubst; exists Mint16unsigned; auto.\ndestruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 2) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk.","proofString":"subst; exists Mint16unsigned; auto."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk.","proofString":"destruct H0.\nsubst; exists Mint32; auto.\nsubst; exists Mint64; auto."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 4) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk.","proofString":"subst; exists Mint32; auto."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk.","proofString":"subst; exists Mint64; auto."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (R : exists chunk : memory_chunk, al = align_chunk chunk /\\ al = size_chunk chunk) : (al | ofs + delta).","proofString":"destruct R as [chunk [A B]].\nassert (valid_access m chunk b ofs Nonempty).\nsplit.\nred; intros; apply H3.\nlia.\ncongruence.\nexploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) : (al | ofs + delta).","proofString":"assert (valid_access m chunk b ofs Nonempty).\nsplit.\nred; intros; apply H3.\nlia.\ncongruence.\nexploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) : valid_access m chunk b ofs Nonempty.","proofString":"split.\nred; intros; apply H3.\nlia.\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) : range_perm m b ofs (ofs + size_chunk chunk) Cur Nonempty.","proofString":"red; intros; apply H3.\nlia."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) (ofs0 : Z) (H6 : ofs <= ofs0 < ofs + size_chunk chunk) : ofs <= ofs0 < ofs + sz.","proofString":"lia."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) : (align_chunk chunk | ofs).","proofString":"congruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) (H6 : valid_access m chunk b ofs Nonempty) : (al | ofs + delta).","proofString":"exploit valid_access_inject; eauto.\nintros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) (H6 : valid_access m chunk b ofs Nonempty) : valid_access m' chunk b' (ofs + delta) Nonempty -> (al | ofs + delta).","proofString":"intros [C D].\ncongruence."},{"statement":"(f : meminj) (m m' : mem) (b : block) (ofs al sz : Z) (b' : block) (delta : Z) (H : inject f m m') (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz > 0) (H2 : (al | sz)) (H3 : range_perm m b ofs (ofs + sz) Cur Nonempty) (H4 : (al | ofs)) (H5 : f b = Some (b', delta)) (P : al > 0) (Q : al <= sz) (chunk : memory_chunk) (A : al = align_chunk chunk) (B : al = size_chunk chunk) (H6 : valid_access m chunk b ofs Nonempty) (C : range_perm m' b' (ofs + delta) (ofs + delta + size_chunk chunk) Cur Nonempty) (D : (align_chunk chunk | ofs + delta)) : (al | ofs + delta).","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H : inject f m1 m2) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) : exists v2 : val,\n  load chunk m2 b2 (ofs + delta) = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H.\neapply load_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (v1 : val) (H0 : load chunk m1 b1 ofs = Some v1) (H1 : f b1 = Some (b2, delta)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists v2 : val,\n  load chunk m2 b2 (ofs + delta) = Some v2 /\\ Val.inject f v1 v2.","proofString":"eapply load_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (a1 a2 v1 : val) (H : inject f m1 m2) (H0 : loadv chunk m1 a1 = Some v1) (H1 : Val.inject f a1 a2) : exists v2 : val, loadv chunk m2 a2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H1; simpl in H0; try discriminate.\nexploit load_inject; eauto.\nintros [v2 [LOAD INJ]].\nexists v2; split; auto.\nunfold loadv.\nreplace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))     with (Ptrofs.unsigned ofs1 + delta).\nauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : exists v2 : val,\n  loadv chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"exploit load_inject; eauto.\nintros [v2 [LOAD INJ]].\nexists v2; split; auto.\nunfold loadv.\nreplace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))     with (Ptrofs.unsigned ofs1 + delta).\nauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) : (exists v2 : val,\n   load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2 /\\\n   Val.inject f v1 v2) ->\nexists v2 : val,\n  loadv chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"intros [v2 [LOAD INJ]].\nexists v2; split; auto.\nunfold loadv.\nreplace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))     with (Ptrofs.unsigned ofs1 + delta).\nauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (v2 : val) (LOAD : load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2) (INJ : Val.inject f v1 v2) : exists v0 : val,\n  loadv chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) = Some v0 /\\\n  Val.inject f v1 v0.","proofString":"exists v2; split; auto.\nunfold loadv.\nreplace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))     with (Ptrofs.unsigned ofs1 + delta).\nauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (v2 : val) (LOAD : load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2) (INJ : Val.inject f v1 v2) : loadv chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) = Some v2.","proofString":"unfold loadv.\nreplace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))     with (Ptrofs.unsigned ofs1 + delta).\nauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (v2 : val) (LOAD : load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2) (INJ : Val.inject f v1 v2) : load chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome v2.","proofString":"replace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))     with (Ptrofs.unsigned ofs1 + delta).\nauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (v2 : val) (LOAD : load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2) (INJ : Val.inject f v1 v2) : load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (v2 : val) (LOAD : load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2) (INJ : Val.inject f v1 v2) : Ptrofs.unsigned ofs1 + delta =\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)).","proofString":"symmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (v1 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : load chunk m1 b1 (Ptrofs.unsigned ofs1) = Some v1) (b2 : block) (delta : Z) (H2 : f b1 = Some (b2, delta)) (v2 : val) (LOAD : load chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) = Some v2) (INJ : Val.inject f v1 v2) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"eapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs len : Z) (b2 : block) (delta : Z) (bytes1 : list memval) (H : inject f m1 m2) (H0 : loadbytes m1 b1 ofs len = Some bytes1) (H1 : f b1 = Some (b2, delta)) : exists bytes2 : list memval,\n  loadbytes m2 b2 (ofs + delta) len = Some bytes2 /\\\n  list_forall2 (memval_inject f) bytes1 bytes2.","proofString":"inv H.\neapply loadbytes_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b1 : block) (ofs len : Z) (b2 : block) (delta : Z) (bytes1 : list memval) (H0 : loadbytes m1 b1 ofs len = Some bytes1) (H1 : f b1 = Some (b2, delta)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists bytes2 : list memval,\n  loadbytes m2 b2 (ofs + delta) len = Some bytes2 /\\\n  list_forall2 (memval_inject f) bytes1 bytes2.","proofString":"eapply loadbytes_inj; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) : exists n2 : mem,\n  store chunk m2 b2 (ofs + delta) v2 = Some n2 /\\ inject f n1 n2.","proofString":"inversion H.\nexploit store_mapped_inj; eauto.\nintros [n2 [STORE MI]].\nexists n2; split.\neauto.\nconstructor.\nauto.\neauto with mem.\neauto with mem.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable; try eassumption.\ndestruct H4; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists n2 : mem,\n  store chunk m2 b2 (ofs + delta) v2 = Some n2 /\\ inject f n1 n2.","proofString":"exploit store_mapped_inj; eauto.\nintros [n2 [STORE MI]].\nexists n2; split.\neauto.\nconstructor.\nauto.\neauto with mem.\neauto with mem.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable; try eassumption.\ndestruct H4; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : (exists n2 : mem,\n   store chunk m2 b2 (ofs + delta) v2 = Some n2 /\\ mem_inj f n1 n2) ->\nexists n2 : mem,\n  store chunk m2 b2 (ofs + delta) v2 = Some n2 /\\ inject f n1 n2.","proofString":"intros [n2 [STORE MI]].\nexists n2; split.\neauto.\nconstructor.\nauto.\neauto with mem.\neauto with mem.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable; try eassumption.\ndestruct H4; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : exists n0 : mem,\n  store chunk m2 b2 (ofs + delta) v2 = Some n0 /\\ inject f n1 n0.","proofString":"exists n2; split.\neauto.\nconstructor.\nauto.\neauto with mem.\neauto with mem.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable; try eassumption.\ndestruct H4; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : store chunk m2 b2 (ofs + delta) v2 = Some n2.","proofString":"eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : inject f n1 n2.","proofString":"constructor.\nauto.\neauto with mem.\neauto with mem.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable; try eassumption.\ndestruct H4; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : mem_inj f n1 n2.","proofString":"auto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : forall b : block, ~ valid_block n1 b -> f b = None.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block n2 b'.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : meminj_no_overlap f n1.","proofString":"red; intros.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs0 + delta0) k p ->\nperm m1 b4 ofs0 k p \\/ ~ perm m1 b4 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H3 : b0 <> b3) (H4 : f b0 = Some (b1', delta1)) (H5 : f b3 = Some (b2', delta2)) (H6 : perm n1 b0 ofs1 Max Nonempty) (H7 : perm n1 b3 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned.","proofString":"intros.\neapply mi_representable; try eassumption.\ndestruct H4; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs1 + delta1) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) (b b' : block) (delta0 : Z) (ofs0 : ptrofs) (H3 : f b = Some (b', delta0)) (H4 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : delta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable; try eassumption.\ndestruct H4; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs1 + delta1) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) (b b' : block) (delta0 : Z) (ofs0 : ptrofs) (H3 : f b = Some (b', delta0)) (H4 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : perm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty.","proofString":"destruct H4; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm n2 b3 (ofs0 + delta0) k p ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs1 + delta1) k0 p0 ->\nperm m1 b4 ofs1 k0 p0 \\/ ~ perm m1 b4 ofs1 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (k : perm_kind) (p : permission) (H3 : f b0 = Some (b3, delta0)) (H4 : perm n2 b3 (ofs0 + delta0) k p) : perm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (b2 : block) (delta : Z) (v2 : val) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : Val.inject f v1 v2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs1 + delta1) k0 p0 ->\nperm m1 b4 ofs1 k0 p0 \\/ ~ perm m1 b4 ofs1 Max Nonempty) (n2 : mem) (STORE : store chunk m2 b2 (ofs + delta) v2 = Some n2) (MI : mem_inj f n1 n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (k : perm_kind) (p : permission) (H3 : f b0 = Some (b3, delta0)) (H4 : perm n2 b3 (ofs0 + delta0) k p) : perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) : inject f n1 m2.","proofString":"inversion H.\nconstructor.\neapply store_unmapped_inj; eauto.\neauto with mem.\neauto with mem.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable; try eassumption.\ndestruct H3; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : inject f n1 m2.","proofString":"constructor.\neapply store_unmapped_inj; eauto.\neauto with mem.\neauto with mem.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable; try eassumption.\ndestruct H3; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : mem_inj f n1 m2.","proofString":"eapply store_unmapped_inj; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall b : block, ~ valid_block n1 b -> f b = None.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b'.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : meminj_no_overlap f n1.","proofString":"red; intros.\neauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta) ->\nperm m2 b4 (ofs0 + delta) k p ->\nperm m1 b3 ofs0 k p \\/ ~ perm m1 b3 ofs0 Max Nonempty) (b0 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H2 : b0 <> b2) (H3 : f b0 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : perm n1 b0 ofs1 Max Nonempty) (H6 : perm n1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned.","proofString":"intros.\neapply mi_representable; try eassumption.\ndestruct H3; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs1 + delta0) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (b b' : block) (delta : Z) (ofs0 : ptrofs) (H2 : f b = Some (b', delta)) (H3 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable; try eassumption.\ndestruct H3; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs1 + delta0) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (b b' : block) (delta : Z) (ofs0 : ptrofs) (H2 : f b = Some (b', delta)) (H3 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : perm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty.","proofString":"destruct H3; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intros.\nexploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs1 + delta0) k0 p0 ->\nperm m1 b3 ofs1 k0 p0 \\/ ~ perm m1 b3 ofs1 Max Nonempty) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m2 b2 (ofs0 + delta) k p) : perm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto using perm_store_2.\nintuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (b1 : block) (ofs : Z) (v1 : val) (n1 m2 : mem) (H : inject f m1 m2) (H0 : store chunk m1 b1 ofs v1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs1 + delta0) k0 p0 ->\nperm m1 b3 ofs1 k0 p0 \\/ ~ perm m1 b3 ofs1 Max Nonempty) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m2 b2 (ofs0 + delta) k p) : perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intuition eauto using perm_store_1, perm_store_2."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') : inject f m1 m2'.","proofString":"inversion H.\nconstructor.\neapply store_outside_inj; eauto.\nauto.\neauto with mem.\nauto.\neauto with mem.\nintros.\neauto using perm_store_2."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : inject f m1 m2'.","proofString":"constructor.\neapply store_outside_inj; eauto.\nauto.\neauto with mem.\nauto.\neauto with mem.\nintros.\neauto using perm_store_2."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : mem_inj f m1 m2'.","proofString":"eapply store_outside_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2' b'.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : meminj_no_overlap f m1.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2' b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty.","proofString":"intros.\neauto using perm_store_2."},{"statement":"(f : meminj) (m1 m2 : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + size_chunk chunk -> False) (H1 : store chunk m2 b ofs v = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs1 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs1 + delta0) k0 p0 ->\nperm m1 b0 ofs1 k0 p0 \\/ ~ perm m1 b0 ofs1 Max Nonempty) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m2' b2 (ofs0 + delta) k p) : perm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty.","proofString":"eauto using perm_store_2."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (a1 v1 : val) (n1 m2 : mem) (a2 v2 : val) (H : inject f m1 m2) (H0 : storev chunk m1 a1 v1 = Some n1) (H1 : Val.inject f a1 a2) (H2 : Val.inject f v1 v2) : exists n2 : mem, storev chunk m2 a2 v2 = Some n2 /\\ inject f n1 n2.","proofString":"inv H1; simpl in H0; try discriminate.\nunfold storev.\nreplace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))    with (Ptrofs.unsigned ofs1 + delta).\neapply store_mapped_inject; eauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (v1 : val) (n1 m2 : mem) (v2 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : store chunk m1 b1 (Ptrofs.unsigned ofs1) v1 = Some n1) (H2 : Val.inject f v1 v2) (b2 : block) (delta : Z) (H3 : f b1 = Some (b2, delta)) : exists n2 : mem,\n  storev chunk m2 (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) v2 =\n  Some n2 /\\ inject f n1 n2.","proofString":"unfold storev.\nreplace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))    with (Ptrofs.unsigned ofs1 + delta).\neapply store_mapped_inject; eauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (v1 : val) (n1 m2 : mem) (v2 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : store chunk m1 b1 (Ptrofs.unsigned ofs1) v1 = Some n1) (H2 : Val.inject f v1 v2) (b2 : block) (delta : Z) (H3 : f b1 = Some (b2, delta)) : exists n2 : mem,\n  store chunk m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))\n    v2 = Some n2 /\\ inject f n1 n2.","proofString":"replace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))    with (Ptrofs.unsigned ofs1 + delta).\neapply store_mapped_inject; eauto.\nsymmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (v1 : val) (n1 m2 : mem) (v2 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : store chunk m1 b1 (Ptrofs.unsigned ofs1) v1 = Some n1) (H2 : Val.inject f v1 v2) (b2 : block) (delta : Z) (H3 : f b1 = Some (b2, delta)) : exists n2 : mem,\n  store chunk m2 b2 (Ptrofs.unsigned ofs1 + delta) v2 = Some n2 /\\\n  inject f n1 n2.","proofString":"eapply store_mapped_inject; eauto."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (v1 : val) (n1 m2 : mem) (v2 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : store chunk m1 b1 (Ptrofs.unsigned ofs1) v1 = Some n1) (H2 : Val.inject f v1 v2) (b2 : block) (delta : Z) (H3 : f b1 = Some (b2, delta)) : Ptrofs.unsigned ofs1 + delta =\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)).","proofString":"symmetry.\neapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (chunk : memory_chunk) (m1 : mem) (v1 : val) (n1 m2 : mem) (v2 : val) (H : inject f m1 m2) (b1 : block) (ofs1 : ptrofs) (H0 : store chunk m1 b1 (Ptrofs.unsigned ofs1) v1 = Some n1) (H2 : Val.inject f v1 v2) (b2 : block) (delta : Z) (H3 : f b1 = Some (b2, delta)) : Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs1 + delta.","proofString":"eapply address_inject'; eauto with mem."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) : exists n2 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n2 /\\ inject f n1 n2.","proofString":"inversion H.\nexploit storebytes_mapped_inj; eauto.\nintros [n2 [STORE MI]].\nexists n2; split.\neauto.\nconstructor.\nauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H3; eapply storebytes_valid_block_1; eauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H4; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : exists n2 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n2 /\\ inject f n1 n2.","proofString":"exploit storebytes_mapped_inj; eauto.\nintros [n2 [STORE MI]].\nexists n2; split.\neauto.\nconstructor.\nauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H3; eapply storebytes_valid_block_1; eauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H4; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : (exists n2 : mem,\n   storebytes m2 b2 (ofs + delta) bytes2 = Some n2 /\\ mem_inj f n1 n2) ->\nexists n2 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n2 /\\ inject f n1 n2.","proofString":"intros [n2 [STORE MI]].\nexists n2; split.\neauto.\nconstructor.\nauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H3; eapply storebytes_valid_block_1; eauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H4; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : exists n0 : mem,\n  storebytes m2 b2 (ofs + delta) bytes2 = Some n0 /\\ inject f n1 n0.","proofString":"exists n2; split.\neauto.\nconstructor.\nauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H3; eapply storebytes_valid_block_1; eauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H4; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : storebytes m2 b2 (ofs + delta) bytes2 = Some n2.","proofString":"eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : inject f n1 n2.","proofString":"constructor.\nauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H3; eapply storebytes_valid_block_1; eauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H4; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : mem_inj f n1 n2.","proofString":"auto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : forall b : block, ~ valid_block n1 b -> f b = None.","proofString":"intros.\napply mi_freeblocks0.\nred; intros; elim H3; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b : block) (H3 : ~ valid_block n1 b) : f b = None.","proofString":"apply mi_freeblocks0.\nred; intros; elim H3; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b : block) (H3 : ~ valid_block n1 b) : ~ valid_block m1 b.","proofString":"red; intros; elim H3; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block n2 b'.","proofString":"intros.\neapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs0 + delta1) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b b' : block) (delta0 : Z) (H3 : f b = Some (b', delta0)) : valid_block n2 b'.","proofString":"eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : meminj_no_overlap f n1.","proofString":"red; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs0 + delta0) k p ->\nperm m1 b4 ofs0 k p \\/ ~ perm m1 b4 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H3 : b0 <> b3) (H4 : f b0 = Some (b1', delta1)) (H5 : f b3 = Some (b2', delta2)) (H6 : perm n1 b0 ofs1 Max Nonempty) (H7 : perm n1 b3 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned.","proofString":"intros.\neapply mi_representable0; eauto.\ndestruct H4; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs1 + delta1) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b b' : block) (delta0 : Z) (ofs0 : ptrofs) (H3 : f b = Some (b', delta0)) (H4 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : delta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; eauto.\ndestruct H4; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs1 + delta1) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b b' : block) (delta0 : Z) (ofs0 : ptrofs) (H3 : f b = Some (b', delta0)) (H4 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : perm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty.","proofString":"destruct H4; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm n2 b3 (ofs0 + delta0) k p ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs1 + delta1) k0 p0 ->\nperm m1 b4 ofs1 k0 p0 \\/ ~ perm m1 b4 ofs1 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (k : perm_kind) (p : permission) (H3 : f b0 = Some (b3, delta0)) (H4 : perm n2 b3 (ofs0 + delta0) k p) : perm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (b2 : block) (delta : Z) (bytes2 : list memval) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = Some (b2, delta)) (H2 : list_forall2 (memval_inject f) bytes1 bytes2) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs1 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs1 + delta1) k0 p0 ->\nperm m1 b4 ofs1 k0 p0 \\/ ~ perm m1 b4 ofs1 Max Nonempty) (n2 : mem) (STORE : storebytes m2 b2 (ofs + delta) bytes2 = Some n2) (MI : mem_inj f n1 n2) (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) (k : perm_kind) (p : permission) (H3 : f b0 = Some (b3, delta0)) (H4 : perm n2 b3 (ofs0 + delta0) k p) : perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) : inject f n1 m2.","proofString":"inversion H.\nconstructor.\neapply storebytes_unmapped_inj; eauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto.\neauto with mem.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : inject f n1 m2.","proofString":"constructor.\neapply storebytes_unmapped_inj; eauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto.\neauto with mem.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : mem_inj f n1 m2.","proofString":"eapply storebytes_unmapped_inj; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall b : block, ~ valid_block n1 b -> f b = None.","proofString":"intros.\napply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b : block) (H2 : ~ valid_block n1 b) : f b = None.","proofString":"apply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b : block) (H2 : ~ valid_block n1 b) : ~ valid_block m1 b.","proofString":"red; intros; elim H2; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b'.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : meminj_no_overlap f n1.","proofString":"red; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta) ->\nperm m2 b4 (ofs0 + delta) k p ->\nperm m1 b3 ofs0 k p \\/ ~ perm m1 b3 ofs0 Max Nonempty) (b0 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H2 : b0 <> b2) (H3 : f b0 = Some (b1', delta1)) (H4 : f b2 = Some (b2', delta2)) (H5 : perm n1 b0 ofs1 Max Nonempty) (H6 : perm n1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned.","proofString":"intros.\neapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs1 + delta0) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (b b' : block) (delta : Z) (ofs0 : ptrofs) (H2 : f b = Some (b', delta)) (H3 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs1 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs1 + delta0) k p ->\nperm m1 b0 ofs1 k p \\/ ~ perm m1 b0 ofs1 Max Nonempty) (b b' : block) (delta : Z) (ofs0 : ptrofs) (H2 : f b = Some (b', delta)) (H3 : perm n1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm n1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty) : perm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty.","proofString":"destruct H3; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intros.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs1 + delta0) k0 p0 ->\nperm m1 b3 ofs1 k0 p0 \\/ ~ perm m1 b3 ofs1 Max Nonempty) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m2 b2 (ofs0 + delta) k p) : perm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs : Z) (bytes1 : list memval) (n1 m2 : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs bytes1 = Some n1) (H1 : f b1 = None) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs1 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs1 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs1 + delta0) k0 p0 ->\nperm m1 b3 ofs1 k0 p0 \\/ ~ perm m1 b3 ofs1 Max Nonempty) (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b2, delta)) (H3 : perm m2 b2 (ofs0 + delta) k p) : perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty ->\nperm n1 b0 ofs0 k p \\/ ~ perm n1 b0 ofs0 Max Nonempty.","proofString":"intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') : inject f m1 m2'.","proofString":"inversion H.\nconstructor.\neapply storebytes_outside_inj; eauto.\nauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nauto.\nauto.\nintros.\neapply mi_perm_inv0; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : inject f m1 m2'.","proofString":"constructor.\neapply storebytes_outside_inj; eauto.\nauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nauto.\nauto.\nintros.\neapply mi_perm_inv0; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : mem_inj f m1 m2'.","proofString":"eapply storebytes_outside_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2' b'.","proofString":"intros.\neapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b'0 : block) (delta0 ofs' : Z),\nf b'0 = Some (b, delta0) ->\nperm m1 b'0 ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b1 : block, ~ valid_block m1 b1 -> f b1 = None) (mi_mappedblocks0 : forall (b1 b'0 : block) (delta0 : Z),\nf b1 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b1 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b1 = Some (b'0, delta0) ->\nperm m1 b1 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 b' : block) (delta : Z) (H2 : f b0 = Some (b', delta)) : valid_block m2' b'.","proofString":"eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : meminj_no_overlap f m1.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta ofs' : Z),\nf b' = Some (b, delta) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2' b2 (ofs0 + delta) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty.","proofString":"intros.\neapply mi_perm_inv0; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (ofs : Z) (bytes2 : list memval) (m2' : mem) (H : inject f m1 m2) (H0 : forall (b' : block) (delta0 ofs' : Z),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs' Cur Readable ->\nofs <= ofs' + delta0 < ofs + Z.of_nat (Datatypes.length bytes2) -> False) (H1 : storebytes m2 b ofs bytes2 = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs1 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs1) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs1 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs1 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs1 + delta0) k0 p0 ->\nperm m1 b0 ofs1 k0 p0 \\/ ~ perm m1 b0 ofs1 Max Nonempty) (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m2' b2 (ofs0 + delta) k p) : perm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty.","proofString":"eapply mi_perm_inv0; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') : inject f m1' m2'.","proofString":"inversion H.\nconstructor; intros.\neapply storebytes_empty_inj; eauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : inject f m1' m2'.","proofString":"constructor; intros.\neapply storebytes_empty_inj; eauto.\nintros.\napply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto.\nintros.\neapply storebytes_valid_block_1; eauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto.\nintros.\neapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2.\nintros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : mem_inj f m1' m2'.","proofString":"eapply storebytes_empty_inj; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (b : block) (H2 : ~ valid_block m1' b) : f b = None.","proofString":"intros.\napply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (b : block) (H2 : ~ valid_block m1' b) : f b = None.","proofString":"apply mi_freeblocks0.\nred; intros; elim H2; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (b : block) (H2 : ~ valid_block m1' b) : ~ valid_block m1 b.","proofString":"red; intros; elim H2; eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (b b' : block) (delta : Z) (H2 : f b = Some (b', delta)) : valid_block m2' b'.","proofString":"intros.\neapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (b b' : block) (delta : Z) (H2 : f b = Some (b', delta)) : valid_block m2' b'.","proofString":"eapply storebytes_valid_block_1; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : meminj_no_overlap f m1'.","proofString":"red; intros.\neapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta) ->\nperm m2 b5 (ofs + delta) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs0 ofs3 : Z) (H2 : b0 <> b3) (H3 : f b0 = Some (b1', delta1)) (H4 : f b3 = Some (b2', delta2)) (H5 : perm m1' b0 ofs0 Max Nonempty) (H6 : perm m1' b3 ofs3 Max Nonempty) : b1' <> b2' \\/ ofs0 + delta1 <> ofs3 + delta2.","proofString":"eapply mi_no_overlap0; eauto; eapply perm_storebytes_2; eauto."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (H2 : f b = Some (b', delta)) (H3 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"intros.\neapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (H2 : f b = Some (b', delta)) (H3 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; eauto.\ndestruct H3; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (H2 : f b = Some (b', delta)) (H3 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty.","proofString":"destruct H3; eauto using perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs0 + delta0) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b3, delta)) (H3 : perm m2' b3 (ofs + delta) k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intros.\nexploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs0 + delta0) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b3, delta)) (H3 : perm m2' b3 (ofs + delta) k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto using perm_storebytes_2.\nintuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 : mem) (b1 : block) (ofs1 : Z) (m1' m2 : mem) (b2 : block) (ofs2 : Z) (m2' : mem) (H : inject f m1 m2) (H0 : storebytes m1 b1 ofs1 nil = Some m1') (H1 : storebytes m2 b2 ofs2 nil = Some m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs0 + delta0) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (b0 : block) (ofs : Z) (b3 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b0 = Some (b3, delta)) (H3 : perm m2' b3 (ofs + delta) k p) : perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty ->\nperm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intuition eauto using perm_storebytes_1, perm_storebytes_2."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) : inject f m1 m2'.","proofString":"injection H0.\nintros NEXT MEM.\ninversion H.\nconstructor.\neapply alloc_right_inj; eauto.\nauto.\neauto with mem.\nauto.\nauto.\nintros.\neapply perm_alloc_inv in H2; eauto.\ndestruct (eq_block b0 b2).\nsubst b0.\neelim fresh_block_alloc; eauto.\neapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) : nextblock m2 = b2 ->\n{|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2' -> inject f m1 m2'.","proofString":"intros NEXT MEM.\ninversion H.\nconstructor.\neapply alloc_right_inj; eauto.\nauto.\neauto with mem.\nauto.\nauto.\nintros.\neapply perm_alloc_inv in H2; eauto.\ndestruct (eq_block b0 b2).\nsubst b0.\neelim fresh_block_alloc; eauto.\neapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') : inject f m1 m2'.","proofString":"inversion H.\nconstructor.\neapply alloc_right_inj; eauto.\nauto.\neauto with mem.\nauto.\nauto.\nintros.\neapply perm_alloc_inv in H2; eauto.\ndestruct (eq_block b0 b2).\nsubst b0.\neelim fresh_block_alloc; eauto.\neapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2 b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : inject f m1 m2'.","proofString":"constructor.\neapply alloc_right_inj; eauto.\nauto.\neauto with mem.\nauto.\nauto.\nintros.\neapply perm_alloc_inv in H2; eauto.\ndestruct (eq_block b0 b2).\nsubst b0.\neelim fresh_block_alloc; eauto.\neapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2 b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : mem_inj f m1 m2'.","proofString":"eapply alloc_right_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2 b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall b : block, ~ valid_block m1 b -> f b = None.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2 b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2' b'.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2 b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : meminj_no_overlap f m1.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2 b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs : Z) (_ : perm_kind) =>\n       if zle lo ofs && zlt ofs hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs : Z) => alloc_obligation_1 m2 lo hi b ofs;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs : Z) (k : perm_kind)\n      (H1 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs k H1;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2 b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b1 : block) (ofs : Z) (b0 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b0, delta) ->\nperm m2' b0 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"intros.\neapply perm_alloc_inv in H2; eauto.\ndestruct (eq_block b0 b2).\nsubst b0.\neelim fresh_block_alloc; eauto.\neapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k0 H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b0, delta)) (H2 : perm m2' b0 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eapply perm_alloc_inv in H2; eauto.\ndestruct (eq_block b0 b2).\nsubst b0.\neelim fresh_block_alloc; eauto.\neapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k0 H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b0, delta)) (H2 : if eq_block b0 b2\nthen lo <= ofs + delta < hi\nelse perm m2 b0 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"destruct (eq_block b0 b2).\nsubst b0.\neelim fresh_block_alloc; eauto.\neapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k0 H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b0, delta)) (e : b0 = b2) (H2 : lo <= ofs + delta < hi) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"subst b0.\neelim fresh_block_alloc; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k0 H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1 : block) (ofs delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : lo <= ofs + delta < hi) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eelim fresh_block_alloc; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (b2 : block) (m2' : mem') (H : inject f m1 m2) (H0 : alloc m2 lo hi = (m2', b2)) (NEXT : nextblock m2 = b2) (MEM : {|\n  mem_contents := PMap.set (nextblock m2) (ZMap.init Undef) (mem_contents m2);\n  mem_access :=\n    PMap.set (nextblock m2)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m2);\n  nextblock := Pos.succ (nextblock m2);\n  access_max :=\n    fun (b : positive) (ofs0 : Z) => alloc_obligation_1 m2 lo hi b ofs0;\n  nextblock_noaccess :=\n    fun (b : positive) (ofs0 : Z) (k0 : perm_kind)\n      (H3 : ~ Plt b (Pos.succ (nextblock m2))) =>\n    alloc_obligation_2 m2 lo hi b ofs0 k0 H3;\n  contents_default := fun b : positive => alloc_obligation_3 m2 b\n|} = m2') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b0 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b0, delta)) (n : b0 <> b2) (H2 : perm m2 b0 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) : exists f' : meminj,\n  inject f' m1' m2 /\\\n  inject_incr f f' /\\\n  f' b1 = None /\\ (forall b : block, b <> b1 -> f' b = f b).","proofString":"inversion H.\nset (f' := fun b => if eq_block b b1 then None else f b).\nassert (inject_incr f f').\nred; unfold f'; intros.\ndestruct (eq_block b b1).\nsubst b.\nassert (f b1 = None).\neauto with mem.\ncongruence.\nauto.\nassert (mem_inj f' m1 m2).\ninversion mi_inj0; constructor; eauto with mem.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ncongruence.\napply memval_inject_incr with f; auto.\nexists f'; split.\nconstructor.\neapply alloc_left_unmapped_inj; eauto.\nunfold f'; apply dec_eq_true.\nintros.\nunfold f'.\ndestruct (eq_block b b1).\nauto.\napply mi_freeblocks0.\nred; intro; elim H3.\neauto with mem.\nunfold f'; intros.\ndestruct (eq_block b b1).\ncongruence.\neauto.\nunfold f'; red; intros.\ndestruct (eq_block b0 b1); destruct (eq_block b2 b1); try congruence.\neapply mi_no_overlap0.\neexact H3.\neauto.\neauto.\nexploit perm_alloc_inv.\neauto.\neexact H6.\nrewrite dec_eq_false; auto.\nexploit perm_alloc_inv.\neauto.\neexact H7.\nrewrite dec_eq_false; auto.\nunfold f'; intros.\ndestruct (eq_block b b1); try discriminate.\neapply mi_representable0; try eassumption.\ndestruct H4; eauto using perm_alloc_4.\nintros.\nunfold f' in H3; destruct (eq_block b0 b1); try discriminate.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_alloc_1, perm_alloc_4.\nsplit.\nauto.\nsplit.\nunfold f'; apply dec_eq_true.\nintros; unfold f'; apply dec_eq_false; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : exists f' : meminj,\n  inject f' m1' m2 /\\\n  inject_incr f f' /\\\n  f' b1 = None /\\ (forall b : block, b <> b1 -> f' b = f b).","proofString":"set (f' := fun b => if eq_block b b1 then None else f b).\nassert (inject_incr f f').\nred; unfold f'; intros.\ndestruct (eq_block b b1).\nsubst b.\nassert (f b1 = None).\neauto with mem.\ncongruence.\nauto.\nassert (mem_inj f' m1 m2).\ninversion mi_inj0; constructor; eauto with mem.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ncongruence.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ncongruence.\napply memval_inject_incr with f; auto.\nexists f'; split.\nconstructor.\neapply alloc_left_unmapped_inj; eauto.\nunfold f'; apply dec_eq_true.\nintros.\nunfold f'.\ndestruct (eq_block b b1).\nauto.\napply mi_freeblocks0.\nred; intro; elim H3.\neauto with mem.\nunfold f'; intros.\ndestruct (eq_block b b1).\ncongruence.\neauto.\nunfold f'; red; intros.\ndestruct (eq_block b0 b1); destruct (eq_block b2 b1); try congruence.\neapply mi_no_overlap0.\neexact H3.\neauto.\neauto.\nexploit perm_alloc_inv.\neauto.\neexact H6.\nrewrite dec_eq_false; auto.\nexploit perm_alloc_inv.\neauto.\neexact H7.\nrewrite dec_eq_false; auto.\nunfold f'; intros.\ndestruct (eq_block b b1); try discriminate.\neapply mi_representable0; try eassumption.\ndestruct H4; eauto using perm_alloc_4.\nintros.\nunfold f' in H3; destruct (eq_block b0 b1); try discriminate.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_alloc_1, perm_alloc_4.\nsplit.\nauto.\nsplit.\nunfold f'; apply dec_eq_true.\nintros; unfold f'; apply dec_eq_false; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b b' : block) (delta : Z) (H1 : f b = Some (b', delta)) : (if eq_block b b1 then None else f b) = Some (b', delta).","proofString":"destruct (eq_block b b1).\nsubst b.\nassert (f b1 = None).\neauto with mem.\ncongruence.\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b b' : block) (delta : Z) (H1 : f b = Some (b', delta)) (e : b = b1) : None = Some (b', delta).","proofString":"subst b.\nassert (f b1 = None).\neauto with mem.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta0 : Z),\nf b = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b'0, delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b' : block) (delta : Z) (H1 : f b1 = Some (b', delta)) : None = Some (b', delta).","proofString":"assert (f b1 = None).\neauto with mem.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta0 : Z),\nf b = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b'0, delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b' : block) (delta : Z) (H1 : f b1 = Some (b', delta)) : f b1 = None.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta0 : Z),\nf b = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b'0, delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b' : block) (delta : Z) (H1 : f b1 = Some (b', delta)) (H2 : f b1 = None) : None = Some (b', delta).","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b b' : block) (delta : Z) (H1 : f b = Some (b', delta)) (n : b <> b1) : f b = Some (b', delta).","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H2 : (if eq_block b0 b1 then None else f b0) = Some (b2, delta)) (H3 : perm m1 b0 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"destruct (eq_block b0 b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (e : b0 = b1) (H2 : None = Some (b2, delta)) (H3 : perm m1 b0 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k0 p0 -> perm m2 b4 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (n : b0 <> b1) (H2 : f b0 = Some (b2, delta)) (H3 : perm m1 b0 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k p0 ->\nperm m1 b3 ofs0 k p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H2 : (if eq_block b0 b1 then None else f b0) = Some (b2, delta)) (H3 : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"destruct (eq_block b0 b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k p0 ->\nperm m1 b3 ofs0 k p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (e : b0 = b1) (H2 : None = Some (b2, delta)) (H3 : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k p0 ->\nperm m1 b3 ofs0 k p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p0 -> perm m2 b4 (ofs0 + delta0) k p0) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (n : b0 <> b1) (H2 : f b0 = Some (b2, delta)) (H3 : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k p ->\nperm m1 b3 ofs0 k p \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (mi_perm0 : forall (b3 b4 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 k p -> perm m2 b4 (ofs0 + delta0) k p) (mi_align0 : forall (b3 b4 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b3 = Some (b4, delta0) ->\nrange_perm m1 b3 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z),\nf b3 = Some (b4, delta0) ->\nperm m1 b3 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b3)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b4)) (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (e : b0 = b1) (H2 : None = Some (b2, delta)) (H3 : perm m1 b0 ofs Cur Readable) : memval_inject (fun b : positive => if eq_block b b1 then None else f b)\n  (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b : block) (H3 : ~ valid_block m1' b) : (if eq_block b b1 then None else f b) = None.","proofString":"destruct (eq_block b b1).\nauto.\napply mi_freeblocks0.\nred; intro; elim H3.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b : block) (H3 : ~ valid_block m1' b) (n : b <> b1) : f b = None.","proofString":"apply mi_freeblocks0.\nred; intro; elim H3.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b : block) (H3 : ~ valid_block m1' b) (n : b <> b1) : ~ valid_block m1 b.","proofString":"red; intro; elim H3.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b : block) (H3 : ~ valid_block m1' b) (n : b <> b1) (H4 : valid_block m1 b) : valid_block m1' b.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b b' : block) (delta : Z) (H3 : (if eq_block b b1 then None else f b) = Some (b', delta)) : valid_block m2 b'.","proofString":"destruct (eq_block b b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b b' : block) (delta : Z) (e : b = b1) (H3 : None = Some (b', delta)) : valid_block m2 b'.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b b' : block) (delta : Z) (n : b <> b1) (H3 : f b = Some (b', delta)) : valid_block m2 b'.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs : Z) (b4 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta) ->\nperm m2 b4 (ofs + delta) k p ->\nperm m1 b3 ofs k p \\/ ~ perm m1 b3 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H3 : b0 <> b2) (H4 : (if eq_block b0 b1 then None else f b0) = Some (b1', delta1)) (H5 : (if eq_block b2 b1 then None else f b2) = Some (b2', delta2)) (H6 : perm m1' b0 ofs1 Max Nonempty) (H7 : perm m1' b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"destruct (eq_block b0 b1); destruct (eq_block b2 b1); try congruence.\neapply mi_no_overlap0.\neexact H3.\neauto.\neauto.\nexploit perm_alloc_inv.\neauto.\neexact H6.\nrewrite dec_eq_false; auto.\nexploit perm_alloc_inv.\neauto.\neexact H7.\nrewrite dec_eq_false; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs : Z) (b4 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta) ->\nperm m2 b4 (ofs + delta) k p ->\nperm m1 b3 ofs k p \\/ ~ perm m1 b3 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H3 : b0 <> b2) (n : b0 <> b1) (H4 : f b0 = Some (b1', delta1)) (n0 : b2 <> b1) (H5 : f b2 = Some (b2', delta2)) (H6 : perm m1' b0 ofs1 Max Nonempty) (H7 : perm m1' b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eapply mi_no_overlap0.\neexact H3.\neauto.\neauto.\nexploit perm_alloc_inv.\neauto.\neexact H6.\nrewrite dec_eq_false; auto.\nexploit perm_alloc_inv.\neauto.\neexact H7.\nrewrite dec_eq_false; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b b' : block) (delta : Z) (ofs : ptrofs) (H3 : (if eq_block b b1 then None else f b) = Some (b', delta)) (H4 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"destruct (eq_block b b1); try discriminate.\neapply mi_representable0; try eassumption.\ndestruct H4; eauto using perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b b' : block) (delta : Z) (ofs : ptrofs) (n : b <> b1) (H3 : f b = Some (b', delta)) (H4 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; try eassumption.\ndestruct H4; eauto using perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b b' : block) (delta : Z) (ofs : ptrofs) (n : b <> b1) (H3 : f b = Some (b', delta)) (H4 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty.","proofString":"destruct H4; eauto using perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (n : b0 <> b1) (H3 : f b0 = Some (b2, delta)) (H4 : perm m2 b2 (ofs + delta) k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto.\nintuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs0 : Z) (b4 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs0 + delta0) k0 p0 ->\nperm m1 b3 ofs0 k0 p0 \\/ ~ perm m1 b3 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) (b0 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (n : b0 <> b1) (H3 : f b0 = Some (b2, delta)) (H4 : perm m2 b2 (ofs + delta) k p) : perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty ->\nperm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 : block) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H1 : inject_incr f f') (H2 : mem_inj f' m1 m2) : inject_incr f f'.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) : exists f' : meminj,\n  inject f' m1' m2 /\\\n  inject_incr f f' /\\\n  f' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> f' b = f b).","proofString":"inversion H.\nset (f' := fun b => if eq_block b b1 then Some(b2, delta) else f b).\nassert (inject_incr f f').\nred; unfold f'; intros.\ndestruct (eq_block b b1).\nsubst b.\nassert (f b1 = None).\neauto with mem.\ncongruence.\nauto.\nassert (mem_inj f' m1 m2).\ninversion mi_inj0; constructor; eauto with mem.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neapply perm_valid_block with (ofs := ofs).\napply H9.\ngeneralize (size_chunk_pos chunk); lia.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem.\napply memval_inject_incr with f; auto.\nexists f'.\nsplit.\nconstructor.\neapply alloc_left_mapped_inj; eauto.\nunfold f'; apply dec_eq_true.\nunfold f'; intros.\ndestruct (eq_block b b1).\nsubst b.\nelim H9.\neauto with mem.\neauto with mem.\nunfold f'; intros.\ndestruct (eq_block b b1).\ncongruence.\neauto.\nunfold f'; red; intros.\nexploit perm_alloc_inv.\neauto.\neexact H12.\nintros P1.\nexploit perm_alloc_inv.\neauto.\neexact H13.\nintros P2.\ndestruct (eq_block b0 b1); destruct (eq_block b3 b1).\ncongruence.\ninversion H10; subst b0 b1' delta1.\ndestruct (eq_block b2 b2'); auto.\nsubst b2'.\nright; red; intros.\neapply H6; eauto.\nlia.\ninversion H11; subst b3 b2' delta2.\ndestruct (eq_block b1' b2); auto.\nsubst b1'.\nright; red; intros.\neapply H6; eauto.\nlia.\neauto.\nunfold f'; intros.\ndestruct (eq_block b b1).\nsubst.\ninjection H9; intros; subst b' delta0.\ndestruct H10.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\neapply mi_representable0; try eassumption.\ndestruct H10; eauto using perm_alloc_4.\nintros.\nunfold f' in H9; destruct (eq_block b0 b1).\ninversion H9; clear H9; subst b0 b3 delta0.\nassert (EITHER: lo <= ofs < hi \\/ ~(lo <= ofs < hi)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; intros A.\neapply perm_alloc_inv in A; eauto.\nrewrite dec_eq_true in A.\ntauto.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_alloc_1, perm_alloc_4.\nsplit.\nauto.\nsplit.\nunfold f'; apply dec_eq_true.\nintros.\nunfold f'; apply dec_eq_false; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) : exists f' : meminj,\n  inject f' m1' m2 /\\\n  inject_incr f f' /\\\n  f' b1 = Some (b2, delta) /\\ (forall b : block, b <> b1 -> f' b = f b).","proofString":"set (f' := fun b => if eq_block b b1 then Some(b2, delta) else f b).\nassert (inject_incr f f').\nred; unfold f'; intros.\ndestruct (eq_block b b1).\nsubst b.\nassert (f b1 = None).\neauto with mem.\ncongruence.\nauto.\nassert (mem_inj f' m1 m2).\ninversion mi_inj0; constructor; eauto with mem.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neapply perm_valid_block with (ofs := ofs).\napply H9.\ngeneralize (size_chunk_pos chunk); lia.\neauto.\nunfold f'; intros.\ndestruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem.\napply memval_inject_incr with f; auto.\nexists f'.\nsplit.\nconstructor.\neapply alloc_left_mapped_inj; eauto.\nunfold f'; apply dec_eq_true.\nunfold f'; intros.\ndestruct (eq_block b b1).\nsubst b.\nelim H9.\neauto with mem.\neauto with mem.\nunfold f'; intros.\ndestruct (eq_block b b1).\ncongruence.\neauto.\nunfold f'; red; intros.\nexploit perm_alloc_inv.\neauto.\neexact H12.\nintros P1.\nexploit perm_alloc_inv.\neauto.\neexact H13.\nintros P2.\ndestruct (eq_block b0 b1); destruct (eq_block b3 b1).\ncongruence.\ninversion H10; subst b0 b1' delta1.\ndestruct (eq_block b2 b2'); auto.\nsubst b2'.\nright; red; intros.\neapply H6; eauto.\nlia.\ninversion H11; subst b3 b2' delta2.\ndestruct (eq_block b1' b2); auto.\nsubst b1'.\nright; red; intros.\neapply H6; eauto.\nlia.\neauto.\nunfold f'; intros.\ndestruct (eq_block b b1).\nsubst.\ninjection H9; intros; subst b' delta0.\ndestruct H10.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\neapply mi_representable0; try eassumption.\ndestruct H10; eauto using perm_alloc_4.\nintros.\nunfold f' in H9; destruct (eq_block b0 b1).\ninversion H9; clear H9; subst b0 b3 delta0.\nassert (EITHER: lo <= ofs < hi \\/ ~(lo <= ofs < hi)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; intros A.\neapply perm_alloc_inv in A; eauto.\nrewrite dec_eq_true in A.\ntauto.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_alloc_1, perm_alloc_4.\nsplit.\nauto.\nsplit.\nunfold f'; apply dec_eq_true.\nintros.\nunfold f'; apply dec_eq_false; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b b' : block) (delta0 : Z) (H7 : f b = Some (b', delta0)) : (if eq_block b b1 then Some (b2, delta) else f b) = Some (b', delta0).","proofString":"destruct (eq_block b b1).\nsubst b.\nassert (f b1 = None).\neauto with mem.\ncongruence.\nauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b b' : block) (delta0 : Z) (H7 : f b = Some (b', delta0)) (e : b = b1) : Some (b2, delta) = Some (b', delta0).","proofString":"subst b.\nassert (f b1 = None).\neauto with mem.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta1 : Z),\nf b = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b = Some (b'0, delta1) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b' : block) (delta0 : Z) (H7 : f b1 = Some (b', delta0)) : Some (b2, delta) = Some (b', delta0).","proofString":"assert (f b1 = None).\neauto with mem.\ncongruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta1 : Z),\nf b = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b = Some (b'0, delta1) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b' : block) (delta0 : Z) (H7 : f b1 = Some (b', delta0)) : f b1 = None.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta1 : Z),\nf b = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b = Some (b'0, delta1) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b' : block) (delta0 : Z) (H7 : f b1 = Some (b', delta0)) (H8 : f b1 = None) : Some (b2, delta) = Some (b', delta0).","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (b b' : block) (delta0 : Z) (H7 : f b = Some (b', delta0)) (n : b <> b1) : f b = Some (b', delta0).","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H8 : (if eq_block b0 b1 then Some (b2, delta) else f b0) = Some (b3, delta0)) (H9 : perm m1 b0 ofs k p) : perm m2 b3 (ofs + delta0) k p.","proofString":"destruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (e : b0 = b1) (H8 : Some (b2, delta) = Some (b3, delta0)) (H9 : perm m1 b0 ofs k p) : perm m2 b3 (ofs + delta0) k p.","proofString":"inversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (e : b0 = b1) (H8 : Some (b2, delta) = Some (b3, delta0)) (H9 : perm m1 b0 ofs k p) (H11 : b2 = b3) (H12 : delta = delta0) : perm m2 b3 (ofs + delta0) k p.","proofString":"subst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (ofs : Z) (k : perm_kind) (p : permission) (H8 : Some (b2, delta) = Some (b2, delta)) (H9 : perm m1 b1 ofs k p) : perm m2 b2 (ofs + delta) k p.","proofString":"elim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (ofs : Z) (k : perm_kind) (p : permission) (H8 : Some (b2, delta) = Some (b2, delta)) (H9 : perm m1 b1 ofs k p) : valid_block m1 b1.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k0 p0 -> perm m2 b5 (ofs0 + delta1) k0 p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (n : b0 <> b1) (H8 : f b0 = Some (b3, delta0)) (H9 : perm m1 b0 ofs k p) : perm m2 b3 (ofs + delta0) k p.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k p0 ->\nperm m1 b4 ofs0 k p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H8 : (if eq_block b0 b1 then Some (b2, delta) else f b0) = Some (b3, delta0)) (H9 : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta0).","proofString":"destruct (eq_block b0 b1).\ninversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neapply perm_valid_block with (ofs := ofs).\napply H9.\ngeneralize (size_chunk_pos chunk); lia.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k p0 ->\nperm m1 b4 ofs0 k p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (e : b0 = b1) (H8 : Some (b2, delta) = Some (b3, delta0)) (H9 : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta0).","proofString":"inversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neapply perm_valid_block with (ofs := ofs).\napply H9.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k p0 ->\nperm m1 b4 ofs0 k p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (e : b0 = b1) (H8 : Some (b2, delta) = Some (b3, delta0)) (H9 : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p) (H11 : b2 = b3) (H12 : delta = delta0) : (align_chunk chunk | delta0).","proofString":"subst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neapply perm_valid_block with (ofs := ofs).\napply H9.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p0 ->\nperm m1 b0 ofs0 k p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (chunk : memory_chunk) (ofs : Z) (p : permission) (H8 : Some (b2, delta) = Some (b2, delta)) (H9 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"elim (fresh_block_alloc _ _ _ _ _ H0).\neapply perm_valid_block with (ofs := ofs).\napply H9.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p0 ->\nperm m1 b0 ofs0 k p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (chunk : memory_chunk) (ofs : Z) (p : permission) (H8 : Some (b2, delta) = Some (b2, delta)) (H9 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) : valid_block m1 b1.","proofString":"eapply perm_valid_block with (ofs := ofs).\napply H9.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p0 ->\nperm m1 b0 ofs0 k p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta0) k p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (chunk : memory_chunk) (ofs : Z) (p : permission) (H8 : Some (b2, delta) = Some (b2, delta)) (H9 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) : ofs <= ofs < ofs + size_chunk chunk.","proofString":"generalize (size_chunk_pos chunk); lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k p0 ->\nperm m1 b4 ofs0 k p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p0 -> perm m2 b5 (ofs0 + delta1) k p0) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (n : b0 <> b1) (H8 : f b0 = Some (b3, delta0)) (H9 : range_perm m1 b0 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta0).","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k p ->\nperm m1 b4 ofs0 k p \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (e : b0 = b1) (H8 : Some (b2, delta) = Some (b3, delta0)) (H9 : perm m1 b0 ofs Cur Readable) : memval_inject\n  (fun b : positive => if eq_block b b1 then Some (b2, delta) else f b)\n  (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"inversion H8.\nsubst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k p ->\nperm m1 b4 ofs0 k p \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b4 b5 : block) (delta1 ofs0 : Z) (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 k p -> perm m2 b5 (ofs0 + delta1) k p) (mi_align0 : forall (b4 b5 : block) (delta1 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b4 = Some (b5, delta1) ->\nrange_perm m1 b4 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta1)) (mi_memval0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z),\nf b4 = Some (b5, delta1) ->\nperm m1 b4 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b4)\n  (ZMap.get (ofs0 + delta1) (mem_contents m2) # b5)) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (e : b0 = b1) (H8 : Some (b2, delta) = Some (b3, delta0)) (H9 : perm m1 b0 ofs Cur Readable) (H11 : b2 = b3) (H12 : delta = delta0) : memval_inject\n  (fun b : positive => if eq_block b b1 then Some (b3, delta0) else f b)\n  (ZMap.get ofs (mem_contents m1) # b0)\n  (ZMap.get (ofs + delta0) (mem_contents m2) # b3).","proofString":"subst b0 b3 delta0.\nelim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (ofs : Z) (H8 : Some (b2, delta) = Some (b2, delta)) (H9 : perm m1 b1 ofs Cur Readable) : memval_inject\n  (fun b : positive => if eq_block b b1 then Some (b2, delta) else f b)\n  (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m2) # b2).","proofString":"elim (fresh_block_alloc _ _ _ _ _ H0).\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (ofs : Z) (H8 : Some (b2, delta) = Some (b2, delta)) (H9 : perm m1 b1 ofs Cur Readable) : valid_block m1 b1.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b : block) (H9 : ~ valid_block m1' b) : (if eq_block b b1 then Some (b2, delta) else f b) = None.","proofString":"destruct (eq_block b b1).\nsubst b.\nelim H9.\neauto with mem.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b : block) (H9 : ~ valid_block m1' b) (e : b = b1) : Some (b2, delta) = None.","proofString":"subst b.\nelim H9.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (H9 : ~ valid_block m1' b1) : Some (b2, delta) = None.","proofString":"elim H9.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (H9 : ~ valid_block m1' b1) : valid_block m1' b1.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b : block) (H9 : ~ valid_block m1' b) (n : b <> b1) : f b = None.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b b' : block) (delta0 : Z) (H9 : (if eq_block b b1 then Some (b2, delta) else f b) = Some (b', delta0)) : valid_block m2 b'.","proofString":"destruct (eq_block b b1).\ncongruence.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b b' : block) (delta0 : Z) (e : b = b1) (H9 : Some (b2, delta) = Some (b', delta0)) : valid_block m2 b'.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs + delta1) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b b' : block) (delta0 : Z) (n : b <> b1) (H9 : f b = Some (b', delta0)) : valid_block m2 b'.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs + delta0) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b0 <> b3) (H10 : (if eq_block b0 b1 then Some (b2, delta) else f b0) = Some (b1', delta1)) (H11 : (if eq_block b3 b1 then Some (b2, delta) else f b3) = Some (b2', delta2)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"exploit perm_alloc_inv.\neauto.\neexact H12.\nintros P1.\nexploit perm_alloc_inv.\neauto.\neexact H13.\nintros P2.\ndestruct (eq_block b0 b1); destruct (eq_block b3 b1).\ncongruence.\ninversion H10; subst b0 b1' delta1.\ndestruct (eq_block b2 b2'); auto.\nsubst b2'.\nright; red; intros.\neapply H6; eauto.\nlia.\ninversion H11; subst b3 b2' delta2.\ndestruct (eq_block b1' b2); auto.\nsubst b1'.\nright; red; intros.\neapply H6; eauto.\nlia.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs + delta0) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b0 <> b3) (H10 : (if eq_block b0 b1 then Some (b2, delta) else f b0) = Some (b1', delta1)) (H11 : (if eq_block b3 b1 then Some (b2, delta) else f b3) = Some (b2', delta2)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : if eq_block b0 b1 then lo <= ofs1 < hi else perm m1 b0 ofs1 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"exploit perm_alloc_inv.\neauto.\neexact H13.\nintros P2.\ndestruct (eq_block b0 b1); destruct (eq_block b3 b1).\ncongruence.\ninversion H10; subst b0 b1' delta1.\ndestruct (eq_block b2 b2'); auto.\nsubst b2'.\nright; red; intros.\neapply H6; eauto.\nlia.\ninversion H11; subst b3 b2' delta2.\ndestruct (eq_block b1' b2); auto.\nsubst b1'.\nright; red; intros.\neapply H6; eauto.\nlia.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs + delta0) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b0 <> b3) (H10 : (if eq_block b0 b1 then Some (b2, delta) else f b0) = Some (b1', delta1)) (H11 : (if eq_block b3 b1 then Some (b2, delta) else f b3) = Some (b2', delta2)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : if eq_block b0 b1 then lo <= ofs1 < hi else perm m1 b0 ofs1 Max Nonempty) (P2 : if eq_block b3 b1 then lo <= ofs2 < hi else perm m1 b3 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"destruct (eq_block b0 b1); destruct (eq_block b3 b1).\ncongruence.\ninversion H10; subst b0 b1' delta1.\ndestruct (eq_block b2 b2'); auto.\nsubst b2'.\nright; red; intros.\neapply H6; eauto.\nlia.\ninversion H11; subst b3 b2' delta2.\ndestruct (eq_block b1' b2); auto.\nsubst b1'.\nright; red; intros.\neapply H6; eauto.\nlia.\neauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs + delta0) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b0 <> b3) (e : b0 = b1) (H10 : Some (b2, delta) = Some (b1', delta1)) (e0 : b3 = b1) (H11 : Some (b2, delta) = Some (b2', delta2)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : lo <= ofs1 < hi) (P2 : lo <= ofs2 < hi) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs + delta0) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b0 <> b3) (e : b0 = b1) (H10 : Some (b2, delta) = Some (b1', delta1)) (n : b3 <> b1) (H11 : f b3 = Some (b2', delta2)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : lo <= ofs1 < hi) (P2 : perm m1 b3 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"inversion H10; subst b0 b1' delta1.\ndestruct (eq_block b2 b2'); auto.\nsubst b2'.\nright; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b1 <> b3) (H10 : Some (b2, delta) = Some (b2, delta)) (n : b3 <> b1) (H11 : f b3 = Some (b2', delta2)) (H12 : perm m1' b1 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : lo <= ofs1 < hi) (P2 : perm m1 b3 ofs2 Max Nonempty) : b2 <> b2' \\/ ofs1 + delta <> ofs2 + delta2.","proofString":"destruct (eq_block b2 b2'); auto.\nsubst b2'.\nright; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b1 <> b3) (H10 : Some (b2, delta) = Some (b2, delta)) (n : b3 <> b1) (H11 : f b3 = Some (b2', delta2)) (H12 : perm m1' b1 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : lo <= ofs1 < hi) (P2 : perm m1 b3 ofs2 Max Nonempty) (e : b2 = b2') : b2 <> b2' \\/ ofs1 + delta <> ofs2 + delta2.","proofString":"subst b2'.\nright; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b3 : block) (delta2 ofs1 ofs2 : Z) (H9 : b1 <> b3) (H10 : Some (b2, delta) = Some (b2, delta)) (n : b3 <> b1) (H11 : f b3 = Some (b2, delta2)) (H12 : perm m1' b1 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : lo <= ofs1 < hi) (P2 : perm m1 b3 ofs2 Max Nonempty) : b2 <> b2 \\/ ofs1 + delta <> ofs2 + delta2.","proofString":"right; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b3 : block) (delta2 ofs1 ofs2 : Z) (H9 : b1 <> b3) (H10 : Some (b2, delta) = Some (b2, delta)) (n : b3 <> b1) (H11 : f b3 = Some (b2, delta2)) (H12 : perm m1' b1 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : lo <= ofs1 < hi) (P2 : perm m1 b3 ofs2 Max Nonempty) (H14 : ofs1 + delta = ofs2 + delta2) : False.","proofString":"eapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b3 : block) (delta2 ofs1 ofs2 : Z) (H9 : b1 <> b3) (H10 : Some (b2, delta) = Some (b2, delta)) (n : b3 <> b1) (H11 : f b3 = Some (b2, delta2)) (H12 : perm m1' b1 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : lo <= ofs1 < hi) (P2 : perm m1 b3 ofs2 Max Nonempty) (H14 : ofs1 + delta = ofs2 + delta2) : lo + delta <= ofs2 + delta2 < hi + delta.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs + delta0) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b0 <> b3) (n : b0 <> b1) (H10 : f b0 = Some (b1', delta1)) (e : b3 = b1) (H11 : Some (b2, delta) = Some (b2', delta2)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : perm m1 b0 ofs1 Max Nonempty) (P2 : lo <= ofs2 < hi) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"inversion H11; subst b3 b2' delta2.\ndestruct (eq_block b1' b2); auto.\nsubst b1'.\nright; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b3 ofs k p \\/ ~ perm m1 b3 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 ofs1 ofs2 : Z) (H9 : b0 <> b1) (n : b0 <> b1) (H10 : f b0 = Some (b1', delta1)) (H11 : Some (b2, delta) = Some (b2, delta)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b1 ofs2 Max Nonempty) (P1 : perm m1 b0 ofs1 Max Nonempty) (P2 : lo <= ofs2 < hi) : b1' <> b2 \\/ ofs1 + delta1 <> ofs2 + delta.","proofString":"destruct (eq_block b1' b2); auto.\nsubst b1'.\nright; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b3 ofs k p \\/ ~ perm m1 b3 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 ofs1 ofs2 : Z) (H9 : b0 <> b1) (n : b0 <> b1) (H10 : f b0 = Some (b1', delta1)) (H11 : Some (b2, delta) = Some (b2, delta)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b1 ofs2 Max Nonempty) (P1 : perm m1 b0 ofs1 Max Nonempty) (P2 : lo <= ofs2 < hi) (e : b1' = b2) : b1' <> b2 \\/ ofs1 + delta1 <> ofs2 + delta.","proofString":"subst b1'.\nright; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b3 ofs k p \\/ ~ perm m1 b3 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 : block) (delta1 ofs1 ofs2 : Z) (H9 : b0 <> b1) (n : b0 <> b1) (H10 : f b0 = Some (b2, delta1)) (H11 : Some (b2, delta) = Some (b2, delta)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b1 ofs2 Max Nonempty) (P1 : perm m1 b0 ofs1 Max Nonempty) (P2 : lo <= ofs2 < hi) : b2 <> b2 \\/ ofs1 + delta1 <> ofs2 + delta.","proofString":"right; red; intros.\neapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b3 ofs k p \\/ ~ perm m1 b3 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 : block) (delta1 ofs1 ofs2 : Z) (H9 : b0 <> b1) (n : b0 <> b1) (H10 : f b0 = Some (b2, delta1)) (H11 : Some (b2, delta) = Some (b2, delta)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b1 ofs2 Max Nonempty) (P1 : perm m1 b0 ofs1 Max Nonempty) (P2 : lo <= ofs2 < hi) (H14 : ofs1 + delta1 = ofs2 + delta) : False.","proofString":"eapply H6; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b3 : block) (ofs : Z) (b4 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b3 = Some (b4, delta0) ->\nperm m2 b4 (ofs + delta0) k p ->\nperm m1 b3 ofs k p \\/ ~ perm m1 b3 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 : block) (delta1 ofs1 ofs2 : Z) (H9 : b0 <> b1) (n : b0 <> b1) (H10 : f b0 = Some (b2, delta1)) (H11 : Some (b2, delta) = Some (b2, delta)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b1 ofs2 Max Nonempty) (P1 : perm m1 b0 ofs1 Max Nonempty) (P2 : lo <= ofs2 < hi) (H14 : ofs1 + delta1 = ofs2 + delta) : lo + delta <= ofs1 + delta1 < hi + delta.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs : Z) (b5 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b4 = Some (b5, delta0) ->\nperm m2 b5 (ofs + delta0) k p ->\nperm m1 b4 ofs k p \\/ ~ perm m1 b4 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 b1' : block) (delta1 : Z) (b3 b2' : block) (delta2 ofs1 ofs2 : Z) (H9 : b0 <> b3) (n : b0 <> b1) (H10 : f b0 = Some (b1', delta1)) (n0 : b3 <> b1) (H11 : f b3 = Some (b2', delta2)) (H12 : perm m1' b0 ofs1 Max Nonempty) (H13 : perm m1' b3 ofs2 Max Nonempty) (P1 : perm m1 b0 ofs1 Max Nonempty) (P2 : perm m1 b3 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs0 + delta1) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b b' : block) (delta0 : Z) (ofs : ptrofs) (H9 : (if eq_block b b1 then Some (b2, delta) else f b) = Some (b', delta0)) (H10 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned.","proofString":"destruct (eq_block b b1).\nsubst.\ninjection H9; intros; subst b' delta0.\ndestruct H10.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\neapply mi_representable0; try eassumption.\ndestruct H10; eauto using perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs0 + delta1) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b b' : block) (delta0 : Z) (ofs : ptrofs) (e : b = b1) (H9 : Some (b2, delta) = Some (b', delta0)) (H10 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned.","proofString":"subst.\ninjection H9; intros; subst b' delta0.\ndestruct H10.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta1 : Z),\nf b = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs0 + delta1) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b' : block) (delta0 : Z) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b', delta0)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b1 (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned.","proofString":"injection H9; intros; subst b' delta0.\ndestruct H10.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b2, delta)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b1 (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"destruct H10.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia.\nexploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b2, delta)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"exploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b2, delta)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs) Max Nonempty) (H11 : lo <= Ptrofs.unsigned ofs < hi) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"exploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b2, delta)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs) Max Nonempty) (H11 : lo <= Ptrofs.unsigned ofs < hi) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned ->\ndelta = 0 \\/ 0 <= Ptrofs.unsigned ofs + delta < Ptrofs.max_unsigned ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b2, delta)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"exploit perm_alloc_inv; eauto; rewrite dec_eq_true; intro.\nexploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b2, delta)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs - 1) Max Nonempty) (H11 : lo <= Ptrofs.unsigned ofs - 1 < hi) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"exploit H3.\napply H4 with (k := Max) (p := Nonempty); eauto.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : ptrofs) (H9 : Some (b2, delta) = Some (b2, delta)) (H10 : perm m1' b1 (Ptrofs.unsigned ofs - 1) Max Nonempty) (H11 : lo <= Ptrofs.unsigned ofs - 1 < hi) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned ->\ndelta = 0 \\/ 0 <= Ptrofs.unsigned ofs - 1 + delta < Ptrofs.max_unsigned ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs0 + delta1) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b b' : block) (delta0 : Z) (ofs : ptrofs) (n : b <> b1) (H9 : f b = Some (b', delta0)) (H10 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; try eassumption.\ndestruct H10; eauto using perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs0 k p -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b0 : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta') ->\nperm m1 b0 ofs0 k p -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta1 : Z),\nf b0 = Some (b'0, delta1) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta1 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta1) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta1 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta1) ->\nperm m2 b3 (ofs0 + delta1) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b b' : block) (delta0 : Z) (ofs : ptrofs) (n : b <> b1) (H9 : f b = Some (b', delta0)) (H10 : perm m1' b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b (Ptrofs.unsigned ofs - 1) Max Nonempty) : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty.","proofString":"destruct H10; eauto using perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (k : perm_kind) (p : permission) (e : b0 = b1) (H9 : Some (b2, delta) = Some (b3, delta0)) (H10 : perm m2 b3 (ofs + delta0) k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"inversion H9; clear H9; subst b0 b3 delta0.\nassert (EITHER: lo <= ofs < hi \\/ ~(lo <= ofs < hi)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; intros A.\neapply perm_alloc_inv in A; eauto.\nrewrite dec_eq_true in A.\ntauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) : perm m1' b1 ofs k p \\/ ~ perm m1' b1 ofs Max Nonempty.","proofString":"assert (EITHER: lo <= ofs < hi \\/ ~(lo <= ofs < hi)) by lia.\ndestruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; intros A.\neapply perm_alloc_inv in A; eauto.\nrewrite dec_eq_true in A.\ntauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (EITHER : lo <= ofs < hi \\/ ~ lo <= ofs < hi) : perm m1' b1 ofs k p \\/ ~ perm m1' b1 ofs Max Nonempty.","proofString":"destruct EITHER.\nleft.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nright; intros A.\neapply perm_alloc_inv in A; eauto.\nrewrite dec_eq_true in A.\ntauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (H9 : lo <= ofs < hi) : perm m1' b1 ofs k p \\/ ~ perm m1' b1 ofs Max Nonempty.","proofString":"left.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (H9 : lo <= ofs < hi) : perm m1' b1 ofs k p.","proofString":"apply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (H9 : lo <= ofs < hi) : perm m1' b1 ofs k Freeable.","proofString":"eapply perm_alloc_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (H9 : ~ lo <= ofs < hi) : perm m1' b1 ofs k p \\/ ~ perm m1' b1 ofs Max Nonempty.","proofString":"right; intros A.\neapply perm_alloc_inv in A; eauto.\nrewrite dec_eq_true in A.\ntauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (H9 : ~ lo <= ofs < hi) (A : perm m1' b1 ofs Max Nonempty) : False.","proofString":"eapply perm_alloc_inv in A; eauto.\nrewrite dec_eq_true in A.\ntauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (H9 : ~ lo <= ofs < hi) (A : if eq_block b1 b1 then lo <= ofs < hi else perm m1 b1 ofs Max Nonempty) : False.","proofString":"rewrite dec_eq_true in A.\ntauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (ofs : Z) (k : perm_kind) (p : permission) (H10 : perm m2 b2 (ofs + delta) k p) (H9 : ~ lo <= ofs < hi) (A : lo <= ofs < hi) : False.","proofString":"tauto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (k : perm_kind) (p : permission) (n : b0 <> b1) (H9 : f b0 = Some (b3, delta0)) (H10 : perm m2 b3 (ofs + delta0) k p) : perm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto.\nintuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b2 ofs0 k0 p0 -> delta = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned) (H4 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nlo <= ofs0 < hi -> perm m2 b2 (ofs0 + delta) k0 p0) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs0 k0 p0 -> lo + delta <= ofs0 + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta1 : Z),\nf b = Some (b', delta1) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta1 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta1) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta1 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b4 : block) (ofs0 : Z) (b5 : block) (delta1 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b4 = Some (b5, delta1) ->\nperm m2 b5 (ofs0 + delta1) k0 p0 ->\nperm m1 b4 ofs0 k0 p0 \\/ ~ perm m1 b4 ofs0 Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) (k : perm_kind) (p : permission) (n : b0 <> b1) (H9 : f b0 = Some (b3, delta0)) (H10 : perm m2 b3 (ofs + delta0) k p) : perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty ->\nperm m1' b0 ofs k p \\/ ~ perm m1' b0 ofs Max Nonempty.","proofString":"intuition eauto using perm_alloc_1, perm_alloc_4."},{"statement":"(f : meminj) (m1 m2 : mem) (lo hi : Z) (m1' : mem') (b1 b2 : block) (delta : Z) (H : inject f m1 m2) (H0 : alloc m1 lo hi = (m1', b1)) (H1 : valid_block m2 b2) (H2 : 0 <= delta <= Ptrofs.max_unsigned) (H3 : forall (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b2 ofs k p -> delta = 0 \\/ 0 <= ofs < Ptrofs.max_unsigned) (H4 : forall (ofs : Z) (k : perm_kind) (p : permission),\nlo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) (H5 : inj_offset_aligned delta (hi - lo)) (H6 : forall (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission),\nf b = Some (b2, delta') ->\nperm m1 b ofs k p -> lo + delta <= ofs + delta' < hi + delta -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (f' : positive -> option (block * Z)) (H7 : inject_incr f f') (H8 : mem_inj f' m1 m2) : inject_incr f f'.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) : exists (f' : meminj) (m2' : mem') (b2 : block),\n  alloc m2 lo2 hi2 = (m2', b2) /\\\n  inject f' m1' m2' /\\\n  inject_incr f f' /\\\n  f' b1 = Some (b2, 0) /\\ (forall b : block, b <> b1 -> f' b = f b).","proofString":"case_eq (alloc m2 lo2 hi2).\nintros m2' b2 ALLOC.\nexploit alloc_left_mapped_inject.\neapply alloc_right_inject; eauto.\neauto.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := 0).\nunfold Ptrofs.max_unsigned.\ngeneralize Ptrofs.modulus_pos; lia.\nauto.\nintros.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nred; intros.\napply Z.divide_0_r.\nintros.\napply (valid_not_valid_diff m2 b2 b2); eauto with mem.\nintros [f' [A [B [C D]]]].\nexists f'; exists m2'; exists b2; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) : forall (m : mem') (b : block),\nalloc m2 lo2 hi2 = (m, b) ->\nexists (f' : meminj) (m2' : mem') (b2 : block),\n  (m, b) = (m2', b2) /\\\n  inject f' m1' m2' /\\\n  inject_incr f f' /\\\n  f' b1 = Some (b2, 0) /\\ (forall b0 : block, b0 <> b1 -> f' b0 = f b0).","proofString":"intros m2' b2 ALLOC.\nexploit alloc_left_mapped_inject.\neapply alloc_right_inject; eauto.\neauto.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := 0).\nunfold Ptrofs.max_unsigned.\ngeneralize Ptrofs.modulus_pos; lia.\nauto.\nintros.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nred; intros.\napply Z.divide_0_r.\nintros.\napply (valid_not_valid_diff m2 b2 b2); eauto with mem.\nintros [f' [A [B [C D]]]].\nexists f'; exists m2'; exists b2; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) : exists (f' : meminj) (m2'0 : mem') (b0 : block),\n  (m2', b2) = (m2'0, b0) /\\\n  inject f' m1' m2'0 /\\\n  inject_incr f f' /\\\n  f' b1 = Some (b0, 0) /\\ (forall b : block, b <> b1 -> f' b = f b).","proofString":"exploit alloc_left_mapped_inject.\neapply alloc_right_inject; eauto.\neauto.\ninstantiate (1 := b2).\neauto with mem.\ninstantiate (1 := 0).\nunfold Ptrofs.max_unsigned.\ngeneralize Ptrofs.modulus_pos; lia.\nauto.\nintros.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nred; intros.\napply Z.divide_0_r.\nintros.\napply (valid_not_valid_diff m2 b2 b2); eauto with mem.\nintros [f' [A [B [C D]]]].\nexists f'; exists m2'; exists b2; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) : valid_block m2' b2.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) : 0 <= 0 <= Ptrofs.max_unsigned.","proofString":"unfold Ptrofs.max_unsigned.\ngeneralize Ptrofs.modulus_pos; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) : 0 <= 0 <= Ptrofs.modulus - 1.","proofString":"generalize Ptrofs.modulus_pos; lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) (ofs : Z) (k : perm_kind) (p : permission) (H3 : lo1 <= ofs < hi1) : perm m2' b2 (ofs + 0) k p.","proofString":"apply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) (ofs : Z) (k : perm_kind) (p : permission) (H3 : lo1 <= ofs < hi1) : perm m2' b2 (ofs + 0) k Freeable.","proofString":"eapply perm_alloc_2; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) (ofs : Z) (k : perm_kind) (p : permission) (H3 : lo1 <= ofs < hi1) : lo2 <= ofs + 0 < hi2.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) (chunk : memory_chunk) (H3 : size_chunk chunk <= hi1 - lo1) : (align_chunk chunk | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) (b : block) (delta' ofs : Z) (k : perm_kind) (p : permission) (H3 : f b = Some (b2, delta')) (H4 : perm m1 b ofs k p) (H5 : lo1 + 0 <= ofs + delta' < hi1 + 0) : False.","proofString":"apply (valid_not_valid_diff m2 b2 b2); eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (lo1 hi1 : Z) (m1' : mem') (b1 : block) (lo2 hi2 : Z) (H : inject f m1 m2) (H0 : alloc m1 lo1 hi1 = (m1', b1)) (H1 : lo2 <= lo1) (H2 : hi1 <= hi2) (m2' : mem') (b2 : block) (ALLOC : alloc m2 lo2 hi2 = (m2', b2)) (f' : meminj) (A : inject f' m1' m2') (B : inject_incr f f') (C : f' b1 = Some (b2, 0)) (D : forall b : block, b <> b1 -> f' b = f b) : exists (f'0 : meminj) (m2'0 : mem') (b0 : block),\n  (m2', b2) = (m2'0, b0) /\\\n  inject f'0 m1' m2'0 /\\\n  inject_incr f f'0 /\\\n  f'0 b1 = Some (b0, 0) /\\ (forall b : block, b <> b1 -> f'0 b = f b).","proofString":"exists f'; exists m2'; exists b2; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') : inject f m1' m2.","proofString":"inversion H.\nconstructor.\neapply free_left_inj; eauto.\neauto with mem.\nauto.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable0; try eassumption.\ndestruct H2; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_free_3.\neapply perm_free_inv in H4; eauto.\ndestruct H4 as [[A B] | A]; auto.\nsubst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : inject f m1' m2.","proofString":"constructor.\neapply free_left_inj; eauto.\neauto with mem.\nauto.\nred; intros.\neauto with mem.\nintros.\neapply mi_representable0; try eassumption.\ndestruct H2; eauto with mem.\nintros.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_free_3.\neapply perm_free_inv in H4; eauto.\ndestruct H4 as [[A B] | A]; auto.\nsubst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : mem_inj f m1' m2.","proofString":"eapply free_left_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall b0 : block, ~ valid_block m1' b0 -> f b0 = None.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b'.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : meminj_no_overlap f m1'.","proofString":"red; intros.\neauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H1 : b1 <> b2) (H2 : f b1 = Some (b1', delta1)) (H3 : f b2 = Some (b2', delta2)) (H4 : perm m1' b1 ofs1 Max Nonempty) (H5 : perm m1' b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1' b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"intros.\neapply mi_representable0; try eassumption.\ndestruct H2; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b1 : block, ~ valid_block m1 b1 -> f b1 = None) (mi_mappedblocks0 : forall (b1 b'0 : block) (delta0 : Z),\nf b1 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b1 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b1 = Some (b'0, delta0) ->\nperm m1 b1 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 b' : block) (delta : Z) (ofs : ptrofs) (H1 : f b0 = Some (b', delta)) (H2 : perm m1' b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b0 (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; try eassumption.\ndestruct H2; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b1 : block, ~ valid_block m1 b1 -> f b1 = None) (mi_mappedblocks0 : forall (b1 b'0 : block) (delta0 : Z),\nf b1 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b1 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b1 = Some (b'0, delta0) ->\nperm m1 b1 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) (b0 b' : block) (delta : Z) (ofs : ptrofs) (H1 : f b0 = Some (b', delta)) (H2 : perm m1' b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1' b0 (Ptrofs.unsigned ofs - 1) Max Nonempty) : perm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty.","proofString":"destruct H2; eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1' b1 ofs k p \\/ ~ perm m1' b1 ofs Max Nonempty.","proofString":"intros.\nexploit mi_perm_inv0; eauto.\nintuition eauto using perm_free_3.\neapply perm_free_inv in H4; eauto.\ndestruct H4 as [[A B] | A]; auto.\nsubst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : perm m2 b2 (ofs + delta) k p) : perm m1' b1 ofs k p \\/ ~ perm m1' b1 ofs Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto.\nintuition eauto using perm_free_3.\neapply perm_free_inv in H4; eauto.\ndestruct H4 as [[A B] | A]; auto.\nsubst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : perm m2 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty ->\nperm m1' b1 ofs k p \\/ ~ perm m1' b1 ofs Max Nonempty.","proofString":"intuition eauto using perm_free_3.\neapply perm_free_inv in H4; eauto.\ndestruct H4 as [[A B] | A]; auto.\nsubst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, (valid_block m1 b0 -> False) -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ (perm m1 b0 ofs0 Max Nonempty -> False)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : perm m2 b2 (ofs + delta) k p) (H4 : perm m1 b1 ofs k p) : perm m1' b1 ofs k p \\/ (perm m1' b1 ofs Max Nonempty -> False).","proofString":"eapply perm_free_inv in H4; eauto.\ndestruct H4 as [[A B] | A]; auto.\nsubst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, (valid_block m1 b0 -> False) -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ (perm m1 b0 ofs0 Max Nonempty -> False)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : perm m2 b2 (ofs + delta) k p) (H4 : b1 = b /\\ lo <= ofs < hi \\/ perm m1' b1 ofs k p) : perm m1' b1 ofs k p \\/ (perm m1' b1 ofs Max Nonempty -> False).","proofString":"destruct H4 as [[A B] | A]; auto.\nsubst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, (valid_block m1 b0 -> False) -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ (perm m1 b0 ofs0 Max Nonempty -> False)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b1 = Some (b2, delta)) (H2 : perm m2 b2 (ofs + delta) k p) (A : b1 = b) (B : lo <= ofs < hi) : perm m1' b1 ofs k p \\/ (perm m1' b1 ofs Max Nonempty -> False).","proofString":"subst b1.\nright; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, (valid_block m1 b0 -> False) -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b0 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b1 = Some (b0, delta0) ->\nperm m2 b0 (ofs0 + delta0) k0 p0 ->\nperm m1 b1 ofs0 k0 p0 \\/ (perm m1 b1 ofs0 Max Nonempty -> False)) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H1 : f b = Some (b2, delta)) (H2 : perm m2 b2 (ofs + delta) k p) (B : lo <= ofs < hi) : perm m1' b ofs k p \\/ (perm m1' b ofs Max Nonempty -> False).","proofString":"right; eapply perm_free_2; eauto."},{"statement":"(f : meminj) (m2 m1 m1' : mem) (H : inject f m1 m2) (H0 : Some m1 = Some m1') : inject f m1' m2.","proofString":"inv H0.\nauto."},{"statement":"(f : meminj) (m2 m1' : mem) (H : inject f m1' m2) : inject f m1' m2.","proofString":"auto."},{"statement":"(f : meminj) (m2 : mem) (a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m1'0 : mem,\ninject f m0 m2 -> free_list m0 l = Some m1'0 -> inject f m1'0 m2) (m1 m1' : mem) (H : inject f m1 m2) (H0 : (let (p0, hi) := a in\n let (b, lo) := p0 in\n match free m1 b lo hi with\n | Some m' => free_list m' l\n | None => None\n end) = Some m1') : inject f m1' m2.","proofString":"destruct a as [[b lo] hi].\ndestruct (free m1 b lo hi) as [m11|] eqn:E; try discriminate.\napply IHl with m11; auto.\neapply free_left_inject; eauto."},{"statement":"(f : meminj) (m2 : mem) (b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 m1'0 : mem,\ninject f m0 m2 -> free_list m0 l = Some m1'0 -> inject f m1'0 m2) (m1 m1' : mem) (H : inject f m1 m2) (H0 : match free m1 b lo hi with\n| Some m' => free_list m' l\n| None => None\nend = Some m1') : inject f m1' m2.","proofString":"destruct (free m1 b lo hi) as [m11|] eqn:E; try discriminate.\napply IHl with m11; auto.\neapply free_left_inject; eauto."},{"statement":"(f : meminj) (m2 : mem) (b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 m1'0 : mem,\ninject f m0 m2 -> free_list m0 l = Some m1'0 -> inject f m1'0 m2) (m1 m1' : mem) (H : inject f m1 m2) (m11 : mem) (E : free m1 b lo hi = Some m11) (H0 : free_list m11 l = Some m1') : inject f m1' m2.","proofString":"apply IHl with m11; auto.\neapply free_left_inject; eauto."},{"statement":"(f : meminj) (m2 : mem) (b : block) (lo hi : Z) (l : list (block * Z * Z)) (IHl : forall m0 m1'0 : mem,\ninject f m0 m2 -> free_list m0 l = Some m1'0 -> inject f m1'0 m2) (m1 m1' : mem) (H : inject f m1 m2) (m11 : mem) (E : free m1 b lo hi = Some m11) (H0 : free_list m11 l = Some m1') : inject f m11 m2.","proofString":"eapply free_left_inject; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) : inject f m1 m2'.","proofString":"inversion H.\nconstructor.\neapply free_right_inj; eauto.\nauto.\neauto with mem.\nauto.\nauto.\nintros.\neauto using perm_free_3."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : inject f m1 m2'.","proofString":"constructor.\neapply free_right_inj; eauto.\nauto.\neauto with mem.\nauto.\nauto.\nintros.\neauto using perm_free_3."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : mem_inj f m1 m2'.","proofString":"eapply free_right_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2' b'.","proofString":"eauto with mem."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : meminj_no_overlap f m1.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p -> lo <= ofs + delta < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2' b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"intros.\neauto using perm_free_3."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free m2 b lo hi = Some m2') (H1 : forall (b0 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> lo <= ofs0 + delta0 < hi -> False) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b2, delta)) (H3 : perm m2' b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eauto using perm_free_3."},{"statement":"(m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : Some m = Some m') (H0 : perm m' b ofs k p) : perm m b ofs k p /\\ (forall lo hi : Z, False -> lo <= ofs < hi -> False).","proofString":"inv H.\nauto."},{"statement":"(m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m' b ofs k p) : perm m' b ofs k p /\\ (forall lo hi : Z, False -> lo <= ofs < hi -> False).","proofString":"auto."},{"statement":"(a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo hi : Z, In (b0, lo, hi) l -> lo <= ofs0 < hi -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : (let (p0, hi) := a in\n let (b0, lo) := p0 in\n match free m b0 lo hi with\n | Some m'0 => free_list m'0 l\n | None => None\n end) = Some m') (H0 : perm m' b ofs k p) : perm m b ofs k p /\\\n(forall lo hi : Z,\n a = (b, lo, hi) \\/ In (b, lo, hi) l -> lo <= ofs < hi -> False).","proofString":"destruct a as [[b1 lo1] hi1].\ndestruct (free m b1 lo1 hi1) as [m1|] eqn:E; try discriminate.\nexploit IHl; eauto.\nintros [A B].\nsplit.\neauto with mem.\nintros.\ndestruct H1.\ninv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto.\neauto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo hi : Z, In (b0, lo, hi) l -> lo <= ofs0 < hi -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : match free m b1 lo1 hi1 with\n| Some m'0 => free_list m'0 l\n| None => None\nend = Some m') (H0 : perm m' b ofs k p) : perm m b ofs k p /\\\n(forall lo hi : Z,\n (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l -> lo <= ofs < hi -> False).","proofString":"destruct (free m b1 lo1 hi1) as [m1|] eqn:E; try discriminate.\nexploit IHl; eauto.\nintros [A B].\nsplit.\neauto with mem.\nintros.\ndestruct H1.\ninv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto.\neauto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo hi : Z, In (b0, lo, hi) l -> lo <= ofs0 < hi -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) : perm m b ofs k p /\\\n(forall lo hi : Z,\n (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l -> lo <= ofs < hi -> False).","proofString":"exploit IHl; eauto.\nintros [A B].\nsplit.\neauto with mem.\nintros.\ndestruct H1.\ninv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto.\neauto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo hi : Z, In (b0, lo, hi) l -> lo <= ofs0 < hi -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) : perm m1 b ofs k p /\\\n(forall lo hi : Z, In (b, lo, hi) l -> lo <= ofs < hi -> False) ->\nperm m b ofs k p /\\\n(forall lo hi : Z,\n (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l -> lo <= ofs < hi -> False).","proofString":"intros [A B].\nsplit.\neauto with mem.\nintros.\ndestruct H1.\ninv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto.\neauto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo hi : Z, In (b0, lo, hi) l -> lo <= ofs0 < hi -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo hi : Z, In (b, lo, hi) l -> lo <= ofs < hi -> False) : perm m b ofs k p /\\\n(forall lo hi : Z,\n (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l -> lo <= ofs < hi -> False).","proofString":"split.\neauto with mem.\nintros.\ndestruct H1.\ninv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto.\neauto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo hi : Z, In (b0, lo, hi) l -> lo <= ofs0 < hi -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo hi : Z, In (b, lo, hi) l -> lo <= ofs < hi -> False) : perm m b ofs k p.","proofString":"eauto with mem."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo hi : Z, In (b0, lo, hi) l -> lo <= ofs0 < hi -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo hi : Z, In (b, lo, hi) l -> lo <= ofs < hi -> False) : forall lo hi : Z,\n(b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l -> lo <= ofs < hi -> False.","proofString":"intros.\ndestruct H1.\ninv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto.\neauto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo0 hi0 : Z, In (b0, lo0, hi0) l -> lo0 <= ofs0 < hi0 -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo0 hi0 : Z, In (b, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) (lo hi : Z) (H1 : (b1, lo1, hi1) = (b, lo, hi) \\/ In (b, lo, hi) l) (H2 : lo <= ofs < hi) : False.","proofString":"destruct H1.\ninv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto.\neauto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo0 hi0 : Z, In (b0, lo0, hi0) l -> lo0 <= ofs0 < hi0 -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo0 hi0 : Z, In (b, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) (lo hi : Z) (H1 : (b1, lo1, hi1) = (b, lo, hi)) (H2 : lo <= ofs < hi) : False.","proofString":"inv H1.\nelim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto."},{"statement":"(l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo0 hi0 : Z, In (b0, lo0, hi0) l -> lo0 <= ofs0 < hi0 -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (lo hi : Z) (E : free m b lo hi = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo0 hi0 : Z, In (b, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) (H2 : lo <= ofs < hi) : False.","proofString":"elim (perm_free_2 _ _ _ _ _ E ofs k p).\nauto.\nauto."},{"statement":"(l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo0 hi0 : Z, In (b0, lo0, hi0) l -> lo0 <= ofs0 < hi0 -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (lo hi : Z) (E : free m b lo hi = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo0 hi0 : Z, In (b, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) (H2 : lo <= ofs < hi) : lo <= ofs < hi.","proofString":"auto."},{"statement":"(l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo0 hi0 : Z, In (b0, lo0, hi0) l -> lo0 <= ofs0 < hi0 -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (lo hi : Z) (E : free m b lo hi = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo0 hi0 : Z, In (b, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) (H2 : lo <= ofs < hi) : perm m1 b ofs k p.","proofString":"auto."},{"statement":"(b1 : block) (lo1 hi1 : Z) (l : list (block * Z * Z)) (IHl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nfree_list m0 l = Some m'0 ->\nperm m'0 b0 ofs0 k0 p0 ->\nperm m0 b0 ofs0 k0 p0 /\\\n(forall lo0 hi0 : Z, In (b0, lo0, hi0) l -> lo0 <= ofs0 < hi0 -> False)) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m1 : mem) (E : free m b1 lo1 hi1 = Some m1) (H : free_list m1 l = Some m') (H0 : perm m' b ofs k p) (A : perm m1 b ofs k p) (B : forall lo0 hi0 : Z, In (b, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) (lo hi : Z) (H1 : In (b, lo, hi) l) (H2 : lo <= ofs < hi) : False.","proofString":"eauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p ->\nlo <= ofs + delta < hi ->\nexists lo1 hi1 : Z, In (b1, lo1, hi1) l /\\ lo1 <= ofs < hi1) : inject f m1' m2'.","proofString":"eapply free_right_inject; eauto.\neapply free_list_left_inject; eauto.\nintros.\nexploit perm_free_list; eauto.\nintros [A B].\nexploit H2; eauto.\nintros [lo1 [hi1 [C D]]].\neauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p ->\nlo <= ofs + delta < hi ->\nexists lo1 hi1 : Z, In (b1, lo1, hi1) l /\\ lo1 <= ofs < hi1) : inject f m1' m2.","proofString":"eapply free_list_left_inject; eauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1 b1 ofs k p ->\nlo <= ofs + delta < hi ->\nexists lo1 hi1 : Z, In (b1, lo1, hi1) l /\\ lo1 <= ofs < hi1) : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b, delta) ->\nperm m1' b1 ofs k p -> lo <= ofs + delta < hi -> False.","proofString":"intros.\nexploit perm_free_list; eauto.\nintros [A B].\nexploit H2; eauto.\nintros [lo1 [hi1 [C D]]].\neauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b0 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b, delta0) ->\nperm m1 b0 ofs0 k0 p0 ->\nlo <= ofs0 + delta0 < hi ->\nexists lo1 hi1 : Z, In (b0, lo1, hi1) l /\\ lo1 <= ofs0 < hi1) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H3 : f b1 = Some (b, delta)) (H4 : perm m1' b1 ofs k p) (H5 : lo <= ofs + delta < hi) : False.","proofString":"exploit perm_free_list; eauto.\nintros [A B].\nexploit H2; eauto.\nintros [lo1 [hi1 [C D]]].\neauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b0 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b, delta0) ->\nperm m1 b0 ofs0 k0 p0 ->\nlo <= ofs0 + delta0 < hi ->\nexists lo1 hi1 : Z, In (b0, lo1, hi1) l /\\ lo1 <= ofs0 < hi1) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H3 : f b1 = Some (b, delta)) (H4 : perm m1' b1 ofs k p) (H5 : lo <= ofs + delta < hi) : perm m1 b1 ofs k p /\\\n(forall lo0 hi0 : Z, In (b1, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) ->\nFalse.","proofString":"intros [A B].\nexploit H2; eauto.\nintros [lo1 [hi1 [C D]]].\neauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b0 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b, delta0) ->\nperm m1 b0 ofs0 k0 p0 ->\nlo <= ofs0 + delta0 < hi ->\nexists lo1 hi1 : Z, In (b0, lo1, hi1) l /\\ lo1 <= ofs0 < hi1) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H3 : f b1 = Some (b, delta)) (H4 : perm m1' b1 ofs k p) (H5 : lo <= ofs + delta < hi) (A : perm m1 b1 ofs k p) (B : forall lo0 hi0 : Z, In (b1, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) : False.","proofString":"exploit H2; eauto.\nintros [lo1 [hi1 [C D]]].\neauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b0 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b, delta0) ->\nperm m1 b0 ofs0 k0 p0 ->\nlo <= ofs0 + delta0 < hi ->\nexists lo1 hi1 : Z, In (b0, lo1, hi1) l /\\ lo1 <= ofs0 < hi1) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H3 : f b1 = Some (b, delta)) (H4 : perm m1' b1 ofs k p) (H5 : lo <= ofs + delta < hi) (A : perm m1 b1 ofs k p) (B : forall lo0 hi0 : Z, In (b1, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) : (exists lo1 hi1 : Z, In (b1, lo1, hi1) l /\\ lo1 <= ofs < hi1) -> False.","proofString":"intros [lo1 [hi1 [C D]]].\neauto."},{"statement":"(f : meminj) (m1 : mem) (l : list (block * Z * Z)) (m1' m2 : mem) (b : block) (lo hi : Z) (m2' : mem) (H : inject f m1 m2) (H0 : free_list m1 l = Some m1') (H1 : free m2 b lo hi = Some m2') (H2 : forall (b0 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b, delta0) ->\nperm m1 b0 ofs0 k0 p0 ->\nlo <= ofs0 + delta0 < hi ->\nexists lo0 hi0 : Z, In (b0, lo0, hi0) l /\\ lo0 <= ofs0 < hi0) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H3 : f b1 = Some (b, delta)) (H4 : perm m1' b1 ofs k p) (H5 : lo <= ofs + delta < hi) (A : perm m1 b1 ofs k p) (B : forall lo0 hi0 : Z, In (b1, lo0, hi0) l -> lo0 <= ofs < hi0 -> False) (lo1 hi1 : Z) (C : In (b1, lo1, hi1) l) (D : lo1 <= ofs < hi1) : False.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) : exists m2' : mem,\n  free m2 b' (lo + delta) (hi + delta) = Some m2' /\\ inject f m1' m2'.","proofString":"destruct (range_perm_free m2 b' (lo + delta) (hi + delta)) as [m2' FREE].\neapply range_perm_inject; eauto.\neapply free_range_perm; eauto.\nexists m2'; split; auto.\neapply free_inject with (m1 := m1) (l := (b,lo,hi)::nil); eauto.\nsimpl; rewrite H0; auto.\nintros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H2; inv H2.\nexists lo, hi; split; auto with coqlib.\nlia.\nexploit mi_no_overlap.\neexact H.\neexact n.\neauto.\neauto.\neapply perm_max.\neapply perm_implies.\neauto.\nauto with mem.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia.\nintros [A|A].\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) : range_perm m2 b' (lo + delta) (hi + delta) Cur Freeable.","proofString":"eapply range_perm_inject; eauto.\neapply free_range_perm; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) : range_perm m1 b lo hi Cur Freeable.","proofString":"eapply free_range_perm; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') : exists m2'0 : mem,\n  free m2 b' (lo + delta) (hi + delta) = Some m2'0 /\\ inject f m1' m2'0.","proofString":"exists m2'; split; auto.\neapply free_inject with (m1 := m1) (l := (b,lo,hi)::nil); eauto.\nsimpl; rewrite H0; auto.\nintros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H2; inv H2.\nexists lo, hi; split; auto with coqlib.\nlia.\nexploit mi_no_overlap.\neexact H.\neexact n.\neauto.\neauto.\neapply perm_max.\neapply perm_implies.\neauto.\nauto with mem.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia.\nintros [A|A].\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') : inject f m1' m2'.","proofString":"eapply free_inject with (m1 := m1) (l := (b,lo,hi)::nil); eauto.\nsimpl; rewrite H0; auto.\nintros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H2; inv H2.\nexists lo, hi; split; auto with coqlib.\nlia.\nexploit mi_no_overlap.\neexact H.\neexact n.\neauto.\neauto.\neapply perm_max.\neapply perm_implies.\neauto.\nauto with mem.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia.\nintros [A|A].\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') : free_list m1 ((b, lo, hi) :: nil) = Some m1'.","proofString":"simpl; rewrite H0; auto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') : forall (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (b', delta0) ->\nperm m1 b1 ofs k p ->\nlo + delta <= ofs + delta0 < hi + delta ->\nexists lo1 hi1 : Z,\n  In (b1, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H2; inv H2.\nexists lo, hi; split; auto with coqlib.\nlia.\nexploit mi_no_overlap.\neexact H.\neexact n.\neauto.\neauto.\neapply perm_max.\neapply perm_implies.\neauto.\nauto with mem.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia.\nintros [A|A].\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) : exists lo1 hi1 : Z,\n  In (b1, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"destruct (eq_block b1 b).\nsubst b1.\nrewrite H1 in H2; inv H2.\nexists lo, hi; split; auto with coqlib.\nlia.\nexploit mi_no_overlap.\neexact H.\neexact n.\neauto.\neauto.\neapply perm_max.\neapply perm_implies.\neauto.\nauto with mem.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia.\nintros [A|A].\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (e : b1 = b) : exists lo1 hi1 : Z,\n  In (b1, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"subst b1.\nrewrite H1 in H2; inv H2.\nexists lo, hi; split; auto with coqlib.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (delta0 ofs : Z) (k : perm_kind) (p : permission) (H3 : perm m1 b ofs k p) (H2 : f b = Some (b', delta0)) (H4 : lo + delta <= ofs + delta0 < hi + delta) : exists lo1 hi1 : Z, In (b, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"rewrite H1 in H2; inv H2.\nexists lo, hi; split; auto with coqlib.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (delta0 : Z) (H1 : f b = Some (b', delta0)) (m2' : mem) (FREE : free m2 b' (lo + delta0) (hi + delta0) = Some m2') (ofs : Z) (k : perm_kind) (p : permission) (H3 : perm m1 b ofs k p) (H4 : lo + delta0 <= ofs + delta0 < hi + delta0) : exists lo1 hi1 : Z, In (b, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"exists lo, hi; split; auto with coqlib.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (delta0 : Z) (H1 : f b = Some (b', delta0)) (m2' : mem) (FREE : free m2 b' (lo + delta0) (hi + delta0) = Some m2') (ofs : Z) (k : perm_kind) (p : permission) (H3 : perm m1 b ofs k p) (H4 : lo + delta0 <= ofs + delta0 < hi + delta0) : lo <= ofs < hi.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (n : b1 <> b) : exists lo1 hi1 : Z,\n  In (b1, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"exploit mi_no_overlap.\neexact H.\neexact n.\neauto.\neauto.\neapply perm_max.\neapply perm_implies.\neauto.\nauto with mem.\ninstantiate (1 := ofs + delta0 - delta).\napply perm_cur_max.\napply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia.\nintros [A|A].\ncongruence.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (n : b1 <> b) : perm m1 b (ofs + delta0 - delta) Max Nonempty.","proofString":"apply perm_cur_max.\napply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (n : b1 <> b) : perm m1 b (ofs + delta0 - delta) Cur Nonempty.","proofString":"apply perm_implies with Freeable; auto with mem.\neapply free_range_perm; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (n : b1 <> b) : perm m1 b (ofs + delta0 - delta) Cur Freeable.","proofString":"eapply free_range_perm; eauto.\nlia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (n : b1 <> b) : lo <= ofs + delta0 - delta < hi.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (n : b1 <> b) (A : b' <> b') : exists lo1 hi1 : Z,\n  In (b1, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"congruence."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (m1' : mem) (b' : block) (delta : Z) (H : inject f m1 m2) (H0 : free m1 b lo hi = Some m1') (H1 : f b = Some (b', delta)) (m2' : mem) (FREE : free m2 b' (lo + delta) (hi + delta) = Some m2') (b1 : block) (delta0 ofs : Z) (k : perm_kind) (p : permission) (H2 : f b1 = Some (b', delta0)) (H3 : perm m1 b1 ofs k p) (H4 : lo + delta <= ofs + delta0 < hi + delta) (n : b1 <> b) (A : ofs + delta0 <> ofs + delta0 - delta + delta) : exists lo1 hi1 : Z,\n  In (b1, lo1, hi1) ((b, lo, hi) :: nil) /\\ lo1 <= ofs < hi1.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (H : inject f m1 m2) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p0 -> lo <= ofs + delta < hi -> False) : inject f m1 m2'.","proofString":"destruct H.\nconstructor; eauto.\neapply drop_outside_inj; eauto.\nintros.\nunfold valid_block in *.\nerewrite nextblock_drop; eauto.\nintros.\neapply mi_perm_inv0; eauto using perm_drop_4."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p0 ->\nperm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p0 -> lo <= ofs + delta < hi -> False) : inject f m1 m2'.","proofString":"constructor; eauto.\neapply drop_outside_inj; eauto.\nintros.\nunfold valid_block in *.\nerewrite nextblock_drop; eauto.\nintros.\neapply mi_perm_inv0; eauto using perm_drop_4."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p0 ->\nperm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p0 -> lo <= ofs + delta < hi -> False) : mem_inj f m1 m2'.","proofString":"eapply drop_outside_inj; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p0 ->\nperm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p0 -> lo <= ofs + delta < hi -> False) : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2' b'.","proofString":"intros.\nunfold valid_block in *.\nerewrite nextblock_drop; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b1 : block, ~ valid_block m1 b1 -> f b1 = None) (mi_mappedblocks0 : forall (b1 b'0 : block) (delta0 : Z),\nf b1 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b1 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b1 = Some (b'0, delta0) ->\nperm m1 b1 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p0 ->\nperm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b'0 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission),\nf b'0 = Some (b, delta0) ->\nperm m1 b'0 ofs k p0 -> lo <= ofs + delta0 < hi -> False) (b0 b' : block) (delta : Z) (H : f b0 = Some (b', delta)) : valid_block m2' b'.","proofString":"unfold valid_block in *.\nerewrite nextblock_drop; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b1 : block, ~ Plt b1 (nextblock m1) -> f b1 = None) (mi_mappedblocks0 : forall (b1 b'0 : block) (delta0 : Z),\nf b1 = Some (b'0, delta0) -> Plt b'0 (nextblock m2)) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b1 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b1 = Some (b'0, delta0) ->\nperm m1 b1 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b1 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p0 ->\nperm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b'0 : block) (delta0 ofs : Z) (k : perm_kind) (p0 : permission),\nf b'0 = Some (b, delta0) ->\nperm m1 b'0 ofs k p0 -> lo <= ofs + delta0 < hi -> False) (b0 b' : block) (delta : Z) (H : f b0 = Some (b', delta)) : Plt b' (nextblock m2').","proofString":"erewrite nextblock_drop; eauto."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p0 ->\nperm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta ofs : Z) (k : perm_kind) (p0 : permission),\nf b' = Some (b, delta) ->\nperm m1 b' ofs k p0 -> lo <= ofs + delta < hi -> False) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p0 : permission),\nf b1 = Some (b2, delta) ->\nperm m2' b2 (ofs + delta) k p0 ->\nperm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"intros.\neapply mi_perm_inv0; eauto using perm_drop_4."},{"statement":"(f : meminj) (m1 m2 : mem) (b : block) (lo hi : Z) (p : permission) (m2' : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b', delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p1 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p1 ->\nperm m1 b0 ofs0 k0 p1 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (H0 : drop_perm m2 b lo hi p = Some m2') (H1 : forall (b' : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nf b' = Some (b, delta0) ->\nperm m1 b' ofs0 k0 p1 -> lo <= ofs0 + delta0 < hi -> False) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : f b1 = Some (b2, delta)) (H2 : perm m2' b2 (ofs + delta) k p0) : perm m1 b1 ofs k p0 \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eapply mi_perm_inv0; eauto using perm_drop_4."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (H : mem_inj f m1 m2) (H0 : mem_inj f' m2 m3) : mem_inj (compose_meminj f f') m1 m3.","proofString":"unfold compose_meminj.\ninv H; inv H0; constructor; intros.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neauto.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\napply Z.divide_add_r.\neapply mi_align0; eauto.\neapply mi_align1 with (ofs := ofs + delta') (p := p); eauto.\nred; intros.\nreplace ofs0 with ((ofs0 - delta') + delta') by lia.\neapply mi_perm0; eauto.\napply H0.\nlia.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neapply memval_inject_compose; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (H : mem_inj f m1 m2) (H0 : mem_inj f' m2 m3) : mem_inj\n  (fun b : block =>\n   match f b with\n   | Some (b', delta) =>\n       match f' b' with\n       | Some (b'', delta') => Some (b'', delta + delta')\n       | None => None\n       end\n   | None => None\n   end) m1 m3.","proofString":"inv H; inv H0; constructor; intros.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neauto.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\napply Z.divide_add_r.\neapply mi_align0; eauto.\neapply mi_align1 with (ofs := ofs + delta') (p := p); eauto.\nred; intros.\nreplace ofs0 with ((ofs0 - delta') + delta') by lia.\neapply mi_perm0; eauto.\napply H0.\nlia.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neapply memval_inject_compose; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 k0 p0 -> perm m3 b3 (ofs0 + delta0) k0 p0) (mi_align1 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf' b0 = Some (b3, delta0) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m3) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : match f b1 with\n| Some (b', delta0) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b2, delta)) (H0 : perm m1 b1 ofs k p) : perm m3 b2 (ofs + delta) k p.","proofString":"destruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta0) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 k0 p0 -> perm m3 b3 (ofs0 + delta0) k0 p0) (mi_align1 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf' b0 = Some (b3, delta0) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta0)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m3) # b3)) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (H : match f' b' with\n| Some (b'', delta'0) => Some (b'', delta' + delta'0)\n| None => None\nend = Some (b2, delta)) (H0 : perm m1 b1 ofs k p) : perm m3 b2 (ofs + delta) k p.","proofString":"destruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 k0 p0 -> perm m3 b3 (ofs0 + delta) k0 p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (ofs : Z) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m1 b1 ofs k p) : perm m3 b2 (ofs + (delta' + delta'')) k p.","proofString":"replace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 k0 p0 -> perm m2 b3 (ofs0 + delta) k0 p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 k0 p0 -> perm m3 b3 (ofs0 + delta) k0 p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (ofs : Z) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m1 b1 ofs k p) : perm m3 b2 (ofs + delta' + delta'') k p.","proofString":"eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta) k p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 k p0 -> perm m3 b3 (ofs0 + delta) k p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta').","proofString":"eapply mi_align0; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 k p0 -> perm m2 b3 (ofs0 + delta) k p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 k p0 -> perm m3 b3 (ofs0 + delta) k p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) : range_perm m2 b' (ofs + delta') (ofs + delta' + size_chunk chunk) Max p.","proofString":"red; intros.\nreplace ofs0 with ((ofs0 - delta') + delta') by lia.\neapply mi_perm0; eauto.\napply H0.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 k p0 -> perm m2 b3 (ofs1 + delta) k p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 k p0 -> perm m3 b3 (ofs1 + delta) k p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval1 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 Cur Readable ->\nmemval_inject f' (ZMap.get ofs1 (mem_contents m2) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H : ofs + delta' <= ofs0 < ofs + delta' + size_chunk chunk) : perm m2 b' ofs0 Max p.","proofString":"replace ofs0 with ((ofs0 - delta') + delta') by lia.\neapply mi_perm0; eauto.\napply H0.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 k p0 -> perm m2 b3 (ofs1 + delta) k p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 k p0 -> perm m3 b3 (ofs1 + delta) k p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval1 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 Cur Readable ->\nmemval_inject f' (ZMap.get ofs1 (mem_contents m2) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H : ofs + delta' <= ofs0 < ofs + delta' + size_chunk chunk) : perm m2 b' (ofs0 - delta' + delta') Max p.","proofString":"eapply mi_perm0; eauto.\napply H0.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 k p0 -> perm m2 b3 (ofs1 + delta) k p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 k p0 -> perm m3 b3 (ofs1 + delta) k p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval1 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 Cur Readable ->\nmemval_inject f' (ZMap.get ofs1 (mem_contents m2) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H : ofs + delta' <= ofs0 < ofs + delta' + size_chunk chunk) : perm m1 b1 (ofs0 - delta') Max p.","proofString":"apply H0.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 k p0 -> perm m2 b3 (ofs1 + delta) k p0) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval0 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs1 Cur Readable ->\nmemval_inject f (ZMap.get ofs1 (mem_contents m1) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs1 : Z) (k : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 k p0 -> perm m3 b3 (ofs1 + delta) k p0) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk0 : memory_chunk) \n  (ofs1 : Z) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs1 (ofs1 + size_chunk chunk0) Max p0 ->\n(align_chunk chunk0 | delta)) (mi_memval1 : forall (b0 : block) (ofs1 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs1 Cur Readable ->\nmemval_inject f' (ZMap.get ofs1 (mem_contents m2) # b0)\n  (ZMap.get (ofs1 + delta) (mem_contents m3) # b3)) (b1 b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) (ofs0 : Z) (H : ofs + delta' <= ofs0 < ofs + delta' + size_chunk chunk) : ofs <= ofs0 - delta' < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 k p -> perm m3 b3 (ofs0 + delta0) k p) (mi_align1 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf' b0 = Some (b3, delta0) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m3) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : match f b1 with\n| Some (b', delta0) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b2, delta)) (H0 : perm m1 b1 ofs Cur Readable) : memval_inject\n  (fun b : block =>\n   match f b with\n   | Some (b', delta0) =>\n       match f' b' with\n       | Some (b'', delta') => Some (b'', delta0 + delta')\n       | None => None\n       end\n   | None => None\n   end) (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m3) # b2).","proofString":"destruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neapply memval_inject_compose; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta0) k p) (mi_align0 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta0) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta0 ofs0 : Z) (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 k p -> perm m3 b3 (ofs0 + delta0) k p) (mi_align1 : forall (b0 b3 : block) (delta0 : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf' b0 = Some (b3, delta0) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta0)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z),\nf' b0 = Some (b3, delta0) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta0) (mem_contents m3) # b3)) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (H : match f' b' with\n| Some (b'', delta'0) => Some (b'', delta' + delta'0)\n| None => None\nend = Some (b2, delta)) (H0 : perm m1 b1 ofs Cur Readable) : memval_inject\n  (fun b : block =>\n   match f b with\n   | Some (b'0, delta0) =>\n       match f' b'0 with\n       | Some (b'', delta'0) => Some (b'', delta0 + delta'0)\n       | None => None\n       end\n   | None => None\n   end) (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (mem_contents m3) # b2).","proofString":"destruct (f' b') as [[b'' delta''] |] eqn:?; inv H.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neapply memval_inject_compose; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta) k p) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 k p -> perm m3 b3 (ofs0 + delta) k p) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m3) # b3)) (b1 : block) (ofs : Z) (b2 b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m1 b1 ofs Cur Readable) : memval_inject\n  (fun b : block =>\n   match f b with\n   | Some (b'0, delta) =>\n       match f' b'0 with\n       | Some (b'', delta'0) => Some (b'', delta + delta'0)\n       | None => None\n       end\n   | None => None\n   end) (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + (delta' + delta'')) (mem_contents m3) # b2).","proofString":"replace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') by lia.\neapply memval_inject_compose; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_perm0 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 k p -> perm m2 b3 (ofs0 + delta) k p) (mi_align0 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf b0 = Some (b3, delta) ->\nrange_perm m1 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf b0 = Some (b3, delta) ->\nperm m1 b0 ofs0 Cur Readable ->\nmemval_inject f (ZMap.get ofs0 (mem_contents m1) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m2) # b3)) (mi_perm1 : forall (b0 b3 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 k p -> perm m3 b3 (ofs0 + delta) k p) (mi_align1 : forall (b0 b3 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\nf' b0 = Some (b3, delta) ->\nrange_perm m2 b0 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z),\nf' b0 = Some (b3, delta) ->\nperm m2 b0 ofs0 Cur Readable ->\nmemval_inject f' (ZMap.get ofs0 (mem_contents m2) # b0)\n  (ZMap.get (ofs0 + delta) (mem_contents m3) # b3)) (b1 : block) (ofs : Z) (b2 b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m1 b1 ofs Cur Readable) : memval_inject\n  (fun b : block =>\n   match f b with\n   | Some (b'0, delta) =>\n       match f' b'0 with\n       | Some (b'', delta'0) => Some (b'', delta + delta'0)\n       | None => None\n       end\n   | None => None\n   end) (ZMap.get ofs (mem_contents m1) # b1)\n  (ZMap.get (ofs + delta' + delta'') (mem_contents m3) # b2).","proofString":"eapply memval_inject_compose; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (H : inject f m1 m2) (H0 : inject f' m2 m3) : inject\n  (fun b : block =>\n   match f b with\n   | Some (b', delta) =>\n       match f' b' with\n       | Some (b'', delta') => Some (b'', delta + delta')\n       | None => None\n       end\n   | None => None\n   end) m1 m3.","proofString":"inv H; inv H0.\nconstructor.\neapply mem_inj_compose; eauto.\nintros.\nerewrite mi_freeblocks0; eauto.\nintros.\ndestruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\neauto.\nred; intros.\ndestruct (f b1) as [[b1x delta1x] |] eqn:?; try discriminate.\ndestruct (f' b1x) as [[b1y delta1y] |] eqn:?; inv H0.\ndestruct (f b2) as [[b2x delta2x] |] eqn:?; try discriminate.\ndestruct (f' b2x) as [[b2y delta2y] |] eqn:?; inv H1.\nexploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia.\nintros.\ndestruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\nexploit mi_representable0; eauto.\nintros [A B].\nset (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia.\nintros.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; try discriminate.\ninversion H; clear H; subst b'' delta.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') in H0 by lia.\nexploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : inject\n  (fun b : block =>\n   match f b with\n   | Some (b', delta) =>\n       match f' b' with\n       | Some (b'', delta') => Some (b'', delta + delta')\n       | None => None\n       end\n   | None => None\n   end) m1 m3.","proofString":"constructor.\neapply mem_inj_compose; eauto.\nintros.\nerewrite mi_freeblocks0; eauto.\nintros.\ndestruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\neauto.\nred; intros.\ndestruct (f b1) as [[b1x delta1x] |] eqn:?; try discriminate.\ndestruct (f' b1x) as [[b1y delta1y] |] eqn:?; inv H0.\ndestruct (f b2) as [[b2x delta2x] |] eqn:?; try discriminate.\ndestruct (f' b2x) as [[b2y delta2y] |] eqn:?; inv H1.\nexploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia.\nintros.\ndestruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\nexploit mi_representable0; eauto.\nintros [A B].\nset (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia.\nintros.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; try discriminate.\ninversion H; clear H; subst b'' delta.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') in H0 by lia.\nexploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : mem_inj\n  (fun b : block =>\n   match f b with\n   | Some (b', delta) =>\n       match f' b' with\n       | Some (b'', delta') => Some (b'', delta + delta')\n       | None => None\n       end\n   | None => None\n   end) m1 m3.","proofString":"eapply mem_inj_compose; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : forall b : block,\n~ valid_block m1 b ->\nmatch f b with\n| Some (b', delta) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta + delta')\n    | None => None\n    end\n| None => None\nend = None.","proofString":"intros.\nerewrite mi_freeblocks0; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b' : block) (delta : Z),\nf' b0 = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf' b0 = Some (b', delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) (b : block) (H : ~ valid_block m1 b) : match f b with\n| Some (b', delta) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta + delta')\n    | None => None\n    end\n| None => None\nend = None.","proofString":"erewrite mi_freeblocks0; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : forall (b b' : block) (delta : Z),\nmatch f b with\n| Some (b'0, delta0) =>\n    match f' b'0 with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b', delta) -> valid_block m3 b'.","proofString":"intros.\ndestruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\neauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf' b0 = Some (b'0, delta0) ->\nperm m2 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta0) ->\nperm m3 b2 (ofs + delta0) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) (b b' : block) (delta : Z) (H : match f b with\n| Some (b'0, delta0) =>\n    match f' b'0 with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b', delta)) : valid_block m3 b'.","proofString":"destruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\neauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf' b0 = Some (b'0, delta0) ->\nperm m2 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta0) ->\nperm m3 b2 (ofs + delta0) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b b' : block) (delta : Z) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (H : match f' b1 with\n| Some (b'', delta') => Some (b'', delta1 + delta')\n| None => None\nend = Some (b', delta)) : valid_block m3 b'.","proofString":"destruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\neauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b b' b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) : valid_block m3 b'.","proofString":"eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : meminj_no_overlap\n  (fun b : block =>\n   match f b with\n   | Some (b', delta) =>\n       match f' b' with\n       | Some (b'', delta') => Some (b'', delta + delta')\n       | None => None\n       end\n   | None => None\n   end) m1.","proofString":"red; intros.\ndestruct (f b1) as [[b1x delta1x] |] eqn:?; try discriminate.\ndestruct (f' b1x) as [[b1y delta1y] |] eqn:?; inv H0.\ndestruct (f b2) as [[b2x delta2x] |] eqn:?; try discriminate.\ndestruct (f' b2x) as [[b2y delta2y] |] eqn:?; inv H1.\nexploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H0 : match f b1 with\n| Some (b', delta) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta + delta')\n    | None => None\n    end\n| None => None\nend = Some (b1', delta1)) (H1 : match f b2 with\n| Some (b', delta) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta + delta')\n    | None => None\n    end\n| None => None\nend = Some (b2', delta2)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"destruct (f b1) as [[b1x delta1x] |] eqn:?; try discriminate.\ndestruct (f' b1x) as [[b1y delta1y] |] eqn:?; inv H0.\ndestruct (f b2) as [[b2x delta2x] |] eqn:?; try discriminate.\ndestruct (f' b2x) as [[b2y delta2y] |] eqn:?; inv H1.\nexploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (H0 : match f' b1x with\n| Some (b'', delta') => Some (b'', delta1x + delta')\n| None => None\nend = Some (b1', delta1)) (H1 : match f b2 with\n| Some (b', delta) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta + delta')\n    | None => None\n    end\n| None => None\nend = Some (b2', delta2)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"destruct (f' b1x) as [[b1y delta1y] |] eqn:?; inv H0.\ndestruct (f b2) as [[b2x delta2x] |] eqn:?; try discriminate.\ndestruct (f' b2x) as [[b2y delta2y] |] eqn:?; inv H1.\nexploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (delta1y : Z) (Heqo0 : f' b1x = Some (b1', delta1y)) (H1 : match f b2 with\n| Some (b', delta) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta + delta')\n    | None => None\n    end\n| None => None\nend = Some (b2', delta2)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + delta2.","proofString":"destruct (f b2) as [[b2x delta2x] |] eqn:?; try discriminate.\ndestruct (f' b2x) as [[b2y delta2y] |] eqn:?; inv H1.\nexploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (delta1y : Z) (Heqo0 : f' b1x = Some (b1', delta1y)) (b2x : block) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (H1 : match f' b2x with\n| Some (b'', delta') => Some (b'', delta2x + delta')\n| None => None\nend = Some (b2', delta2)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + delta2.","proofString":"destruct (f' b2x) as [[b2y delta2y] |] eqn:?; inv H1.\nexploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (delta1y : Z) (Heqo0 : f' b1x = Some (b1', delta1y)) (b2x : block) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"exploit mi_no_overlap0; eauto.\nintros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (delta1y : Z) (Heqo0 : f' b1x = Some (b1', delta1y)) (b2x : block) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) : b1x <> b2x \\/ ofs1 + delta1x <> ofs2 + delta2x ->\nb1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"intros A.\ndestruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (delta1y : Z) (Heqo0 : f' b1x = Some (b1', delta1y)) (b2x : block) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) (A : b1x <> b2x \\/ ofs1 + delta1x <> ofs2 + delta2x) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"destruct (eq_block b1x b2x).\nsubst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia.\nexploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (delta1y : Z) (Heqo0 : f' b1x = Some (b1', delta1y)) (b2x : block) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) (A : b1x <> b2x \\/ ofs1 + delta1x <> ofs2 + delta2x) (e : b1x = b2x) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"subst b1x.\ndestruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (delta1x : Z) (b2x : block) (Heqo : f b1 = Some (b2x, delta1x)) (delta1y : Z) (Heqo0 : f' b2x = Some (b1', delta1y)) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) (A : b2x <> b2x \\/ ofs1 + delta1x <> ofs2 + delta2x) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"destruct A.\ncongruence.\nassert (delta1y = delta2y) by congruence.\nright; lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (delta1x : Z) (b2x : block) (Heqo : f b1 = Some (b2x, delta1x)) (delta1y : Z) (Heqo0 : f' b2x = Some (b1', delta1y)) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) (H0 : b2x <> b2x) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"congruence."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (delta1x : Z) (b2x : block) (Heqo : f b1 = Some (b2x, delta1x)) (delta1y : Z) (Heqo0 : f' b2x = Some (b1', delta1y)) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) (H0 : ofs1 + delta1x <> ofs2 + delta2x) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"assert (delta1y = delta2y) by congruence.\nright; lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (delta1x : Z) (b2x : block) (Heqo : f b1 = Some (b2x, delta1x)) (delta1y : Z) (Heqo0 : f' b2x = Some (b1', delta1y)) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) (H0 : ofs1 + delta1x <> ofs2 + delta2x) (H1 : delta1y = delta2y) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"right; lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' b2 b2' : block) (ofs1 ofs2 : Z) (H : b1 <> b2) (b1x : block) (delta1x : Z) (Heqo : f b1 = Some (b1x, delta1x)) (delta1y : Z) (Heqo0 : f' b1x = Some (b1', delta1y)) (b2x : block) (delta2x : Z) (Heqo1 : f b2 = Some (b2x, delta2x)) (delta2y : Z) (Heqo2 : f' b2x = Some (b2', delta2y)) (H2 : perm m1 b1 ofs1 Max Nonempty) (H3 : perm m1 b2 ofs2 Max Nonempty) (A : b1x <> b2x \\/ ofs1 + delta1x <> ofs2 + delta2x) (n : b1x <> b2x) : b1' <> b2' \\/ ofs1 + (delta1x + delta1y) <> ofs2 + (delta2x + delta2y).","proofString":"exploit mi_no_overlap1.\neauto.\neauto.\neauto.\neapply perm_inj.\neauto.\neexact H2.\neauto.\neapply perm_inj.\neauto.\neexact H3.\neauto.\nintuition lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nmatch f b with\n| Some (b'0, delta0) =>\n    match f' b'0 with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"intros.\ndestruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\nexploit mi_representable0; eauto.\nintros [A B].\nset (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta0) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta0) ->\nperm m3 b2 (ofs0 + delta0) k p ->\nperm m2 b1 ofs0 k p \\/ ~ perm m2 b1 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (H : match f b with\n| Some (b'0, delta0) =>\n    match f' b'0 with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b', delta)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"destruct (f b) as [[b1 delta1] |] eqn:?; try discriminate.\ndestruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\nexploit mi_representable0; eauto.\nintros [A B].\nset (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta0 : Z),\nf' b0 = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta0) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta0) ->\nperm m3 b2 (ofs0 + delta0) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (H : match f' b1 with\n| Some (b'', delta') => Some (b'', delta1 + delta')\n| None => None\nend = Some (b', delta)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"destruct (f' b1) as [[b2 delta2] |] eqn:?; inv H.\nexploit mi_representable0; eauto.\nintros [A B].\nset (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta1 + delta2 >= 0 /\\\n0 <= Ptrofs.unsigned ofs + (delta1 + delta2) <= Ptrofs.max_unsigned.","proofString":"exploit mi_representable0; eauto.\nintros [A B].\nset (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta1 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned ->\ndelta1 + delta2 >= 0 /\\\n0 <= Ptrofs.unsigned ofs + (delta1 + delta2) <= Ptrofs.max_unsigned.","proofString":"intros [A B].\nset (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta1 >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) : delta1 + delta2 >= 0 /\\\n0 <= Ptrofs.unsigned ofs + (delta1 + delta2) <= Ptrofs.max_unsigned.","proofString":"set (ofs' := Ptrofs.repr (Ptrofs.unsigned ofs + delta1)).\nassert (Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1).\nunfold ofs'; apply Ptrofs.unsigned_repr.\nauto.\nexploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta1 >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (ofs' : ptrofs) : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned.","proofString":"auto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta1 >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (ofs' : ptrofs) (H : Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1) : delta1 + delta2 >= 0 /\\\n0 <= Ptrofs.unsigned ofs + (delta1 + delta2) <= Ptrofs.max_unsigned.","proofString":"exploit mi_representable1.\neauto.\ninstantiate (1 := ofs').\nrewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj.\nrewrite H.\nlia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta1 >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (ofs' : ptrofs) (H : Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1) : perm m2 b1 (Ptrofs.unsigned ofs') Max Nonempty \\/\nperm m2 b1 (Ptrofs.unsigned ofs' - 1) Max Nonempty.","proofString":"rewrite H.\nreplace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta1 >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (ofs' : ptrofs) (H : Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1) : perm m2 b1 (Ptrofs.unsigned ofs + delta1) Max Nonempty \\/\nperm m2 b1 (Ptrofs.unsigned ofs + delta1 - 1) Max Nonempty.","proofString":"replace (Ptrofs.unsigned ofs + delta1 - 1) with    ((Ptrofs.unsigned ofs - 1) + delta1) by lia.\ndestruct H0; eauto using perm_inj."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta1 >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (ofs' : ptrofs) (H : Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1) : perm m2 b1 (Ptrofs.unsigned ofs + delta1) Max Nonempty \\/\nperm m2 b1 (Ptrofs.unsigned ofs - 1 + delta1) Max Nonempty.","proofString":"destruct H0; eauto using perm_inj."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta : Z),\nf b0 = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b2, delta) ->\nperm m2 b2 (ofs0 + delta) k p ->\nperm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b0 : block, ~ valid_block m2 b0 -> f' b0 = None) (mi_mappedblocks1 : forall (b0 b'0 : block) (delta : Z),\nf' b0 = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b0 = Some (b'0, delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b0 = Some (b2, delta) ->\nperm m3 b2 (ofs0 + delta) k p ->\nperm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (ofs : ptrofs) (b1 : block) (delta1 : Z) (Heqo : f b = Some (b1, delta1)) (delta2 : Z) (Heqo0 : f' b1 = Some (b', delta2)) (H0 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta1 >= 0) (B : 0 <= Ptrofs.unsigned ofs + delta1 <= Ptrofs.max_unsigned) (ofs' : ptrofs) (H : Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs + delta1) : delta2 >= 0 /\\\n0 <= Ptrofs.unsigned ofs + delta1 + delta2 <= Ptrofs.max_unsigned ->\ndelta1 + delta2 >= 0 /\\\n0 <= Ptrofs.unsigned ofs + (delta1 + delta2) <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta : Z),\nf' b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf' b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf' b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nmatch f b1 with\n| Some (b', delta0) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"intros.\ndestruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; try discriminate.\ninversion H; clear H; subst b'' delta.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') in H0 by lia.\nexploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b' : block) (delta0 : Z),\nf' b = Some (b', delta0) -> valid_block m3 b') (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf' b = Some (b', delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H : match f b1 with\n| Some (b', delta0) =>\n    match f' b' with\n    | Some (b'', delta') => Some (b'', delta0 + delta')\n    | None => None\n    end\n| None => None\nend = Some (b2, delta)) (H0 : perm m3 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"destruct (f b1) as [[b' delta'] |] eqn:?; try discriminate.\ndestruct (f' b') as [[b'' delta''] |] eqn:?; try discriminate.\ninversion H; clear H; subst b'' delta.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') in H0 by lia.\nexploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta0 : Z),\nf b = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta0 : Z),\nf' b = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (H : match f' b' with\n| Some (b'', delta'0) => Some (b'', delta' + delta'0)\n| None => None\nend = Some (b2, delta)) (H0 : perm m3 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"destruct (f' b') as [[b'' delta''] |] eqn:?; try discriminate.\ninversion H; clear H; subst b'' delta.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') in H0 by lia.\nexploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta0 : Z),\nf b = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta0 : Z),\nf' b = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (b'' : block) (delta'' : Z) (Heqo0 : f' b' = Some (b'', delta'')) (H : Some (b'', delta' + delta'') = Some (b2, delta)) (H0 : perm m3 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"inversion H; clear H; subst b'' delta.\nreplace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') in H0 by lia.\nexploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta : Z),\nf b = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs0 + delta) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs0 + delta) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m3 b2 (ofs + (delta' + delta'')) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"replace (ofs + (delta' + delta'')) with ((ofs + delta') + delta'') in H0 by lia.\nexploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta : Z),\nf b = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs0 + delta) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs0 + delta) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m3 b2 (ofs + delta' + delta'') k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"exploit mi_perm_inv1; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta : Z),\nf b = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs0 + delta) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs0 + delta) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m3 b2 (ofs + delta' + delta'') k p) : perm m2 b' (ofs + delta') k p \\/ ~ perm m2 b' (ofs + delta') Max Nonempty ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"intros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta : Z),\nf b = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs0 + delta) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs0 + delta) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m3 b2 (ofs + delta' + delta'') k p) (A : perm m2 b' (ofs + delta') k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eapply mi_perm_inv0; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta : Z),\nf b = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs0 + delta) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs0 + delta) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m3 b2 (ofs + delta' + delta'') k p) (A : ~ perm m2 b' (ofs + delta') Max Nonempty) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"right; red; intros.\nelim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta : Z),\nf b = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs0 + delta) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs0 + delta) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m3 b2 (ofs + delta' + delta'') k p) (A : ~ perm m2 b' (ofs + delta') Max Nonempty) (H : perm m1 b1 ofs Max Nonempty) : False.","proofString":"elim A.\neapply perm_inj; eauto."},{"statement":"(f f' : meminj) (m1 m2 m3 : mem) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b'0 : block) (delta : Z),\nf b = Some (b'0, delta) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf b = Some (b'0, delta) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs0 + delta) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj1 : mem_inj f' m2 m3) (mi_freeblocks1 : forall b : block, ~ valid_block m2 b -> f' b = None) (mi_mappedblocks1 : forall (b b'0 : block) (delta : Z),\nf' b = Some (b'0, delta) -> valid_block m3 b'0) (mi_no_overlap1 : meminj_no_overlap f' m2) (mi_representable1 : forall (b b'0 : block) (delta : Z) (ofs0 : ptrofs),\nf' b = Some (b'0, delta) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta <= Ptrofs.max_unsigned) (mi_perm_inv1 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta : Z) \n  (k0 : perm_kind) (p0 : permission),\nf' b0 = Some (b3, delta) ->\nperm m3 b3 (ofs0 + delta) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (b' : block) (delta' : Z) (Heqo : f b1 = Some (b', delta')) (delta'' : Z) (Heqo0 : f' b' = Some (b2, delta'')) (H0 : perm m3 b2 (ofs + delta' + delta'') k p) (A : ~ perm m2 b' (ofs + delta') Max Nonempty) (H : perm m1 b1 ofs Max Nonempty) : perm m2 b' (ofs + delta') Max Nonempty.","proofString":"eapply perm_inj; eauto."},{"statement":"(f : meminj) (v1 v2 v3 : val) (H : Val.lessdef v1 v2) (H0 : Val.inject f v2 v3) : Val.inject f v1 v3.","proofString":"inv H.\nauto.\nauto."},{"statement":"(f : meminj) (v2 v3 : val) (H0 : Val.inject f v2 v3) : Val.inject f v2 v3.","proofString":"auto."},{"statement":"(f : meminj) (v2 v3 : val) (H0 : Val.inject f v2 v3) : Val.inject f Vundef v3.","proofString":"auto."},{"statement":"(f : meminj) (v1 v2 v3 : val) (H : Val.inject f v1 v2) (H0 : Val.lessdef v2 v3) : Val.inject f v1 v3.","proofString":"inv H0.\nauto.\ninv H.\nauto."},{"statement":"(f : meminj) (v1 v3 : val) (H : Val.inject f v1 v3) : Val.inject f v1 v3.","proofString":"auto."},{"statement":"(f : meminj) (v1 v3 : val) (H : Val.inject f v1 Vundef) : Val.inject f v1 v3.","proofString":"inv H.\nauto."},{"statement":"(f : meminj) (v3 : val) : Val.inject f Vundef v3.","proofString":"auto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (H0 : inject f m2 m3) : inject f m1 m3.","proofString":"inversion H; inv H0.\nconstructor; intros.\nreplace f with (compose_meminj inject_id f).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto.\neapply mi_freeblocks0.\nerewrite <- valid_block_extends; eauto.\neauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_extends; eauto.\neapply mi_representable0; eauto.\ndestruct H1; eauto using perm_extends.\nexploit mi_perm_inv0; eauto.\nintros [A|A].\neapply mext_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : inject f m1 m3.","proofString":"constructor; intros.\nreplace f with (compose_meminj inject_id f).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto.\neapply mi_freeblocks0.\nerewrite <- valid_block_extends; eauto.\neauto.\nred; intros.\neapply mi_no_overlap0; eauto; eapply perm_extends; eauto.\neapply mi_representable0; eauto.\ndestruct H1; eauto using perm_extends.\nexploit mi_perm_inv0; eauto.\nintros [A|A].\neapply mext_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : mem_inj f m1 m3.","proofString":"replace f with (compose_meminj inject_id f).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : mem_inj (compose_meminj inject_id f) m1 m3.","proofString":"eapply mem_inj_compose; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : compose_meminj inject_id f = f.","proofString":"apply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) (x : block) : compose_meminj inject_id f x = f x.","proofString":"unfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) (x : block) : match f x with\n| Some (b'', delta') => Some (b'', 0 + delta')\n| None => None\nend = f x.","proofString":"destruct (f x) as [[y delta] | ]; auto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b0 : block, ~ valid_block m2 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) (b : block) (H0 : ~ valid_block m1 b) : f b = None.","proofString":"eapply mi_freeblocks0.\nerewrite <- valid_block_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b0 : block, ~ valid_block m2 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m2 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) (b : block) (H0 : ~ valid_block m1 b) : ~ valid_block m2 b.","proofString":"erewrite <- valid_block_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs k p -> perm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b0 : block, ~ valid_block m2 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m2 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m3 b2 (ofs + delta0) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) (b b' : block) (delta : Z) (H0 : f b = Some (b', delta)) : valid_block m3 b'.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m3 b2 (ofs + delta) k p ->\nperm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty) : meminj_no_overlap f m1.","proofString":"red; intros.\neapply mi_no_overlap0; eauto; eapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m3 b3 (ofs + delta) k p ->\nperm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H0 : b1 <> b2) (H1 : f b1 = Some (b1', delta1)) (H2 : f b2 = Some (b2', delta2)) (H3 : perm m1 b1 ofs1 Max Nonempty) (H4 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eapply mi_no_overlap0; eauto; eapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b0 : block, ~ valid_block m2 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m3 b2 (ofs0 + delta0) k p ->\nperm m2 b1 ofs0 k p \\/ ~ perm m2 b1 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (H0 : f b = Some (b', delta)) (H1 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; eauto.\ndestruct H1; eauto using perm_extends."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m2 b0 ofs0 k p -> perm m1 b0 ofs0 k p \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b0 : block, ~ valid_block m2 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m3 b'0) (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m2 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m3 b2 (ofs0 + delta0) k p ->\nperm m2 b1 ofs0 k p \\/ ~ perm m2 b1 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (H0 : f b = Some (b', delta)) (H1 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) : perm m2 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs - 1) Max Nonempty.","proofString":"destruct H1; eauto using perm_extends."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b ofs0 k0 p0 -> perm m1 b ofs0 k0 p0 \\/ ~ perm m1 b ofs0 Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H0 : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"exploit mi_perm_inv0; eauto.\nintros [A|A].\neapply mext_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b ofs0 k0 p0 -> perm m1 b ofs0 k0 p0 \\/ ~ perm m1 b ofs0 Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H0 : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) : perm m2 b1 ofs k p \\/ ~ perm m2 b1 ofs Max Nonempty ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"intros [A|A].\neapply mext_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b ofs0 k0 p0 -> perm m1 b ofs0 k0 p0 \\/ ~ perm m1 b ofs0 Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H0 : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) (A : perm m2 b1 ofs k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eapply mext_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b ofs0 k0 p0 -> perm m1 b ofs0 k0 p0 \\/ ~ perm m1 b ofs0 Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H0 : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) (A : ~ perm m2 b1 ofs Max Nonempty) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"right; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b ofs0 k0 p0 -> perm m1 b ofs0 k0 p0 \\/ ~ perm m1 b ofs0 Max Nonempty) (mi_inj0 : mem_inj f m2 m3) (mi_freeblocks0 : forall b : block, ~ valid_block m2 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m3 b') (mi_no_overlap0 : meminj_no_overlap f m2) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m2 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m2 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m3 b3 (ofs0 + delta0) k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H0 : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) (A : ~ perm m2 b1 ofs Max Nonempty) (H2 : perm m1 b1 ofs Max Nonempty) : perm m2 b1 ofs Max Nonempty.","proofString":"eapply perm_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H : inject f m1 m2) (H0 : extends m2 m3) : inject f m1 m3.","proofString":"inv H; inversion H0.\nconstructor; intros.\nreplace f with (compose_meminj f inject_id).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto.\ndecEq.\ndecEq.\nlia.\neauto.\nerewrite <- valid_block_extends; eauto.\nred; intros.\neapply mi_no_overlap0; eauto.\neapply mi_representable0; eauto.\nexploit mext_perm_inv0; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : inject f m1 m3.","proofString":"constructor; intros.\nreplace f with (compose_meminj f inject_id).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto.\ndecEq.\ndecEq.\nlia.\neauto.\nerewrite <- valid_block_extends; eauto.\nred; intros.\neapply mi_no_overlap0; eauto.\neapply mi_representable0; eauto.\nexploit mext_perm_inv0; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : mem_inj f m1 m3.","proofString":"replace f with (compose_meminj f inject_id).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto.\ndecEq.\ndecEq.\nlia."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : mem_inj (compose_meminj f inject_id) m1 m3.","proofString":"eapply mem_inj_compose; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : compose_meminj f inject_id = f.","proofString":"apply extensionality; intros.\nunfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto.\ndecEq.\ndecEq.\nlia."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (x : block) : compose_meminj f inject_id x = f x.","proofString":"unfold compose_meminj, inject_id.\ndestruct (f x) as [[y delta] | ]; auto.\ndecEq.\ndecEq.\nlia."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (x : block) : match f x with\n| Some (b', delta) => Some (b', delta + 0)\n| None => None\nend = f x.","proofString":"destruct (f x) as [[y delta] | ]; auto.\ndecEq.\ndecEq.\nlia."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (x y : block) (delta : Z) : Some (y, delta + 0) = Some (y, delta).","proofString":"decEq.\ndecEq.\nlia."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (x y : block) (delta : Z) : (y, delta + 0) = (y, delta).","proofString":"decEq.\nlia."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (x y : block) (delta : Z) : delta + 0 = delta.","proofString":"lia."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b' : block) (delta : Z),\nf b0 = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nf b0 = Some (b', delta) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b0 ofs k p -> perm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b : block) (H : ~ valid_block m1 b) : f b = None.","proofString":"eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs + delta0) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b0 : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b0 ofs k p -> perm m2 b0 ofs k p \\/ ~ perm m2 b0 ofs Max Nonempty) (b b' : block) (delta : Z) (H : f b = Some (b', delta)) : valid_block m3 b'.","proofString":"erewrite <- valid_block_extends; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta) ->\nperm m2 b2 (ofs + delta) k p ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : meminj_no_overlap f m1.","proofString":"red; intros.\neapply mi_no_overlap0; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta : Z),\nf b = Some (b', delta) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nf b = Some (b', delta) ->\nperm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs : Z) (b3 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nf b0 = Some (b3, delta) ->\nperm m2 b3 (ofs + delta) k p ->\nperm m1 b0 ofs k p \\/ ~ perm m1 b0 ofs Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H1 : f b1 = Some (b1', delta1)) (H2 : f b2 = Some (b2', delta2)) (H3 : perm m1 b1 ofs1 Max Nonempty) (H4 : perm m1 b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"eapply mi_no_overlap0; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b0 : block, ~ valid_block m1 b0 -> f b0 = None) (mi_mappedblocks0 : forall (b0 b'0 : block) (delta0 : Z),\nf b0 = Some (b'0, delta0) -> valid_block m2 b'0) (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nf b0 = Some (b'0, delta0) ->\nperm m1 b0 (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b0 (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta0 : Z) \n  (k : perm_kind) (p : permission),\nf b1 = Some (b2, delta0) ->\nperm m2 b2 (ofs0 + delta0) k p ->\nperm m1 b1 ofs0 k p \\/ ~ perm m1 b1 ofs0 Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nperm m3 b0 ofs0 k p -> perm m2 b0 ofs0 k p \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b b' : block) (delta : Z) (ofs : ptrofs) (H : f b = Some (b', delta)) (H1 : perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"eapply mi_representable0; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b ofs0 k0 p0 -> perm m2 b ofs0 k0 p0 \\/ ~ perm m2 b ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"exploit mext_perm_inv0; eauto.\nintros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b ofs0 k0 p0 -> perm m2 b ofs0 k0 p0 \\/ ~ perm m2 b ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) : perm m2 b2 (ofs + delta) k p \\/ ~ perm m2 b2 (ofs + delta) Max Nonempty ->\nperm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"intros [A|A].\neapply mi_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b ofs0 k0 p0 -> perm m2 b ofs0 k0 p0 \\/ ~ perm m2 b ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) (A : perm m2 b2 (ofs + delta) k p) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"eapply mi_perm_inv0; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b ofs0 k0 p0 -> perm m2 b ofs0 k0 p0 \\/ ~ perm m2 b ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) (A : ~ perm m2 b2 (ofs + delta) Max Nonempty) : perm m1 b1 ofs k p \\/ ~ perm m1 b1 ofs Max Nonempty.","proofString":"right; red; intros; elim A.\neapply perm_inj; eauto."},{"statement":"(f : meminj) (m1 m2 m3 : mem) (H0 : extends m2 m3) (mi_inj0 : mem_inj f m1 m2) (mi_freeblocks0 : forall b : block, ~ valid_block m1 b -> f b = None) (mi_mappedblocks0 : forall (b b' : block) (delta0 : Z),\nf b = Some (b', delta0) -> valid_block m2 b') (mi_no_overlap0 : meminj_no_overlap f m1) (mi_representable0 : forall (b b' : block) (delta0 : Z) (ofs0 : ptrofs),\nf b = Some (b', delta0) ->\nperm m1 b (Ptrofs.unsigned ofs0) Max Nonempty \\/\nperm m1 b (Ptrofs.unsigned ofs0 - 1) Max Nonempty ->\ndelta0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs0 + delta0 <= Ptrofs.max_unsigned) (mi_perm_inv0 : forall (b0 : block) (ofs0 : Z) (b3 : block) (delta0 : Z) \n  (k0 : perm_kind) (p0 : permission),\nf b0 = Some (b3, delta0) ->\nperm m2 b3 (ofs0 + delta0) k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next0 : nextblock m2 = nextblock m3) (mext_inj0 : mem_inj inject_id m2 m3) (mext_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b ofs0 k0 p0 -> perm m2 b ofs0 k0 p0 \\/ ~ perm m2 b ofs0 Max Nonempty) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (b2, delta)) (H1 : perm m3 b2 (ofs + delta) k p) (A : ~ perm m2 b2 (ofs + delta) Max Nonempty) (H2 : perm m1 b1 ofs Max Nonempty) : perm m2 b2 (ofs + delta) Max Nonempty.","proofString":"eapply perm_inj; eauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (H0 : extends m2 m3) : extends m1 m3.","proofString":"inversion H; subst; inv H0; constructor; intros.\ncongruence.\nreplace inject_id with (compose_meminj inject_id inject_id).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\nauto.\nexploit mext_perm_inv1; eauto.\nintros [A|A].\neapply mext_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : nextblock m1 = nextblock m3.","proofString":"congruence."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : mem_inj inject_id m1 m3.","proofString":"replace inject_id with (compose_meminj inject_id inject_id).\neapply mem_inj_compose; eauto.\napply extensionality; intros.\nunfold compose_meminj, inject_id.\nauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : mem_inj (compose_meminj inject_id inject_id) m1 m3.","proofString":"eapply mem_inj_compose; eauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) : compose_meminj inject_id inject_id = inject_id.","proofString":"apply extensionality; intros.\nunfold compose_meminj, inject_id.\nauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (x : block) : compose_meminj inject_id inject_id x = inject_id x.","proofString":"unfold compose_meminj, inject_id.\nauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m2 b ofs k p -> perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nperm m3 b ofs k p -> perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty) (x : block) : Some (x, 0 + 0) = Some (x, 0).","proofString":"auto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b0 ofs0 k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m3 b ofs k p) : perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty.","proofString":"exploit mext_perm_inv1; eauto.\nintros [A|A].\neapply mext_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b0 ofs0 k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m3 b ofs k p) : perm m2 b ofs k p \\/ ~ perm m2 b ofs Max Nonempty ->\nperm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty.","proofString":"intros [A|A].\neapply mext_perm_inv0; eauto.\nright; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b0 ofs0 k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m3 b ofs k p) (A : perm m2 b ofs k p) : perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty.","proofString":"eapply mext_perm_inv0; eauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b0 ofs0 k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m3 b ofs k p) (A : ~ perm m2 b ofs Max Nonempty) : perm m1 b ofs k p \\/ ~ perm m1 b ofs Max Nonempty.","proofString":"right; red; intros; elim A.\neapply perm_extends; eauto."},{"statement":"(m1 m2 m3 : mem) (H : extends m1 m2) (mext_next0 : nextblock m1 = nextblock m2) (mext_inj0 : mem_inj inject_id m1 m2) (mext_perm_inv0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m2 b0 ofs0 k0 p0 ->\nperm m1 b0 ofs0 k0 p0 \\/ ~ perm m1 b0 ofs0 Max Nonempty) (mext_next1 : nextblock m2 = nextblock m3) (mext_inj1 : mem_inj inject_id m2 m3) (mext_perm_inv1 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nperm m3 b0 ofs0 k0 p0 ->\nperm m2 b0 ofs0 k0 p0 \\/ ~ perm m2 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm m3 b ofs k p) (A : ~ perm m2 b ofs Max Nonempty) (H1 : perm m1 b ofs Max Nonempty) : perm m2 b ofs Max Nonempty.","proofString":"eapply perm_extends; eauto."},{"statement":"(thr : block) (m : mem) (b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H0 : (if plt b1 thr then Some (b1, 0) else None) = Some (b1', delta1)) (H1 : (if plt b2 thr then Some (b2, 0) else None) = Some (b2', delta2)) (H2 : perm m b1 ofs1 Max Nonempty) (H3 : perm m b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"destruct (plt b1 thr); inversion H0; subst.\ndestruct (plt b2 thr); inversion H1; subst.\nauto."},{"statement":"(thr : block) (m : mem) (b1' b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H0 : Some (b1', 0) = Some (b1', 0)) (p : Plt b1' thr) (H : b1' <> b2) (H1 : (if plt b2 thr then Some (b2, 0) else None) = Some (b2', delta2)) (H2 : perm m b1' ofs1 Max Nonempty) (H3 : perm m b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + 0 <> ofs2 + delta2.","proofString":"destruct (plt b2 thr); inversion H1; subst.\nauto."},{"statement":"(thr : block) (m : mem) (b1' b2' : block) (ofs1 ofs2 : Z) (H0 : Some (b1', 0) = Some (b1', 0)) (p : Plt b1' thr) (H1 : Some (b2', 0) = Some (b2', 0)) (p0 : Plt b2' thr) (H : b1' <> b2') (H2 : perm m b1' ofs1 Max Nonempty) (H3 : perm m b2' ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + 0 <> ofs2 + 0.","proofString":"auto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) : inject (flat_inj (nextblock m)) m m.","proofString":"constructor.\nauto.\nunfold flat_inj, valid_block; intros.\napply pred_dec_false.\nauto.\nunfold flat_inj, valid_block; intros.\ndestruct (plt b (nextblock m)); inversion H0; subst.\nauto.\napply flat_inj_no_overlap.\nunfold flat_inj; intros.\ndestruct (plt b (nextblock m)); inv H0.\ngeneralize (Ptrofs.unsigned_range_2 ofs); lia.\nunfold flat_inj; intros.\ndestruct (plt b1 (nextblock m)); inv H0.\nrewrite Z.add_0_r in H1; auto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) : mem_inj (flat_inj (nextblock m)) m m.","proofString":"auto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) : forall b : block, ~ valid_block m b -> flat_inj (nextblock m) b = None.","proofString":"unfold flat_inj, valid_block; intros.\napply pred_dec_false.\nauto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (b : block) (H0 : ~ Plt b (nextblock m)) : (if plt b (nextblock m) then Some (b, 0) else None) = None.","proofString":"apply pred_dec_false.\nauto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (b : block) (H0 : ~ Plt b (nextblock m)) : ~ Plt b (nextblock m).","proofString":"auto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) : forall (b b' : block) (delta : Z),\nflat_inj (nextblock m) b = Some (b', delta) -> valid_block m b'.","proofString":"unfold flat_inj, valid_block; intros.\ndestruct (plt b (nextblock m)); inversion H0; subst.\nauto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (b b' : block) (delta : Z) (H0 : (if plt b (nextblock m) then Some (b, 0) else None) = Some (b', delta)) : Plt b' (nextblock m).","proofString":"destruct (plt b (nextblock m)); inversion H0; subst.\nauto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (b' : block) (H0 : Some (b', 0) = Some (b', 0)) (p : Plt b' (nextblock m)) : Plt b' (nextblock m).","proofString":"auto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) : meminj_no_overlap (flat_inj (nextblock m)) m.","proofString":"apply flat_inj_no_overlap."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nflat_inj (nextblock m) b = Some (b', delta) ->\nperm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m b (Ptrofs.unsigned ofs - 1) Max Nonempty ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"unfold flat_inj; intros.\ndestruct (plt b (nextblock m)); inv H0.\ngeneralize (Ptrofs.unsigned_range_2 ofs); lia."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (b b' : block) (delta : Z) (ofs : ptrofs) (H0 : (if plt b (nextblock m) then Some (b, 0) else None) = Some (b', delta)) (H1 : perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"destruct (plt b (nextblock m)); inv H0.\ngeneralize (Ptrofs.unsigned_range_2 ofs); lia."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (b' : block) (ofs : ptrofs) (H1 : perm m b' (Ptrofs.unsigned ofs) Max Nonempty \\/\nperm m b' (Ptrofs.unsigned ofs - 1) Max Nonempty) (p : Plt b' (nextblock m)) : 0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + 0 <= Ptrofs.max_unsigned.","proofString":"generalize (Ptrofs.unsigned_range_2 ofs); lia."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z) \n  (k : perm_kind) (p : permission),\nflat_inj (nextblock m) b1 = Some (b2, delta) ->\nperm m b2 (ofs + delta) k p ->\nperm m b1 ofs k p \\/ ~ perm m b1 ofs Max Nonempty.","proofString":"unfold flat_inj; intros.\ndestruct (plt b1 (nextblock m)); inv H0.\nrewrite Z.add_0_r in H1; auto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p : permission) (H0 : (if plt b1 (nextblock m) then Some (b1, 0) else None) = Some (b2, delta)) (H1 : perm m b2 (ofs + delta) k p) : perm m b1 ofs k p \\/ ~ perm m b1 ofs Max Nonempty.","proofString":"destruct (plt b1 (nextblock m)); inv H0.\nrewrite Z.add_0_r in H1; auto."},{"statement":"(m : mem') (H : inject_neutral (nextblock m) m) (ofs : Z) (b2 : block) (k : perm_kind) (p : permission) (p0 : Plt b2 (nextblock m)) (H1 : perm m b2 (ofs + 0) k p) : perm m b2 ofs k p \\/ ~ perm m b2 ofs Max Nonempty.","proofString":"rewrite Z.add_0_r in H1; auto."},{"statement":"(thr : block) : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nflat_inj thr b1 = Some (b2, delta) ->\nperm empty b1 ofs k p -> perm empty b2 (ofs + delta) k p.","proofString":"unfold flat_inj; intros.\ndestruct (plt b1 thr); inv H.\nreplace (ofs + 0) with ofs by lia; auto."},{"statement":"(thr b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : (if plt b1 thr then Some (b1, 0) else None) = Some (b2, delta)) (H0 : perm empty b1 ofs k p) : perm empty b2 (ofs + delta) k p.","proofString":"destruct (plt b1 thr); inv H.\nreplace (ofs + 0) with ofs by lia; auto."},{"statement":"(thr b2 : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : perm empty b2 ofs k p) (p0 : Plt b2 thr) : perm empty b2 (ofs + 0) k p.","proofString":"replace (ofs + 0) with ofs by lia; auto."},{"statement":"(thr : block) : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\nflat_inj thr b1 = Some (b2, delta) ->\nrange_perm empty b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta).","proofString":"unfold flat_inj; intros.\ndestruct (plt b1 thr); inv H.\napply Z.divide_0_r."},{"statement":"(thr b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H : (if plt b1 thr then Some (b1, 0) else None) = Some (b2, delta)) (H0 : range_perm empty b1 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"destruct (plt b1 thr); inv H.\napply Z.divide_0_r."},{"statement":"(thr b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : range_perm empty b2 ofs (ofs + size_chunk chunk) Max p) (p0 : Plt b2 thr) : (align_chunk chunk | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(thr : block) : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\nflat_inj thr b1 = Some (b2, delta) ->\nperm empty b1 ofs Cur Readable ->\nmemval_inject (flat_inj thr) (ZMap.get ofs (mem_contents empty) # b1)\n  (ZMap.get (ofs + delta) (mem_contents empty) # b2).","proofString":"intros; simpl.\nrewrite ! PMap.gi.\nrewrite ! ZMap.gi.\nconstructor."},{"statement":"(thr b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : flat_inj thr b1 = Some (b2, delta)) (H0 : perm empty b1 ofs Cur Readable) : memval_inject (flat_inj thr)\n  (ZMap.get ofs (PMap.init (ZMap.init Undef)) # b1)\n  (ZMap.get (ofs + delta) (PMap.init (ZMap.init Undef)) # b2).","proofString":"rewrite ! PMap.gi.\nrewrite ! ZMap.gi.\nconstructor."},{"statement":"(thr b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : flat_inj thr b1 = Some (b2, delta)) (H0 : perm empty b1 ofs Cur Readable) : memval_inject (flat_inj thr) (ZMap.get ofs (ZMap.init Undef))\n  (ZMap.get (ofs + delta) (ZMap.init Undef)).","proofString":"rewrite ! ZMap.gi.\nconstructor."},{"statement":"(thr b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H : flat_inj thr b1 = Some (b2, delta)) (H0 : perm empty b1 ofs Cur Readable) : memval_inject (flat_inj thr) Undef Undef.","proofString":"constructor."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) : mem_inj (flat_inj thr) m' m'.","proofString":"eapply alloc_left_mapped_inj with (m1 := m) (b2 := b) (delta := 0).\neapply alloc_right_inj; eauto.\neauto.\neauto with mem.\nred.\nintros.\napply Z.divide_0_r.\nintros.\napply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia.\nunfold flat_inj.\napply pred_dec_true.\nrewrite (alloc_result _ _ _ _ _ H).\nauto."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) : mem_inj (flat_inj thr) m m'.","proofString":"eapply alloc_right_inj; eauto."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) : valid_block m' b.","proofString":"eauto with mem."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) : forall chunk : memory_chunk,\nsize_chunk chunk <= hi - lo -> (align_chunk chunk | 0).","proofString":"intros.\napply Z.divide_0_r."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) (chunk : memory_chunk) (H2 : size_chunk chunk <= hi - lo) : (align_chunk chunk | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) (ofs : Z) (k : perm_kind) (p : permission) (H2 : lo <= ofs < hi) : perm m' b (ofs + 0) k p.","proofString":"apply perm_implies with Freeable; auto with mem.\neapply perm_alloc_2; eauto.\nlia."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) (ofs : Z) (k : perm_kind) (p : permission) (H2 : lo <= ofs < hi) : perm m' b (ofs + 0) k Freeable.","proofString":"eapply perm_alloc_2; eauto.\nlia."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) (ofs : Z) (k : perm_kind) (p : permission) (H2 : lo <= ofs < hi) : lo <= ofs + 0 < hi.","proofString":"lia."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) : (if plt b thr then Some (b, 0) else None) = Some (b, 0).","proofString":"apply pred_dec_true.\nrewrite (alloc_result _ _ _ _ _ H).\nauto."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) : Plt b thr.","proofString":"rewrite (alloc_result _ _ _ _ _ H).\nauto."},{"statement":"(thr : block) (m : mem) (lo hi : Z) (b : block) (m' : mem') (H : alloc m lo hi = (m', b)) (H0 : inject_neutral thr m) (H1 : Plt (nextblock m) thr) : Plt (nextblock m) thr.","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (thr : block) (H : store chunk m b ofs v = Some m') (H0 : inject_neutral thr m) (H1 : Plt b thr) (H2 : Val.inject (flat_inj thr) v v) : mem_inj (flat_inj thr) m' m'.","proofString":"exploit store_mapped_inj.\neauto.\neauto.\napply flat_inj_no_overlap.\nunfold flat_inj.\napply pred_dec_true; auto.\neauto.\nreplace (ofs + 0) with ofs by lia.\nintros [m'' [A B]].\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (thr : block) (H : store chunk m b ofs v = Some m') (H0 : inject_neutral thr m) (H1 : Plt b thr) (H2 : Val.inject (flat_inj thr) v v) : (exists n2 : mem,\n   store chunk m b ofs v = Some n2 /\\ mem_inj (flat_inj thr) m' n2) ->\nmem_inj (flat_inj thr) m' m'.","proofString":"intros [m'' [A B]].\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (thr : block) (H : store chunk m b ofs v = Some m') (H0 : inject_neutral thr m) (H1 : Plt b thr) (H2 : Val.inject (flat_inj thr) v v) (m'' : mem) (A : store chunk m b ofs v = Some m'') (B : mem_inj (flat_inj thr) m' m'') : mem_inj (flat_inj thr) m' m'.","proofString":"congruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (thr : block) (H : drop_perm m b lo hi p = Some m') (H0 : mem_inj (flat_inj thr) m m) (H1 : Plt b thr) : mem_inj (flat_inj thr) m' m'.","proofString":"exploit drop_mapped_inj; eauto.\napply flat_inj_no_overlap.\nunfold flat_inj.\napply pred_dec_true; eauto.\nrepeat rewrite Z.add_0_r.\nintros [m'' [A B]].\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (thr : block) (H : drop_perm m b lo hi p = Some m') (H0 : mem_inj (flat_inj thr) m m) (H1 : Plt b thr) : meminj_no_overlap (flat_inj thr) m.","proofString":"apply flat_inj_no_overlap."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (thr : block) (H : drop_perm m b lo hi p = Some m') (H0 : mem_inj (flat_inj thr) m m) (H1 : Plt b thr) : (exists m2' : mem,\n   drop_perm m b lo hi p = Some m2' /\\ mem_inj (flat_inj thr) m' m2') ->\nmem_inj (flat_inj thr) m' m'.","proofString":"intros [m'' [A B]].\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (thr : block) (H : drop_perm m b lo hi p = Some m') (H0 : mem_inj (flat_inj thr) m m) (H1 : Plt b thr) (m'' : mem) (A : drop_perm m b lo hi p = Some m'') (B : mem_inj (flat_inj thr) m' m'') : mem_inj (flat_inj thr) m' m'.","proofString":"congruence."},{"statement":"(m : mem) : Ple (nextblock m) (nextblock m).","proofString":"apply Ple_refl."},{"statement":"(m : mem) : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nP b ofs -> valid_block m b -> perm m b ofs k p <-> perm m b ofs k p.","proofString":"tauto."},{"statement":"(m : mem) : forall (b : block) (ofs : Z),\nP b ofs ->\nperm m b ofs Cur Readable ->\nZMap.get ofs (mem_contents m) # b = ZMap.get ofs (mem_contents m) # b.","proofString":"tauto."},{"statement":"(m m' : mem) (b : block) (H : unchanged_on m m') (H0 : Plt b (nextblock m)) : Plt b (nextblock m').","proofString":"apply unchanged_on_nextblock in H.\nextlia."},{"statement":"(m m' : mem) (b : block) (H : Ple (nextblock m) (nextblock m')) (H0 : Plt b (nextblock m)) : Plt b (nextblock m').","proofString":"extlia."},{"statement":"(m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : unchanged_on m m') (H0 : P b ofs) (H1 : perm m b ofs k p) : perm m' b ofs k p.","proofString":"destruct H.\napply unchanged_on_perm0; auto.\neapply perm_valid_block; eauto."},{"statement":"(m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nP b0 ofs0 ->\nvalid_block m b0 -> perm m b0 ofs0 k0 p0 <-> perm m' b0 ofs0 k0 p0) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : P b ofs) (H1 : perm m b ofs k p) : perm m' b ofs k p.","proofString":"apply unchanged_on_perm0; auto.\neapply perm_valid_block; eauto."},{"statement":"(m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nP b0 ofs0 ->\nvalid_block m b0 -> perm m b0 ofs0 k0 p0 <-> perm m' b0 ofs0 k0 p0) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : P b ofs) (H1 : perm m b ofs k p) : valid_block m b.","proofString":"eapply perm_valid_block; eauto."},{"statement":"(m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : unchanged_on m m') (H0 : P b ofs) (H1 : valid_block m b) (H2 : perm m' b ofs k p) : perm m b ofs k p.","proofString":"destruct H.\napply unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nP b0 ofs0 ->\nvalid_block m b0 -> perm m b0 ofs0 k0 p0 <-> perm m' b0 ofs0 k0 p0) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : P b ofs) (H1 : valid_block m b) (H2 : perm m' b ofs k p) : perm m b ofs k p.","proofString":"apply unchanged_on_perm0; auto."},{"statement":"(m1 m2 m3 : mem) (H : unchanged_on m1 m2) (H0 : unchanged_on m2 m3) : Ple (nextblock m1) (nextblock m3).","proofString":"apply Ple_trans with (nextblock m2); apply unchanged_on_nextblock; auto."},{"statement":"(m1 m2 m3 : mem) (H : unchanged_on m1 m2) (H0 : unchanged_on m2 m3) : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nP b ofs -> valid_block m1 b -> perm m1 b ofs k p <-> perm m3 b ofs k p.","proofString":"intros.\ntransitivity (perm m2 b ofs k p); apply unchanged_on_perm; auto.\neapply valid_block_unchanged_on; eauto."},{"statement":"(m1 m2 m3 : mem) (H : unchanged_on m1 m2) (H0 : unchanged_on m2 m3) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b ofs) (H2 : valid_block m1 b) : perm m1 b ofs k p <-> perm m3 b ofs k p.","proofString":"transitivity (perm m2 b ofs k p); apply unchanged_on_perm; auto.\neapply valid_block_unchanged_on; eauto."},{"statement":"(m1 m2 m3 : mem) (H : unchanged_on m1 m2) (H0 : unchanged_on m2 m3) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b ofs) (H2 : valid_block m1 b) : valid_block m2 b.","proofString":"eapply valid_block_unchanged_on; eauto."},{"statement":"(m1 m2 m3 : mem) (H : unchanged_on m1 m2) (H0 : unchanged_on m2 m3) : forall (b : block) (ofs : Z),\nP b ofs ->\nperm m1 b ofs Cur Readable ->\nZMap.get ofs (mem_contents m3) # b = ZMap.get ofs (mem_contents m1) # b.","proofString":"intros.\ntransitivity (ZMap.get ofs (mem_contents m2)#b); apply unchanged_on_contents; auto.\neapply perm_unchanged_on; eauto."},{"statement":"(m1 m2 m3 : mem) (H : unchanged_on m1 m2) (H0 : unchanged_on m2 m3) (b : block) (ofs : Z) (H1 : P b ofs) (H2 : perm m1 b ofs Cur Readable) : ZMap.get ofs (mem_contents m3) # b = ZMap.get ofs (mem_contents m1) # b.","proofString":"transitivity (ZMap.get ofs (mem_contents m2)#b); apply unchanged_on_contents; auto.\neapply perm_unchanged_on; eauto."},{"statement":"(m1 m2 m3 : mem) (H : unchanged_on m1 m2) (H0 : unchanged_on m2 m3) (b : block) (ofs : Z) (H1 : P b ofs) (H2 : perm m1 b ofs Cur Readable) : perm m2 b ofs Cur Readable.","proofString":"eapply perm_unchanged_on; eauto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) : loadbytes m' b ofs n = loadbytes m b ofs n.","proofString":"destruct (zle n 0).\nerewrite ! loadbytes_empty by assumption.\nauto.\nunfold loadbytes.\ndestruct H.\ndestruct (range_perm_dec m b ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nf_equal.\napply getN_exten.\nintros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto.\nred; intros.\napply unchanged_on_perm0; auto.\nrewrite pred_dec_false.\nauto.\nred; intros; elim n0; red; intros.\napply <- unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (l : n <= 0) : loadbytes m' b ofs n = loadbytes m b ofs n.","proofString":"erewrite ! loadbytes_empty by assumption.\nauto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) : loadbytes m' b ofs n = loadbytes m b ofs n.","proofString":"unfold loadbytes.\ndestruct H.\ndestruct (range_perm_dec m b ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nf_equal.\napply getN_exten.\nintros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto.\nred; intros.\napply unchanged_on_perm0; auto.\nrewrite pred_dec_false.\nauto.\nred; intros; elim n0; red; intros.\napply <- unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) : (if range_perm_dec m' b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m') # b)\n else None) =\n(if range_perm_dec m b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m) # b)\n else None).","proofString":"destruct H.\ndestruct (range_perm_dec m b ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nf_equal.\napply getN_exten.\nintros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto.\nred; intros.\napply unchanged_on_perm0; auto.\nrewrite pred_dec_false.\nauto.\nred; intros; elim n0; red; intros.\napply <- unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) : (if range_perm_dec m' b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m') # b)\n else None) =\n(if range_perm_dec m b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m) # b)\n else None).","proofString":"destruct (range_perm_dec m b ofs (ofs + n) Cur Readable).\nrewrite pred_dec_true.\nf_equal.\napply getN_exten.\nintros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto.\nred; intros.\napply unchanged_on_perm0; auto.\nrewrite pred_dec_false.\nauto.\nred; intros; elim n0; red; intros.\napply <- unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) : (if range_perm_dec m' b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m') # b)\n else None) = Some (getN (Z.to_nat n) ofs (mem_contents m) # b).","proofString":"rewrite pred_dec_true.\nf_equal.\napply getN_exten.\nintros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto.\nred; intros.\napply unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) : Some (getN (Z.to_nat n) ofs (mem_contents m') # b) =\nSome (getN (Z.to_nat n) ofs (mem_contents m) # b).","proofString":"f_equal.\napply getN_exten.\nintros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) : getN (Z.to_nat n) ofs (mem_contents m') # b =\ngetN (Z.to_nat n) ofs (mem_contents m) # b.","proofString":"apply getN_exten.\nintros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) : forall i : Z,\nofs <= i < ofs + Z.of_nat (Z.to_nat n) ->\nZMap.get i (mem_contents m') # b = ZMap.get i (mem_contents m) # b.","proofString":"intros.\nrewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i0 : Z, ofs <= i0 < ofs + n -> P b i0) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) (i : Z) (H : ofs <= i < ofs + Z.of_nat (Z.to_nat n)) : ZMap.get i (mem_contents m') # b = ZMap.get i (mem_contents m) # b.","proofString":"rewrite Z2Nat.id in H by lia.\napply unchanged_on_contents0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i0 : Z, ofs <= i0 < ofs + n -> P b i0) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) (i : Z) (H : ofs <= i < ofs + n) : ZMap.get i (mem_contents m') # b = ZMap.get i (mem_contents m) # b.","proofString":"apply unchanged_on_contents0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) : range_perm m' b ofs (ofs + n) Cur Readable.","proofString":"red; intros.\napply unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs1 : Z) (k : perm_kind) (p : permission),\nP b0 ofs1 -> valid_block m b0 -> perm m b0 ofs1 k p <-> perm m' b0 ofs1 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs1 : Z),\nP b0 ofs1 ->\nperm m b0 ofs1 Cur Readable ->\nZMap.get ofs1 (mem_contents m') # b0 = ZMap.get ofs1 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (r : range_perm m b ofs (ofs + n) Cur Readable) (ofs0 : Z) (H : ofs <= ofs0 < ofs + n) : perm m' b ofs0 Cur Readable.","proofString":"apply unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (n0 : ~ range_perm m b ofs (ofs + n) Cur Readable) : (if range_perm_dec m' b ofs (ofs + n) Cur Readable\n then Some (getN (Z.to_nat n) ofs (mem_contents m') # b)\n else None) = None.","proofString":"rewrite pred_dec_false.\nauto.\nred; intros; elim n0; red; intros.\napply <- unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (n0 : ~ range_perm m b ofs (ofs + n) Cur Readable) : ~ range_perm m' b ofs (ofs + n) Cur Readable.","proofString":"red; intros; elim n0; red; intros.\napply <- unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs1 : Z) (k : perm_kind) (p : permission),\nP b0 ofs1 -> valid_block m b0 -> perm m b0 ofs1 k p <-> perm m' b0 ofs1 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs1 : Z),\nP b0 ofs1 ->\nperm m b0 ofs1 Cur Readable ->\nZMap.get ofs1 (mem_contents m') # b0 = ZMap.get ofs1 (mem_contents m) # b0) (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + n -> P b i) (g : n > 0) (n0 : ~ range_perm m b ofs (ofs + n) Cur Readable) (H : range_perm m' b ofs (ofs + n) Cur Readable) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + n) : perm m b ofs0 Cur Readable.","proofString":"apply <- unchanged_on_perm0; auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : loadbytes m b ofs n = Some bytes) : loadbytes m' b ofs n = Some bytes.","proofString":"destruct (zle n 0).\nerewrite loadbytes_empty in * by assumption.\nauto.\nrewrite <- H1.\napply loadbytes_unchanged_on_1; auto.\nexploit loadbytes_range_perm; eauto.\ninstantiate (1 := ofs).\nlia.\nintros.\neauto with mem."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : loadbytes m b ofs n = Some bytes) (l : n <= 0) : loadbytes m' b ofs n = Some bytes.","proofString":"erewrite loadbytes_empty in * by assumption.\nauto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : Some nil = Some bytes) (l : n <= 0) : Some nil = Some bytes.","proofString":"auto."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : loadbytes m b ofs n = Some bytes) (g : n > 0) : loadbytes m' b ofs n = Some bytes.","proofString":"rewrite <- H1.\napply loadbytes_unchanged_on_1; auto.\nexploit loadbytes_range_perm; eauto.\ninstantiate (1 := ofs).\nlia.\nintros.\neauto with mem."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : loadbytes m b ofs n = Some bytes) (g : n > 0) : loadbytes m' b ofs n = loadbytes m b ofs n.","proofString":"apply loadbytes_unchanged_on_1; auto.\nexploit loadbytes_range_perm; eauto.\ninstantiate (1 := ofs).\nlia.\nintros.\neauto with mem."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : loadbytes m b ofs n = Some bytes) (g : n > 0) : valid_block m b.","proofString":"exploit loadbytes_range_perm; eauto.\ninstantiate (1 := ofs).\nlia.\nintros.\neauto with mem."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : loadbytes m b ofs n = Some bytes) (g : n > 0) : ofs <= ofs < ofs + n.","proofString":"lia."},{"statement":"(m m' : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + n -> P b i) (H1 : loadbytes m b ofs n = Some bytes) (g : n > 0) (H2 : perm m b ofs Cur Readable) : valid_block m b.","proofString":"eauto with mem."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) : load chunk m' b ofs = load chunk m b ofs.","proofString":"unfold load.\ndestruct (valid_access_dec m chunk b ofs Readable).\ndestruct v.\nrewrite pred_dec_true.\nf_equal.\nf_equal.\napply getN_exten.\nintros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto.\nsplit; auto.\nred; intros.\neapply perm_unchanged_on; eauto.\nrewrite pred_dec_false.\nauto.\nred; intros [A B]; elim n; split; auto.\nred; intros; eapply perm_unchanged_on_2; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) : (if valid_access_dec m' chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b))\n else None) =\n(if valid_access_dec m chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b))\n else None).","proofString":"destruct (valid_access_dec m chunk b ofs Readable).\ndestruct v.\nrewrite pred_dec_true.\nf_equal.\nf_equal.\napply getN_exten.\nintros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto.\nsplit; auto.\nred; intros.\neapply perm_unchanged_on; eauto.\nrewrite pred_dec_false.\nauto.\nred; intros [A B]; elim n; split; auto.\nred; intros; eapply perm_unchanged_on_2; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (v : valid_access m chunk b ofs Readable) : (if valid_access_dec m' chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b))\n else None) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).","proofString":"destruct v.\nrewrite pred_dec_true.\nf_equal.\nf_equal.\napply getN_exten.\nintros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto.\nsplit; auto.\nred; intros.\neapply perm_unchanged_on; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) : (if valid_access_dec m' chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b))\n else None) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).","proofString":"rewrite pred_dec_true.\nf_equal.\nf_equal.\napply getN_exten.\nintros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto.\nsplit; auto.\nred; intros.\neapply perm_unchanged_on; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) : Some\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b)) =\nSome\n  (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).","proofString":"f_equal.\nf_equal.\napply getN_exten.\nintros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) : decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b) =\ndecode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m) # b).","proofString":"f_equal.\napply getN_exten.\nintros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) : getN (size_chunk_nat chunk) ofs (mem_contents m') # b =\ngetN (size_chunk_nat chunk) ofs (mem_contents m) # b.","proofString":"apply getN_exten.\nintros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) : forall i : Z,\nofs <= i < ofs + Z.of_nat (size_chunk_nat chunk) ->\nZMap.get i (mem_contents m') # b = ZMap.get i (mem_contents m) # b.","proofString":"intros.\nrewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i0 : Z, ofs <= i0 < ofs + size_chunk chunk -> P b i0) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) (i : Z) (H4 : ofs <= i < ofs + Z.of_nat (size_chunk_nat chunk)) : ZMap.get i (mem_contents m') # b = ZMap.get i (mem_contents m) # b.","proofString":"rewrite <- size_chunk_conv in H4.\neapply unchanged_on_contents; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i0 : Z, ofs <= i0 < ofs + size_chunk chunk -> P b i0) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) (i : Z) (H4 : ofs <= i < ofs + size_chunk chunk) : ZMap.get i (mem_contents m') # b = ZMap.get i (mem_contents m) # b.","proofString":"eapply unchanged_on_contents; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) : valid_access m' chunk b ofs Readable.","proofString":"split; auto.\nred; intros.\neapply perm_unchanged_on; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) : range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable.","proofString":"red; intros.\neapply perm_unchanged_on; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H2 : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable) (H3 : (align_chunk chunk | ofs)) (ofs0 : Z) (H4 : ofs <= ofs0 < ofs + size_chunk chunk) : perm m' b ofs0 Cur Readable.","proofString":"eapply perm_unchanged_on; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (n : ~ valid_access m chunk b ofs Readable) : (if valid_access_dec m' chunk b ofs Readable\n then\n  Some\n    (decode_val chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b))\n else None) = None.","proofString":"rewrite pred_dec_false.\nauto.\nred; intros [A B]; elim n; split; auto.\nred; intros; eapply perm_unchanged_on_2; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (n : ~ valid_access m chunk b ofs Readable) : ~ valid_access m' chunk b ofs Readable.","proofString":"red; intros [A B]; elim n; split; auto.\nred; intros; eapply perm_unchanged_on_2; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (H : unchanged_on m m') (H0 : valid_block m b) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (n : ~ valid_access m chunk b ofs Readable) (A : range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) : range_perm m b ofs (ofs + size_chunk chunk) Cur Readable.","proofString":"red; intros; eapply perm_unchanged_on_2; eauto."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H1 : load chunk m b ofs = Some v) : load chunk m' b ofs = Some v.","proofString":"rewrite <- H1.\neapply load_unchanged_on_1; eauto with mem."},{"statement":"(m m' : mem) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : unchanged_on m m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (H1 : load chunk m b ofs = Some v) : load chunk m' b ofs = load chunk m b ofs.","proofString":"eapply load_unchanged_on_1; eauto with mem."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) : Ple (nextblock m) (nextblock m').","proofString":"rewrite (nextblock_store _ _ _ _ _ _ H).\napply Ple_refl."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) : Ple (nextblock m) (nextblock m).","proofString":"apply Ple_refl."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs0) (H2 : valid_block m b0) : perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p.","proofString":"split; intros; eauto with mem."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) : ZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0.","proofString":"erewrite store_mem_contents; eauto.\nrewrite PMap.gsspec.\ndestruct (peq b0 b); auto.\nsubst b0.\napply setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) : ZMap.get ofs0\n  (PMap.set b (setN (encode_val chunk v) ofs (mem_contents m) # b)\n     (mem_contents m)) # b0 = ZMap.get ofs0 (mem_contents m) # b0.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b0 b); auto.\nsubst b0.\napply setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) : ZMap.get ofs0\n  (if peq b0 b\n   then setN (encode_val chunk v) ofs (mem_contents m) # b\n   else (mem_contents m) # b0) = ZMap.get ofs0 (mem_contents m) # b0.","proofString":"destruct (peq b0 b); auto.\nsubst b0.\napply setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) (e : b0 = b) : ZMap.get ofs0 (setN (encode_val chunk v) ofs (mem_contents m) # b) =\nZMap.get ofs0 (mem_contents m) # b0.","proofString":"subst b0.\napply setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) : ZMap.get ofs0 (setN (encode_val chunk v) ofs (mem_contents m) # b) =\nZMap.get ofs0 (mem_contents m) # b.","proofString":"apply setN_outside.\nrewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (Datatypes.length (encode_val chunk v)).","proofString":"rewrite encode_val_length.\nrewrite <- size_chunk_conv.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (size_chunk_nat chunk).","proofString":"rewrite <- size_chunk_conv.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) : ofs0 < ofs \\/ ofs0 >= ofs + size_chunk chunk.","proofString":"destruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) : ofs0 < ofs \\/ ofs0 >= ofs + size_chunk chunk.","proofString":"destruct (zlt ofs0 (ofs + size_chunk chunk)); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) (l : ofs0 < ofs + size_chunk chunk) : ofs0 < ofs \\/ ofs0 >= ofs + size_chunk chunk.","proofString":"elim (H0 ofs0).\nlia.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) (l : ofs0 < ofs + size_chunk chunk) : ofs <= ofs0 < ofs + size_chunk chunk.","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (H : store chunk m b ofs v = Some m') (H0 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) (l : ofs0 < ofs + size_chunk chunk) : P b ofs0.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) : Ple (nextblock m) (nextblock m').","proofString":"rewrite (nextblock_storebytes _ _ _ _ _ H).\napply Ple_refl."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) : Ple (nextblock m) (nextblock m).","proofString":"apply Ple_refl."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs0) (H2 : valid_block m b0) : perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p.","proofString":"split; intros.\neapply perm_storebytes_1; eauto.\neapply perm_storebytes_2; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs0) (H2 : valid_block m b0) (H3 : perm m b0 ofs0 k p) : perm m' b0 ofs0 k p.","proofString":"eapply perm_storebytes_1; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs0) (H2 : valid_block m b0) (H3 : perm m' b0 ofs0 k p) : perm m b0 ofs0 k p.","proofString":"eapply perm_storebytes_2; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) : ZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0.","proofString":"erewrite storebytes_mem_contents; eauto.\nrewrite PMap.gsspec.\ndestruct (peq b0 b); auto.\nsubst b0.\napply setN_outside.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) : ZMap.get ofs0\n  (PMap.set b (setN bytes ofs (mem_contents m) # b) (mem_contents m)) # b0 =\nZMap.get ofs0 (mem_contents m) # b0.","proofString":"rewrite PMap.gsspec.\ndestruct (peq b0 b); auto.\nsubst b0.\napply setN_outside.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) : ZMap.get ofs0\n  (if peq b0 b\n   then setN bytes ofs (mem_contents m) # b\n   else (mem_contents m) # b0) = ZMap.get ofs0 (mem_contents m) # b0.","proofString":"destruct (peq b0 b); auto.\nsubst b0.\napply setN_outside.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (b0 : block) (ofs0 : Z) (H1 : P b0 ofs0) (H2 : perm m b0 ofs0 Cur Readable) (e : b0 = b) : ZMap.get ofs0 (setN bytes ofs (mem_contents m) # b) =\nZMap.get ofs0 (mem_contents m) # b0.","proofString":"subst b0.\napply setN_outside.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) : ZMap.get ofs0 (setN bytes ofs (mem_contents m) # b) =\nZMap.get ofs0 (mem_contents m) # b.","proofString":"apply setN_outside.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (Datatypes.length bytes).","proofString":"destruct (zlt ofs0 ofs); auto.\ndestruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (Datatypes.length bytes).","proofString":"destruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.\nelim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) (l : ofs0 < ofs + Z.of_nat (Datatypes.length bytes)) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (Datatypes.length bytes).","proofString":"elim (H0 ofs0).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) (l : ofs0 < ofs + Z.of_nat (Datatypes.length bytes)) : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes).","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (H : storebytes m b ofs bytes = Some m') (H0 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes) -> ~ P b i) (ofs0 : Z) (H2 : perm m b ofs0 Cur Readable) (H1 : P b ofs0) (g : ofs0 >= ofs) (l : ofs0 < ofs + Z.of_nat (Datatypes.length bytes)) : P b ofs0.","proofString":"auto."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) : Ple (nextblock m) (nextblock m').","proofString":"rewrite (nextblock_alloc _ _ _ _ _ H).\napply Ple_succ."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) : Ple (nextblock m) (Pos.succ (nextblock m)).","proofString":"apply Ple_succ."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : P b0 ofs) (H1 : valid_block m b0) : perm m b0 ofs k p <-> perm m' b0 ofs k p.","proofString":"split; intros.\neapply perm_alloc_1; eauto.\neapply perm_alloc_4; eauto.\neapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : P b0 ofs) (H1 : valid_block m b0) (H2 : perm m b0 ofs k p) : perm m' b0 ofs k p.","proofString":"eapply perm_alloc_1; eauto."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : P b0 ofs) (H1 : valid_block m b0) (H2 : perm m' b0 ofs k p) : perm m b0 ofs k p.","proofString":"eapply perm_alloc_4; eauto.\neapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H0 : P b0 ofs) (H1 : valid_block m b0) (H2 : perm m' b0 ofs k p) : b0 <> b.","proofString":"eapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (H0 : P b0 ofs) (H1 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents m') # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"injection H; intros A B.\nrewrite <- B; simpl.\nrewrite PMap.gso; auto.\nrewrite A.\neapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (H0 : P b0 ofs) (H1 : perm m b0 ofs Cur Readable) (A : nextblock m = b) (B : {|\n  mem_contents := PMap.set (nextblock m) (ZMap.init Undef) (mem_contents m);\n  mem_access :=\n    PMap.set (nextblock m)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m);\n  nextblock := Pos.succ (nextblock m);\n  access_max :=\n    fun (b1 : positive) (ofs0 : Z) => alloc_obligation_1 m lo hi b1 ofs0;\n  nextblock_noaccess :=\n    fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n      (H2 : ~ Plt b1 (Pos.succ (nextblock m))) =>\n    alloc_obligation_2 m lo hi b1 ofs0 k H2;\n  contents_default := fun b1 : positive => alloc_obligation_3 m b1\n|} = m') : ZMap.get ofs (mem_contents m') # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"rewrite <- B; simpl.\nrewrite PMap.gso; auto.\nrewrite A.\neapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (H0 : P b0 ofs) (H1 : perm m b0 ofs Cur Readable) (A : nextblock m = b) (B : {|\n  mem_contents := PMap.set (nextblock m) (ZMap.init Undef) (mem_contents m);\n  mem_access :=\n    PMap.set (nextblock m)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m);\n  nextblock := Pos.succ (nextblock m);\n  access_max :=\n    fun (b1 : positive) (ofs0 : Z) => alloc_obligation_1 m lo hi b1 ofs0;\n  nextblock_noaccess :=\n    fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n      (H2 : ~ Plt b1 (Pos.succ (nextblock m))) =>\n    alloc_obligation_2 m lo hi b1 ofs0 k H2;\n  contents_default := fun b1 : positive => alloc_obligation_3 m b1\n|} = m') : ZMap.get ofs (PMap.set (nextblock m) (ZMap.init Undef) (mem_contents m)) # b0 =\nZMap.get ofs (mem_contents m) # b0.","proofString":"rewrite PMap.gso; auto.\nrewrite A.\neapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (H0 : P b0 ofs) (H1 : perm m b0 ofs Cur Readable) (A : nextblock m = b) (B : {|\n  mem_contents := PMap.set (nextblock m) (ZMap.init Undef) (mem_contents m);\n  mem_access :=\n    PMap.set (nextblock m)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m);\n  nextblock := Pos.succ (nextblock m);\n  access_max :=\n    fun (b1 : positive) (ofs0 : Z) => alloc_obligation_1 m lo hi b1 ofs0;\n  nextblock_noaccess :=\n    fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n      (H2 : ~ Plt b1 (Pos.succ (nextblock m))) =>\n    alloc_obligation_2 m lo hi b1 ofs0 k H2;\n  contents_default := fun b1 : positive => alloc_obligation_3 m b1\n|} = m') : b0 <> nextblock m.","proofString":"rewrite A.\neapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (lo hi : Z) (m' : mem') (b : block) (H : alloc m lo hi = (m', b)) (b0 : block) (ofs : Z) (H0 : P b0 ofs) (H1 : perm m b0 ofs Cur Readable) (A : nextblock m = b) (B : {|\n  mem_contents := PMap.set (nextblock m) (ZMap.init Undef) (mem_contents m);\n  mem_access :=\n    PMap.set (nextblock m)\n      (fun (ofs0 : Z) (_ : perm_kind) =>\n       if zle lo ofs0 && zlt ofs0 hi then Some Freeable else None)\n      (mem_access m);\n  nextblock := Pos.succ (nextblock m);\n  access_max :=\n    fun (b1 : positive) (ofs0 : Z) => alloc_obligation_1 m lo hi b1 ofs0;\n  nextblock_noaccess :=\n    fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n      (H2 : ~ Plt b1 (Pos.succ (nextblock m))) =>\n    alloc_obligation_2 m lo hi b1 ofs0 k H2;\n  contents_default := fun b1 : positive => alloc_obligation_3 m b1\n|} = m') : b0 <> b.","proofString":"eapply valid_not_valid_diff; eauto with mem."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) : Ple (nextblock m) (nextblock m').","proofString":"rewrite (nextblock_free _ _ _ _ _ H).\napply Ple_refl."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) : Ple (nextblock m) (nextblock m).","proofString":"apply Ple_refl."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) : perm m b0 ofs k p <-> perm m' b0 ofs k p.","proofString":"split; intros.\neapply perm_free_1; eauto.\ndestruct (eq_block b0 b); auto.\ndestruct (zlt ofs lo); auto.\ndestruct (zle hi ofs); auto.\nsubst b0.\nelim (H0 ofs).\nlia.\nauto.\neapply perm_free_3; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p) : perm m' b0 ofs k p.","proofString":"eapply perm_free_1; eauto.\ndestruct (eq_block b0 b); auto.\ndestruct (zlt ofs lo); auto.\ndestruct (zle hi ofs); auto.\nsubst b0.\nelim (H0 ofs).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"destruct (eq_block b0 b); auto.\ndestruct (zlt ofs lo); auto.\ndestruct (zle hi ofs); auto.\nsubst b0.\nelim (H0 ofs).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p) (e : b0 = b) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"destruct (zlt ofs lo); auto.\ndestruct (zle hi ofs); auto.\nsubst b0.\nelim (H0 ofs).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p) (e : b0 = b) (g : ofs >= lo) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"destruct (zle hi ofs); auto.\nsubst b0.\nelim (H0 ofs).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p) (e : b0 = b) (g : ofs >= lo) (g0 : hi > ofs) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"subst b0.\nelim (H0 ofs).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (ofs : Z) (k : perm_kind) (p : permission) (H3 : perm m b ofs k p) (H2 : valid_block m b) (H1 : P b ofs) (g : ofs >= lo) (g0 : hi > ofs) : b <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"elim (H0 ofs).\nlia.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (ofs : Z) (k : perm_kind) (p : permission) (H3 : perm m b ofs k p) (H2 : valid_block m b) (H1 : P b ofs) (g : ofs >= lo) (g0 : hi > ofs) : lo <= ofs < hi.","proofString":"lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (ofs : Z) (k : perm_kind) (p : permission) (H3 : perm m b ofs k p) (H2 : valid_block m b) (H1 : P b ofs) (g : ofs >= lo) (g0 : hi > ofs) : P b ofs.","proofString":"auto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m' b0 ofs k p) : perm m b0 ofs k p.","proofString":"eapply perm_free_3; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : free m b lo hi = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents m') # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"unfold free in H.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv H.\nsimpl.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (H : (if range_perm_dec m b lo hi Cur Freeable\n then Some (unchecked_free m b lo hi)\n else None) = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents m') # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"destruct (range_perm_dec m b lo hi Cur Freeable); inv H.\nsimpl.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (r : range_perm m b lo hi Cur Freeable) (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents (unchecked_free m b lo hi)) # b0 =\nZMap.get ofs (mem_contents m) # b0.","proofString":"simpl.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (r : range_perm m b lo hi Cur Freeable) (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents m) # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"auto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) : Ple (nextblock m) (nextblock m').","proofString":"rewrite (nextblock_drop _ _ _ _ _ _ H).\napply Ple_refl."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) : Ple (nextblock m) (nextblock m).","proofString":"apply Ple_refl."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p0 : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) : perm m b0 ofs k p0 <-> perm m' b0 ofs k p0.","proofString":"split; intros.\neapply perm_drop_3; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nassert (~ (lo <= ofs < hi)).\nred; intros; eelim H0; eauto.\nright; lia.\neapply perm_drop_4; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p0 : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p0) : perm m' b0 ofs k p0.","proofString":"eapply perm_drop_3; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nassert (~ (lo <= ofs < hi)).\nred; intros; eelim H0; eauto.\nright; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p0 : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p0) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"destruct (eq_block b0 b); auto.\nsubst b0.\nassert (~ (lo <= ofs < hi)).\nred; intros; eelim H0; eauto.\nright; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p0 : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m b0 ofs k p0) (e : b0 = b) : b0 <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"subst b0.\nassert (~ (lo <= ofs < hi)).\nred; intros; eelim H0; eauto.\nright; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m b ofs k p0) (H2 : valid_block m b) (H1 : P b ofs) : b <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"assert (~ (lo <= ofs < hi)).\nred; intros; eelim H0; eauto.\nright; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m b ofs k p0) (H2 : valid_block m b) (H1 : P b ofs) : ~ lo <= ofs < hi.","proofString":"red; intros; eelim H0; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (ofs : Z) (k : perm_kind) (p0 : permission) (H3 : perm m b ofs k p0) (H2 : valid_block m b) (H1 : P b ofs) (H4 : ~ lo <= ofs < hi) : b <> b \\/ ofs < lo \\/ hi <= ofs.","proofString":"right; lia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (k : perm_kind) (p0 : permission) (H1 : P b0 ofs) (H2 : valid_block m b0) (H3 : perm m' b0 ofs k p0) : perm m b0 ofs k p0.","proofString":"eapply perm_drop_4; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : drop_perm m b lo hi p = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents m') # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"unfold drop_perm in H.\ndestruct (range_perm_dec m b lo hi Cur Freeable); inv H; simpl.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (m' : mem) (H : match range_perm_dec m b lo hi Cur Freeable with\n| left H3 =>\n    Some\n      {|\n        mem_contents := mem_contents m;\n        mem_access :=\n          PMap.set b\n            (fun (ofs0 : Z) (k : perm_kind) =>\n             if zle lo ofs0 && zlt ofs0 hi\n             then Some p\n             else (mem_access m) # b ofs0 k) (mem_access m);\n        nextblock := nextblock m;\n        access_max :=\n          fun (b1 : positive) (ofs0 : Z) =>\n          drop_perm_obligation_1 m b lo hi p b1 ofs0;\n        nextblock_noaccess :=\n          fun (b1 : positive) (ofs0 : Z) (k : perm_kind)\n            (H4 : ~ Plt b1 (nextblock m)) =>\n          drop_perm_obligation_2 m b lo hi p H3 b1 ofs0 k H4;\n        contents_default := fun b1 : positive => drop_perm_obligation_3 m b1\n      |}\n| right _ => None\nend = Some m') (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents m') # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"destruct (range_perm_dec m b lo hi Cur Freeable); inv H; simpl.\nauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (p : permission) (r : range_perm m b lo hi Cur Freeable) (H0 : forall i : Z, lo <= i < hi -> ~ P b i) (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : perm m b0 ofs Cur Readable) : ZMap.get ofs (mem_contents m) # b0 = ZMap.get ofs (mem_contents m) # b0.","proofString":"auto."},{"statement":"(P Q : block -> Z -> Prop) (m m' : mem) (H : unchanged_on P m m') (H0 : forall (b : block) (ofs : Z), Q b ofs -> valid_block m b -> P b ofs) : unchanged_on Q m m'.","proofString":"destruct H.\nconstructor; intros.\nauto.\napply unchanged_on_perm0; auto.\napply unchanged_on_contents0; auto.\napply H0; auto.\neapply perm_valid_block; eauto."},{"statement":"(P Q : block -> Z -> Prop) (m m' : mem) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nP b ofs -> valid_block m b -> perm m b ofs k p <-> perm m' b ofs k p) (unchanged_on_contents0 : forall (b : block) (ofs : Z),\nP b ofs ->\nperm m b ofs Cur Readable ->\nZMap.get ofs (mem_contents m') # b = ZMap.get ofs (mem_contents m) # b) (H0 : forall (b : block) (ofs : Z), Q b ofs -> valid_block m b -> P b ofs) : unchanged_on Q m m'.","proofString":"constructor; intros.\nauto.\napply unchanged_on_perm0; auto.\napply unchanged_on_contents0; auto.\napply H0; auto.\neapply perm_valid_block; eauto."},{"statement":"(P Q : block -> Z -> Prop) (m m' : mem) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nP b ofs -> valid_block m b -> perm m b ofs k p <-> perm m' b ofs k p) (unchanged_on_contents0 : forall (b : block) (ofs : Z),\nP b ofs ->\nperm m b ofs Cur Readable ->\nZMap.get ofs (mem_contents m') # b = ZMap.get ofs (mem_contents m) # b) (H0 : forall (b : block) (ofs : Z), Q b ofs -> valid_block m b -> P b ofs) : Ple (nextblock m) (nextblock m').","proofString":"auto."},{"statement":"(P Q : block -> Z -> Prop) (m m' : mem) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nP b0 ofs0 ->\nvalid_block m b0 -> perm m b0 ofs0 k0 p0 <-> perm m' b0 ofs0 k0 p0) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : forall (b0 : block) (ofs0 : Z), Q b0 ofs0 -> valid_block m b0 -> P b0 ofs0) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : Q b ofs) (H1 : valid_block m b) : perm m b ofs k p <-> perm m' b ofs k p.","proofString":"apply unchanged_on_perm0; auto."},{"statement":"(P Q : block -> Z -> Prop) (m m' : mem) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : forall (b0 : block) (ofs0 : Z), Q b0 ofs0 -> valid_block m b0 -> P b0 ofs0) (b : block) (ofs : Z) (H : Q b ofs) (H1 : perm m b ofs Cur Readable) : ZMap.get ofs (mem_contents m') # b = ZMap.get ofs (mem_contents m) # b.","proofString":"apply unchanged_on_contents0; auto.\napply H0; auto.\neapply perm_valid_block; eauto."},{"statement":"(P Q : block -> Z -> Prop) (m m' : mem) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : forall (b0 : block) (ofs0 : Z), Q b0 ofs0 -> valid_block m b0 -> P b0 ofs0) (b : block) (ofs : Z) (H : Q b ofs) (H1 : perm m b ofs Cur Readable) : P b ofs.","proofString":"apply H0; auto.\neapply perm_valid_block; eauto."},{"statement":"(P Q : block -> Z -> Prop) (m m' : mem) (unchanged_on_nextblock0 : Ple (nextblock m) (nextblock m')) (unchanged_on_perm0 : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nP b0 ofs0 -> valid_block m b0 -> perm m b0 ofs0 k p <-> perm m' b0 ofs0 k p) (unchanged_on_contents0 : forall (b0 : block) (ofs0 : Z),\nP b0 ofs0 ->\nperm m b0 ofs0 Cur Readable ->\nZMap.get ofs0 (mem_contents m') # b0 = ZMap.get ofs0 (mem_contents m) # b0) (H0 : forall (b0 : block) (ofs0 : Z), Q b0 ofs0 -> valid_block m b0 -> P b0 ofs0) (b : block) (ofs : Z) (H : Q b ofs) (H1 : perm m b ofs Cur Readable) : valid_block m b.","proofString":"eapply perm_valid_block; eauto."}]}