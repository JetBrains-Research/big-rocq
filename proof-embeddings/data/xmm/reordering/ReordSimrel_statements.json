{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/reordering/ReordSimrel.v","fileSamples":[{"statement":"(a_s : actid) (NINA : ~ E_t a_t) (INB : E_t b_t) (n : ~ (~ E_t a_t /\\ E_t b_t)) : ∅ ≡₁ eq a_s.","proofString":"exfalso; eauto."},{"statement":"(a_s : actid) (INA : E_t a_t) : extra_a a_s ≡₁ ∅.","proofString":"apply extra_a_none; tauto."},{"statement":"(a_s : actid) (BNIN : ~ E_t b_t) : extra_a a_s ≡₁ ∅.","proofString":"apply extra_a_none; tauto."},{"statement":"(SIMREL : reord_simrel) : mapper ↑₁ E_t ⊆₁ E_s.","proofString":"rewrite (rsr_acts SIMREL).\nclear.\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) : mapper ↑₁ E_t ⊆₁ mapper ↑₁ E_t ∪₁ extra_a b_t.","proofString":"clear.\nbasic_solver."},{"statement":"mapper ↑₁ E_t ⊆₁ mapper ↑₁ E_t ∪₁ extra_a b_t.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : extra_a b_t ⊆₁ same_tid b_t.","proofString":"rewrite (rsr_as SIMREL).\nintros x HSET.\napply HSET."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : extra_a_pred ⊆₁ same_tid b_t.","proofString":"intros x HSET.\napply HSET."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x : actid) (HSET : extra_a_pred x) : same_tid b_t x.","proofString":"apply HSET."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : same_tid b_t ⊆₁ set_compl (fun a : actid => is_init a).","proofString":"assert (NTID : tid b_t <> tid_init).\nrewrite <- (rsr_at_bt_tid PRED).\napply PRED.\nunfold same_tid, is_init.\nclear - NTID.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : tid b_t <> tid_init.","proofString":"rewrite <- (rsr_at_bt_tid PRED).\napply PRED."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : tid a_t <> tid_init.","proofString":"apply PRED."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (NTID : tid b_t <> tid_init) : same_tid b_t ⊆₁ set_compl (fun a : actid => is_init a).","proofString":"unfold same_tid, is_init.\nclear - NTID.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (NTID : tid b_t <> tid_init) : (fun y : actid => tid b_t = tid y)\n⊆₁ set_compl\n     (fun a : actid =>\n      match a with\n      | InitEvent _ => true\n      | ThreadEvent _ _ => false\n      end).","proofString":"clear - NTID.\nbasic_solver."},{"statement":"(NTID : tid b_t <> tid_init) : (fun y : actid => tid b_t = tid y)\n⊆₁ set_compl\n     (fun a : actid =>\n      match a with\n      | InitEvent _ => true\n      | ThreadEvent _ _ => false\n      end).","proofString":"basic_solver."},{"statement":"(t : BinNums.positive) (SIMREL : reord_simrel) : mapper ↑₁ (E_t ∩₁ Tid_ t) ≡₁ mapper ↑₁ E_t ∩₁ Tid_ t.","proofString":"unfolder.\nsplit; ins; desf; splits; eauto.\nsymmetry.\nnow apply rsr_tid'.\neexists; splits; eauto.\nnow apply rsr_tid'."},{"statement":"(t : BinNums.positive) (SIMREL : reord_simrel) : (forall x : actid,\n (exists y : actid, (E_t y /\\ tid y = t) /\\ mapper y = x) ->\n (exists y : actid, E_t y /\\ mapper y = x) /\\ tid x = t) /\\\n(forall x : actid,\n (exists y : actid, E_t y /\\ mapper y = x) /\\ tid x = t ->\n exists y : actid, (E_t y /\\ tid y = t) /\\ mapper y = x).","proofString":"split; ins; desf; splits; eauto.\nsymmetry.\nnow apply rsr_tid'.\neexists; splits; eauto.\nnow apply rsr_tid'."},{"statement":"(SIMREL : reord_simrel) (y : actid) (H : E_t y) : tid (mapper y) = tid y.","proofString":"symmetry.\nnow apply rsr_tid'."},{"statement":"(SIMREL : reord_simrel) (y : actid) (H : E_t y) : tid y = tid (mapper y).","proofString":"now apply rsr_tid'."},{"statement":"(SIMREL : reord_simrel) (y : actid) (H : E_t y) : exists y0 : actid,\n  (E_t y0 /\\ tid y0 = tid (mapper y)) /\\ mapper y0 = mapper y.","proofString":"eexists; splits; eauto.\nnow apply rsr_tid'."},{"statement":"(SIMREL : reord_simrel) (y : actid) (H : E_t y) : tid y = tid (mapper y).","proofString":"now apply rsr_tid'."},{"statement":"(PRED : reord_step_pred) : tid a_t <> tid_init.","proofString":"apply PRED."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : extra_a_pred ∩₁ Tid_ tid_init ⊆₁ ∅.","proofString":"transitivity (same_tid b_t ∩₁ Tid_ tid_init).\napply set_subset_inter; [| ins].\nunfolder; ins.\nnow apply eba_tid.\nassert (NEQ : tid b_t <> tid_init).\nnow apply rsr_bt_tid.\nclear - NEQ.\nunfold same_tid.\nunfolder.\nins.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : extra_a_pred ∩₁ Tid_ tid_init ⊆₁ same_tid b_t ∩₁ Tid_ tid_init.","proofString":"apply set_subset_inter; [| ins].\nunfolder; ins.\nnow apply eba_tid."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : extra_a_pred ⊆₁ same_tid b_t.","proofString":"unfolder; ins.\nnow apply eba_tid."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x : actid) (H : extra_a_pred x) : same_tid b_t x.","proofString":"now apply eba_tid."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : same_tid b_t ∩₁ Tid_ tid_init ⊆₁ ∅.","proofString":"assert (NEQ : tid b_t <> tid_init).\nnow apply rsr_bt_tid.\nclear - NEQ.\nunfold same_tid.\nunfolder.\nins.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : tid b_t <> tid_init.","proofString":"now apply rsr_bt_tid."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (NEQ : tid b_t <> tid_init) : same_tid b_t ∩₁ Tid_ tid_init ⊆₁ ∅.","proofString":"clear - NEQ.\nunfold same_tid.\nunfolder.\nins.\ndesf.\ncongruence."},{"statement":"(NEQ : tid b_t <> tid_init) : same_tid b_t ∩₁ Tid_ tid_init ⊆₁ ∅.","proofString":"unfold same_tid.\nunfolder.\nins.\ndesf.\ncongruence."},{"statement":"(NEQ : tid b_t <> tid_init) : (fun y : actid => tid b_t = tid y) ∩₁ Tid_ tid_init ⊆₁ ∅.","proofString":"unfolder.\nins.\ndesf.\ncongruence."},{"statement":"(NEQ : tid b_t <> tid_init) : forall x : actid, tid b_t = tid x /\\ tid x = tid_init -> False.","proofString":"ins.\ndesf.\ncongruence."},{"statement":"(NEQ : tid b_t <> tid_init) (x : actid) (H : tid b_t = tid x /\\ tid x = tid_init) : False.","proofString":"desf.\ncongruence."},{"statement":"(NEQ : tid b_t <> tid_init) (x : actid) (H : tid b_t = tid x) (H0 : tid x = tid_init) : False.","proofString":"congruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : mapper ↑₁ E_t ∩₁ Tid_ tid_init ∪₁ extra_a b_t ∩₁ Tid_ tid_init\n⊆₁ (fun a : actid => is_init a).","proofString":"rewrite <- rsr_same_tid'; [| auto].\nrewrite rsr_ninit_exa_tid; ins.\nrewrite (rsr_ninit_acts PRED),          <- (fixset_set_fixpoint (rsr_init SIMREL)).\nnow rewrite set_union_empty_r."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : mapper ↑₁ (E_t ∩₁ Tid_ tid_init) ∪₁ extra_a b_t ∩₁ Tid_ tid_init\n⊆₁ (fun a : actid => is_init a).","proofString":"rewrite rsr_ninit_exa_tid; ins.\nrewrite (rsr_ninit_acts PRED),          <- (fixset_set_fixpoint (rsr_init SIMREL)).\nnow rewrite set_union_empty_r."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : mapper ↑₁ (E_t ∩₁ Tid_ tid_init) ∪₁ ∅ ⊆₁ (fun a : actid => is_init a).","proofString":"rewrite (rsr_ninit_acts PRED),          <- (fixset_set_fixpoint (rsr_init SIMREL)).\nnow rewrite set_union_empty_r."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : (fun a : actid => is_init a) ∪₁ ∅ ⊆₁ (fun a : actid => is_init a).","proofString":"now rewrite set_union_empty_r."},{"statement":"(e : actid) (SIMREL : reord_simrel) : same_tid e ≡₁ Tid_ (tid e).","proofString":"unfold same_tid.\nbasic_solver."},{"statement":"(e : actid) (SIMREL : reord_simrel) : (fun y : actid => tid e = tid y) ≡₁ Tid_ (tid e).","proofString":"basic_solver."},{"statement":"(e : actid) (SIMREL : reord_simrel) : mapper ↑₁ (E_t ∩₁ Tid_ (tid e)) ≡₁ mapper ↑₁ E_t ∩₁ Tid_ (tid e).","proofString":"now apply rsr_same_tid'."},{"statement":"(e : actid) (ll : actid -> label) (l : option location) : extra_co_D (eq e) ll l\n≡₁ (fun a : actid => is_w ll a)\n   ∩₁ (eq e ∩₁ (fun e0 : actid => loc ll e0 = l)).","proofString":"unfold extra_co_D.\nbasic_solver."},{"statement":"(e : actid) (ll : actid -> label) (l : option location) : eq e ∩₁ (fun a : actid => is_w ll a) ∩₁ (fun e0 : actid => loc ll e0 = l)\n≡₁ (fun a : actid => is_w ll a)\n   ∩₁ (eq e ∩₁ (fun e0 : actid => loc ll e0 = l)).","proofString":"basic_solver."},{"statement":"(s1 s2 : actid -> Prop) (ll : actid -> label) (l : option location) : (s1 ∪₁ s2) ∩₁ (fun a : actid => is_w ll a) ∩₁ (fun e : actid => loc ll e = l)\n≡₁ s1 ∩₁ (fun a : actid => is_w ll a) ∩₁ (fun e : actid => loc ll e = l)\n   ∪₁ s2 ∩₁ (fun a : actid => is_w ll a) ∩₁ (fun e : actid => loc ll e = l).","proofString":"now rewrite !set_inter_union_l."},{"statement":"(s1 s2 : actid -> Prop) (ll : actid -> label) (l : option location) : s1 ∩₁ (fun a : actid => is_w ll a) ∩₁ (fun e : actid => loc ll e = l) \\₁ s2\n≡₁ (s1 \\₁ s2) ∩₁ (fun a : actid => is_w ll a)\n   ∩₁ (fun e : actid => loc ll e = l).","proofString":"now rewrite !set_inter_minus_l."},{"statement":"(GSIM : reord_simrel) : set_disjoint (mapper ↑₁ E_t) (extra_a b_t).","proofString":"apply set_disjointE.\nsplit; [| basic_solver].\nrewrite (rsr_codom GSIM).\nbasic_solver."},{"statement":"(GSIM : reord_simrel) : mapper ↑₁ E_t ∩₁ extra_a b_t ≡₁ ∅.","proofString":"split; [| basic_solver].\nrewrite (rsr_codom GSIM).\nbasic_solver."},{"statement":"(GSIM : reord_simrel) : mapper ↑₁ E_t ∩₁ extra_a b_t ⊆₁ ∅.","proofString":"rewrite (rsr_codom GSIM).\nbasic_solver."},{"statement":"(GSIM : reord_simrel) : (E_s \\₁ extra_a b_t) ∩₁ extra_a b_t ⊆₁ ∅.","proofString":"basic_solver."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) : extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s\n≡₁ mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t)).","proofString":"rewrite extra_co_D_minus.\nunfold extra_co_D.\nrewrite set_minus_inter, (rsr_acts GSIM).\nrewrite set_minus_union_l, set_minusK, set_union_empty_r.\nrewrite set_minus_disjoint; ins.\nunfolder.\nsplit; intros x HSET.\ndestruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins.\ndestruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) : extra_co_D (E_s \\₁ extra_a b_t ∩₁ W_s) lab_s (loc_s b_t)\n≡₁ mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t)).","proofString":"unfold extra_co_D.\nrewrite set_minus_inter, (rsr_acts GSIM).\nrewrite set_minus_union_l, set_minusK, set_union_empty_r.\nrewrite set_minus_disjoint; ins.\nunfolder.\nsplit; intros x HSET.\ndestruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins.\ndestruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) : (E_s \\₁ extra_a b_t ∩₁ W_s) ∩₁ W_s ∩₁ Loc_s_ (loc_s b_t)\n≡₁ mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t)).","proofString":"rewrite set_minus_inter, (rsr_acts GSIM).\nrewrite set_minus_union_l, set_minusK, set_union_empty_r.\nrewrite set_minus_disjoint; ins.\nunfolder.\nsplit; intros x HSET.\ndestruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins.\ndestruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) : ((mapper ↑₁ E_t ∪₁ extra_a b_t) \\₁ extra_a b_t) ∩₁ W_s ∩₁ Loc_s_ (loc_s b_t)\n≡₁ mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t)).","proofString":"rewrite set_minus_union_l, set_minusK, set_union_empty_r.\nrewrite set_minus_disjoint; ins.\nunfolder.\nsplit; intros x HSET.\ndestruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins.\ndestruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) : (mapper ↑₁ E_t \\₁ extra_a b_t) ∩₁ W_s ∩₁ Loc_s_ (loc_s b_t)\n≡₁ mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t)).","proofString":"rewrite set_minus_disjoint; ins.\nunfolder.\nsplit; intros x HSET.\ndestruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins.\ndestruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) : mapper ↑₁ E_t ∩₁ W_s ∩₁ Loc_s_ (loc_s b_t)\n≡₁ mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t)).","proofString":"unfolder.\nsplit; intros x HSET.\ndestruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins.\ndestruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) : (forall x : actid,\n ((exists y : actid, E_t y /\\ mapper y = x) /\\ is_w lab_s x) /\\\n loc_s x = loc_s b_t ->\n exists y : actid,\n   ((E_t y /\\ is_w lab_t y) /\\ loc_t y = loc_s b_t) /\\ mapper y = x) /\\\n(forall x : actid,\n (exists y : actid,\n    ((E_t y /\\ is_w lab_t y) /\\ loc_t y = loc_s b_t) /\\ mapper y = x) ->\n ((exists y : actid, E_t y /\\ mapper y = x) /\\ is_w lab_s x) /\\\n loc_s x = loc_s b_t).","proofString":"split; intros x HSET.\ndestruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins.\ndestruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (x : actid) (HSET : ((exists y : actid, E_t y /\\ mapper y = x) /\\ is_w lab_s x) /\\\nloc_s x = loc_s b_t) : exists y : actid,\n  ((E_t y /\\ is_w lab_t y) /\\ loc_t y = loc_s b_t) /\\ mapper y = x.","proofString":"destruct HSET as (((y & INE & XEQ) & ISW) & LOC).\nsubst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (x y : actid) (INE : E_t y) (XEQ : mapper y = x) (ISW : is_w lab_s x) (LOC : loc_s x = loc_s b_t) : exists y0 : actid,\n  ((E_t y0 /\\ is_w lab_t y0) /\\ loc_t y0 = loc_s b_t) /\\ mapper y0 = x.","proofString":"subst x.\nexists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (LOC : loc_s (mapper y) = loc_s b_t) (ISW : is_w lab_s (mapper y)) : exists y0 : actid,\n  ((E_t y0 /\\ is_w lab_t y0) /\\ loc_t y0 = loc_s b_t) /\\ mapper y0 = mapper y.","proofString":"exists y; splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM); ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (LOC : loc_s (mapper y) = loc_s b_t) (ISW : is_w lab_s (mapper y)) : is_w lab_t y.","proofString":"unfold is_w in *.\nrewrite <- (rsr_lab GSIM); ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (LOC : loc_s (mapper y) = loc_s b_t) (ISW : match lab_s (mapper y) with\n| Astore _ _ _ _ => true\n| _ => false\nend) : match lab_t y with\n| Astore _ _ _ _ => true\n| _ => false\nend.","proofString":"rewrite <- (rsr_lab GSIM); ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (LOC : loc_s (mapper y) = loc_s b_t) (ISW : is_w lab_s (mapper y)) : loc_t y = loc_s b_t.","proofString":"unfold loc in *.\nrewrite <- (rsr_lab GSIM); ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (LOC : match lab_s (mapper y) with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend) (ISW : is_w lab_s (mapper y)) : match lab_t y with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"rewrite <- (rsr_lab GSIM); ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (x : actid) (HSET : exists y : actid,\n  ((E_t y /\\ is_w lab_t y) /\\ loc_t y = loc_s b_t) /\\ mapper y = x) : ((exists y : actid, E_t y /\\ mapper y = x) /\\ is_w lab_s x) /\\\nloc_s x = loc_s b_t.","proofString":"destruct HSET as (y & ((INE & ISW) & LOC) & XEQ).\nsubst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (x y : actid) (INE : E_t y) (ISW : is_w lab_t y) (LOC : loc_t y = loc_s b_t) (XEQ : mapper y = x) : ((exists y0 : actid, E_t y0 /\\ mapper y0 = x) /\\ is_w lab_s x) /\\\nloc_s x = loc_s b_t.","proofString":"subst x.\nsplits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (ISW : is_w lab_t y) (LOC : loc_t y = loc_s b_t) : ((exists y0 : actid, E_t y0 /\\ mapper y0 = mapper y) /\\ is_w lab_s (mapper y)) /\\\nloc_s (mapper y) = loc_s b_t.","proofString":"splits; eauto.\nunfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins.\nunfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (ISW : is_w lab_t y) (LOC : loc_t y = loc_s b_t) : is_w lab_s (mapper y).","proofString":"unfold is_w in *.\nrewrite <- (rsr_lab GSIM) in ISW; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (ISW : match lab_t y with\n| Astore _ _ _ _ => true\n| _ => false\nend) (LOC : loc_t y = loc_s b_t) : match lab_s (mapper y) with\n| Astore _ _ _ _ => true\n| _ => false\nend.","proofString":"rewrite <- (rsr_lab GSIM) in ISW; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (ISW : is_w lab_t y) (LOC : loc_t y = loc_s b_t) : loc_s (mapper y) = loc_s b_t.","proofString":"unfold loc in *.\nrewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(GSIM : reord_simrel) (DISJ : set_disjoint (mapper ↑₁ E_t) (extra_a b_t)) (y : actid) (INE : E_t y) (ISW : is_w lab_t y) (LOC : match lab_t y with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend) : match lab_s (mapper y) with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"rewrite <- (rsr_lab GSIM) in LOC; ins."},{"statement":"(SIMREL : reord_simrel) : forall x y : actid,\nsrf_s x y /\\ extra_a b_t y /\\ is_r lab_s y -> same_val_s x y.","proofString":"ins.\ndesf.\nsplits; ins.\neapply eba_val; [| basic_solver].\neapply rsr_as; eauto."},{"statement":"(SIMREL : reord_simrel) (x y : actid) (H : srf_s x y /\\ extra_a b_t y /\\ is_r lab_s y) : same_val_s x y.","proofString":"desf.\nsplits; ins.\neapply eba_val; [| basic_solver].\neapply rsr_as; eauto."},{"statement":"(SIMREL : reord_simrel) (x y : actid) (H : srf_s x y) (H0 : extra_a b_t y) (H1 : is_r lab_s y) : same_val_s x y.","proofString":"splits; ins.\neapply eba_val; [| basic_solver].\neapply rsr_as; eauto."},{"statement":"(SIMREL : reord_simrel) (x y : actid) (H : srf_s x y) (H0 : extra_a b_t y) (H1 : is_r lab_s y) : same_val_s x y.","proofString":"eapply eba_val; [| basic_solver].\neapply rsr_as; eauto."},{"statement":"(SIMREL : reord_simrel) (x y : actid) (H : srf_s x y) (H0 : extra_a b_t y) (H1 : is_r lab_s y) : extra_a_pred y.","proofString":"eapply rsr_as; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional rf_s⁻¹.","proofString":"rewrite (rsr_rf SIMREL), transp_union.\nrewrite (wf_rfE WF).\napply functional_union.\nrewrite <- (wf_rfE WF).\neapply sico_rff, rsr_common; try red; eauto.\nrewrite transp_seq, transp_eqv_rel.\napply functional_seq; [basic_solver |].\napply wf_srff'.\nauto using G_s_co_total.\nclear - SIMREL.\nunfolder in *.\nins.\ndesf.\neapply (rsr_codom SIMREL); basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional ((mapper ↑ rf_t)⁻¹ ∪ (srf_s ⨾ ⦗extra_a b_t ∩₁ R_s⦘)⁻¹).","proofString":"rewrite (wf_rfE WF).\napply functional_union.\nrewrite <- (wf_rfE WF).\neapply sico_rff, rsr_common; try red; eauto.\nrewrite transp_seq, transp_eqv_rel.\napply functional_seq; [basic_solver |].\napply wf_srff'.\nauto using G_s_co_total.\nclear - SIMREL.\nunfolder in *.\nins.\ndesf.\neapply (rsr_codom SIMREL); basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional\n  ((mapper ↑ (⦗E_t⦘ ⨾ rf_t ⨾ ⦗E_t⦘))⁻¹ ∪ (srf_s ⨾ ⦗extra_a b_t ∩₁ R_s⦘)⁻¹).","proofString":"apply functional_union.\nrewrite <- (wf_rfE WF).\neapply sico_rff, rsr_common; try red; eauto.\nrewrite transp_seq, transp_eqv_rel.\napply functional_seq; [basic_solver |].\napply wf_srff'.\nauto using G_s_co_total.\nclear - SIMREL.\nunfolder in *.\nins.\ndesf.\neapply (rsr_codom SIMREL); basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional (mapper ↑ (⦗E_t⦘ ⨾ rf_t ⨾ ⦗E_t⦘))⁻¹.","proofString":"rewrite <- (wf_rfE WF).\neapply sico_rff, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional (mapper ↑ rf_t)⁻¹.","proofString":"eapply sico_rff, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional (srf_s ⨾ ⦗extra_a b_t ∩₁ R_s⦘)⁻¹.","proofString":"rewrite transp_seq, transp_eqv_rel.\napply functional_seq; [basic_solver |].\napply wf_srff'.\nauto using G_s_co_total."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional (⦗extra_a b_t ∩₁ R_s⦘ ⨾ srf_s⁻¹).","proofString":"apply functional_seq; [basic_solver |].\napply wf_srff'.\nauto using G_s_co_total."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : functional srf_s⁻¹.","proofString":"apply wf_srff'.\nauto using G_s_co_total."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : forall ol : option location, is_total (E_s ∩₁ W_s ∩₁ Loc_s_ ol) co_s.","proofString":"auto using G_s_co_total."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : forall x : actid,\ndom_rel (mapper ↑ (⦗E_t⦘ ⨾ rf_t ⨾ ⦗E_t⦘))⁻¹ x ->\ndom_rel (srf_s ⨾ ⦗extra_a b_t ∩₁ R_s⦘)⁻¹ x -> False.","proofString":"clear - SIMREL.\nunfolder in *.\nins.\ndesf.\neapply (rsr_codom SIMREL); basic_solver."},{"statement":"(SIMREL : reord_simrel) : forall x : actid,\ndom_rel (mapper ↑ (⦗E_t⦘ ⨾ rf_t ⨾ ⦗E_t⦘))⁻¹ x ->\ndom_rel (srf_s ⨾ ⦗extra_a b_t ∩₁ R_s⦘)⁻¹ x -> False.","proofString":"unfolder in *.\nins.\ndesf.\neapply (rsr_codom SIMREL); basic_solver."},{"statement":"(SIMREL : reord_simrel) : forall x : actid,\n(exists y x' y' : actid,\n   (exists z : actid,\n      (x' = z /\\ E_t x') /\\\n      (exists z0 : actid, rf_t z z0 /\\ z0 = y' /\\ E_t z0)) /\\\n   mapper x' = y /\\ mapper y' = x) ->\n(exists y z : actid, srf_s y z /\\ z = x /\\ extra_a b_t z /\\ is_r lab_s z) ->\nFalse.","proofString":"ins.\ndesf.\neapply (rsr_codom SIMREL); basic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (H : exists y x' y' : actid,\n  (exists z : actid,\n     (x' = z /\\ E_t x') /\\\n     (exists z0 : actid, rf_t z z0 /\\ z0 = y' /\\ E_t z0)) /\\\n  mapper x' = y /\\ mapper y' = x) (H0 : exists y z : actid, srf_s y z /\\ z = x /\\ extra_a b_t z /\\ is_r lab_s z) : False.","proofString":"desf.\neapply (rsr_codom SIMREL); basic_solver."},{"statement":"(SIMREL : reord_simrel) (y' z0 : actid) (H9 : E_t z0) (H6 : rf_t z0 y') (H8 : E_t y') (y : actid) (H0 : srf_s y (mapper y')) (H3 : is_r lab_s (mapper y')) (H2 : extra_a b_t (mapper y')) : False.","proofString":"eapply (rsr_codom SIMREL); basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : rf_s ≡ ⦗E_s⦘ ⨾ rf_s ⨾ ⦗E_s⦘.","proofString":"apply dom_helper_3.\nrewrite (rsr_rf SIMREL).\napply inclusion_union_l.\neapply sico_rfE, rsr_common; try red; eauto.\nrewrite inclusion_seq_eqv_r.\napply dom_helper_3, wf_srfE."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : rf_s ⊆ E_s × E_s.","proofString":"rewrite (rsr_rf SIMREL).\napply inclusion_union_l.\neapply sico_rfE, rsr_common; try red; eauto.\nrewrite inclusion_seq_eqv_r.\napply dom_helper_3, wf_srfE."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ rf_t ∪ srf_s ⨾ ⦗extra_a b_t ∩₁ R_s⦘ ⊆ E_s × E_s.","proofString":"apply inclusion_union_l.\neapply sico_rfE, rsr_common; try red; eauto.\nrewrite inclusion_seq_eqv_r.\napply dom_helper_3, wf_srfE."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ rf_t ⊆ E_s × E_s.","proofString":"eapply sico_rfE, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : srf_s ⨾ ⦗extra_a b_t ∩₁ R_s⦘ ⊆ E_s × E_s.","proofString":"rewrite inclusion_seq_eqv_r.\napply dom_helper_3, wf_srfE."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : srf_s ⊆ E_s × E_s.","proofString":"apply dom_helper_3, wf_srfE."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : transitive co_s.","proofString":"assert (COL : forall ol, upward_closed co_t (Loc_t_ ol)).\nunfold upward_closed.\nintros ol x y CO LOC.\napply (wf_col WF) in CO.\nunfold same_loc in *.\ncongruence.\nassert (COE : upward_closed co_t E_t).\nunfold upward_closed.\nintros x y CO YIN.\napply (wf_coE WF) in CO.\nunfolder in CO; desf.\nassert (COD : upward_closed co_t W_t).\nunfold upward_closed.\nintros x y CO YD.\napply (wf_coD WF) in CO.\nunfolder in CO; desf.\nrewrite (rsr_co SIMREL).\napply expand_transitive.\neapply sico_co_trans, rsr_common; try red; eauto.\nunfold upward_closed in *.\nintros x y REL XIN.\napply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf.\narewrite (extra_a b_t ∩₁ W_s ⊆₁ set_compl (mapper ↑₁ E_t)).\nrewrite (rsr_codom SIMREL).\nclear.\nunfolder.\nins.\ndesf.\ntauto.\nrewrite (wf_coE WF).\napply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : forall ol : option location, upward_closed co_t Loc_t_ ol.","proofString":"unfold upward_closed.\nintros ol x y CO LOC.\napply (wf_col WF) in CO.\nunfold same_loc in *.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : forall (ol : option location) (x y : actid),\nco_t x y -> loc_t y = ol -> loc_t x = ol.","proofString":"intros ol x y CO LOC.\napply (wf_col WF) in CO.\nunfold same_loc in *.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (ol : option location) (x y : actid) (CO : co_t x y) (LOC : loc_t y = ol) : loc_t x = ol.","proofString":"apply (wf_col WF) in CO.\nunfold same_loc in *.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (ol : option location) (x y : actid) (CO : same_loc_t x y) (LOC : loc_t y = ol) : loc_t x = ol.","proofString":"unfold same_loc in *.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (ol : option location) (x y : actid) (CO : loc_t x = loc_t y) (LOC : loc_t y = ol) : loc_t x = ol.","proofString":"congruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) : transitive co_s.","proofString":"assert (COE : upward_closed co_t E_t).\nunfold upward_closed.\nintros x y CO YIN.\napply (wf_coE WF) in CO.\nunfolder in CO; desf.\nassert (COD : upward_closed co_t W_t).\nunfold upward_closed.\nintros x y CO YD.\napply (wf_coD WF) in CO.\nunfolder in CO; desf.\nrewrite (rsr_co SIMREL).\napply expand_transitive.\neapply sico_co_trans, rsr_common; try red; eauto.\nunfold upward_closed in *.\nintros x y REL XIN.\napply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf.\narewrite (extra_a b_t ∩₁ W_s ⊆₁ set_compl (mapper ↑₁ E_t)).\nrewrite (rsr_codom SIMREL).\nclear.\nunfolder.\nins.\ndesf.\ntauto.\nrewrite (wf_coE WF).\napply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) : upward_closed co_t E_t.","proofString":"unfold upward_closed.\nintros x y CO YIN.\napply (wf_coE WF) in CO.\nunfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) : forall x y : actid, co_t x y -> E_t y -> E_t x.","proofString":"intros x y CO YIN.\napply (wf_coE WF) in CO.\nunfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (x y : actid) (CO : co_t x y) (YIN : E_t y) : E_t x.","proofString":"apply (wf_coE WF) in CO.\nunfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (x y : actid) (CO : (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘) x y) (YIN : E_t y) : E_t x.","proofString":"unfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) : transitive co_s.","proofString":"assert (COD : upward_closed co_t W_t).\nunfold upward_closed.\nintros x y CO YD.\napply (wf_coD WF) in CO.\nunfolder in CO; desf.\nrewrite (rsr_co SIMREL).\napply expand_transitive.\neapply sico_co_trans, rsr_common; try red; eauto.\nunfold upward_closed in *.\nintros x y REL XIN.\napply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf.\narewrite (extra_a b_t ∩₁ W_s ⊆₁ set_compl (mapper ↑₁ E_t)).\nrewrite (rsr_codom SIMREL).\nclear.\nunfolder.\nins.\ndesf.\ntauto.\nrewrite (wf_coE WF).\napply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) : upward_closed co_t W_t.","proofString":"unfold upward_closed.\nintros x y CO YD.\napply (wf_coD WF) in CO.\nunfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) : forall x y : actid, co_t x y -> is_w lab_t y -> is_w lab_t x.","proofString":"intros x y CO YD.\napply (wf_coD WF) in CO.\nunfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (x y : actid) (CO : co_t x y) (YD : is_w lab_t y) : is_w lab_t x.","proofString":"apply (wf_coD WF) in CO.\nunfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (x y : actid) (CO : (⦗W_t⦘ ⨾ co_t ⨾ ⦗W_t⦘) x y) (YD : is_w lab_t y) : is_w lab_t x.","proofString":"unfolder in CO; desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : transitive co_s.","proofString":"rewrite (rsr_co SIMREL).\napply expand_transitive.\neapply sico_co_trans, rsr_common; try red; eauto.\nunfold upward_closed in *.\nintros x y REL XIN.\napply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf.\narewrite (extra_a b_t ∩₁ W_s ⊆₁ set_compl (mapper ↑₁ E_t)).\nrewrite (rsr_codom SIMREL).\nclear.\nunfolder.\nins.\ndesf.\ntauto.\nrewrite (wf_coE WF).\napply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : transitive\n  (mapper ↑ co_t\n   ∪ add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s)).","proofString":"apply expand_transitive.\neapply sico_co_trans, rsr_common; try red; eauto.\nunfold upward_closed in *.\nintros x y REL XIN.\napply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf.\narewrite (extra_a b_t ∩₁ W_s ⊆₁ set_compl (mapper ↑₁ E_t)).\nrewrite (rsr_codom SIMREL).\nclear.\nunfolder.\nins.\ndesf.\ntauto.\nrewrite (wf_coE WF).\napply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : transitive (mapper ↑ co_t).","proofString":"eapply sico_co_trans, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : upward_closed (mapper ↑ co_t)\n  (extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s).","proofString":"unfold upward_closed in *.\nintros x y REL XIN.\napply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x y : actid),\nco_t x y -> loc_t y = ol -> loc_t x = ol) (COE : forall x y : actid, co_t x y -> E_t y -> E_t x) (COD : forall x y : actid, co_t x y -> is_w lab_t y -> is_w lab_t x) : forall x y : actid,\n(mapper ↑ co_t) x y ->\n(extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s) y ->\n(extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s) x.","proofString":"intros x y REL XIN.\napply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x0 y0 : actid),\nco_t x0 y0 -> loc_t y0 = ol -> loc_t x0 = ol) (COE : forall x0 y0 : actid, co_t x0 y0 -> E_t y0 -> E_t x0) (COD : forall x0 y0 : actid, co_t x0 y0 -> is_w lab_t y0 -> is_w lab_t x0) (x y : actid) (REL : (mapper ↑ co_t) x y) (XIN : (extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s) y) : (extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s) x.","proofString":"apply (extra_co_DE SIMREL).\napply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x0 y0 : actid),\nco_t x0 y0 -> loc_t y0 = ol -> loc_t x0 = ol) (COE : forall x0 y0 : actid, co_t x0 y0 -> E_t y0 -> E_t x0) (COD : forall x0 y0 : actid, co_t x0 y0 -> is_w lab_t y0 -> is_w lab_t x0) (x y : actid) (REL : (mapper ↑ co_t) x y) (XIN : (extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s) y) : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) x.","proofString":"apply (extra_co_DE SIMREL) in XIN.\ndestruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x0 y0 : actid),\nco_t x0 y0 -> loc_t y0 = ol -> loc_t x0 = ol) (COE : forall x0 y0 : actid, co_t x0 y0 -> E_t y0 -> E_t x0) (COD : forall x0 y0 : actid, co_t x0 y0 -> is_w lab_t y0 -> is_w lab_t x0) (x y : actid) (REL : (mapper ↑ co_t) x y) (XIN : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) y) : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) x.","proofString":"destruct REL as (x' & y' & CO & XEQ & YEQ).\nsubst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x0 y0 : actid),\nco_t x0 y0 -> loc_t y0 = ol -> loc_t x0 = ol) (COE : forall x0 y0 : actid, co_t x0 y0 -> E_t y0 -> E_t x0) (COD : forall x0 y0 : actid, co_t x0 y0 -> is_w lab_t y0 -> is_w lab_t x0) (x y x' y' : actid) (CO : co_t x' y') (XEQ : mapper x' = x) (YEQ : mapper y' = y) (XIN : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) y) : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) x.","proofString":"subst.\ndestruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x y : actid),\nco_t x y -> loc_t y = ol -> loc_t x = ol) (COE : forall x y : actid, co_t x y -> E_t y -> E_t x) (COD : forall x y : actid, co_t x y -> is_w lab_t y -> is_w lab_t x) (x' y' : actid) (CO : co_t x' y') (XIN : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) (mapper y')) : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) (mapper x').","proofString":"destruct XIN as (y & ((YINE & ISW) & HLOC) & YMAP).\napply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x y0 : actid),\nco_t x y0 -> loc_t y0 = ol -> loc_t x = ol) (COE : forall x y0 : actid, co_t x y0 -> E_t y0 -> E_t x) (COD : forall x y0 : actid, co_t x y0 -> is_w lab_t y0 -> is_w lab_t x) (x' y' : actid) (CO : co_t x' y') (y : actid) (YINE : E_t y) (ISW : is_w lab_t y) (HLOC : loc_t y = loc_s b_t) (YMAP : mapper y = mapper y') : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) (mapper x').","proofString":"apply (rsr_inj SIMREL) in YMAP; desf.\nunfolder.\neauto 11.\nclear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x y : actid),\nco_t x y -> loc_t y = ol -> loc_t x = ol) (COE : forall x y : actid, co_t x y -> E_t y -> E_t x) (COD : forall x y : actid, co_t x y -> is_w lab_t y -> is_w lab_t x) (x' y' : actid) (CO : co_t x' y') (HLOC : loc_t y' = loc_s b_t) (ISW : is_w lab_t y') (YINE : E_t y') : (mapper ↑₁ (E_t ∩₁ W_t ∩₁ Loc_t_ (loc_s b_t))) (mapper x').","proofString":"unfolder.\neauto 11."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x y : actid),\nco_t x y -> loc_t y = ol -> loc_t x = ol) (COE : forall x y : actid, co_t x y -> E_t y -> E_t x) (COD : forall x y : actid, co_t x y -> is_w lab_t y -> is_w lab_t x) (x' y' : actid) (CO : co_t x' y') (HLOC : loc_t y' = loc_s b_t) (ISW : is_w lab_t y') (YINE : E_t y') : exists y : actid,\n  ((E_t y /\\ is_w lab_t y) /\\ loc_t y = loc_s b_t) /\\ mapper y = mapper x'.","proofString":"eauto 11."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall (ol : option location) (x y0 : actid),\nco_t x y0 -> loc_t y0 = ol -> loc_t x = ol) (COE : forall x y0 : actid, co_t x y0 -> E_t y0 -> E_t x) (COD : forall x y0 : actid, co_t x y0 -> is_w lab_t y0 -> is_w lab_t x) (x' y' : actid) (CO : co_t x' y') (y : actid) (YINE : E_t y) (ISW : is_w lab_t y) (HLOC : loc_t y = loc_s b_t) (YMAP : mapper y = mapper y') : E_t y'.","proofString":"clear - CO WF.\napply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(WF : Wf G_t) (x' y' : actid) (CO : co_t x' y') : E_t y'.","proofString":"apply (wf_coE WF) in CO.\nunfolder in CO.\ndesf."},{"statement":"(WF : Wf G_t) (x' y' : actid) (CO : (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘) x' y') : E_t y'.","proofString":"unfolder in CO.\ndesf."},{"statement":"(WF : Wf G_t) (x' y' : actid) (CO : E_t x' /\\ co_t x' y' /\\ E_t y') : E_t y'.","proofString":"desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : extra_a b_t ∩₁ W_s ⊆₁ set_compl (dom_rel (mapper ↑ co_t)).","proofString":"arewrite (extra_a b_t ∩₁ W_s ⊆₁ set_compl (mapper ↑₁ E_t)).\nrewrite (rsr_codom SIMREL).\nclear.\nunfolder.\nins.\ndesf.\ntauto.\nrewrite (wf_coE WF).\napply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : extra_a b_t ∩₁ W_s ⊆₁ set_compl (mapper ↑₁ E_t).","proofString":"rewrite (rsr_codom SIMREL).\nclear.\nunfolder.\nins.\ndesf.\ntauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : extra_a b_t ∩₁ W_s ⊆₁ set_compl (E_s \\₁ extra_a b_t).","proofString":"clear.\nunfolder.\nins.\ndesf.\ntauto."},{"statement":"extra_a b_t ∩₁ W_s ⊆₁ set_compl (E_s \\₁ extra_a b_t).","proofString":"unfolder.\nins.\ndesf.\ntauto."},{"statement":"forall x : actid,\nextra_a b_t x /\\ is_w lab_s x -> ~ (E_s x /\\ ~ extra_a b_t x).","proofString":"ins.\ndesf.\ntauto."},{"statement":"(x : actid) (H : extra_a b_t x /\\ is_w lab_s x) : ~ (E_s x /\\ ~ extra_a b_t x).","proofString":"desf.\ntauto."},{"statement":"(x : actid) (H : extra_a b_t x) (H0 : is_w lab_s x) : ~ (E_s x /\\ ~ extra_a b_t x).","proofString":"tauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : set_compl (mapper ↑₁ E_t) ⊆₁ set_compl (dom_rel (mapper ↑ co_t)).","proofString":"rewrite (wf_coE WF).\napply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : set_compl (mapper ↑₁ E_t)\n⊆₁ set_compl (dom_rel (mapper ↑ (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘))).","proofString":"apply set_compl_mori.\nunfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : flip set_subset (mapper ↑₁ E_t) (dom_rel (mapper ↑ (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘))).","proofString":"unfold flip.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (COL : forall ol : option location, upward_closed co_t Loc_t_ ol) (COE : upward_closed co_t E_t) (COD : upward_closed co_t W_t) : dom_rel (mapper ↑ (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘)) ⊆₁ mapper ↑₁ E_t.","proofString":"clear.\nbasic_solver."},{"statement":"dom_rel (mapper ↑ (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘)) ⊆₁ mapper ↑₁ E_t.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : irreflexive co_s.","proofString":"rewrite (rsr_co SIMREL).\napply irreflexive_union.\nsplit.\neapply sico_co_irr, rsr_common; try red; eauto.\nunfold add_max.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : irreflexive\n  (mapper ↑ co_t\n   ∪ add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s)).","proofString":"apply irreflexive_union.\nsplit.\neapply sico_co_irr, rsr_common; try red; eauto.\nunfold add_max.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : irreflexive (mapper ↑ co_t) /\\\nirreflexive (add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s)).","proofString":"split.\neapply sico_co_irr, rsr_common; try red; eauto.\nunfold add_max.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : irreflexive (mapper ↑ co_t).","proofString":"eapply sico_co_irr, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : irreflexive (add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s)).","proofString":"unfold add_max.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : irreflexive\n  ((extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s)\n   × (extra_a b_t ∩₁ W_s)).","proofString":"clear.\nbasic_solver."},{"statement":"irreflexive\n  ((extra_co_D E_s lab_s (loc_s b_t) \\₁ extra_a b_t ∩₁ W_s)\n   × (extra_a b_t ∩₁ W_s)).","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : co_s ⊆ same_loc_s.","proofString":"rewrite (rsr_co SIMREL).\napply inclusion_union_l.\neapply sico_col, rsr_common; try red; eauto.\nunfold extra_a.\ndesf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ co_t\n∪ add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s)\n⊆ same_loc_s.","proofString":"apply inclusion_union_l.\neapply sico_col, rsr_common; try red; eauto.\nunfold extra_a.\ndesf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ co_t ⊆ same_loc_s.","proofString":"eapply sico_col, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s) ⊆ same_loc_s.","proofString":"unfold extra_a.\ndesf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : add_max (extra_co_D E_s lab_s (loc_s b_t))\n  ((ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅) ∩₁ W_s) ⊆ same_loc_s.","proofString":"desf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (a : ~ E_t a_t /\\ E_t b_t) : add_max (extra_co_D E_s lab_s (loc_s b_t)) (eq b_t ∩₁ W_s) ⊆ same_loc_s.","proofString":"clear.\nbasic_solver."},{"statement":"add_max (extra_co_D E_s lab_s (loc_s b_t)) (eq b_t ∩₁ W_s) ⊆ same_loc_s.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (n : ~ (~ E_t a_t /\\ E_t b_t)) : add_max (extra_co_D E_s lab_s (loc_s b_t)) (∅ ∩₁ W_s) ⊆ same_loc_s.","proofString":"rewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (n : ~ (~ E_t a_t /\\ E_t b_t)) : ∅₂ ⊆ same_loc_s.","proofString":"clear.\nbasic_solver."},{"statement":"∅₂ ⊆ same_loc_s.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : co_s ≡ ⦗E_s⦘ ⨾ co_s ⨾ ⦗E_s⦘.","proofString":"apply dom_helper_3.\nrewrite (rsr_co SIMREL).\napply inclusion_union_l.\neapply sico_coE, rsr_common; try red; eauto.\nrewrite (rsr_acts SIMREL).\nunfold extra_a.\ndesf.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : co_s ⊆ E_s × E_s.","proofString":"rewrite (rsr_co SIMREL).\napply inclusion_union_l.\neapply sico_coE, rsr_common; try red; eauto.\nrewrite (rsr_acts SIMREL).\nunfold extra_a.\ndesf.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ co_t\n∪ add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s) ⊆ \nE_s × E_s.","proofString":"apply inclusion_union_l.\neapply sico_coE, rsr_common; try red; eauto.\nrewrite (rsr_acts SIMREL).\nunfold extra_a.\ndesf.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ co_t ⊆ E_s × E_s.","proofString":"eapply sico_coE, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s) ⊆ E_s × E_s.","proofString":"rewrite (rsr_acts SIMREL).\nunfold extra_a.\ndesf.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : add_max (extra_co_D (mapper ↑₁ E_t ∪₁ extra_a b_t) lab_s (loc_s b_t))\n  (extra_a b_t ∩₁ W_s)\n⊆ (mapper ↑₁ E_t ∪₁ extra_a b_t) × (mapper ↑₁ E_t ∪₁ extra_a b_t).","proofString":"unfold extra_a.\ndesf.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : add_max\n  (extra_co_D\n     (mapper ↑₁ E_t ∪₁ (ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅)) lab_s\n     (loc_s b_t)) ((ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅) ∩₁ W_s)\n⊆ (mapper ↑₁ E_t ∪₁ (ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅))\n  × (mapper ↑₁ E_t ∪₁ (ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅)).","proofString":"desf.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (a : ~ E_t a_t /\\ E_t b_t) : add_max (extra_co_D (mapper ↑₁ E_t ∪₁ eq b_t) lab_s (loc_s b_t))\n  (eq b_t ∩₁ W_s) ⊆ (mapper ↑₁ E_t ∪₁ eq b_t) × (mapper ↑₁ E_t ∪₁ eq b_t).","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (n : ~ (~ E_t a_t /\\ E_t b_t)) : add_max (extra_co_D (mapper ↑₁ E_t ∪₁ ∅) lab_s (loc_s b_t)) (∅ ∩₁ W_s)\n⊆ (mapper ↑₁ E_t ∪₁ ∅) × (mapper ↑₁ E_t ∪₁ ∅).","proofString":"rewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (n : ~ (~ E_t a_t /\\ E_t b_t)) : ∅₂ ⊆ (mapper ↑₁ E_t ∪₁ ∅) × (mapper ↑₁ E_t ∪₁ ∅).","proofString":"clear.\nbasic_solver."},{"statement":"∅₂ ⊆ (mapper ↑₁ E_t ∪₁ ∅) × (mapper ↑₁ E_t ∪₁ ∅).","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : co_s ≡ ⦗W_s⦘ ⨾ co_s ⨾ ⦗W_s⦘.","proofString":"apply dom_helper_3.\nrewrite (rsr_co SIMREL).\napply inclusion_union_l.\neapply sico_coD, rsr_common; try red; eauto.\nunfold extra_a.\ndesf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : co_s ⊆ W_s × W_s.","proofString":"rewrite (rsr_co SIMREL).\napply inclusion_union_l.\neapply sico_coD, rsr_common; try red; eauto.\nunfold extra_a.\ndesf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ co_t\n∪ add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s) ⊆ \nW_s × W_s.","proofString":"apply inclusion_union_l.\neapply sico_coD, rsr_common; try red; eauto.\nunfold extra_a.\ndesf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : mapper ↑ co_t ⊆ W_s × W_s.","proofString":"eapply sico_coD, rsr_common; try red; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : add_max (extra_co_D E_s lab_s (loc_s b_t)) (extra_a b_t ∩₁ W_s) ⊆ W_s × W_s.","proofString":"unfold extra_a.\ndesf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) : add_max (extra_co_D E_s lab_s (loc_s b_t))\n  ((ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅) ∩₁ W_s) ⊆ \nW_s × W_s.","proofString":"desf.\nclear.\nbasic_solver.\nrewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (a : ~ E_t a_t /\\ E_t b_t) : add_max (extra_co_D E_s lab_s (loc_s b_t)) (eq b_t ∩₁ W_s) ⊆ W_s × W_s.","proofString":"clear.\nbasic_solver."},{"statement":"add_max (extra_co_D E_s lab_s (loc_s b_t)) (eq b_t ∩₁ W_s) ⊆ W_s × W_s.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (n : ~ (~ E_t a_t /\\ E_t b_t)) : add_max (extra_co_D E_s lab_s (loc_s b_t)) (∅ ∩₁ W_s) ⊆ W_s × W_s.","proofString":"rewrite set_inter_empty_l, add_max_empty_r.\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (WF : Wf G_t) (n : ~ (~ E_t a_t /\\ E_t b_t)) : ∅₂ ⊆ W_s × W_s.","proofString":"clear.\nbasic_solver."},{"statement":"∅₂ ⊆ W_s × W_s.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : mapper ↑₁ (fun a : actid => is_init a) ⊆₁ E_s.","proofString":"rewrite (rsr_init_acts PRED), (rsr_codom SIMREL).\nclear.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : E_s \\₁ extra_a b_t ⊆₁ E_s.","proofString":"clear.\nbasic_solver."},{"statement":"E_s \\₁ extra_a b_t ⊆₁ E_s.","proofString":"basic_solver."},{"statement":"(IN : E_t b_t) (SIMREL : reord_simrel) : a_t = b_s.","proofString":"apply (rsr_bt SIMREL).\nbasic_solver."},{"statement":"(IN : E_t b_t) (SIMREL : reord_simrel) : (mapper ↑₁ (eq b_t ∩₁ E_t)) b_s.","proofString":"basic_solver."},{"statement":"(IN : E_t a_t) (SIMREL : reord_simrel) : b_t = mapper a_t.","proofString":"apply (rsr_at SIMREL).\nbasic_solver."},{"statement":"(IN : E_t a_t) (SIMREL : reord_simrel) : (mapper ↑₁ (eq a_t ∩₁ E_t)) (mapper a_t).","proofString":"basic_solver."},{"statement":"(SIMREL : reord_simrel) : forall x : actid, E_t x -> mapper x = upd (upd id a_t b_t) b_t a_t x.","proofString":"intros x XIN.\ndestruct classic with (x = b_t) as [XEQB|XNQB].\nsubst x.\nrewrite upds.\nsymmetry.\napply (rsr_bt SIMREL).\nbasic_solver.\nrewrite updo by exact XNQB.\ndestruct classic with (x = a_t) as [XEQA|XNQA].\nsubst x.\nrewrite upds.\nsymmetry.\napply (rsr_at SIMREL).\nbasic_solver.\nrewrite updo by exact XNQA.\nrewrite (rsr_mid SIMREL); [reflexivity |].\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) : mapper x = upd (upd id a_t b_t) b_t a_t x.","proofString":"destruct classic with (x = b_t) as [XEQB|XNQB].\nsubst x.\nrewrite upds.\nsymmetry.\napply (rsr_bt SIMREL).\nbasic_solver.\nrewrite updo by exact XNQB.\ndestruct classic with (x = a_t) as [XEQA|XNQA].\nsubst x.\nrewrite upds.\nsymmetry.\napply (rsr_at SIMREL).\nbasic_solver.\nrewrite updo by exact XNQA.\nrewrite (rsr_mid SIMREL); [reflexivity |].\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (XEQB : x = b_t) : mapper x = upd (upd id a_t b_t) b_t a_t x.","proofString":"subst x.\nrewrite upds.\nsymmetry.\napply (rsr_bt SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XIN : E_t b_t) : b_s = upd (upd id a_t b_t) b_t a_t b_t.","proofString":"rewrite upds.\nsymmetry.\napply (rsr_bt SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XIN : E_t b_t) : b_s = a_t.","proofString":"symmetry.\napply (rsr_bt SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XIN : E_t b_t) : a_t = b_s.","proofString":"apply (rsr_bt SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XIN : E_t b_t) : (mapper ↑₁ (eq b_t ∩₁ E_t)) b_s.","proofString":"basic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (XNQB : x <> b_t) : mapper x = upd (upd id a_t b_t) b_t a_t x.","proofString":"rewrite updo by exact XNQB.\ndestruct classic with (x = a_t) as [XEQA|XNQA].\nsubst x.\nrewrite upds.\nsymmetry.\napply (rsr_at SIMREL).\nbasic_solver.\nrewrite updo by exact XNQA.\nrewrite (rsr_mid SIMREL); [reflexivity |].\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (XNQB : x <> b_t) : mapper x = upd id a_t b_t x.","proofString":"destruct classic with (x = a_t) as [XEQA|XNQA].\nsubst x.\nrewrite upds.\nsymmetry.\napply (rsr_at SIMREL).\nbasic_solver.\nrewrite updo by exact XNQA.\nrewrite (rsr_mid SIMREL); [reflexivity |].\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (XNQB : x <> b_t) (XEQA : x = a_t) : mapper x = upd id a_t b_t x.","proofString":"subst x.\nrewrite upds.\nsymmetry.\napply (rsr_at SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XNQB : a_t <> b_t) (XIN : E_t a_t) : mapper a_t = upd id a_t b_t a_t.","proofString":"rewrite upds.\nsymmetry.\napply (rsr_at SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XNQB : a_t <> b_t) (XIN : E_t a_t) : mapper a_t = b_t.","proofString":"symmetry.\napply (rsr_at SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XNQB : a_t <> b_t) (XIN : E_t a_t) : b_t = mapper a_t.","proofString":"apply (rsr_at SIMREL).\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (XNQB : a_t <> b_t) (XIN : E_t a_t) : (mapper ↑₁ (eq a_t ∩₁ E_t)) (mapper a_t).","proofString":"basic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (XNQB : x <> b_t) (XNQA : x <> a_t) : mapper x = upd id a_t b_t x.","proofString":"rewrite updo by exact XNQA.\nrewrite (rsr_mid SIMREL); [reflexivity |].\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (XNQB : x <> b_t) (XNQA : x <> a_t) : mapper x = id x.","proofString":"rewrite (rsr_mid SIMREL); [reflexivity |].\nbasic_solver."},{"statement":"(SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (XNQB : x <> b_t) (XNQA : x <> a_t) : ((E_t \\₁ eq a_t) \\₁ eq b_t) x.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : mapper ↑ (sb_t \\ eq b_t × eq a_t)\n⊆ mapper ↑ swap_rel sb_t (eq b_t ∩₁ E_t) (eq a_t ∩₁ E_t)\n  ∪ (mapper ↑₁ dom_rel (sb_t ⨾ ⦗eq b_t⦘)) × extra_a b_t\n  ∪ extra_a b_t × eq b_s.","proofString":"arewrite (    sb_t \\ eq b_t × eq a_t ⊆    sb_t \\ (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)  ).\napply minus_rel_mori; auto with hahn.\nunfold flip.\nbasic_solver.\nbasic_solver 11."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : sb_t \\ eq b_t × eq a_t ⊆ sb_t \\ (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t).","proofString":"apply minus_rel_mori; auto with hahn.\nunfold flip.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : flip inclusion (eq b_t × eq a_t) ((eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t)).","proofString":"unfold flip.\nbasic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t) ⊆ eq b_t × eq a_t.","proofString":"basic_solver."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : mapper ↑ (sb_t \\ (eq b_t ∩₁ E_t) × (eq a_t ∩₁ E_t))\n⊆ mapper ↑ swap_rel sb_t (eq b_t ∩₁ E_t) (eq a_t ∩₁ E_t)\n  ∪ (mapper ↑₁ dom_rel (sb_t ⨾ ⦗eq b_t⦘)) × extra_a b_t\n  ∪ extra_a b_t × eq b_s.","proofString":"basic_solver 11."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) : sb_t x b_t \\/ x = b_t.","proofString":"assert (NIX : ~is_init x).\nunfold is_init.\ndesf.\nexfalso.\nnow apply (rsr_bt_tid PRED).\ndestruct PeanoNat.Nat.lt_total      with (n := index x) (m := index b_t)        as [ZB | [EQ | BZ]].\nleft.\nunfold sb, ext_sb.\nunfolder.\nsplits; auto.\nunfold is_init, index in *; desf.\nright.\nunfold is_init, index, tid in *; desf.\nexfalso.\napply (rsr_bt_max PRED INB NINA)   with (x := b_t) (y := x).\nunfold sb; unfolder; splits; auto.\nunfold ext_sb, is_init, index in *.\ndesf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) : ~ is_init x.","proofString":"unfold is_init.\ndesf.\nexfalso.\nnow apply (rsr_bt_tid PRED)."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) : ~ match x with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end.","proofString":"desf.\nexfalso.\nnow apply (rsr_bt_tid PRED)."},{"statement":"(PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (l : location) (XIN : E_t (InitEvent l)) (TID : tid (InitEvent l) = tid b_t) (NIB : ~ is_init b_t) : ~ true.","proofString":"exfalso.\nnow apply (rsr_bt_tid PRED)."},{"statement":"(PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (l : location) (XIN : E_t (InitEvent l)) (TID : tid (InitEvent l) = tid b_t) (NIB : ~ is_init b_t) : False.","proofString":"now apply (rsr_bt_tid PRED)."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) : sb_t x b_t \\/ x = b_t.","proofString":"destruct PeanoNat.Nat.lt_total      with (n := index x) (m := index b_t)        as [ZB | [EQ | BZ]].\nleft.\nunfold sb, ext_sb.\nunfolder.\nsplits; auto.\nunfold is_init, index in *; desf.\nright.\nunfold is_init, index, tid in *; desf.\nexfalso.\napply (rsr_bt_max PRED INB NINA)   with (x := b_t) (y := x).\nunfold sb; unfolder; splits; auto.\nunfold ext_sb, is_init, index in *.\ndesf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (ZB : index x < index b_t) : sb_t x b_t \\/ x = b_t.","proofString":"left.\nunfold sb, ext_sb.\nunfolder.\nsplits; auto.\nunfold is_init, index in *; desf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (ZB : index x < index b_t) : sb_t x b_t.","proofString":"unfold sb, ext_sb.\nunfolder.\nsplits; auto.\nunfold is_init, index in *; desf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (ZB : index x < index b_t) : (⦗E_t⦘\n ⨾ (fun a b : actid =>\n    match a with\n    | InitEvent _ =>\n        match b with\n        | InitEvent _ => False\n        | ThreadEvent _ _ => True\n        end\n    | ThreadEvent t i =>\n        match b with\n        | InitEvent _ => False\n        | ThreadEvent t' i' => t = t' /\\ i < i'\n        end\n    end) ⨾ ⦗E_t⦘) x b_t.","proofString":"unfolder.\nsplits; auto.\nunfold is_init, index in *; desf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (ZB : index x < index b_t) : E_t x /\\\nmatch x with\n| InitEvent _ =>\n    match b_t with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t i =>\n    match b_t with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t = t' /\\ i < i'\n    end\nend /\\ E_t b_t.","proofString":"splits; auto.\nunfold is_init, index in *; desf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (ZB : index x < index b_t) : match x with\n| InitEvent _ =>\n    match b_t with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t i =>\n    match b_t with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t = t' /\\ i < i'\n    end\nend.","proofString":"unfold is_init, index in *; desf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (EQ : index x = index b_t) : sb_t x b_t \\/ x = b_t.","proofString":"right.\nunfold is_init, index, tid in *; desf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (EQ : index x = index b_t) : x = b_t.","proofString":"unfold is_init, index, tid in *; desf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (BZ : index b_t < index x) : sb_t x b_t \\/ x = b_t.","proofString":"exfalso.\napply (rsr_bt_max PRED INB NINA)   with (x := b_t) (y := x).\nunfold sb; unfolder; splits; auto.\nunfold ext_sb, is_init, index in *.\ndesf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (BZ : index b_t < index x) : False.","proofString":"apply (rsr_bt_max PRED INB NINA)   with (x := b_t) (y := x).\nunfold sb; unfolder; splits; auto.\nunfold ext_sb, is_init, index in *.\ndesf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (BZ : index b_t < index x) : (⦗eq b_t ∩₁ E_t⦘ ⨾ sb_t) b_t x.","proofString":"unfold sb; unfolder; splits; auto.\nunfold ext_sb, is_init, index in *.\ndesf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ is_init b_t) (NIX : ~ is_init x) (BZ : index b_t < index x) : ext_sb b_t x.","proofString":"unfold ext_sb, is_init, index in *.\ndesf."},{"statement":"(x : actid) (PRED : reord_step_pred) (INB : E_t b_t) (NINA : ~ E_t a_t) (XIN : E_t x) (TID : tid x = tid b_t) (NIB : ~ match b_t with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end) (NIX : ~ match x with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end) (BZ : match b_t with\n| InitEvent _ => 0\n| ThreadEvent _ n => n\nend < match x with\n      | InitEvent _ => 0\n      | ThreadEvent _ n => n\n      end) : match b_t with\n| InitEvent _ =>\n    match x with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t i =>\n    match x with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t = t' /\\ i < i'\n    end\nend.","proofString":"desf."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x : actid) (XEQ : a_t = x) (XIN : E_s x) : set_compl (Rel_s ∪₁ Acq_s) x.","proofString":"subst x.\nunfolder.\nunfold is_rel, is_acq, mod.\napply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt.\nassert (NEQ : a_t <> b_t) by apply PRED.\nexfalso.\nred in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_s a_t) : set_compl (Rel_s ∪₁ Acq_s) a_t.","proofString":"unfolder.\nunfold is_rel, is_acq, mod.\napply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt.\nassert (NEQ : a_t <> b_t) by apply PRED.\nexfalso.\nred in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_s a_t) : ~ (is_rel lab_s a_t \\/ is_acq lab_s a_t).","proofString":"unfold is_rel, is_acq, mod.\napply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt.\nassert (NEQ : a_t <> b_t) by apply PRED.\nexfalso.\nred in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_s a_t) : ~\n(mode_le Orel\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"apply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt.\nassert (NEQ : a_t <> b_t) by apply PRED.\nexfalso.\nred in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : (mapper ↑₁ E_t ∪₁ extra_a b_t) a_t) : ~\n(mode_le Orel\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"destruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt.\nassert (NEQ : a_t <> b_t) by apply PRED.\nexfalso.\nred in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = a_t) : ~\n(mode_le Orel\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"rewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = a_t) : ~\n(mode_le Orel\n   match lab_s (mapper x') with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s (mapper x') with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"change (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = a_t) : ~\n(mode_le Orel\n   match (lab_s ∘ mapper) x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match (lab_s ∘ mapper) x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"rewrite (rsr_lab SIMREL); auto.\napply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = a_t) : ~\n(mode_le Orel\n   match lab_t x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_t x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"apply (rsr_bt_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_bt."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = a_t) : (eq b_t ∩₁ E_t) x'.","proofString":"split; auto.\nsymmetry.\nnow apply rsr_mapinv_bt."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = a_t) : b_t = x'.","proofString":"symmetry.\nnow apply rsr_mapinv_bt."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = a_t) : x' = b_t.","proofString":"now apply rsr_mapinv_bt."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (EXA : extra_a b_t a_t) : ~\n(mode_le Orel\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"assert (NEQ : a_t <> b_t) by apply PRED.\nexfalso.\nred in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (EXA : extra_a b_t a_t) (NEQ : a_t <> b_t) : ~\n(mode_le Orel\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s a_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"exfalso.\nred in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (EXA : extra_a b_t a_t) (NEQ : a_t <> b_t) : False.","proofString":"red in EXA.\ndesf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (EXA : (ifP ~ E_t a_t /\\ E_t b_t then eq b_t else ∅) a_t) (NEQ : a_t <> b_t) : False.","proofString":"desf.\ncongruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (a : ~ E_t a_t /\\ E_t b_t) (EXA : b_t = a_t) (NEQ : a_t <> b_t) : False.","proofString":"congruence."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x : actid) (XEQ : b_t = x) (XIN : E_s x) : set_compl (Rel_s ∪₁ Acq_s) x.","proofString":"subst x.\nunfolder.\nunfold is_rel, is_acq, mod.\napply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at.\nnow apply eba_rlx, (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_s b_t) : set_compl (Rel_s ∪₁ Acq_s) b_t.","proofString":"unfolder.\nunfold is_rel, is_acq, mod.\napply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at.\nnow apply eba_rlx, (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_s b_t) : ~ (is_rel lab_s b_t \\/ is_acq lab_s b_t).","proofString":"unfold is_rel, is_acq, mod.\napply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at.\nnow apply eba_rlx, (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_s b_t) : ~\n(mode_le Orel\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"apply (rsr_acts SIMREL) in XIN.\ndestruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at.\nnow apply eba_rlx, (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : (mapper ↑₁ E_t ∪₁ extra_a b_t) b_t) : ~\n(mode_le Orel\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"destruct XIN as [(x' & XIN & MAP) | EXA].\nrewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at.\nnow apply eba_rlx, (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = b_t) : ~\n(mode_le Orel\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"rewrite <- MAP.\nchange (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = b_t) : ~\n(mode_le Orel\n   match lab_s (mapper x') with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s (mapper x') with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"change (lab_s (mapper x')) with ((lab_s ∘ mapper) x').\nrewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = b_t) : ~\n(mode_le Orel\n   match (lab_s ∘ mapper) x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match (lab_s ∘ mapper) x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"rewrite (rsr_lab SIMREL); auto.\napply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = b_t) : ~\n(mode_le Orel\n   match lab_t x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_t x' with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"apply (rsr_at_rlx PRED).\nsplit; auto.\nsymmetry.\nnow apply rsr_mapinv_at."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = b_t) : (eq a_t ∩₁ E_t) x'.","proofString":"split; auto.\nsymmetry.\nnow apply rsr_mapinv_at."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = b_t) : a_t = x'.","proofString":"symmetry.\nnow apply rsr_mapinv_at."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' : actid) (XIN : E_t x') (MAP : mapper x' = b_t) : x' = a_t.","proofString":"now apply rsr_mapinv_at."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (EXA : extra_a b_t b_t) : ~\n(mode_le Orel\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end \\/\n mode_le Oacq\n   match lab_s b_t with\n   | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n   end).","proofString":"now apply eba_rlx, (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : ⦗eq a_t ∩₁ mapper ↑₁ E_t ∪₁ eq a_t ∩₁ extra_a b_t⦘\n⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ mapper ↑₁ E_t ∪₁ eq b_t ∩₁ extra_a b_t⦘ ⊆ ∅₂.","proofString":"arewrite (eq a_t ∩₁ extra_a b_t ≡₁ ∅).\nsplit; auto with hahn.\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nins.\ndesf.\nnow apply (rsr_at_neq_bt PRED).\nrewrite set_union_empty_r.\nrewrite id_union, !seq_union_r, unionC.\napply inclusion_union_l.\nunfolder.\nins.\ndesf.\neapply eba_loc; eauto.\nnow apply (rsr_as SIMREL).\nrewrite <- (rsr_at_bt_loc PRED).\nunfolder.\nintros x' y'.\nintros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq a_t ∩₁ extra_a b_t ≡₁ ∅.","proofString":"split; auto with hahn.\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nins.\ndesf.\nnow apply (rsr_at_neq_bt PRED)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq a_t ∩₁ extra_a b_t ⊆₁ ∅.","proofString":"unfold extra_a; desf; [| basic_solver].\nunfolder.\nins.\ndesf.\nnow apply (rsr_at_neq_bt PRED)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (a : ~ E_t a_t /\\ E_t b_t) : eq a_t ∩₁ eq b_t ⊆₁ ∅.","proofString":"unfolder.\nins.\ndesf.\nnow apply (rsr_at_neq_bt PRED)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (a : ~ E_t a_t /\\ E_t b_t) : forall x : actid, a_t = x /\\ b_t = x -> False.","proofString":"ins.\ndesf.\nnow apply (rsr_at_neq_bt PRED)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (a : ~ E_t a_t /\\ E_t b_t) (x : actid) (H : a_t = x /\\ b_t = x) : False.","proofString":"desf.\nnow apply (rsr_at_neq_bt PRED)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (a : ~ E_t a_t) (a0 : E_t b_t) (H0 : b_t = a_t) : False.","proofString":"now apply (rsr_at_neq_bt PRED)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : ⦗eq a_t ∩₁ mapper ↑₁ E_t ∪₁ ∅⦘\n⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ mapper ↑₁ E_t ∪₁ eq b_t ∩₁ extra_a b_t⦘ ⊆ ∅₂.","proofString":"rewrite set_union_empty_r.\nrewrite id_union, !seq_union_r, unionC.\napply inclusion_union_l.\nunfolder.\nins.\ndesf.\neapply eba_loc; eauto.\nnow apply (rsr_as SIMREL).\nrewrite <- (rsr_at_bt_loc PRED).\nunfolder.\nintros x' y'.\nintros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : ⦗eq a_t ∩₁ mapper ↑₁ E_t⦘\n⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ mapper ↑₁ E_t ∪₁ eq b_t ∩₁ extra_a b_t⦘ ⊆ ∅₂.","proofString":"rewrite id_union, !seq_union_r, unionC.\napply inclusion_union_l.\nunfolder.\nins.\ndesf.\neapply eba_loc; eauto.\nnow apply (rsr_as SIMREL).\nrewrite <- (rsr_at_bt_loc PRED).\nunfolder.\nintros x' y'.\nintros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : ⦗eq a_t ∩₁ mapper ↑₁ E_t⦘ ⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ extra_a b_t⦘\n∪ ⦗eq a_t ∩₁ mapper ↑₁ E_t⦘ ⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ mapper ↑₁ E_t⦘ ⊆ ∅₂.","proofString":"apply inclusion_union_l.\nunfolder.\nins.\ndesf.\neapply eba_loc; eauto.\nnow apply (rsr_as SIMREL).\nrewrite <- (rsr_at_bt_loc PRED).\nunfolder.\nintros x' y'.\nintros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : ⦗eq a_t ∩₁ mapper ↑₁ E_t⦘ ⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ extra_a b_t⦘ ⊆ ∅₂.","proofString":"unfolder.\nins.\ndesf.\neapply eba_loc; eauto.\nnow apply (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : forall x y : actid,\n(a_t = x /\\ (exists y0 : actid, E_t y0 /\\ mapper y0 = x)) /\\\nsame_loc_s x y /\\ b_t = y /\\ extra_a b_t y -> False.","proofString":"ins.\ndesf.\neapply eba_loc; eauto.\nnow apply (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x y : actid) (H : (a_t = x /\\ (exists y0 : actid, E_t y0 /\\ mapper y0 = x)) /\\\nsame_loc_s x y /\\ b_t = y /\\ extra_a b_t y) : False.","proofString":"desf.\neapply eba_loc; eauto.\nnow apply (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (y0 : actid) (H3 : E_t y0) (H0 : same_loc_s a_t b_t) (H4 : mapper y0 = a_t) (H2 : extra_a b_t b_t) : False.","proofString":"eapply eba_loc; eauto.\nnow apply (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (y0 : actid) (H3 : E_t y0) (H0 : same_loc_s a_t b_t) (H4 : mapper y0 = a_t) (H2 : extra_a b_t b_t) : extra_a_pred b_t.","proofString":"now apply (rsr_as SIMREL)."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : ⦗eq a_t ∩₁ mapper ↑₁ E_t⦘ ⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ mapper ↑₁ E_t⦘ ⊆ ∅₂.","proofString":"rewrite <- (rsr_at_bt_loc PRED).\nunfolder.\nintros x' y'.\nintros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : ⦗eq a_t ∩₁ mapper ↑₁ E_t⦘ ⨾ same_loc_s ⨾ ⦗eq b_t ∩₁ mapper ↑₁ E_t⦘\n⊆ ⦗eq a_t ∩₁ E_t⦘ ⨾ same_loc_t ⨾ ⦗eq b_t ∩₁ E_t⦘.","proofString":"unfolder.\nintros x' y'.\nintros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : forall x y : actid,\n(a_t = x /\\ (exists y0 : actid, E_t y0 /\\ mapper y0 = x)) /\\\nsame_loc_s x y /\\ b_t = y /\\ (exists y0 : actid, E_t y0 /\\ mapper y0 = y) ->\n(a_t = x /\\ E_t x) /\\ same_loc_t x y /\\ b_t = y /\\ E_t y.","proofString":"intros x' y'.\nintros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' y' : actid) : (a_t = x' /\\ (exists y : actid, E_t y /\\ mapper y = x')) /\\\nsame_loc_s x' y' /\\ b_t = y' /\\ (exists y : actid, E_t y /\\ mapper y = y') ->\n(a_t = x' /\\ E_t x') /\\ same_loc_t x' y' /\\ b_t = y' /\\ E_t y'.","proofString":"intros (    (XEQ & (x & XIN & XEQ')) &          LOC &    (YEQ & (y & YIN & YEQ'))  ).\nsubst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x' y' : actid) (XEQ : a_t = x') (x : actid) (XIN : E_t x) (XEQ' : mapper x = x') (LOC : same_loc_s x' y') (YEQ : b_t = y') (y : actid) (YIN : E_t y) (YEQ' : mapper y = y') : (a_t = x' /\\ E_t x') /\\ same_loc_t x' y' /\\ b_t = y' /\\ E_t y'.","proofString":"subst x' y'.\nassert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (LOC : same_loc_s a_t b_t) (XEQ' : mapper x = a_t) (y : actid) (YIN : E_t y) (YEQ' : mapper y = b_t) : (a_t = a_t /\\ E_t a_t) /\\ same_loc_t a_t b_t /\\ b_t = b_t /\\ E_t b_t.","proofString":"assert (x = b_t) by now apply rsr_mapinv_bt.\nassert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (LOC : same_loc_s a_t b_t) (XEQ' : mapper x = a_t) (y : actid) (YIN : E_t y) (YEQ' : mapper y = b_t) (H : x = b_t) : (a_t = a_t /\\ E_t a_t) /\\ same_loc_t a_t b_t /\\ b_t = b_t /\\ E_t b_t.","proofString":"assert (y = a_t) by now apply rsr_mapinv_at.\ndesf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x : actid) (XIN : E_t x) (LOC : same_loc_s a_t b_t) (XEQ' : mapper x = a_t) (y : actid) (YIN : E_t y) (YEQ' : mapper y = b_t) (H : x = b_t) (H0 : y = a_t) : (a_t = a_t /\\ E_t a_t) /\\ same_loc_t a_t b_t /\\ b_t = b_t /\\ E_t b_t.","proofString":"desf.\nsplits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_t b_t) (LOC : same_loc_s a_t b_t) (XEQ' : b_s = a_t) (YEQ' : mapper a_t = b_t) (YIN : E_t a_t) : (a_t = a_t /\\ E_t a_t) /\\ same_loc_t a_t b_t /\\ b_t = b_t /\\ E_t b_t.","proofString":"splits; auto.\nunfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_t b_t) (LOC : same_loc_s a_t b_t) (XEQ' : b_s = a_t) (YEQ' : mapper a_t = b_t) (YIN : E_t a_t) : same_loc_t a_t b_t.","proofString":"unfold same_loc, loc in *.\nrewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_t b_t) (LOC : match lab_s a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend) (XEQ' : b_s = a_t) (YEQ' : mapper a_t = b_t) (YIN : E_t a_t) : match lab_t a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_t b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"rewrite <- YEQ' in LOC.\nrewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_t b_t) (LOC : match lab_s a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s (mapper a_t) with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend) (XEQ' : b_s = a_t) (YEQ' : mapper a_t = b_t) (YIN : E_t a_t) : match lab_t a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_t b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"rewrite <- XEQ' in LOC at 1.\nchange (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_t b_t) (LOC : match lab_s b_s with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s (mapper a_t) with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend) (XEQ' : b_s = a_t) (YEQ' : mapper a_t = b_t) (YIN : E_t a_t) : match lab_t a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_t b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"change (lab_s (mapper b_t)) with ((lab_s ∘ mapper) b_t) in LOC.\nchange (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_t b_t) (LOC : match (lab_s ∘ mapper) b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_s (mapper a_t) with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend) (XEQ' : b_s = a_t) (YEQ' : mapper a_t = b_t) (YIN : E_t a_t) : match lab_t a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_t b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"change (lab_s (mapper a_t)) with ((lab_s ∘ mapper) a_t) in LOC.\nrewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (XIN : E_t b_t) (LOC : match (lab_s ∘ mapper) b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch (lab_s ∘ mapper) a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend) (XEQ' : b_s = a_t) (YEQ' : mapper a_t = b_t) (YIN : E_t a_t) : match lab_t a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend =\nmatch lab_t b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"rewrite !(rsr_lab SIMREL) in LOC; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq b_t ∩₁ (mapper ↑₁ E_t ∪₁ extra_a b_t) ⊆₁ R_s ∪₁ W_s.","proofString":"rewrite set_inter_union_r, set_unionC.\napply set_subset_union_l.\nsplit.\nrewrite (rsr_as SIMREL).\nunfolder.\nins; desf.\neapply eba_wr; eauto.\ntransitivity ((R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t);    [| basic_solver].\nassert (INCL :    mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁      (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t  ).\nunfolder.\nintros x (y & (ACQ & YIN) & XEQ).\nunfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto.\nrewrite <- INCL, set_unionC.\nrewrite <- (rsr_a_t_is_r_or_w PRED).\nunfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq b_t ∩₁ extra_a b_t ∪₁ eq b_t ∩₁ mapper ↑₁ E_t ⊆₁ R_s ∪₁ W_s.","proofString":"apply set_subset_union_l.\nsplit.\nrewrite (rsr_as SIMREL).\nunfolder.\nins; desf.\neapply eba_wr; eauto.\ntransitivity ((R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t);    [| basic_solver].\nassert (INCL :    mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁      (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t  ).\nunfolder.\nintros x (y & (ACQ & YIN) & XEQ).\nunfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto.\nrewrite <- INCL, set_unionC.\nrewrite <- (rsr_a_t_is_r_or_w PRED).\nunfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq b_t ∩₁ extra_a b_t ⊆₁ R_s ∪₁ W_s /\\ eq b_t ∩₁ mapper ↑₁ E_t ⊆₁ R_s ∪₁ W_s.","proofString":"split.\nrewrite (rsr_as SIMREL).\nunfolder.\nins; desf.\neapply eba_wr; eauto.\ntransitivity ((R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t);    [| basic_solver].\nassert (INCL :    mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁      (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t  ).\nunfolder.\nintros x (y & (ACQ & YIN) & XEQ).\nunfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto.\nrewrite <- INCL, set_unionC.\nrewrite <- (rsr_a_t_is_r_or_w PRED).\nunfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq b_t ∩₁ extra_a b_t ⊆₁ R_s ∪₁ W_s.","proofString":"rewrite (rsr_as SIMREL).\nunfolder.\nins; desf.\neapply eba_wr; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq b_t ∩₁ extra_a_pred ⊆₁ R_s ∪₁ W_s.","proofString":"unfolder.\nins; desf.\neapply eba_wr; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : forall x : actid, b_t = x /\\ extra_a_pred x -> is_r lab_s x \\/ is_w lab_s x.","proofString":"ins; desf.\neapply eba_wr; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (H0 : extra_a_pred b_t) : is_r lab_s b_t \\/ is_w lab_s b_t.","proofString":"eapply eba_wr; eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq b_t ∩₁ mapper ↑₁ E_t ⊆₁ R_s ∪₁ W_s.","proofString":"transitivity ((R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t);    [| basic_solver].\nassert (INCL :    mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁      (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t  ).\nunfolder.\nintros x (y & (ACQ & YIN) & XEQ).\nunfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto.\nrewrite <- INCL, set_unionC.\nrewrite <- (rsr_a_t_is_r_or_w PRED).\nunfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : eq b_t ∩₁ mapper ↑₁ E_t ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t.","proofString":"assert (INCL :    mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁      (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t  ).\nunfolder.\nintros x (y & (ACQ & YIN) & XEQ).\nunfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto.\nrewrite <- INCL, set_unionC.\nrewrite <- (rsr_a_t_is_r_or_w PRED).\nunfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t.","proofString":"unfolder.\nintros x (y & (ACQ & YIN) & XEQ).\nunfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) : forall x : actid,\n(exists y : actid, ((is_r lab_t y \\/ is_w lab_t y) /\\ E_t y) /\\ mapper y = x) ->\n(is_r lab_s x \\/ is_w lab_s x) /\\ (exists y : actid, E_t y /\\ mapper y = x).","proofString":"intros x (y & (ACQ & YIN) & XEQ).\nunfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x y : actid) (ACQ : is_r lab_t y \\/ is_w lab_t y) (YIN : E_t y) (XEQ : mapper y = x) : (is_r lab_s x \\/ is_w lab_s x) /\\\n(exists y0 : actid, E_t y0 /\\ mapper y0 = x).","proofString":"unfold is_w, is_r in *.\nsubst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (x y : actid) (ACQ : match lab_t y with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match lab_t y with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end) (YIN : E_t y) (XEQ : mapper y = x) : (match lab_s x with\n | Aload _ _ _ _ => true\n | _ => false\n end \\/ match lab_s x with\n        | Astore _ _ _ _ => true\n        | _ => false\n        end) /\\ (exists y0 : actid, E_t y0 /\\ mapper y0 = x).","proofString":"subst x.\nchange (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (y : actid) (ACQ : match lab_t y with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match lab_t y with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end) (YIN : E_t y) : (match lab_s (mapper y) with\n | Aload _ _ _ _ => true\n | _ => false\n end \\/ match lab_s (mapper y) with\n        | Astore _ _ _ _ => true\n        | _ => false\n        end) /\\ (exists y0 : actid, E_t y0 /\\ mapper y0 = mapper y).","proofString":"change (lab_s (mapper y)) with ((lab_s ∘ mapper) y).\nrewrite (rsr_lab SIMREL); eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (y : actid) (ACQ : match lab_t y with\n| Aload _ _ _ _ => true\n| _ => false\nend \\/ match lab_t y with\n       | Astore _ _ _ _ => true\n       | _ => false\n       end) (YIN : E_t y) : (match (lab_s ∘ mapper) y with\n | Aload _ _ _ _ => true\n | _ => false\n end \\/\n match (lab_s ∘ mapper) y with\n | Astore _ _ _ _ => true\n | _ => false\n end) /\\ (exists y0 : actid, E_t y0 /\\ mapper y0 = mapper y).","proofString":"rewrite (rsr_lab SIMREL); eauto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (INCL : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t) : eq b_t ∩₁ mapper ↑₁ E_t ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t.","proofString":"rewrite <- INCL, set_unionC.\nrewrite <- (rsr_a_t_is_r_or_w PRED).\nunfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (INCL : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t) : eq b_t ∩₁ mapper ↑₁ E_t ⊆₁ mapper ↑₁ ((W_t ∪₁ R_t) ∩₁ E_t).","proofString":"rewrite <- (rsr_a_t_is_r_or_w PRED).\nunfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (INCL : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t) : eq b_t ∩₁ mapper ↑₁ E_t ⊆₁ mapper ↑₁ (eq a_t ∩₁ E_t ∩₁ E_t).","proofString":"unfolder.\nintros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (INCL : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t) : forall x : actid,\nb_t = x /\\ (exists y : actid, E_t y /\\ mapper y = x) ->\nexists y : actid, ((a_t = y /\\ E_t y) /\\ E_t y) /\\ mapper y = x.","proofString":"intros x (XEQ & (y & YIN & YEQ)).\nsubst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (INCL : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t) (x : actid) (XEQ : b_t = x) (y : actid) (YIN : E_t y) (YEQ : mapper y = x) : exists y0 : actid, ((a_t = y0 /\\ E_t y0) /\\ E_t y0) /\\ mapper y0 = x.","proofString":"subst x.\nassert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (INCL : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t) (y : actid) (YIN : E_t y) (YEQ : mapper y = b_t) : exists y0 : actid, ((a_t = y0 /\\ E_t y0) /\\ E_t y0) /\\ mapper y0 = b_t.","proofString":"assert (y = a_t); desf; eauto.\napply rsr_mapinv_at; auto."},{"statement":"(PRED : reord_step_pred) (SIMREL : reord_simrel) (INCL : mapper ↑₁ ((R_t ∪₁ W_t) ∩₁ E_t) ⊆₁ (R_s ∪₁ W_s) ∩₁ mapper ↑₁ E_t) (y : actid) (YIN : E_t y) (YEQ : mapper y = b_t) : y = a_t.","proofString":"apply rsr_mapinv_at; auto."}]}