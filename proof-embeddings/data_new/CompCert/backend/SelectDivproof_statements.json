{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/SelectDivproof.v","fileSamples":[{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) : n / d = m * n / two_p (N + l).","conclusion":"n / d = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N)","proofString":"exploit (Z_div_mod_eq n d).\nauto.\nset (q := n / d).\nset (r := n mod d).\nintro EUCL.\nassert (0 <= r <= d - 1).\nunfold r.\ngeneralize (Z_mod_lt n d d_pos).\nlia.\nassert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nset (k := m * d - two_p (N + l)).\nassert (0 <= k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nassert (0 <= k * n).\napply Z.mul_nonneg_nonneg; lia.\nassert (k * n <= two_p (N + l) - two_p l).\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) : d > 0.","conclusion":"d > 0","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N)","proofString":"auto."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) : n = d * (n / d) + n mod d -> n / d = m * n / two_p (N + l).","conclusion":"n = d * (n / d) + n mod d -> n / d = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N)","proofString":"set (q := n / d).\nset (r := n mod d).\nintro EUCL.\nassert (0 <= r <= d - 1).\nunfold r.\ngeneralize (Z_mod_lt n d d_pos).\nlia.\nassert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nset (k := m * d - two_p (N + l)).\nassert (0 <= k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nassert (0 <= k * n).\napply Z.mul_nonneg_nonneg; lia.\nassert (k * n <= two_p (N + l) - two_p l).\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) : n = d * q + n mod d -> q = m * n / two_p (N + l).","conclusion":"n = d * q + n mod d -> q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z)","proofString":"set (r := n mod d).\nintro EUCL.\nassert (0 <= r <= d - 1).\nunfold r.\ngeneralize (Z_mod_lt n d d_pos).\nlia.\nassert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nset (k := m * d - two_p (N + l)).\nassert (0 <= k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nassert (0 <= k * n).\napply Z.mul_nonneg_nonneg; lia.\nassert (k * n <= two_p (N + l) - two_p l).\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) : 0 <= n mod d <= d - 1.","conclusion":"0 <= n mod d <= d - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r)","proofString":"generalize (Z_mod_lt n d d_pos).\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) : 0 <= n mod d < d -> 0 <= n mod d <= d - 1.","conclusion":"0 <= n mod d < d -> 0 <= n mod d <= d - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"assert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nset (k := m * d - two_p (N + l)).\nassert (0 <= k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nassert (0 <= k * n).\napply Z.mul_nonneg_nonneg; lia.\nassert (k * n <= two_p (N + l) - two_p l).\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"apply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : d > 0.","conclusion":"d > 0","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"auto."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : 0 <= m * d.","conclusion":"0 <= m * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"exploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : 0 <= N + l.","conclusion":"0 <= N + l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : two_p (N + l) > 0 -> 0 <= m * d.","conclusion":"two_p (N + l) > 0 -> 0 <= m * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"set (k := m * d - two_p (N + l)).\nassert (0 <= k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nassert (0 <= k * n).\napply Z.mul_nonneg_nonneg; lia.\nassert (k * n <= two_p (N + l) - two_p l).\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) : (m * n - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * n + two_p (N + l) * r.","conclusion":"(m * n - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * n + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l)","proofString":"rewrite EUCL.\nring."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) : (m * (d * q + r) - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * (d * q + r) + two_p (N + l) * r.","conclusion":"(m * (d * q + r) - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * (d * q + r) + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l)","proofString":"ring."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"assert (0 <= k * n).\napply Z.mul_nonneg_nonneg; lia.\nassert (k * n <= two_p (N + l) - two_p l).\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 <= k * n.","conclusion":"0 <= k * n","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"apply Z.mul_nonneg_nonneg; lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"assert (k * n <= two_p (N + l) - two_p l).\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : k * n <= two_p (N + l) - two_p l.","conclusion":"k * n <= two_p (N + l) - two_p l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"apply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\nreplace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : k * n <= two_p l * n.","conclusion":"k * n <= two_p l * n","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"apply Z.mul_le_mono_nonneg_r; lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : two_p l * n <= two_p (N + l) - two_p l.","conclusion":"two_p l * n <= two_p (N + l) - two_p l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"replace (N + l) with (l + N) by lia.\nrewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : two_p l * n <= two_p (l + N) - two_p l.","conclusion":"two_p l * n <= two_p (l + N) - two_p l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"rewrite two_p_is_exp.\nreplace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : two_p l * n <= two_p l * two_p N - two_p l.","conclusion":"two_p l * n <= two_p l * two_p N - two_p l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"replace (two_p l * two_p N - two_p l)       with (two_p l * (two_p N - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : two_p l * n <= two_p l * (two_p N - 1).","conclusion":"two_p l * n <= two_p l * (two_p N - 1)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"apply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : 0 <= two_p l.","conclusion":"0 <= two_p l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : n <= two_p N - 1.","conclusion":"n <= two_p N - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"exploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : 0 <= l.","conclusion":"0 <= l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : two_p l > 0 -> n <= two_p N - 1.","conclusion":"two_p l > 0 -> n <= two_p N - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : 0 <= l.","conclusion":"0 <= l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) : 0 <= N.","conclusion":"0 <= N","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l)","proofString":"assert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) : 0 <= two_p (N + l) * r.","conclusion":"0 <= two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l)","proofString":"apply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) : 0 <= two_p (N + l).","conclusion":"0 <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l)","proofString":"exploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) : 0 <= N + l.","conclusion":"0 <= N + l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) : two_p (N + l) > 0 -> 0 <= two_p (N + l).","conclusion":"two_p (N + l) > 0 -> 0 <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) : 0 <= r.","conclusion":"0 <= r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r)","proofString":"assert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nassert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l).","conclusion":"two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r)","proofString":"replace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1)) by ring.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) : two_p (N + l) * r <= two_p (N + l) * (d - 1).","conclusion":"two_p (N + l) * r <= two_p (N + l) * (d - 1)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r)","proofString":"apply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) : 0 <= two_p (N + l).","conclusion":"0 <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) : r <= d - 1.","conclusion":"r <= d - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r)","proofString":"exploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) : 0 <= N + l.","conclusion":"0 <= N + l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) : two_p (N + l) > 0 -> r <= d - 1.","conclusion":"two_p (N + l) > 0 -> r <= d - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l))","proofString":"assert (0 <= m * n - two_p (N + l) * q).\napply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia.\nassert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) : 0 <= m * n - two_p (N + l) * q.","conclusion":"0 <= m * n - two_p (N + l) * q","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l))","proofString":"apply Zmult_le_reg_r with d.\nauto.\nreplace (0 * d) with 0 by ring.\nrewrite H2.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) : d > 0.","conclusion":"d > 0","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l))","proofString":"auto."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) : 0 * d <= (m * n - two_p (N + l) * q) * d.","conclusion":"0 * d <= (m * n - two_p (N + l) * q) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l))","proofString":"replace (0 * d) with 0 by ring.\nrewrite H2.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) : 0 <= (m * n - two_p (N + l) * q) * d.","conclusion":"0 <= (m * n - two_p (N + l) * q) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l))","proofString":"rewrite H2.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) : 0 <= k * n + two_p (N + l) * r.","conclusion":"0 <= k * n + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l))","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"assert (m * n - two_p (N + l) * q < two_p (N + l)).\napply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nsymmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : m * n - two_p (N + l) * q < two_p (N + l).","conclusion":"m * n - two_p (N + l) * q < two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"apply Zmult_lt_reg_r with d.\nlia.\nrewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : 0 < d.","conclusion":"0 < d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : (m * n - two_p (N + l) * q) * d < two_p (N + l) * d.","conclusion":"(m * n - two_p (N + l) * q) * d < two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"rewrite H2.\napply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : k * n + two_p (N + l) * r < two_p (N + l) * d.","conclusion":"k * n + two_p (N + l) * r < two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"apply Z.le_lt_trans with (two_p (N + l) * d - two_p l).\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : k * n + two_p (N + l) * r <= two_p (N + l) * d - two_p l.","conclusion":"k * n + two_p (N + l) * r <= two_p (N + l) * d - two_p l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : two_p (N + l) * d - two_p l < two_p (N + l) * d.","conclusion":"two_p (N + l) * d - two_p l < two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"exploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : 0 <= l.","conclusion":"0 <= l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) : two_p l > 0 -> two_p (N + l) * d - two_p l < two_p (N + l) * d.","conclusion":"two_p l > 0 -> two_p (N + l) * d - two_p l < two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l)) : q = m * n / two_p (N + l).","conclusion":"q = m * n / two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l))","proofString":"symmetry.\napply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l)) : m * n / two_p (N + l) = q.","conclusion":"m * n / two_p (N + l) = q","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l))","proofString":"apply Zdiv_unique with (m * n - two_p (N + l) * q).\nring.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l)) : m * n = q * two_p (N + l) + (m * n - two_p (N + l) * q).","conclusion":"m * n = q * two_p (N + l) + (m * n - two_p (N + l) * q)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l))","proofString":"ring."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l)) : 0 <= m * n - two_p (N + l) * q < two_p (N + l).","conclusion":"0 <= m * n - two_p (N + l) * q < two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) <= m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 <= n < two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 <= k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 <= k * n) (H4 : k * n <= two_p (N + l) - two_p l) (H5 : 0 <= two_p (N + l) * r) (H6 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) (H7 : 0 <= m * n - two_p (N + l) * q) (H8 : m * n - two_p (N + l) * q < two_p (N + l))","proofString":"lia."},{"statement":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y) : x / y = q - 1.","conclusion":"x / y = q - 1","hypotheses":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y)","proofString":"apply Zdiv_unique with (x - (q - 1) * y).\nring.\nreplace ((q - 1) * y) with (y * q - y) by ring.\nlia."},{"statement":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y) : x = (q - 1) * y + (x - (q - 1) * y).","conclusion":"x = (q - 1) * y + (x - (q - 1) * y)","hypotheses":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y)","proofString":"ring."},{"statement":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y) : 0 <= x - (q - 1) * y < y.","conclusion":"0 <= x - (q - 1) * y < y","hypotheses":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y)","proofString":"replace ((q - 1) * y) with (y * q - y) by ring.\nlia."},{"statement":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y) : 0 <= x - (y * q - y) < y.","conclusion":"0 <= x - (y * q - y) < y","hypotheses":"(x y q : Z) (H : y > 0) (H0 : 0 < y * q - x <= y)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) : n / d = - (m * - n / two_p (N + l)) - 1.","conclusion":"n / d = - (m * - n / two_p (N + l)) - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N)","proofString":"replace (m * (-n)) with (- (m * n)) by ring.\nexploit (Z_div_mod_eq n d).\nauto.\nset (q := n / d).\nset (r := n mod d).\nintro EUCL.\nassert (0 <= r <= d - 1).\nunfold r.\ngeneralize (Z_mod_lt n d d_pos).\nlia.\nassert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\ncut (Z.div (- (m * n)) (two_p (N + l)) = -q - 1).\nlia.\napply Zdiv_unique_2.\napply two_p_gt_ZERO.\nlia.\nreplace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) : n / d = - (- (m * n) / two_p (N + l)) - 1.","conclusion":"n / d = - (- (m * n) / two_p (N + l)) - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N)","proofString":"exploit (Z_div_mod_eq n d).\nauto.\nset (q := n / d).\nset (r := n mod d).\nintro EUCL.\nassert (0 <= r <= d - 1).\nunfold r.\ngeneralize (Z_mod_lt n d d_pos).\nlia.\nassert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\ncut (Z.div (- (m * n)) (two_p (N + l)) = -q - 1).\nlia.\napply Zdiv_unique_2.\napply two_p_gt_ZERO.\nlia.\nreplace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) : d > 0.","conclusion":"d > 0","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N)","proofString":"auto."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) : n = d * (n / d) + n mod d -> n / d = - (- (m * n) / two_p (N + l)) - 1.","conclusion":"n = d * (n / d) + n mod d -> n / d = - (- (m * n) / two_p (N + l)) - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N)","proofString":"set (q := n / d).\nset (r := n mod d).\nintro EUCL.\nassert (0 <= r <= d - 1).\nunfold r.\ngeneralize (Z_mod_lt n d d_pos).\nlia.\nassert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\ncut (Z.div (- (m * n)) (two_p (N + l)) = -q - 1).\nlia.\napply Zdiv_unique_2.\napply two_p_gt_ZERO.\nlia.\nreplace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) : n = d * q + n mod d -> q = - (- (m * n) / two_p (N + l)) - 1.","conclusion":"n = d * q + n mod d -> q = - (- (m * n) / two_p (N + l)) - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z)","proofString":"set (r := n mod d).\nintro EUCL.\nassert (0 <= r <= d - 1).\nunfold r.\ngeneralize (Z_mod_lt n d d_pos).\nlia.\nassert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\ncut (Z.div (- (m * n)) (two_p (N + l)) = -q - 1).\nlia.\napply Zdiv_unique_2.\napply two_p_gt_ZERO.\nlia.\nreplace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) : 0 <= n mod d <= d - 1.","conclusion":"0 <= n mod d <= d - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r)","proofString":"generalize (Z_mod_lt n d d_pos).\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) : 0 <= n mod d < d -> 0 <= n mod d <= d - 1.","conclusion":"0 <= n mod d < d -> 0 <= n mod d <= d - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : q = - (- (m * n) / two_p (N + l)) - 1.","conclusion":"q = - (- (m * n) / two_p (N + l)) - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"assert (0 <= m).\napply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\ncut (Z.div (- (m * n)) (two_p (N + l)) = -q - 1).\nlia.\napply Zdiv_unique_2.\napply two_p_gt_ZERO.\nlia.\nreplace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"apply Zmult_le_0_reg_r with d.\nauto.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : d > 0.","conclusion":"d > 0","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"auto."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : 0 <= m * d.","conclusion":"0 <= m * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"exploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : 0 <= N + l.","conclusion":"0 <= N + l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) : two_p (N + l) > 0 -> 0 <= m * d.","conclusion":"two_p (N + l) > 0 -> 0 <= m * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : q = - (- (m * n) / two_p (N + l)) - 1.","conclusion":"q = - (- (m * n) / two_p (N + l)) - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"cut (Z.div (- (m * n)) (two_p (N + l)) = -q - 1).\nlia.\napply Zdiv_unique_2.\napply two_p_gt_ZERO.\nlia.\nreplace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : - (m * n) / two_p (N + l) = - q - 1 -> q = - (- (m * n) / two_p (N + l)) - 1.","conclusion":"- (m * n) / two_p (N + l) = - q - 1 -> q = - (- (m * n) / two_p (N + l)) - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : - (m * n) / two_p (N + l) = - q - 1.","conclusion":"- (m * n) / two_p (N + l) = - q - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"apply Zdiv_unique_2.\napply two_p_gt_ZERO.\nlia.\nreplace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : two_p (N + l) > 0.","conclusion":"two_p (N + l) > 0","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"apply two_p_gt_ZERO.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : 0 <= N + l.","conclusion":"0 <= N + l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : 0 < two_p (N + l) * - q - - (m * n) <= two_p (N + l).","conclusion":"0 < two_p (N + l) * - q - - (m * n) <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"replace (two_p (N + l) * - q - - (m * n))     with (m * n - two_p (N + l) * q)       by ring.\nset (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) : 0 < m * n - two_p (N + l) * q <= two_p (N + l).","conclusion":"0 < m * n - two_p (N + l) * q <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m)","proofString":"set (k := m * d - two_p (N + l)).\nassert (0 < k <= two_p l).\nunfold k; lia.\nassert ((m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r).\nunfold k.\nrewrite EUCL.\nring.\nsplit.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) : (m * n - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * n + two_p (N + l) * r.","conclusion":"(m * n - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * n + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l)","proofString":"rewrite EUCL.\nring."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) : (m * (d * q + r) - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * (d * q + r) + two_p (N + l) * r.","conclusion":"(m * (d * q + r) - two_p (N + l) * q) * d =\n(m * d - two_p (N + l)) * (d * q + r) + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l)","proofString":"ring."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 < m * n - two_p (N + l) * q <= two_p (N + l).","conclusion":"0 < m * n - two_p (N + l) * q <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"split.\napply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia.\napply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 < m * n - two_p (N + l) * q.","conclusion":"0 < m * n - two_p (N + l) * q","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"apply Zmult_lt_reg_r with d.\nlia.\nreplace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 < d.","conclusion":"0 < d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 * d < (m * n - two_p (N + l) * q) * d.","conclusion":"0 * d < (m * n - two_p (N + l) * q) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"replace (0 * d) with 0 by lia.\nrewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 < (m * n - two_p (N + l) * q) * d.","conclusion":"0 < (m * n - two_p (N + l) * q) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"rewrite H2.\nassert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 < k * n + two_p (N + l) * r.","conclusion":"0 < k * n + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"assert (0 < k * n).\napply Z.mul_pos_pos; lia.\nassert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 < k * n.","conclusion":"0 < k * n","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"apply Z.mul_pos_pos; lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n) : 0 < k * n + two_p (N + l) * r.","conclusion":"0 < k * n + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n)","proofString":"assert (0 <= two_p (N + l) * r).\napply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n) : 0 <= two_p (N + l) * r.","conclusion":"0 <= two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n)","proofString":"apply Z.mul_nonneg_nonneg.\nexploit (two_p_gt_ZERO (N + l)); lia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n) : 0 <= two_p (N + l).","conclusion":"0 <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n)","proofString":"exploit (two_p_gt_ZERO (N + l)); lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n) : 0 <= r.","conclusion":"0 <= r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n) (H4 : 0 <= two_p (N + l) * r) : 0 < k * n + two_p (N + l) * r.","conclusion":"0 < k * n + two_p (N + l) * r","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : 0 < k * n) (H4 : 0 <= two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : m * n - two_p (N + l) * q <= two_p (N + l).","conclusion":"m * n - two_p (N + l) * q <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"apply Zmult_le_reg_r with d.\nlia.\nrewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : d > 0.","conclusion":"d > 0","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : (m * n - two_p (N + l) * q) * d <= two_p (N + l) * d.","conclusion":"(m * n - two_p (N + l) * q) * d <= two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"rewrite H2.\nassert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : k * n + two_p (N + l) * r <= two_p (N + l) * d.","conclusion":"k * n + two_p (N + l) * r <= two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"assert (k * n <= two_p (N + l)).\nrewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia.\nassert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : k * n <= two_p (N + l).","conclusion":"k * n <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"rewrite Z.add_comm.\nrewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : k * n <= two_p (l + N).","conclusion":"k * n <= two_p (l + N)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"rewrite two_p_is_exp; try lia.\napply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : k * n <= two_p l * two_p N.","conclusion":"k * n <= two_p l * two_p N","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"apply Z.le_trans with (two_p l * n).\napply Z.mul_le_mono_nonneg_r; lia.\napply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : k * n <= two_p l * n.","conclusion":"k * n <= two_p l * n","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"apply Z.mul_le_mono_nonneg_r; lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : two_p l * n <= two_p l * two_p N.","conclusion":"two_p l * n <= two_p l * two_p N","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"apply Z.mul_le_mono_nonneg_l.\nlia.\nexploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 <= two_p l.","conclusion":"0 <= two_p l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : n <= two_p N.","conclusion":"n <= two_p N","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"exploit (two_p_gt_ZERO l).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : 0 <= l.","conclusion":"0 <= l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) : two_p l > 0 -> n <= two_p N.","conclusion":"two_p l > 0 -> n <= two_p N","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r)","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) : k * n + two_p (N + l) * r <= two_p (N + l) * d.","conclusion":"k * n + two_p (N + l) * r <= two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l))","proofString":"assert (two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)).\nreplace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l).","conclusion":"two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l))","proofString":"replace (two_p (N + l) * d - two_p (N + l))       with (two_p (N + l) * (d - 1))         by ring.\napply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) : two_p (N + l) * r <= two_p (N + l) * (d - 1).","conclusion":"two_p (N + l) * r <= two_p (N + l) * (d - 1)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l))","proofString":"apply Z.mul_le_mono_nonneg_l.\nexploit (two_p_gt_ZERO (N + l)).\nlia.\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) : 0 <= two_p (N + l).","conclusion":"0 <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l))","proofString":"exploit (two_p_gt_ZERO (N + l)).\nlia.\nlia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) : 0 <= N + l.","conclusion":"0 <= N + l","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l))","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) : two_p (N + l) > 0 -> 0 <= two_p (N + l).","conclusion":"two_p (N + l) > 0 -> 0 <= two_p (N + l)","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l))","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) : r <= d - 1.","conclusion":"r <= d - 1","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l))","proofString":"lia."},{"statement":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) (H4 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l)) : k * n + two_p (N + l) * r <= two_p (N + l) * d.","conclusion":"k * n + two_p (N + l) * r <= two_p (N + l) * d","hypotheses":"(m l : Z) (l_pos : l >= 0) (LO : two_p (N + l) < m * d) (HI : m * d <= two_p (N + l) + two_p l) (n : Z) (RANGE : 0 < n <= two_p N) (q : Z) (r : Z) (EUCL : n = d * q + r) (H : 0 <= r <= d - 1) (H0 : 0 <= m) (k : Z) (H1 : 0 < k <= two_p l) (H2 : (m * n - two_p (N + l) * q) * d = k * n + two_p (N + l) * r) (H3 : k * n <= two_p (N + l)) (H4 : two_p (N + l) * r <= two_p (N + l) * d - two_p (N + l))","proofString":"lia."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) : n  d = m * n / two_p (N + l) + (if zlt n 0 then 1 else 0).","conclusion":"n  d = m * n / two_p (N + l) + (if zlt n 0 then 1 else 0)","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N)","proofString":"destruct (zlt n 0).\nexploit (Zdiv_mul_opp m l H H0 (-n)).\nlia.\nreplace (- - n) with n by ring.\nreplace (Z.quot n d) with (- Z.quot (-n) d).\nrewrite Zquot_Zdiv_pos by lia.\nlia.\nrewrite Z.quot_opp_l by lia.\nring.\nrewrite Z.add_0_r.\nrewrite Zquot_Zdiv_pos by lia.\napply Zdiv_mul_pos; lia."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : n  d = m * n / two_p (N + l) + 1.","conclusion":"n  d = m * n / two_p (N + l) + 1","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"exploit (Zdiv_mul_opp m l H H0 (-n)).\nlia.\nreplace (- - n) with n by ring.\nreplace (Z.quot n d) with (- Z.quot (-n) d).\nrewrite Zquot_Zdiv_pos by lia.\nlia.\nrewrite Z.quot_opp_l by lia.\nring."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : 0 < - n <= two_p N.","conclusion":"0 < - n <= two_p N","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"lia."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : - n / d = - (m * - - n / two_p (N + l)) - 1 ->\nn  d = m * n / two_p (N + l) + 1.","conclusion":"- n / d = - (m * - - n / two_p (N + l)) - 1 ->\nn  d = m * n / two_p (N + l) + 1","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"replace (- - n) with n by ring.\nreplace (Z.quot n d) with (- Z.quot (-n) d).\nrewrite Zquot_Zdiv_pos by lia.\nlia.\nrewrite Z.quot_opp_l by lia.\nring."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : - n / d = - (m * n / two_p (N + l)) - 1 -> n  d = m * n / two_p (N + l) + 1.","conclusion":"- n / d = - (m * n / two_p (N + l)) - 1 -> n  d = m * n / two_p (N + l) + 1","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"replace (Z.quot n d) with (- Z.quot (-n) d).\nrewrite Zquot_Zdiv_pos by lia.\nlia.\nrewrite Z.quot_opp_l by lia.\nring."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : - n / d = - (m * n / two_p (N + l)) - 1 ->\n- (- n  d) = m * n / two_p (N + l) + 1.","conclusion":"- n / d = - (m * n / two_p (N + l)) - 1 ->\n- (- n  d) = m * n / two_p (N + l) + 1","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"rewrite Zquot_Zdiv_pos by lia.\nlia."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : - n / d = - (m * n / two_p (N + l)) - 1 ->\n- (- n / d) = m * n / two_p (N + l) + 1.","conclusion":"- n / d = - (m * n / two_p (N + l)) - 1 ->\n- (- n / d) = m * n / two_p (N + l) + 1","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"lia."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : - (- n  d) = n  d.","conclusion":"- (- n  d) = n  d","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"rewrite Z.quot_opp_l by lia.\nring."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0) : - - (n  d) = n  d.","conclusion":"- - (n  d) = n  d","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (l0 : n < 0)","proofString":"ring."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (g : n >= 0) : n  d = m * n / two_p (N + l) + 0.","conclusion":"n  d = m * n / two_p (N + l) + 0","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (g : n >= 0)","proofString":"rewrite Z.add_0_r.\nrewrite Zquot_Zdiv_pos by lia.\napply Zdiv_mul_pos; lia."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (g : n >= 0) : n  d = m * n / two_p (N + l).","conclusion":"n  d = m * n / two_p (N + l)","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (g : n >= 0)","proofString":"rewrite Zquot_Zdiv_pos by lia.\napply Zdiv_mul_pos; lia."},{"statement":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (g : n >= 0) : n / d = m * n / two_p (N + l).","conclusion":"n / d = m * n / two_p (N + l)","hypotheses":"(m l : Z) (H : l >= 0) (H0 : two_p (N + l) < m * d <= two_p (N + l) + two_p l) (n : Z) (H1 : - two_p N <= n < two_p N) (g : n >= 0)","proofString":"apply Zdiv_mul_pos; lia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') : 0 <= m' < Int.modulus /\\\n0 <= p' < 32 /\\\n(forall n : Z,\n Int.min_signed <= n <= Int.max_signed ->\n n  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0)).","conclusion":"0 <= m' < Int.modulus /\\\n0 <= p' < 32 /\\\n(forall n : Z,\n Int.min_signed <= n <= Int.max_signed ->\n n  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p')","proofString":"split.\nauto.\nsplit.\nauto.\nintros.\nreplace (32 + p') with (31 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (31 + (p' + 1)) with (32 + p') by lia.\nlia.\nchange (Int.min_signed <= n < Int.half_modulus).\nunfold Int.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') : 0 <= m' < Int.modulus.","conclusion":"0 <= m' < Int.modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') : 0 <= p' < 32 /\\\n(forall n : Z,\n Int.min_signed <= n <= Int.max_signed ->\n n  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0)).","conclusion":"0 <= p' < 32 /\\\n(forall n : Z,\n Int.min_signed <= n <= Int.max_signed ->\n n  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p')","proofString":"split.\nauto.\nintros.\nreplace (32 + p') with (31 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (31 + (p' + 1)) with (32 + p') by lia.\nlia.\nchange (Int.min_signed <= n < Int.half_modulus).\nunfold Int.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') : 0 <= p' < 32.","conclusion":"0 <= p' < 32","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') : forall n : Z,\nInt.min_signed <= n <= Int.max_signed ->\nn  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0).","conclusion":"forall n : Z,\nInt.min_signed <= n <= Int.max_signed ->\nn  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p')","proofString":"intros.\nreplace (32 + p') with (31 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (31 + (p' + 1)) with (32 + p') by lia.\nlia.\nchange (Int.min_signed <= n < Int.half_modulus).\nunfold Int.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed) : n  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0).","conclusion":"n  d = m' * n / two_p (32 + p') + (if zlt n 0 then 1 else 0)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed)","proofString":"replace (32 + p') with (31 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (31 + (p' + 1)) with (32 + p') by lia.\nlia.\nchange (Int.min_signed <= n < Int.half_modulus).\nunfold Int.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed) : n  d = m' * n / two_p (31 + (p' + 1)) + (if zlt n 0 then 1 else 0).","conclusion":"n  d = m' * n / two_p (31 + (p' + 1)) + (if zlt n 0 then 1 else 0)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed)","proofString":"apply Zquot_mul; try lia.\nreplace (31 + (p' + 1)) with (32 + p') by lia.\nlia.\nchange (Int.min_signed <= n < Int.half_modulus).\nunfold Int.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed) : two_p (31 + (p' + 1)) < m' * d <= two_p (31 + (p' + 1)) + two_p (p' + 1).","conclusion":"two_p (31 + (p' + 1)) < m' * d <= two_p (31 + (p' + 1)) + two_p (p' + 1)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed)","proofString":"replace (31 + (p' + 1)) with (32 + p') by lia.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed) : two_p (32 + p') < m' * d <= two_p (32 + p') + two_p (p' + 1).","conclusion":"two_p (32 + p') < m' * d <= two_p (32 + p') + two_p (p' + 1)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed)","proofString":"lia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed) : - two_p 31 <= n < two_p 31.","conclusion":"- two_p 31 <= n < two_p 31","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed)","proofString":"change (Int.min_signed <= n < Int.half_modulus).\nunfold Int.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed) : Int.min_signed <= n < Int.half_modulus.","conclusion":"Int.min_signed <= n < Int.half_modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.max_signed)","proofString":"unfold Int.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.half_modulus - 1) : Int.min_signed <= n < Int.half_modulus.","conclusion":"Int.min_signed <= n < Int.half_modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') < m' * d) (l1 : m' * d <= two_p (32 + p') + two_p (p' + 1)) (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : Int.min_signed <= n <= Int.half_modulus - 1)","proofString":"lia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') : 0 <= m' < Int.modulus /\\\n0 <= p' < 32 /\\\n(forall n : Z, 0 <= n < Int.modulus -> n / d = m' * n / two_p (32 + p')).","conclusion":"0 <= m' < Int.modulus /\\\n0 <= p' < 32 /\\\n(forall n : Z, 0 <= n < Int.modulus -> n / d = m' * n / two_p (32 + p'))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p')","proofString":"split.\nauto.\nsplit.\nauto.\nintros.\napply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') : 0 <= m' < Int.modulus.","conclusion":"0 <= m' < Int.modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') : 0 <= p' < 32 /\\\n(forall n : Z, 0 <= n < Int.modulus -> n / d = m' * n / two_p (32 + p')).","conclusion":"0 <= p' < 32 /\\\n(forall n : Z, 0 <= n < Int.modulus -> n / d = m' * n / two_p (32 + p'))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p')","proofString":"split.\nauto.\nintros.\napply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') : 0 <= p' < 32.","conclusion":"0 <= p' < 32","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') : forall n : Z, 0 <= n < Int.modulus -> n / d = m' * n / two_p (32 + p').","conclusion":"forall n : Z, 0 <= n < Int.modulus -> n / d = m' * n / two_p (32 + p')","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p')","proofString":"intros.\napply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int.modulus) : n / d = m' * n / two_p (32 + p').","conclusion":"n / d = m' * n / two_p (32 + p')","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int.modulus)","proofString":"apply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int.modulus) : 0 <= n < two_p 32.","conclusion":"0 <= n < two_p 32","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int.modulus) (l2 : 0 <= m') (l0 : two_p (32 + p') <= m' * d) (l1 : m' * d <= two_p (32 + p') + two_p p') (l5 : p' < 32) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int.modulus)","proofString":"assumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) : 0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m))","proofString":"set (n := Int.signed x).\nset (d := Int.signed y) in *.\nexploit divs_mul_params_sound; eauto.\nintros (A & B & C).\nsplit.\nauto.\nsplit.\nauto.\nunfold Int.divs.\nfold n; fold d.\nrewrite C by (apply Int.signed_range).\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv.\nrewrite Int.shru_lt_zero.\nunfold Int.add.\napply Int.eqm_samerepr.\napply Int.eqm_add.\nrewrite Int.shr_div_two_p.\napply Int.eqm_unsigned_repr_r.\napply Int.eqm_refl2.\nrewrite Int.unsigned_repr.\nf_equal.\nrewrite Int.signed_repr.\nrewrite Int.modulus_power.\nf_equal.\nring.\ncut (Int.min_signed <= n * m / Int.modulus < Int.half_modulus).\nunfold Int.max_signed; lia.\napply Zdiv_interval_1.\ngeneralize Int.min_signed_neg; lia.\napply Int.half_modulus_pos.\napply Int.modulus_pos.\nsplit.\napply Z.le_trans with (Int.min_signed * m).\napply Z.mul_le_mono_nonpos_l.\ngeneralize Int.min_signed_neg; lia.\nlia.\napply Z.mul_le_mono_nonneg_r.\nlia.\nunfold n; generalize (Int.signed_range x); tauto.\napply Z.le_lt_trans with (Int.half_modulus * m).\napply Z.mul_le_mono_nonneg_r.\ntauto.\ngeneralize (Int.signed_range x); unfold n, Int.max_signed; lia.\napply Zmult_lt_compat_l.\ngeneralize Int.half_modulus_pos; lia.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\nunfold Int.lt; fold n.\nrewrite Int.signed_zero.\ndestruct (zlt n 0); apply Int.eqm_unsigned_repr.\napply two_p_gt_ZERO.\nlia.\napply two_p_gt_ZERO.\nlia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= m < Int.modulus.","conclusion":"0 <= m < Int.modulus","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"auto."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= p < 32.","conclusion":"0 <= p < 32","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"auto."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : m * n / two_p 32 = n * m / Int.modulus.","conclusion":"m * n / two_p 32 = n * m / Int.modulus","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"rewrite Int.modulus_power.\nf_equal.\nring."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : m * n / two_p 32 = n * m / two_p Int.zwordsize.","conclusion":"m * n / two_p 32 = n * m / two_p Int.zwordsize","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"f_equal.\nring."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : m * n = n * m.","conclusion":"m * n = n * m","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"ring."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.min_signed <= n * m / Int.modulus < Int.half_modulus ->\nInt.min_signed <= n * m / Int.modulus <= Int.max_signed.","conclusion":"Int.min_signed <= n * m / Int.modulus < Int.half_modulus ->\nInt.min_signed <= n * m / Int.modulus <= Int.max_signed","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.min_signed <= 0.","conclusion":"Int.min_signed <= 0","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"generalize Int.min_signed_neg; lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.half_modulus > 0.","conclusion":"Int.half_modulus > 0","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Int.half_modulus_pos."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.modulus > 0.","conclusion":"Int.modulus > 0","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Int.modulus_pos."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.min_signed * Int.modulus <= Int.min_signed * m.","conclusion":"Int.min_signed * Int.modulus <= Int.min_signed * m","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Z.mul_le_mono_nonpos_l.\ngeneralize Int.min_signed_neg; lia.\nlia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.min_signed <= 0.","conclusion":"Int.min_signed <= 0","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"generalize Int.min_signed_neg; lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : m <= Int.modulus.","conclusion":"m <= Int.modulus","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"tauto."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.half_modulus * m < Int.half_modulus * Int.modulus.","conclusion":"Int.half_modulus * m < Int.half_modulus * Int.modulus","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Zmult_lt_compat_l.\ngeneralize Int.half_modulus_pos; lia.\ntauto."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 < Int.half_modulus.","conclusion":"0 < Int.half_modulus","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"generalize Int.half_modulus_pos; lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : m < Int.modulus.","conclusion":"m < Int.modulus","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"tauto."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"assert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) (H0 : 32 < Int.max_unsigned) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) (H0 : 32 < Int.max_unsigned)","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.eqm (if zlt n 0 then 1 else 0)\n  (Int.unsigned\n     (if if zlt n (Int.signed Int.zero) then true else false\n      then Int.one\n      else Int.zero)).","conclusion":"Int.eqm (if zlt n 0 then 1 else 0)\n  (Int.unsigned\n     (if if zlt n (Int.signed Int.zero) then true else false\n      then Int.one\n      else Int.zero))","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"rewrite Int.signed_zero.\ndestruct (zlt n 0); apply Int.eqm_unsigned_repr."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : Int.eqm (if zlt n 0 then 1 else 0)\n  (Int.unsigned\n     (if if zlt n 0 then true else false then Int.one else Int.zero)).","conclusion":"Int.eqm (if zlt n 0 then 1 else 0)\n  (Int.unsigned\n     (if if zlt n 0 then true else false then Int.one else Int.zero))","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"destruct (zlt n 0); apply Int.eqm_unsigned_repr."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : two_p 32 > 0.","conclusion":"two_p 32 > 0","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply two_p_gt_ZERO.\nlia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= 32.","conclusion":"0 <= 32","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : two_p p > 0.","conclusion":"two_p p > 0","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply two_p_gt_ZERO.\nlia."},{"statement":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= p.","conclusion":"0 <= p","hypotheses":"(x y : int) (m p : Z) (d : Z) (H : divs_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n0 : Z,\nInt.min_signed <= n0 <= Int.max_signed ->\nn0  d = m * n0 / two_p (32 + p) + (if zlt n0 0 then 1 else 0))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) : 0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus)","proofString":"exploit divs_mul_shift_gen; eauto.\ninstantiate (1 := x).\nintros (A & B & C).\nsplit.\nauto.\nrewrite C.\nunfold Int.mulhs.\nrewrite Int.signed_repr.\nauto.\ngeneralize Int.min_signed_neg; unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) : 0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus)","proofString":"intros (A & B & C).\nsplit.\nauto.\nrewrite C.\nunfold Int.mulhs.\nrewrite Int.signed_repr.\nauto.\ngeneralize Int.min_signed_neg; unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : 0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"split.\nauto.\nrewrite C.\nunfold Int.mulhs.\nrewrite Int.signed_repr.\nauto.\ngeneralize Int.min_signed_neg; unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : 0 <= p < 32.","conclusion":"0 <= p < 32","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"auto."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"rewrite C.\nunfold Int.mulhs.\nrewrite Int.signed_repr.\nauto.\ngeneralize Int.min_signed_neg; unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add (Int.shr (Int.mulhs x (Int.repr m)) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"unfold Int.mulhs.\nrewrite Int.signed_repr.\nauto.\ngeneralize Int.min_signed_neg; unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add\n  (Int.shr (Int.repr (Int.signed x * Int.signed (Int.repr m) / Int.modulus))\n     (Int.repr p)) (Int.shru x (Int.repr 31)).","conclusion":"Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add\n  (Int.shr (Int.repr (Int.signed x * Int.signed (Int.repr m) / Int.modulus))\n     (Int.repr p)) (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"rewrite Int.signed_repr.\nauto.\ngeneralize Int.min_signed_neg; unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"auto."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.min_signed <= m <= Int.max_signed.","conclusion":"Int.min_signed <= m <= Int.max_signed","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m < Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"generalize Int.min_signed_neg; unfold Int.max_signed; lia."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) : 0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus)","proofString":"exploit divs_mul_shift_gen; eauto.\ninstantiate (1 := x).\nintros (A & B & C).\nsplit.\nauto.\nrewrite C.\nf_equal.\nf_equal.\nrewrite Int.add_signed.\nunfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) : 0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\n0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus)","proofString":"intros (A & B & C).\nsplit.\nauto.\nrewrite C.\nf_equal.\nf_equal.\nrewrite Int.add_signed.\nunfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : 0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"split.\nauto.\nrewrite C.\nf_equal.\nf_equal.\nrewrite Int.add_signed.\nunfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : 0 <= p < 32.","conclusion":"0 <= p < 32","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"auto."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"rewrite C.\nf_equal.\nf_equal.\nrewrite Int.add_signed.\nunfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)).","conclusion":"Int.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"f_equal.\nf_equal.\nrewrite Int.add_signed.\nunfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p) =\nInt.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p).","conclusion":"Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p) =\nInt.shr (Int.add (Int.mulhs x (Int.repr m)) x) (Int.repr p)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"f_equal.\nrewrite Int.add_signed.\nunfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.repr (Int.signed x * m / Int.modulus) =\nInt.add (Int.mulhs x (Int.repr m)) x.","conclusion":"Int.repr (Int.signed x * m / Int.modulus) =\nInt.add (Int.mulhs x (Int.repr m)) x","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"rewrite Int.add_signed.\nunfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.repr (Int.signed x * m / Int.modulus) =\nInt.repr (Int.signed (Int.mulhs x (Int.repr m)) + Int.signed x).","conclusion":"Int.repr (Int.signed x * m / Int.modulus) =\nInt.repr (Int.signed (Int.mulhs x (Int.repr m)) + Int.signed x)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"unfold Int.mulhs.\nset (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : Int.repr (Int.signed x * m / Int.modulus) =\nInt.repr\n  (Int.signed\n     (Int.repr (Int.signed x * Int.signed (Int.repr m) / Int.modulus)) +\n   Int.signed x).","conclusion":"Int.repr (Int.signed x * m / Int.modulus) =\nInt.repr\n  (Int.signed\n     (Int.repr (Int.signed x * Int.signed (Int.repr m) / Int.modulus)) +\n   Int.signed x)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"set (n := Int.signed x).\ntransitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.repr (n * m / Int.modulus) =\nInt.repr\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)) + n).","conclusion":"Int.repr (n * m / Int.modulus) =\nInt.repr\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)) + n)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"transitivity (Int.repr (n * (m - Int.modulus) / Int.modulus + n)).\napply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos.\napply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.repr (n * m / Int.modulus) =\nInt.repr (n * (m - Int.modulus) / Int.modulus + n).","conclusion":"Int.repr (n * m / Int.modulus) =\nInt.repr (n * (m - Int.modulus) / Int.modulus + n)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply f_equal.\nreplace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : n * m / Int.modulus = n * (m - Int.modulus) / Int.modulus + n.","conclusion":"n * m / Int.modulus = n * (m - Int.modulus) / Int.modulus + n","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"replace (n * (m - Int.modulus)) with (n * m +  (-n) * Int.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int.modulus_pos."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : n * m / Int.modulus = (n * m + - n * Int.modulus) / Int.modulus + n.","conclusion":"n * m / Int.modulus = (n * m + - n * Int.modulus) / Int.modulus + n","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"rewrite Z_div_plus.\nring.\napply Int.modulus_pos."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : n * m / Int.modulus = n * m / Int.modulus + - n + n.","conclusion":"n * m / Int.modulus = n * m / Int.modulus + - n + n","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"ring."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.modulus > 0.","conclusion":"Int.modulus > 0","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply Int.modulus_pos."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.repr (n * (m - Int.modulus) / Int.modulus + n) =\nInt.repr\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)) + n).","conclusion":"Int.repr (n * (m - Int.modulus) / Int.modulus + n) =\nInt.repr\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)) + n)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply Int.eqm_samerepr.\napply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.eqm (n * (m - Int.modulus) / Int.modulus + n)\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)) + n).","conclusion":"Int.eqm (n * (m - Int.modulus) / Int.modulus + n)\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)) + n)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply Int.eqm_add; auto with ints.\napply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.eqm (n * (m - Int.modulus) / Int.modulus)\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus))).","conclusion":"Int.eqm (n * (m - Int.modulus) / Int.modulus)\n  (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)))","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply Int.eqm_sym.\neapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.eqm (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)))\n  (n * (m - Int.modulus) / Int.modulus).","conclusion":"Int.eqm (Int.signed (Int.repr (n * Int.signed (Int.repr m) / Int.modulus)))\n  (n * (m - Int.modulus) / Int.modulus)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"eapply Int.eqm_trans.\napply Int.eqm_signed_unsigned.\napply Int.eqm_unsigned_repr_l.\napply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.eqm (n * Int.signed (Int.repr m) / Int.modulus)\n  (n * (m - Int.modulus) / Int.modulus).","conclusion":"Int.eqm (n * Int.signed (Int.repr m) / Int.modulus)\n  (n * (m - Int.modulus) / Int.modulus)","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply Int.eqm_refl2.\napply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : n * Int.signed (Int.repr m) / Int.modulus =\nn * (m - Int.modulus) / Int.modulus.","conclusion":"n * Int.signed (Int.repr m) / Int.modulus =\nn * (m - Int.modulus) / Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply (f_equal (fun x => n * x / Int.modulus)).\nrewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : Int.signed (Int.repr m) = m - Int.modulus.","conclusion":"Int.signed (Int.repr m) = m - Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"rewrite Int.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : (if zlt (m mod Int.modulus) Int.half_modulus\n then m mod Int.modulus\n else m mod Int.modulus - Int.modulus) = m - Int.modulus.","conclusion":"(if zlt (m mod Int.modulus) Int.half_modulus\n then m mod Int.modulus\n else m mod Int.modulus - Int.modulus) = m - Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"rewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : (if zlt m Int.half_modulus then m else m - Int.modulus) = m - Int.modulus.","conclusion":"(if zlt m Int.half_modulus then m else m - Int.modulus) = m - Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"apply zlt_false.\nassumption."},{"statement":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z) : m >= Int.half_modulus.","conclusion":"m >= Int.half_modulus","hypotheses":"(x y : int) (m p : Z) (H : divs_mul_params (Int.signed y) = Some (p, m)) (H0 : m >= Int.half_modulus) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : Int.divs x y =\nInt.add (Int.shr (Int.repr (Int.signed x * m / Int.modulus)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (n : Z)","proofString":"assumption."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) : 0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p).","conclusion":"0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p)","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m))","proofString":"exploit divu_mul_params_sound; eauto.\nintros (A & B & C).\nsplit.\nauto.\nrewrite Int.shru_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int.divu, Int.mulhu.\nf_equal.\nrewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) : 0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\n(forall n : Z,\n 0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) ->\n0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p).","conclusion":"0 <= m < Int.modulus /\\\n0 <= p < 32 /\\\n(forall n : Z,\n 0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) ->\n0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p)","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m))","proofString":"intros (A & B & C).\nsplit.\nauto.\nrewrite Int.shru_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int.divu, Int.mulhu.\nf_equal.\nrewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p).","conclusion":"0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p)","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"split.\nauto.\nrewrite Int.shru_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int.divu, Int.mulhu.\nf_equal.\nrewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= p < 32.","conclusion":"0 <= p < 32","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"auto."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p).","conclusion":"Int.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p)","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"rewrite Int.shru_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int.divu, Int.mulhu.\nf_equal.\nrewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.divu x y =\nInt.repr\n  (Int.unsigned (Int.mulhu x (Int.repr m)) /\n   two_p (Int.unsigned (Int.repr p))).","conclusion":"Int.divu x y =\nInt.repr\n  (Int.unsigned (Int.mulhu x (Int.repr m)) /\n   two_p (Int.unsigned (Int.repr p)))","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"rewrite Int.unsigned_repr.\nunfold Int.divu, Int.mulhu.\nf_equal.\nrewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.divu x y = Int.repr (Int.unsigned (Int.mulhu x (Int.repr m)) / two_p p).","conclusion":"Int.divu x y = Int.repr (Int.unsigned (Int.mulhu x (Int.repr m)) / two_p p)","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"unfold Int.divu, Int.mulhu.\nf_equal.\nrewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.repr (Int.unsigned x / Int.unsigned y) =\nInt.repr\n  (Int.unsigned\n     (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\n   two_p p).","conclusion":"Int.repr (Int.unsigned x / Int.unsigned y) =\nInt.repr\n  (Int.unsigned\n     (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\n   two_p p)","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"f_equal.\nrewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.unsigned x / Int.unsigned y =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p.","conclusion":"Int.unsigned x / Int.unsigned y =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"rewrite C by apply Int.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m * Int.unsigned x / two_p (32 + p) =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p.","conclusion":"m * Int.unsigned x / two_p (32 + p) =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"rewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m * Int.unsigned x / (two_p 32 * two_p p) =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p.","conclusion":"m * Int.unsigned x / (two_p 32 * two_p p) =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"rewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m * Int.unsigned x / two_p 32 / two_p p =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p.","conclusion":"m * Int.unsigned x / two_p 32 / two_p p =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)) /\ntwo_p p","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"f_equal.\nrewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m * Int.unsigned x / two_p 32 =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus)).","conclusion":"m * Int.unsigned x / two_p 32 =\nInt.unsigned\n  (Int.repr (Int.unsigned x * Int.unsigned (Int.repr m) / Int.modulus))","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"rewrite (Int.unsigned_repr m).\nrewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m * Int.unsigned x / two_p 32 =\nInt.unsigned (Int.repr (Int.unsigned x * m / Int.modulus)).","conclusion":"m * Int.unsigned x / two_p 32 =\nInt.unsigned (Int.repr (Int.unsigned x * m / Int.modulus))","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"rewrite Int.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m * Int.unsigned x / two_p 32 = Int.unsigned x * m / Int.modulus.","conclusion":"m * Int.unsigned x / two_p 32 = Int.unsigned x * m / Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"f_equal.\nring."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m * Int.unsigned x = Int.unsigned x * m.","conclusion":"m * Int.unsigned x = Int.unsigned x * m","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"ring."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= Int.unsigned x * m / Int.modulus <= Int.max_unsigned.","conclusion":"0 <= Int.unsigned x * m / Int.modulus <= Int.max_unsigned","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"cut (0 <= Int.unsigned x * m / Int.modulus < Int.modulus).\nunfold Int.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= Int.unsigned x * m / Int.modulus < Int.modulus ->\n0 <= Int.unsigned x * m / Int.modulus <= Int.max_unsigned.","conclusion":"0 <= Int.unsigned x * m / Int.modulus < Int.modulus ->\n0 <= Int.unsigned x * m / Int.modulus <= Int.max_unsigned","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"unfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= Int.unsigned x * m / Int.modulus < Int.modulus.","conclusion":"0 <= Int.unsigned x * m / Int.modulus < Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"apply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= 0.","conclusion":"0 <= 0","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.modulus > 0.","conclusion":"Int.modulus > 0","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"compute; auto."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.modulus > 0.","conclusion":"Int.modulus > 0","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"compute; auto."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 * Int.modulus <= Int.unsigned x * m < Int.modulus * Int.modulus.","conclusion":"0 * Int.modulus <= Int.unsigned x * m < Int.modulus * Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"split.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 * Int.modulus <= Int.unsigned x * m.","conclusion":"0 * Int.modulus <= Int.unsigned x * m","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"simpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= Int.unsigned x * m.","conclusion":"0 <= Int.unsigned x * m","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"apply Z.mul_nonneg_nonneg.\ngeneralize (Int.unsigned_range x); lia.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= Int.unsigned x.","conclusion":"0 <= Int.unsigned x","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"generalize (Int.unsigned_range x); lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.unsigned x * m < Int.modulus * Int.modulus.","conclusion":"Int.unsigned x * m < Int.modulus * Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"apply Z.le_lt_trans with (Int.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.unsigned x * m <= Int.modulus * m.","conclusion":"Int.unsigned x * m <= Int.modulus * m","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"apply Zmult_le_compat_r.\ngeneralize (Int.unsigned_range x); lia.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.unsigned x <= Int.modulus.","conclusion":"Int.unsigned x <= Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"generalize (Int.unsigned_range x); lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : Int.modulus * m < Int.modulus * Int.modulus.","conclusion":"Int.modulus * m < Int.modulus * Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"apply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 < Int.modulus.","conclusion":"0 < Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"compute; auto."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : m < Int.modulus.","conclusion":"m < Int.modulus","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= m <= Int.max_unsigned.","conclusion":"0 <= m <= Int.max_unsigned","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"unfold Int.max_unsigned; lia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p))","proofString":"assert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) (H0 : 32 < Int.max_unsigned) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int) (m p : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, m)) (A : 0 <= m < Int.modulus) (B : 0 <= p < 32) (C : forall n : Z,\n0 <= n < Int.modulus -> n / Int.unsigned y = m * n / two_p (32 + p)) (H0 : 32 < Int.max_unsigned)","proofString":"lia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') : 0 <= m' < Int64.modulus /\\\n0 <= p' < 64 /\\\n(forall n : Z,\n Int64.min_signed <= n <= Int64.max_signed ->\n n  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0)).","conclusion":"0 <= m' < Int64.modulus /\\\n0 <= p' < 64 /\\\n(forall n : Z,\n Int64.min_signed <= n <= Int64.max_signed ->\n n  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p')","proofString":"split.\nauto.\nsplit.\nauto.\nintros.\nreplace (64 + p') with (63 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (63 + (p' + 1)) with (64 + p') by lia.\nlia.\nchange (Int64.min_signed <= n < Int64.half_modulus).\nunfold Int64.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') : 0 <= m' < Int64.modulus.","conclusion":"0 <= m' < Int64.modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') : 0 <= p' < 64 /\\\n(forall n : Z,\n Int64.min_signed <= n <= Int64.max_signed ->\n n  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0)).","conclusion":"0 <= p' < 64 /\\\n(forall n : Z,\n Int64.min_signed <= n <= Int64.max_signed ->\n n  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p')","proofString":"split.\nauto.\nintros.\nreplace (64 + p') with (63 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (63 + (p' + 1)) with (64 + p') by lia.\nlia.\nchange (Int64.min_signed <= n < Int64.half_modulus).\nunfold Int64.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') : 0 <= p' < 64.","conclusion":"0 <= p' < 64","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') : forall n : Z,\nInt64.min_signed <= n <= Int64.max_signed ->\nn  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0).","conclusion":"forall n : Z,\nInt64.min_signed <= n <= Int64.max_signed ->\nn  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p')","proofString":"intros.\nreplace (64 + p') with (63 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (63 + (p' + 1)) with (64 + p') by lia.\nlia.\nchange (Int64.min_signed <= n < Int64.half_modulus).\nunfold Int64.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed) : n  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0).","conclusion":"n  d = m' * n / two_p (64 + p') + (if zlt n 0 then 1 else 0)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed)","proofString":"replace (64 + p') with (63 + (p' + 1)) by lia.\napply Zquot_mul; try lia.\nreplace (63 + (p' + 1)) with (64 + p') by lia.\nlia.\nchange (Int64.min_signed <= n < Int64.half_modulus).\nunfold Int64.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed) : n  d = m' * n / two_p (63 + (p' + 1)) + (if zlt n 0 then 1 else 0).","conclusion":"n  d = m' * n / two_p (63 + (p' + 1)) + (if zlt n 0 then 1 else 0)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed)","proofString":"apply Zquot_mul; try lia.\nreplace (63 + (p' + 1)) with (64 + p') by lia.\nlia.\nchange (Int64.min_signed <= n < Int64.half_modulus).\nunfold Int64.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed) : two_p (63 + (p' + 1)) < m' * d <= two_p (63 + (p' + 1)) + two_p (p' + 1).","conclusion":"two_p (63 + (p' + 1)) < m' * d <= two_p (63 + (p' + 1)) + two_p (p' + 1)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed)","proofString":"replace (63 + (p' + 1)) with (64 + p') by lia.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed) : two_p (64 + p') < m' * d <= two_p (64 + p') + two_p (p' + 1).","conclusion":"two_p (64 + p') < m' * d <= two_p (64 + p') + two_p (p' + 1)","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed)","proofString":"lia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed) : - two_p 63 <= n < two_p 63.","conclusion":"- two_p 63 <= n < two_p 63","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed)","proofString":"change (Int64.min_signed <= n < Int64.half_modulus).\nunfold Int64.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed) : Int64.min_signed <= n < Int64.half_modulus.","conclusion":"Int64.min_signed <= n < Int64.half_modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.max_signed)","proofString":"unfold Int64.max_signed in H.\nlia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.half_modulus - 1) : Int64.min_signed <= n < Int64.half_modulus.","conclusion":"Int64.min_signed <= n < Int64.half_modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') < m' * d) (l1 : m' * d <= two_p (64 + p') + two_p (p' + 1)) (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : Int64.min_signed <= n <= Int64.half_modulus - 1)","proofString":"lia."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') : 0 <= m' < Int64.modulus /\\\n0 <= p' < 64 /\\\n(forall n : Z, 0 <= n < Int64.modulus -> n / d = m' * n / two_p (64 + p')).","conclusion":"0 <= m' < Int64.modulus /\\\n0 <= p' < 64 /\\\n(forall n : Z, 0 <= n < Int64.modulus -> n / d = m' * n / two_p (64 + p'))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p')","proofString":"split.\nauto.\nsplit.\nauto.\nintros.\napply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') : 0 <= m' < Int64.modulus.","conclusion":"0 <= m' < Int64.modulus","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') : 0 <= p' < 64 /\\\n(forall n : Z, 0 <= n < Int64.modulus -> n / d = m' * n / two_p (64 + p')).","conclusion":"0 <= p' < 64 /\\\n(forall n : Z, 0 <= n < Int64.modulus -> n / d = m' * n / two_p (64 + p'))","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p')","proofString":"split.\nauto.\nintros.\napply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') : 0 <= p' < 64.","conclusion":"0 <= p' < 64","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p')","proofString":"auto."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') : forall n : Z, 0 <= n < Int64.modulus -> n / d = m' * n / two_p (64 + p').","conclusion":"forall n : Z, 0 <= n < Int64.modulus -> n / d = m' * n / two_p (64 + p')","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p')","proofString":"intros.\napply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int64.modulus) : n / d = m' * n / two_p (64 + p').","conclusion":"n / d = m' * n / two_p (64 + p')","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int64.modulus)","proofString":"apply Zdiv_mul_pos; try lia.\nassumption."},{"statement":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int64.modulus) : 0 <= n < two_p 64.","conclusion":"0 <= n < two_p 64","hypotheses":"(d m' p' p : Z) (l : 0 < d) (l3 : m' < Int64.modulus) (l2 : 0 <= m') (l0 : two_p (64 + p') <= m' * d) (l1 : m' * d <= two_p (64 + p') + two_p p') (l5 : p' < 64) (l4 : 0 <= p') (n : Z) (H : 0 <= n < Int64.modulus)","proofString":"assumption."},{"statement":"(x : int64) (y : int) : Int64.repr (Z.shiftr (Int64.signed x) (Int.unsigned y)) =\nInt64.repr (Int64.signed x / two_p (Int.unsigned y)).","conclusion":"Int64.repr (Z.shiftr (Int64.signed x) (Int.unsigned y)) =\nInt64.repr (Int64.signed x / two_p (Int.unsigned y))","hypotheses":"(x : int64) (y : int)","proofString":"rewrite Zshiftr_div_two_p; auto.\ngeneralize (Int.unsigned_range y); lia."},{"statement":"(x : int64) (y : int) : 0 <= Int.unsigned y.","conclusion":"0 <= Int.unsigned y","hypotheses":"(x : int64) (y : int)","proofString":"generalize (Int.unsigned_range y); lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) : 0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)).","conclusion":"0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m))","proofString":"set (n := Int64.signed x).\nset (d := Int64.signed y) in *.\nexploit divls_mul_params_sound; eauto.\nintros (A & B & C).\nsplit.\nauto.\nsplit.\nauto.\nunfold Int64.divs.\nfold n; fold d.\nrewrite C by (apply Int64.signed_range).\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv.\nrewrite Int64.shru_lt_zero.\nunfold Int64.add.\napply Int64.eqm_samerepr.\napply Int64.eqm_add.\nrewrite int64_shr'_div_two_p.\napply Int64.eqm_unsigned_repr_r.\napply Int64.eqm_refl2.\nrewrite Int.unsigned_repr.\nf_equal.\nrewrite Int64.signed_repr.\nrewrite Int64.modulus_power.\nf_equal.\nring.\ncut (Int64.min_signed <= n * m / Int64.modulus < Int64.half_modulus).\nunfold Int64.max_signed; lia.\napply Zdiv_interval_1.\ngeneralize Int64.min_signed_neg; lia.\napply Int64.half_modulus_pos.\napply Int64.modulus_pos.\nsplit.\napply Z.le_trans with (Int64.min_signed * m).\napply Z.mul_le_mono_nonpos_l.\ngeneralize Int64.min_signed_neg; lia.\nlia.\napply Z.mul_le_mono_nonneg_r.\ntauto.\nunfold n; generalize (Int64.signed_range x); tauto.\napply Z.le_lt_trans with (Int64.half_modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.signed_range x); unfold n, Int64.max_signed; lia.\ntauto.\napply Zmult_lt_compat_l.\ngeneralize Int64.half_modulus_pos; lia.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nunfold Int64.lt; fold n.\nrewrite Int64.signed_zero.\ndestruct (zlt n 0); apply Int64.eqm_unsigned_repr.\napply two_p_gt_ZERO.\nlia.\napply two_p_gt_ZERO.\nlia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= m < Int64.modulus.","conclusion":"0 <= m < Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"auto."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= p < 64.","conclusion":"0 <= p < 64","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"auto."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : m * n / two_p 64 = n * m / Int64.modulus.","conclusion":"m * n / two_p 64 = n * m / Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"rewrite Int64.modulus_power.\nf_equal.\nring."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : m * n / two_p 64 = n * m / two_p Int64.zwordsize.","conclusion":"m * n / two_p 64 = n * m / two_p Int64.zwordsize","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"f_equal.\nring."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : m * n = n * m.","conclusion":"m * n = n * m","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"ring."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.min_signed <= n * m / Int64.modulus < Int64.half_modulus ->\nInt64.min_signed <= n * m / Int64.modulus <= Int64.max_signed.","conclusion":"Int64.min_signed <= n * m / Int64.modulus < Int64.half_modulus ->\nInt64.min_signed <= n * m / Int64.modulus <= Int64.max_signed","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.min_signed <= 0.","conclusion":"Int64.min_signed <= 0","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"generalize Int64.min_signed_neg; lia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.half_modulus > 0.","conclusion":"Int64.half_modulus > 0","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Int64.half_modulus_pos."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.modulus > 0.","conclusion":"Int64.modulus > 0","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Int64.modulus_pos."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.min_signed * Int64.modulus <= Int64.min_signed * m.","conclusion":"Int64.min_signed * Int64.modulus <= Int64.min_signed * m","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Z.mul_le_mono_nonpos_l.\ngeneralize Int64.min_signed_neg; lia.\nlia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.min_signed <= 0.","conclusion":"Int64.min_signed <= 0","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"generalize Int64.min_signed_neg; lia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : m <= Int64.modulus.","conclusion":"m <= Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"tauto."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"tauto."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.half_modulus * m < Int64.half_modulus * Int64.modulus.","conclusion":"Int64.half_modulus * m < Int64.half_modulus * Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply Zmult_lt_compat_l.\ngeneralize Int64.half_modulus_pos; lia.\ntauto."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 < Int64.half_modulus.","conclusion":"0 < Int64.half_modulus","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"generalize Int64.half_modulus_pos; lia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : m < Int64.modulus.","conclusion":"m < Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"tauto."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"assert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) (H0 : 64 < Int.max_unsigned) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) (H0 : 64 < Int.max_unsigned)","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.eqm (if zlt n 0 then 1 else 0)\n  (Int64.unsigned\n     (if if zlt n (Int64.signed Int64.zero) then true else false\n      then Int64.one\n      else Int64.zero)).","conclusion":"Int64.eqm (if zlt n 0 then 1 else 0)\n  (Int64.unsigned\n     (if if zlt n (Int64.signed Int64.zero) then true else false\n      then Int64.one\n      else Int64.zero))","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"rewrite Int64.signed_zero.\ndestruct (zlt n 0); apply Int64.eqm_unsigned_repr."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : Int64.eqm (if zlt n 0 then 1 else 0)\n  (Int64.unsigned\n     (if if zlt n 0 then true else false then Int64.one else Int64.zero)).","conclusion":"Int64.eqm (if zlt n 0 then 1 else 0)\n  (Int64.unsigned\n     (if if zlt n 0 then true else false then Int64.one else Int64.zero))","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"destruct (zlt n 0); apply Int64.eqm_unsigned_repr."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : two_p 64 > 0.","conclusion":"two_p 64 > 0","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply two_p_gt_ZERO.\nlia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= 64.","conclusion":"0 <= 64","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : two_p p > 0.","conclusion":"two_p p > 0","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"apply two_p_gt_ZERO.\nlia."},{"statement":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0)) : 0 <= p.","conclusion":"0 <= p","hypotheses":"(x y : int64) (m p : Z) (d : Z) (H : divls_mul_params d = Some (p, m)) (n : Z) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n0 : Z,\nInt64.min_signed <= n0 <= Int64.max_signed ->\nn0  d = m * n0 / two_p (64 + p) + (if zlt n0 0 then 1 else 0))","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) : 0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus)","proofString":"exploit divls_mul_shift_gen; eauto.\ninstantiate (1 := x).\nintros (A & B & C).\nsplit.\nauto.\nrewrite C.\nunfold Int64.mulhs.\nrewrite Int64.signed_repr.\nauto.\ngeneralize Int64.min_signed_neg; unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) : 0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) ->\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) ->\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus)","proofString":"intros (A & B & C).\nsplit.\nauto.\nrewrite C.\nunfold Int64.mulhs.\nrewrite Int64.signed_repr.\nauto.\ngeneralize Int64.min_signed_neg; unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : 0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"split.\nauto.\nrewrite C.\nunfold Int64.mulhs.\nrewrite Int64.signed_repr.\nauto.\ngeneralize Int64.min_signed_neg; unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : 0 <= p < 64.","conclusion":"0 <= p < 64","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"auto."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"Int64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"rewrite C.\nunfold Int64.mulhs.\nrewrite Int64.signed_repr.\nauto.\ngeneralize Int64.min_signed_neg; unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr m)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"unfold Int64.mulhs.\nrewrite Int64.signed_repr.\nauto.\ngeneralize Int64.min_signed_neg; unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add\n  (Int64.shr'\n     (Int64.repr\n        (Int64.signed x * Int64.signed (Int64.repr m) / Int64.modulus))\n     (Int.repr p)) (Int64.shru' x (Int.repr 63)).","conclusion":"Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add\n  (Int64.shr'\n     (Int64.repr\n        (Int64.signed x * Int64.signed (Int64.repr m) / Int64.modulus))\n     (Int.repr p)) (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"rewrite Int64.signed_repr.\nauto.\ngeneralize Int64.min_signed_neg; unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"auto."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.min_signed <= m <= Int64.max_signed.","conclusion":"Int64.min_signed <= m <= Int64.max_signed","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m < Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"generalize Int64.min_signed_neg; unfold Int64.max_signed; lia."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) : 0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus)","proofString":"exploit divls_mul_shift_gen; eauto.\ninstantiate (1 := x).\nintros (A & B & C).\nsplit.\nauto.\nrewrite C.\nf_equal.\nf_equal.\nrewrite Int64.add_signed.\nunfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) : 0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) ->\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) ->\n0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus)","proofString":"intros (A & B & C).\nsplit.\nauto.\nrewrite C.\nf_equal.\nf_equal.\nrewrite Int64.add_signed.\nunfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : 0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"0 <= p < 64 /\\\nInt64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"split.\nauto.\nrewrite C.\nf_equal.\nf_equal.\nrewrite Int64.add_signed.\nunfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : 0 <= p < 64.","conclusion":"0 <= p < 64","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"auto."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"rewrite C.\nf_equal.\nf_equal.\nrewrite Int64.add_signed.\nunfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)).","conclusion":"Int64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)) =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"f_equal.\nf_equal.\nrewrite Int64.add_signed.\nunfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p) =\nInt64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p).","conclusion":"Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p) =\nInt64.shr' (Int64.add (Int64.mulhs x (Int64.repr m)) x) (Int.repr p)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"f_equal.\nrewrite Int64.add_signed.\nunfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.repr (Int64.signed x * m / Int64.modulus) =\nInt64.add (Int64.mulhs x (Int64.repr m)) x.","conclusion":"Int64.repr (Int64.signed x * m / Int64.modulus) =\nInt64.add (Int64.mulhs x (Int64.repr m)) x","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"rewrite Int64.add_signed.\nunfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.repr (Int64.signed x * m / Int64.modulus) =\nInt64.repr (Int64.signed (Int64.mulhs x (Int64.repr m)) + Int64.signed x).","conclusion":"Int64.repr (Int64.signed x * m / Int64.modulus) =\nInt64.repr (Int64.signed (Int64.mulhs x (Int64.repr m)) + Int64.signed x)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"unfold Int64.mulhs.\nset (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) : Int64.repr (Int64.signed x * m / Int64.modulus) =\nInt64.repr\n  (Int64.signed\n     (Int64.repr\n        (Int64.signed x * Int64.signed (Int64.repr m) / Int64.modulus)) +\n   Int64.signed x).","conclusion":"Int64.repr (Int64.signed x * m / Int64.modulus) =\nInt64.repr\n  (Int64.signed\n     (Int64.repr\n        (Int64.signed x * Int64.signed (Int64.repr m) / Int64.modulus)) +\n   Int64.signed x)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63)))","proofString":"set (n := Int64.signed x).\ntransitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.repr (n * m / Int64.modulus) =\nInt64.repr\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)) + n).","conclusion":"Int64.repr (n * m / Int64.modulus) =\nInt64.repr\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)) + n)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"transitivity (Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n)).\napply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos.\napply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.repr (n * m / Int64.modulus) =\nInt64.repr (n * (m - Int64.modulus) / Int64.modulus + n).","conclusion":"Int64.repr (n * m / Int64.modulus) =\nInt64.repr (n * (m - Int64.modulus) / Int64.modulus + n)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply f_equal.\nreplace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : n * m / Int64.modulus = n * (m - Int64.modulus) / Int64.modulus + n.","conclusion":"n * m / Int64.modulus = n * (m - Int64.modulus) / Int64.modulus + n","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"replace (n * (m - Int64.modulus)) with (n * m +  (-n) * Int64.modulus) by ring.\nrewrite Z_div_plus.\nring.\napply Int64.modulus_pos."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : n * m / Int64.modulus = (n * m + - n * Int64.modulus) / Int64.modulus + n.","conclusion":"n * m / Int64.modulus = (n * m + - n * Int64.modulus) / Int64.modulus + n","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"rewrite Z_div_plus.\nring.\napply Int64.modulus_pos."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : n * m / Int64.modulus = n * m / Int64.modulus + - n + n.","conclusion":"n * m / Int64.modulus = n * m / Int64.modulus + - n + n","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"ring."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.modulus > 0.","conclusion":"Int64.modulus > 0","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply Int64.modulus_pos."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n) =\nInt64.repr\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)) + n).","conclusion":"Int64.repr (n * (m - Int64.modulus) / Int64.modulus + n) =\nInt64.repr\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)) + n)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply Int64.eqm_samerepr.\napply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.eqm (n * (m - Int64.modulus) / Int64.modulus + n)\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)) + n).","conclusion":"Int64.eqm (n * (m - Int64.modulus) / Int64.modulus + n)\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)) + n)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply Int64.eqm_add; auto with ints.\napply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.eqm (n * (m - Int64.modulus) / Int64.modulus)\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus))).","conclusion":"Int64.eqm (n * (m - Int64.modulus) / Int64.modulus)\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)))","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply Int64.eqm_sym.\neapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.eqm\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)))\n  (n * (m - Int64.modulus) / Int64.modulus).","conclusion":"Int64.eqm\n  (Int64.signed\n     (Int64.repr (n * Int64.signed (Int64.repr m) / Int64.modulus)))\n  (n * (m - Int64.modulus) / Int64.modulus)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"eapply Int64.eqm_trans.\napply Int64.eqm_signed_unsigned.\napply Int64.eqm_unsigned_repr_l.\napply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.eqm (n * Int64.signed (Int64.repr m) / Int64.modulus)\n  (n * (m - Int64.modulus) / Int64.modulus).","conclusion":"Int64.eqm (n * Int64.signed (Int64.repr m) / Int64.modulus)\n  (n * (m - Int64.modulus) / Int64.modulus)","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply Int64.eqm_refl2.\napply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : n * Int64.signed (Int64.repr m) / Int64.modulus =\nn * (m - Int64.modulus) / Int64.modulus.","conclusion":"n * Int64.signed (Int64.repr m) / Int64.modulus =\nn * (m - Int64.modulus) / Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply (f_equal (fun x => n * x / Int64.modulus)).\nrewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : Int64.signed (Int64.repr m) = m - Int64.modulus.","conclusion":"Int64.signed (Int64.repr m) = m - Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"rewrite Int64.signed_repr_eq.\nrewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : (if zlt (m mod Int64.modulus) Int64.half_modulus\n then m mod Int64.modulus\n else m mod Int64.modulus - Int64.modulus) = m - Int64.modulus.","conclusion":"(if zlt (m mod Int64.modulus) Int64.half_modulus\n then m mod Int64.modulus\n else m mod Int64.modulus - Int64.modulus) = m - Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"rewrite Z.mod_small by assumption.\napply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : (if zlt m Int64.half_modulus then m else m - Int64.modulus) =\nm - Int64.modulus.","conclusion":"(if zlt m Int64.half_modulus then m else m - Int64.modulus) =\nm - Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"apply zlt_false.\nassumption."},{"statement":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z) : m >= Int64.half_modulus.","conclusion":"m >= Int64.half_modulus","hypotheses":"(x y : int64) (m p : Z) (H : divls_mul_params (Int64.signed y) = Some (p, m)) (H0 : m >= Int64.half_modulus) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.repr (Int64.signed x * m / Int64.modulus)) (Int.repr p))\n  (Int64.shru x (Int64.repr 63))) (n : Z)","proofString":"assumption."},{"statement":"(x : int64) (y : int) : Int64.repr (Z.shiftr (Int64.unsigned x) (Int.unsigned y)) =\nInt64.repr (Int64.unsigned x / two_p (Int.unsigned y)).","conclusion":"Int64.repr (Z.shiftr (Int64.unsigned x) (Int.unsigned y)) =\nInt64.repr (Int64.unsigned x / two_p (Int.unsigned y))","hypotheses":"(x : int64) (y : int)","proofString":"rewrite Zshiftr_div_two_p; auto.\ngeneralize (Int.unsigned_range y); lia."},{"statement":"(x : int64) (y : int) : 0 <= Int.unsigned y.","conclusion":"0 <= Int.unsigned y","hypotheses":"(x : int64) (y : int)","proofString":"generalize (Int.unsigned_range y); lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) : 0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p).","conclusion":"0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p)","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m))","proofString":"exploit divlu_mul_params_sound; eauto.\nintros (A & B & C).\nsplit.\nauto.\nrewrite int64_shru'_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int64.divu, Int64.mulhu.\nf_equal.\nrewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) : 0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\n(forall n : Z,\n 0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) ->\n0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p).","conclusion":"0 <= m < Int64.modulus /\\\n0 <= p < 64 /\\\n(forall n : Z,\n 0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) ->\n0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p)","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m))","proofString":"intros (A & B & C).\nsplit.\nauto.\nrewrite int64_shru'_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int64.divu, Int64.mulhu.\nf_equal.\nrewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p).","conclusion":"0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p)","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"split.\nauto.\nrewrite int64_shru'_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int64.divu, Int64.mulhu.\nf_equal.\nrewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= p < 64.","conclusion":"0 <= p < 64","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"auto."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p).","conclusion":"Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr m)) (Int.repr p)","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"rewrite int64_shru'_div_two_p.\nrewrite Int.unsigned_repr.\nunfold Int64.divu, Int64.mulhu.\nf_equal.\nrewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.divu x y =\nInt64.repr\n  (Int64.unsigned (Int64.mulhu x (Int64.repr m)) /\n   two_p (Int.unsigned (Int.repr p))).","conclusion":"Int64.divu x y =\nInt64.repr\n  (Int64.unsigned (Int64.mulhu x (Int64.repr m)) /\n   two_p (Int.unsigned (Int.repr p)))","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"rewrite Int.unsigned_repr.\nunfold Int64.divu, Int64.mulhu.\nf_equal.\nrewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.divu x y =\nInt64.repr (Int64.unsigned (Int64.mulhu x (Int64.repr m)) / two_p p).","conclusion":"Int64.divu x y =\nInt64.repr (Int64.unsigned (Int64.mulhu x (Int64.repr m)) / two_p p)","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"unfold Int64.divu, Int64.mulhu.\nf_equal.\nrewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.repr (Int64.unsigned x / Int64.unsigned y) =\nInt64.repr\n  (Int64.unsigned\n     (Int64.repr\n        (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\n   two_p p).","conclusion":"Int64.repr (Int64.unsigned x / Int64.unsigned y) =\nInt64.repr\n  (Int64.unsigned\n     (Int64.repr\n        (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\n   two_p p)","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"f_equal.\nrewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.unsigned x / Int64.unsigned y =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p.","conclusion":"Int64.unsigned x / Int64.unsigned y =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"rewrite C by apply Int64.unsigned_range.\nrewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m * Int64.unsigned x / two_p (64 + p) =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p.","conclusion":"m * Int64.unsigned x / two_p (64 + p) =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"rewrite two_p_is_exp by lia.\nrewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m * Int64.unsigned x / (two_p 64 * two_p p) =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p.","conclusion":"m * Int64.unsigned x / (two_p 64 * two_p p) =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"rewrite <- Zdiv_Zdiv by (apply two_p_gt_ZERO; lia).\nf_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m * Int64.unsigned x / two_p 64 / two_p p =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p.","conclusion":"m * Int64.unsigned x / two_p 64 / two_p p =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)) /\ntwo_p p","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"f_equal.\nrewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m * Int64.unsigned x / two_p 64 =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus)).","conclusion":"m * Int64.unsigned x / two_p 64 =\nInt64.unsigned\n  (Int64.repr\n     (Int64.unsigned x * Int64.unsigned (Int64.repr m) / Int64.modulus))","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"rewrite (Int64.unsigned_repr m).\nrewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia.\nunfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m * Int64.unsigned x / two_p 64 =\nInt64.unsigned (Int64.repr (Int64.unsigned x * m / Int64.modulus)).","conclusion":"m * Int64.unsigned x / two_p 64 =\nInt64.unsigned (Int64.repr (Int64.unsigned x * m / Int64.modulus))","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"rewrite Int64.unsigned_repr.\nf_equal.\nring.\ncut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m * Int64.unsigned x / two_p 64 = Int64.unsigned x * m / Int64.modulus.","conclusion":"m * Int64.unsigned x / two_p 64 = Int64.unsigned x * m / Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"f_equal.\nring."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m * Int64.unsigned x = Int64.unsigned x * m.","conclusion":"m * Int64.unsigned x = Int64.unsigned x * m","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"ring."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= Int64.unsigned x * m / Int64.modulus <= Int64.max_unsigned.","conclusion":"0 <= Int64.unsigned x * m / Int64.modulus <= Int64.max_unsigned","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"cut (0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus).\nunfold Int64.max_unsigned; lia.\napply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus ->\n0 <= Int64.unsigned x * m / Int64.modulus <= Int64.max_unsigned.","conclusion":"0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus ->\n0 <= Int64.unsigned x * m / Int64.modulus <= Int64.max_unsigned","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"unfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus.","conclusion":"0 <= Int64.unsigned x * m / Int64.modulus < Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"apply Zdiv_interval_1.\nlia.\ncompute; auto.\ncompute; auto.\nsplit.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= 0.","conclusion":"0 <= 0","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.modulus > 0.","conclusion":"Int64.modulus > 0","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"compute; auto."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.modulus > 0.","conclusion":"Int64.modulus > 0","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"compute; auto."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 * Int64.modulus <= Int64.unsigned x * m < Int64.modulus * Int64.modulus.","conclusion":"0 * Int64.modulus <= Int64.unsigned x * m < Int64.modulus * Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"split.\nsimpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 * Int64.modulus <= Int64.unsigned x * m.","conclusion":"0 * Int64.modulus <= Int64.unsigned x * m","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"simpl.\napply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= Int64.unsigned x * m.","conclusion":"0 <= Int64.unsigned x * m","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"apply Z.mul_nonneg_nonneg.\ngeneralize (Int64.unsigned_range x); lia.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= Int64.unsigned x.","conclusion":"0 <= Int64.unsigned x","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"generalize (Int64.unsigned_range x); lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.unsigned x * m < Int64.modulus * Int64.modulus.","conclusion":"Int64.unsigned x * m < Int64.modulus * Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"apply Z.le_lt_trans with (Int64.modulus * m).\napply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia.\napply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.unsigned x * m <= Int64.modulus * m.","conclusion":"Int64.unsigned x * m <= Int64.modulus * m","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"apply Zmult_le_compat_r.\ngeneralize (Int64.unsigned_range x); lia.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.unsigned x <= Int64.modulus.","conclusion":"Int64.unsigned x <= Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"generalize (Int64.unsigned_range x); lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= m.","conclusion":"0 <= m","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : Int64.modulus * m < Int64.modulus * Int64.modulus.","conclusion":"Int64.modulus * m < Int64.modulus * Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"apply Zmult_lt_compat_l.\ncompute; auto.\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 < Int64.modulus.","conclusion":"0 < Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"compute; auto."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : m < Int64.modulus.","conclusion":"m < Int64.modulus","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= m <= Int64.max_unsigned.","conclusion":"0 <= m <= Int64.max_unsigned","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"unfold Int64.max_unsigned; lia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p))","proofString":"assert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) (H0 : 64 < Int.max_unsigned) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(x y : int64) (m p : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, m)) (A : 0 <= m < Int64.modulus) (B : 0 <= p < 64) (C : forall n : Z,\n0 <= n < Int64.modulus -> n / Int64.unsigned y = m * n / two_p (64 + p)) (H0 : 64 < Int.max_unsigned)","proofString":"lia."},{"statement":"(v : val) (n0 : int) (e0 : exprlist) (n : int) (le : letenv) (H : Some n0 = Some n) (H0 : eval_expr ge sp e m le (Eop (Ointconst n0) e0) v) : v = Vint n.","conclusion":"v = Vint n","hypotheses":"(v : val) (n0 : int) (e0 : exprlist) (n : int) (le : letenv) (H : Some n0 = Some n) (H0 : eval_expr ge sp e m le (Eop (Ointconst n0) e0) v)","proofString":"inv H.\ninv H0.\ndestruct vl; inv H5.\nauto."},{"statement":"(v : val) (e0 : exprlist) (n : int) (le : letenv) (H0 : eval_expr ge sp e m le (Eop (Ointconst n) e0) v) : v = Vint n.","conclusion":"v = Vint n","hypotheses":"(v : val) (e0 : exprlist) (n : int) (le : letenv) (H0 : eval_expr ge sp e m le (Eop (Ointconst n) e0) v)","proofString":"inv H0.\ndestruct vl; inv H5.\nauto."},{"statement":"(v : val) (e0 : exprlist) (n : int) (le : letenv) (vl : list val) (H3 : eval_exprlist ge sp e m le e0 vl) (H5 : eval_operation ge sp (Ointconst n) vl m = Some v) : v = Vint n.","conclusion":"v = Vint n","hypotheses":"(v : val) (e0 : exprlist) (n : int) (le : letenv) (vl : list val) (H3 : eval_exprlist ge sp e m le e0 vl) (H5 : eval_operation ge sp (Ointconst n) vl m = Some v)","proofString":"destruct vl; inv H5.\nauto."},{"statement":"(e0 : exprlist) (n : int) (le : letenv) (H3 : eval_exprlist ge sp e m le e0 nil) : Vint n = Vint n.","conclusion":"Vint n = Vint n","hypotheses":"(e0 : exprlist) (n : int) (le : letenv) (H3 : eval_exprlist ge sp e m le e0 nil)","proofString":"auto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) : eval_expr ge sp e m le (divu_mul p M) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le (divu_mul p M) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x))","proofString":"unfold divu_mul.\nexploit (divu_mul_shift x); eauto.\nintros [A B].\nassert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; eauto).\nassert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhu.\neexact C.\neexact D.\nintros (v & E & F).\nsimpl in F.\ninv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x))","proofString":"exploit (divu_mul_shift x); eauto.\nintros [A B].\nassert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; eauto).\nassert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhu.\neexact C.\neexact D.\nintros (v & E & F).\nsimpl in F.\ninv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) : 0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p) ->\neval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"0 <= p < 32 /\\\nInt.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p) ->\neval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x))","proofString":"intros [A B].\nassert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; eauto).\nassert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhu.\neexact C.\neexact D.\nintros (v & E & F).\nsimpl in F.\ninv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))","proofString":"assert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; eauto).\nassert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhu.\neexact C.\neexact D.\nintros (v & E & F).\nsimpl in F.\ninv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x))","proofString":"assert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhu.\neexact C.\neexact D.\nintros (v & E & F).\nsimpl in F.\ninv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M)))","proofString":"exploit eval_mulhu.\neexact C.\neexact D.\nintros (v & E & F).\nsimpl in F.\ninv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (v : val) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) v) (F : Val.lessdef (Val.mulhu (Vint x) (Vint (Int.repr M))) v) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (v : val) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) v) (F : Val.lessdef (Val.mulhu (Vint x) (Vint (Int.repr M))) v)","proofString":"simpl in F.\ninv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (v : val) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) v) (F : Val.lessdef (Vint (Int.mulhu x (Int.repr M))) v) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (v : val) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) v) (F : Val.lessdef (Vint (Int.mulhu x (Int.repr M))) v)","proofString":"inv F.\nexploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M))))","proofString":"exploit eval_shruimm.\neexact E.\ninstantiate (1 := Int.repr p).\nintros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) : (exists v : val,\n   eval_expr ge sp e m le\n     (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) v /\\\n   Val.lessdef\n     (Val.shru (Vint (Int.mulhu x (Int.repr M))) (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le\n     (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) v /\\\n   Val.lessdef\n     (Val.shru (Vint (Int.mulhu x (Int.repr M))) (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M))))","proofString":"intros [v [P Q]].\nsimpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef (Val.shru (Vint (Int.mulhu x (Int.repr M))) (Vint (Int.repr p)))\n  v) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef (Val.shru (Vint (Int.mulhu x (Int.repr M))) (Vint (Int.repr p)))\n  v)","proofString":"simpl in Q.\nreplace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v)","proofString":"replace (Int.ltu (Int.repr p) Int.iwordsize) with true in Q.\ninv Q.\nrewrite B.\nauto.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))) v) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))) v)","proofString":"inv Q.\nrewrite B.\nauto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)))) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.divu x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))))","proofString":"rewrite B.\nauto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)))) : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))).","conclusion":"eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))))","proofString":"auto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) : true = Int.ltu (Int.repr p) Int.iwordsize.","conclusion":"true = Int.ltu (Int.repr p) Int.iwordsize","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v)","proofString":"unfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) : true =\n(if zlt (Int.unsigned (Int.repr p)) (Int.unsigned Int.iwordsize)\n then true\n else false).","conclusion":"true =\n(if zlt (Int.unsigned (Int.repr p)) (Int.unsigned Int.iwordsize)\n then true\n else false)","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v)","proofString":"rewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) : true = (if zlt p (Int.unsigned Int.iwordsize) then true else false).","conclusion":"true = (if zlt p (Int.unsigned Int.iwordsize) then true else false)","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v)","proofString":"rewrite zlt_true; auto.\ntauto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) : p < Int.unsigned Int.iwordsize.","conclusion":"p < Int.unsigned Int.iwordsize","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v)","proofString":"tauto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v)","proofString":"assert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) (H1 : 32 < Int.max_unsigned) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divu_mul_params (Int.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (A : 0 <= p < 32) (B : Int.divu x y = Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (E : eval_expr ge sp e m le\n  (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhu x (Int.repr M)))) (v : val) (P : eval_expr ge sp e m le\n  (shruimm (mulhu (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v) (Q : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shru (Int.mulhu x (Int.repr M)) (Int.repr p))\n   else Vundef) v) (H1 : 32 < Int.max_unsigned)","proofString":"lia."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.divu x (Vint n2) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.divu x (Vint n2) = Some z)","proofString":"generalize H0; intros DIV.\ndestruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.divu_pow2 by eauto.\nreplace (Vint (Int.shru i l)) with (Val.shru (Vint i) (Vint l)).\napply eval_shruimm; auto.\nsimpl.\nerewrite Int.is_power2_range; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divu i n2)); split; auto.\neconstructor; eauto.\neapply eval_divu_mul; eauto.\neapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 DIV : Val.divu x (Vint n2) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 DIV : Val.divu x (Vint n2) = Some z)","proofString":"destruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.divu_pow2 by eauto.\nreplace (Vint (Int.shru i l)) with (Val.shru (Vint i) (Vint l)).\napply eval_shruimm; auto.\nsimpl.\nerewrite Int.is_power2_range; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divu i n2)); split; auto.\neconstructor; eauto.\neapply eval_divu_mul; eauto.\neapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some z) (DIV : (if Int.eq n2 Int.zero then None else Some (Vint (Int.divu i n2))) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some z) (DIV : (if Int.eq n2 Int.zero then None else Some (Vint (Int.divu i n2))) = Some z)","proofString":"destruct (Int.eq n2 Int.zero) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.divu_pow2 by eauto.\nreplace (Vint (Int.shru i l)) with (Val.shru (Vint i) (Vint l)).\napply eval_shruimm; auto.\nsimpl.\nerewrite Int.is_power2_range; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divu i n2)); split; auto.\neconstructor; eauto.\neapply eval_divu_mul; eauto.\neapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef (Vint (Int.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l => shruimm e1 l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (divu_mul p m0)\n         | None => divu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef (Vint (Int.divu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false)","proofString":"destruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.divu_pow2 by eauto.\nreplace (Vint (Int.shru i l)) with (Val.shru (Vint i) (Vint l)).\napply eval_shruimm; auto.\nsimpl.\nerewrite Int.is_power2_range; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divu i n2)); split; auto.\neconstructor; eauto.\neapply eval_divu_mul; eauto.\neapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (shruimm e1 l) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shruimm e1 l) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"erewrite Int.divu_pow2 by eauto.\nreplace (Vint (Int.shru i l)) with (Val.shru (Vint i) (Vint l)).\napply eval_shruimm; auto.\nsimpl.\nerewrite Int.is_power2_range; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (shruimm e1 l) v /\\\n  Val.lessdef (Vint (Int.shru i l)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shruimm e1 l) v /\\\n  Val.lessdef (Vint (Int.shru i l)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"replace (Vint (Int.shru i l)) with (Val.shru (Vint i) (Vint l)).\napply eval_shruimm; auto.\nsimpl.\nerewrite Int.is_power2_range; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (shruimm e1 l) v /\\\n  Val.lessdef (Val.shru (Vint i) (Vint l)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shruimm e1 l) v /\\\n  Val.lessdef (Val.shru (Vint i) (Vint l)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"apply eval_shruimm; auto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : Val.shru (Vint i) (Vint l) = Vint (Int.shru i l).","conclusion":"Val.shru (Vint i) (Vint l) = Vint (Int.shru i l)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"simpl.\nerewrite Int.is_power2_range; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : (if Int.ltu l Int.iwordsize then Vint (Int.shru i l) else Vundef) =\nVint (Int.shru i l).","conclusion":"(if Int.ltu l Int.iwordsize then Vint (Int.shru i l) else Vundef) =\nVint (Int.shru i l)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"erewrite Int.is_power2_range; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divu_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divu_mul_params (Int.unsigned n2) with\n      | Some (p, m0) => Elet e1 (divu_mul p m0)\n      | None => divu_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\ Val.lessdef (Vint (Int.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divu_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divu_mul_params (Int.unsigned n2) with\n      | Some (p, m0) => Elet e1 (divu_mul p m0)\n      | None => divu_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\ Val.lessdef (Vint (Int.divu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_divu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divu i n2)); split; auto.\neconstructor; eauto.\neapply eval_divu_mul; eauto.\neapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le (divu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (divu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"eapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divu_mul_params (Int.unsigned n2) with\n    | Some (p, m0) => Elet e1 (divu_mul p m0)\n    | None => divu_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\ Val.lessdef (Vint (Int.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divu_mul_params (Int.unsigned n2) with\n    | Some (p, m0) => Elet e1 (divu_mul p m0)\n    | None => divu_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\ Val.lessdef (Vint (Int.divu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divu i n2)); split; auto.\neconstructor; eauto.\neapply eval_divu_mul; eauto.\neapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet e1 (divu_mul p M)) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet e1 (divu_mul p M)) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M))","proofString":"exists (Vint (Int.divu i n2)); split; auto.\neconstructor; eauto.\neapply eval_divu_mul; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M)) : eval_expr ge sp e m le (Elet e1 (divu_mul p M)) (Vint (Int.divu i n2)).","conclusion":"eval_expr ge sp e m le (Elet e1 (divu_mul p M)) (Vint (Int.divu i n2))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M))","proofString":"econstructor; eauto.\neapply eval_divu_mul; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M)) : eval_expr ge sp e m (Vint i :: le) (divu_mul p M) (Vint (Int.divu i n2)).","conclusion":"eval_expr ge sp e m (Vint i :: le) (divu_mul p M) (Vint (Int.divu i n2))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M))","proofString":"eapply eval_divu_mul; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None) : exists v : val,\n  eval_expr ge sp e m le (divu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (divu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None)","proofString":"eapply eval_divu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divu (Vint i) (Vint n2) = Some (Vint (Int.divu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then divu_base a b\n            else Eop (Ointconst (Int.divu n1 n2)) Enil\n        | None => divuimm a n2\n        end\n    | None => divu_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then divu_base a b\n            else Eop (Ointconst (Int.divu n1 n2)) Enil\n        | None => divuimm a n2\n        end\n    | None => divu_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z)","proofString":"destruct (is_intconst b) as [n2|] eqn:B.\nexploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_divuimm; eauto.\neapply eval_divu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divu_base a b\n        else Eop (Ointconst (Int.divu n1 n2)) Enil\n    | None => divuimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divu_base a b\n        else Eop (Ointconst (Int.divu n1 n2)) Enil\n    | None => divuimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"exploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_divuimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divu_base a b\n        else Eop (Ointconst (Int.divu n1 n2)) Enil\n    | None => divuimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divu_base a b\n        else Eop (Ointconst (Int.divu n1 n2)) Enil\n    | None => divuimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"intros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_divuimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divu_base a b\n        else Eop (Ointconst (Int.divu n1 n2)) Enil\n    | None => divuimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divu_base a b\n        else Eop (Ointconst (Int.divu n1 n2)) Enil\n    | None => divuimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2)","proofString":"destruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_divuimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divu_base a b\n     else Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divu_base a b\n     else Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"exploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divu_base a b\n     else Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divu_base a b\n     else Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"intros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divu_base a b\n     else Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divu_base a b\n     else Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1)","proofString":"destruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true) : exists v : val, eval_expr ge sp e m le (divu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true)","proofString":"eapply eval_divu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false)","proofString":"subst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.divu (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.divu (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"simpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"rewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.divu n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divu n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.divu n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (divuimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divuimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None)","proofString":"subst.\neapply eval_divuimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.divu x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (divuimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divuimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.divu x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None)","proofString":"eapply eval_divuimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (B : is_intconst b = None) : exists v : val, eval_expr ge sp e m le (divu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) (B : is_intconst b = None)","proofString":"eapply eval_divu_base; eauto."},{"statement":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) : eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n))).","conclusion":"eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x))","proofString":"exploit eval_mulimm; eauto.\ninstantiate (1 := n).\nintros [v [A B]].\nsimpl in B.\ninv B.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) : (exists v : val,\n   eval_expr ge sp e m le (mulimm n a) v /\\\n   Val.lessdef (Val.mul (Vint y) (Vint n)) v) ->\neval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n))).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (mulimm n a) v /\\\n   Val.lessdef (Val.mul (Vint y) (Vint n)) v) ->\neval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x))","proofString":"intros [v [A B]].\nsimpl in B.\ninv B.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) (v : val) (A : eval_expr ge sp e m le (mulimm n a) v) (B : Val.lessdef (Val.mul (Vint y) (Vint n)) v) : eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n))).","conclusion":"eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) (v : val) (A : eval_expr ge sp e m le (mulimm n a) v) (B : Val.lessdef (Val.mul (Vint y) (Vint n)) v)","proofString":"simpl in B.\ninv B.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) (v : val) (A : eval_expr ge sp e m le (mulimm n a) v) (B : Val.lessdef (Vint (Int.mul y n)) v) : eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n))).","conclusion":"eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) (v : val) (A : eval_expr ge sp e m le (mulimm n a) v) (B : Val.lessdef (Vint (Int.mul y n)) v)","proofString":"inv B.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) (A : eval_expr ge sp e m le (mulimm n a) (Vint (Int.mul y n))) : eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n))).","conclusion":"eval_expr ge sp e m le (Eop Osub (Eletvar 0 ::: mulimm n a ::: Enil))\n  (Vint (Int.sub x (Int.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int) (H : eval_expr ge sp e m le a (Vint y)) (H0 : nth_error le 0 = Some (Vint x)) (A : eval_expr ge sp e m le (mulimm n a) (Vint (Int.mul y n)))","proofString":"EvalOp."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.modu x (Vint n2) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.modu x (Vint n2) = Some z)","proofString":"generalize H0; intros MOD.\ndestruct x; simpl in MOD; try discriminate.\ndestruct (Int.eq n2 Int.zero) eqn:Z2; inv MOD.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.modu_and by eauto.\nchange (Vint (Int.and i (Int.sub n2 Int.one)))    with (Val.and (Vint i) (Vint (Int.sub n2 Int.one))).\napply eval_andimm.\nauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor; eauto.\neapply eval_mod_from_div.\neapply eval_divu_mul; eauto.\nsimpl; eauto.\nsimpl; eauto.\nrewrite Int.modu_divu.\nauto.\nred; intros; subst n2; discriminate.\neapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 MOD : Val.modu x (Vint n2) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 MOD : Val.modu x (Vint n2) = Some z)","proofString":"destruct x; simpl in MOD; try discriminate.\ndestruct (Int.eq n2 Int.zero) eqn:Z2; inv MOD.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.modu_and by eauto.\nchange (Vint (Int.and i (Int.sub n2 Int.one)))    with (Val.and (Vint i) (Vint (Int.sub n2 Int.one))).\napply eval_andimm.\nauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor; eauto.\neapply eval_mod_from_div.\neapply eval_divu_mul; eauto.\nsimpl; eauto.\nsimpl; eauto.\nrewrite Int.modu_divu.\nauto.\nred; intros; subst n2; discriminate.\neapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some z) (MOD : (if Int.eq n2 Int.zero then None else Some (Vint (Int.modu i n2))) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some z) (MOD : (if Int.eq n2 Int.zero then None else Some (Vint (Int.modu i n2))) = Some z)","proofString":"destruct (Int.eq n2 Int.zero) eqn:Z2; inv MOD.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.modu_and by eauto.\nchange (Vint (Int.and i (Int.sub n2 Int.one)))    with (Val.and (Vint i) (Vint (Int.sub n2 Int.one))).\napply eval_andimm.\nauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor; eauto.\neapply eval_mod_from_div.\neapply eval_divu_mul; eauto.\nsimpl; eauto.\nsimpl; eauto.\nrewrite Int.modu_divu.\nauto.\nred; intros; subst n2; discriminate.\neapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef (Vint (Int.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some _ => andimm (Int.sub n2 Int.one) e1\n    | None =>\n        if Compopts.optim_for_size tt\n        then modu_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divu_mul_params (Int.unsigned n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n         | None => modu_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef (Vint (Int.modu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false)","proofString":"destruct (Int.is_power2 n2) as [l | ] eqn:P2.\nerewrite Int.modu_and by eauto.\nchange (Vint (Int.and i (Int.sub n2 Int.one)))    with (Val.and (Vint i) (Vint (Int.sub n2 Int.one))).\napply eval_andimm.\nauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor; eauto.\neapply eval_mod_from_div.\neapply eval_divu_mul; eauto.\nsimpl; eauto.\nsimpl; eauto.\nrewrite Int.modu_divu.\nauto.\nred; intros; subst n2; discriminate.\neapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (andimm (Int.sub n2 Int.one) e1) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andimm (Int.sub n2 Int.one) e1) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"erewrite Int.modu_and by eauto.\nchange (Vint (Int.and i (Int.sub n2 Int.one)))    with (Val.and (Vint i) (Vint (Int.sub n2 Int.one))).\napply eval_andimm.\nauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (andimm (Int.sub n2 Int.one) e1) v /\\\n  Val.lessdef (Vint (Int.and i (Int.sub n2 Int.one))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andimm (Int.sub n2 Int.one) e1) v /\\\n  Val.lessdef (Vint (Int.and i (Int.sub n2 Int.one))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"change (Vint (Int.and i (Int.sub n2 Int.one)))    with (Val.and (Vint i) (Vint (Int.sub n2 Int.one))).\napply eval_andimm.\nauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (andimm (Int.sub n2 Int.one) e1) v /\\\n  Val.lessdef (Val.and (Vint i) (Vint (Int.sub n2 Int.one))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andimm (Int.sub n2 Int.one) e1) v /\\\n  Val.lessdef (Val.and (Vint i) (Vint (Int.sub n2 Int.one))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"apply eval_andimm.\nauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : eval_expr ge sp e m le e1 (Vint i).","conclusion":"eval_expr ge sp e m le e1 (Vint i)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"auto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then modu_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divu_mul_params (Int.unsigned n2) with\n      | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n      | None => modu_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\ Val.lessdef (Vint (Int.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then modu_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divu_mul_params (Int.unsigned n2) with\n      | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n      | None => modu_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\ Val.lessdef (Vint (Int.modu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_modu_base; eauto.\nEvalOp.\ndestruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor; eauto.\neapply eval_mod_from_div.\neapply eval_divu_mul; eauto.\nsimpl; eauto.\nsimpl; eauto.\nrewrite Int.modu_divu.\nauto.\nred; intros; subst n2; discriminate.\neapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le (modu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (modu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"eapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divu_mul_params (Int.unsigned n2) with\n    | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n    | None => modu_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\ Val.lessdef (Vint (Int.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divu_mul_params (Int.unsigned n2) with\n    | Some (p, m0) => Elet e1 (mod_from_div (divu_mul p m0) n2)\n    | None => modu_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\ Val.lessdef (Vint (Int.modu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (divu_mul_params (Int.unsigned n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor; eauto.\neapply eval_mod_from_div.\neapply eval_divu_mul; eauto.\nsimpl; eauto.\nsimpl; eauto.\nrewrite Int.modu_divu.\nauto.\nred; intros; subst n2; discriminate.\neapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (divu_mul p M) n2)) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (divu_mul p M) n2)) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M))","proofString":"econstructor; split.\neconstructor; eauto.\neapply eval_mod_from_div.\neapply eval_divu_mul; eauto.\nsimpl; eauto.\nsimpl; eauto.\nrewrite Int.modu_divu.\nauto.\nred; intros; subst n2; discriminate."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M)) : Val.lessdef (Vint (Int.sub i (Int.mul (Int.divu i n2) n2)))\n  (Vint (Int.sub i (Int.mul (Int.divu i n2) n2))).","conclusion":"Val.lessdef (Vint (Int.sub i (Int.mul (Int.divu i n2) n2)))\n  (Vint (Int.sub i (Int.mul (Int.divu i n2) n2)))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M))","proofString":"auto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M)) : n2 <> Int.zero.","conclusion":"n2 <> Int.zero","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divu_mul_params (Int.unsigned n2) = Some (p, M))","proofString":"red; intros; subst n2; discriminate."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None) : exists v : val,\n  eval_expr ge sp e m le (modu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (modu_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.modu i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None)","proofString":"eapply eval_modu_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.modu (Vint i) (Vint n2) = Some (Vint (Int.modu i n2))) (Z2 : Int.eq n2 Int.zero = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divu_mul_params (Int.unsigned n2) = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then modu_base a b\n            else Eop (Ointconst (Int.modu n1 n2)) Enil\n        | None => moduimm a n2\n        end\n    | None => modu_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then modu_base a b\n            else Eop (Ointconst (Int.modu n1 n2)) Enil\n        | None => moduimm a n2\n        end\n    | None => modu_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z)","proofString":"destruct (is_intconst b) as [n2|] eqn:B.\nexploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_modu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_moduimm; eauto.\neapply eval_modu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then modu_base a b\n        else Eop (Ointconst (Int.modu n1 n2)) Enil\n    | None => moduimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then modu_base a b\n        else Eop (Ointconst (Int.modu n1 n2)) Enil\n    | None => moduimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"exploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_modu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_moduimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then modu_base a b\n        else Eop (Ointconst (Int.modu n1 n2)) Enil\n    | None => moduimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then modu_base a b\n        else Eop (Ointconst (Int.modu n1 n2)) Enil\n    | None => moduimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"intros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_modu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_moduimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then modu_base a b\n        else Eop (Ointconst (Int.modu n1 n2)) Enil\n    | None => moduimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then modu_base a b\n        else Eop (Ointconst (Int.modu n1 n2)) Enil\n    | None => moduimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2)","proofString":"destruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_modu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists.\nsubst.\neapply eval_moduimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then modu_base a b\n     else Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then modu_base a b\n     else Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"exploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_modu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then modu_base a b\n     else Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then modu_base a b\n     else Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"intros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_modu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then modu_base a b\n     else Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then modu_base a b\n     else Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1)","proofString":"destruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_modu_base; eauto.\nsubst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true) : exists v : val, eval_expr ge sp e m le (modu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true)","proofString":"eapply eval_modu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false)","proofString":"subst.\nsimpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.modu (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.modu (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"simpl in H1.\nrewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"rewrite Z in H1; inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.modu n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.modu n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.modu n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (moduimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (moduimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None)","proofString":"subst.\neapply eval_moduimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.modu x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (moduimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (moduimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.modu x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None)","proofString":"eapply eval_moduimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (B : is_intconst b = None) : exists v : val, eval_expr ge sp e m le (modu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (B : is_intconst b = None)","proofString":"eapply eval_modu_base; eauto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) : eval_expr ge sp e m le (divs_mul p M) (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le (divs_mul p M) (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x))","proofString":"unfold divs_mul.\nassert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; eauto).\nassert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhs.\neexact C.\neexact D.\nintros (v & X & F).\nsimpl in F; inv F.\nexploit eval_shruimm.\neexact C.\ninstantiate (1 := Int.repr (Int.zwordsize - 1)).\nintros [v1 [Y LD]].\nsimpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x))","proofString":"assert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; eauto).\nassert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhs.\neexact C.\neexact D.\nintros (v & X & F).\nsimpl in F; inv F.\nexploit eval_shruimm.\neexact C.\ninstantiate (1 := Int.repr (Int.zwordsize - 1)).\nintros [v1 [Y LD]].\nsimpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x))","proofString":"assert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\nexploit eval_mulhs.\neexact C.\neexact D.\nintros (v & X & F).\nsimpl in F; inv F.\nexploit eval_shruimm.\neexact C.\ninstantiate (1 := Int.repr (Int.zwordsize - 1)).\nintros [v1 [Y LD]].\nsimpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M)))","proofString":"exploit eval_mulhs.\neexact C.\neexact D.\nintros (v & X & F).\nsimpl in F; inv F.\nexploit eval_shruimm.\neexact C.\ninstantiate (1 := Int.repr (Int.zwordsize - 1)).\nintros [v1 [Y LD]].\nsimpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (v : val) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) v) (F : Val.lessdef (Val.mulhs (Vint x) (Vint (Int.repr M))) v) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (v : val) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) v) (F : Val.lessdef (Val.mulhs (Vint x) (Vint (Int.repr M))) v)","proofString":"simpl in F; inv F.\nexploit eval_shruimm.\neexact C.\ninstantiate (1 := Int.repr (Int.zwordsize - 1)).\nintros [v1 [Y LD]].\nsimpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M))))","proofString":"exploit eval_shruimm.\neexact C.\ninstantiate (1 := Int.repr (Int.zwordsize - 1)).\nintros [v1 [Y LD]].\nsimpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) : (exists v : val,\n   eval_expr ge sp e m le\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))) v /\\\n   Val.lessdef (Val.shru (Vint x) (Vint (Int.repr (Int.zwordsize - 1)))) v) ->\neval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))) v /\\\n   Val.lessdef (Val.shru (Vint x) (Vint (Int.repr (Int.zwordsize - 1)))) v) ->\neval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M))))","proofString":"intros [v1 [Y LD]].\nsimpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef (Val.shru (Vint x) (Vint (Int.repr (Int.zwordsize - 1)))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef (Val.shru (Vint x) (Vint (Int.repr (Int.zwordsize - 1)))) v1)","proofString":"simpl in LD.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shru x (Int.repr 31))\n   else Vundef) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shru x (Int.repr 31))\n   else Vundef) v1)","proofString":"change (Int.ltu (Int.repr 31) Int.iwordsize) with true in LD.\nsimpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef (if true then Vint (Int.shru x (Int.repr 31)) else Vundef) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef (if true then Vint (Int.shru x (Int.repr 31)) else Vundef) v1)","proofString":"simpl in LD.\ninv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef (Vint (Int.shru x (Int.repr 31))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (v1 : val) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  v1) (LD : Val.lessdef (Vint (Int.shru x (Int.repr 31))) v1)","proofString":"inv LD.\nassert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31))))","proofString":"assert (RANGE: 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia.\ndestruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true.","conclusion":"0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31))))","proofString":"intros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32) : Int.ltu (Int.repr p) Int.iwordsize = true.","conclusion":"Int.ltu (Int.repr p) Int.iwordsize = true","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32)","proofString":"unfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32) : (if zlt (Int.unsigned (Int.repr p)) (Int.unsigned Int.iwordsize)\n then true\n else false) = true.","conclusion":"(if zlt (Int.unsigned (Int.repr p)) (Int.unsigned Int.iwordsize)\n then true\n else false) = true","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32)","proofString":"rewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32) : (if zlt p (Int.unsigned Int.iwordsize) then true else false) = true.","conclusion":"(if zlt p (Int.unsigned Int.iwordsize) then true else false) = true","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32)","proofString":"rewrite zlt_true by tauto.\nauto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32) : true = true.","conclusion":"true = true","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32)","proofString":"auto."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32)","proofString":"assert (32 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32) (H2 : 32 < Int.max_unsigned) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (H1 : 0 <= p < 32) (H2 : 32 < Int.max_unsigned)","proofString":"lia."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (if zlt M Int.half_modulus\n         then mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)\n         else\n          add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n            (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true)","proofString":"destruct (zlt M Int.half_modulus).\nexploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W.\nexploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus)","proofString":"exploit (divs_mul_shift_1 x); eauto.\nintros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) : 0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\neval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\neval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus)","proofString":"intros [A B].\nexploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"exploit eval_shrimm.\neexact X.\ninstantiate (1 := Int.repr p).\nintros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : (exists v : val,\n   eval_expr ge sp e m le\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) v /\\\n   Val.lessdef\n     (Val.shr (Vint (Int.mulhs x (Int.repr M))) (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) v /\\\n   Val.lessdef\n     (Val.shr (Vint (Int.mulhs x (Int.repr M))) (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"intros [v1 [Z LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v1) (LD : Val.lessdef (Val.shr (Vint (Int.mulhs x (Int.repr M))) (Vint (Int.repr p)))\n  v1) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v1) (LD : Val.lessdef (Val.shr (Vint (Int.mulhs x (Int.repr M))) (Vint (Int.repr p)))\n  v1)","proofString":"simpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n   else Vundef) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n   else Vundef) v1)","proofString":"rewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v1) (LD : Val.lessdef (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) v1) (LD : Val.lessdef (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))) v1)","proofString":"inv LD.\nexploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))))","proofString":"exploit eval_add.\neexact Z.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  v1) (LD : Val.lessdef\n  (Val.add (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))\n     (Vint (Int.shru x (Int.repr 31)))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  v1) (LD : Val.lessdef\n  (Val.add (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))\n     (Vint (Int.shru x (Int.repr 31)))) v1)","proofString":"simpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  v1) (LD : Val.lessdef\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31)))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  v1) (LD : Val.lessdef\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31)))) v1)","proofString":"inv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31))))) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31)))))","proofString":"rewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31))))) : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31)))).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31))))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (l : M < Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n     (Int.repr p)) (Vint (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n        (Int.repr p)) (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.mulhs x (Int.repr M)) (Int.repr p))\n        (Int.shru x (Int.repr 31)))))","proofString":"exact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus)","proofString":"exploit (divs_mul_shift_2 x); eauto.\nintros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) : 0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\neval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"0 <= p < 32 /\\\nInt.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)) ->\neval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus)","proofString":"intros [A B].\nexploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31)))","proofString":"exploit eval_add.\neexact X.\neexact C.\nintros [v1 [Z LD]].\nsimpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  v1) (LD : Val.lessdef (Val.add (Vint (Int.mulhs x (Int.repr M))) (Vint x)) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  v1) (LD : Val.lessdef (Val.add (Vint (Int.mulhs x (Int.repr M))) (Vint x)) v1)","proofString":"simpl in LD.\ninv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  v1) (LD : Val.lessdef (Vint (Int.add (Int.mulhs x (Int.repr M)) x)) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (v1 : val) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  v1) (LD : Val.lessdef (Vint (Int.add (Int.mulhs x (Int.repr M)) x)) v1)","proofString":"inv LD.\nexploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x)))","proofString":"exploit eval_shrimm.\neexact Z.\ninstantiate (1 := Int.repr p).\nintros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) : (exists v : val,\n   eval_expr ge sp e m le\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p)) v /\\\n   Val.lessdef\n     (Val.shr (Vint (Int.add (Int.mulhs x (Int.repr M)) x))\n        (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p)) v /\\\n   Val.lessdef\n     (Val.shr (Vint (Int.add (Int.mulhs x (Int.repr M)) x))\n        (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x)))","proofString":"intros [v1 [U LD]].\nsimpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (v1 : val) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (Val.shr (Vint (Int.add (Int.mulhs x (Int.repr M)) x)) (Vint (Int.repr p)))\n  v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (v1 : val) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (Val.shr (Vint (Int.add (Int.mulhs x (Int.repr M)) x)) (Vint (Int.repr p)))\n  v1)","proofString":"simpl in LD.\nrewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (v1 : val) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n   else Vundef) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (v1 : val) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (if Int.ltu (Int.repr p) Int.iwordsize\n   then Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n   else Vundef) v1)","proofString":"rewrite RANGE in LD by auto.\ninv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (v1 : val) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (v1 : val) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p)) v1) (LD : Val.lessdef\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))) v1)","proofString":"inv LD.\nexploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))))","proofString":"exploit eval_add.\neexact U.\neexact Y.\nintros [v1 [W LD]].\nsimpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))) v1) (LD : Val.lessdef\n  (Val.add\n     (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))\n     (Vint (Int.shru x (Int.repr 31)))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))) v1) (LD : Val.lessdef\n  (Val.add\n     (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))\n     (Vint (Int.shru x (Int.repr 31)))) v1)","proofString":"simpl in LD.\ninv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))) v1) (LD : Val.lessdef\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31)))) v1) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (v1 : val) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))) v1) (LD : Val.lessdef\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31)))) v1)","proofString":"inv LD.\nrewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31))))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint (Int.divs x y))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31)))))","proofString":"rewrite B.\nexact W."},{"statement":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31))))) : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31)))).","conclusion":"eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31))))","hypotheses":"(le : list val) (x y : int) (p M : BinNums.Z) (H : divs_mul_params (Int.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vint x)) (C : eval_expr ge sp e m le (Eletvar 0) (Vint x)) (D : eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil)\n  (Vint (Int.repr M))) (X : eval_expr ge sp e m le\n  (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n  (Vint (Int.mulhs x (Int.repr M)))) (Y : eval_expr ge sp e m le (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1)))\n  (Vint (Int.shru x (Int.repr 31)))) (RANGE : 0 <= p < 32 -> Int.ltu (Int.repr p) Int.iwordsize = true) (g : M >= Int.half_modulus) (A : 0 <= p < 32) (B : Int.divs x y =\nInt.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n  (Int.shru x (Int.repr 31))) (Z : eval_expr ge sp e m le\n  (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n  (Vint (Int.add (Int.mulhs x (Int.repr M)) x))) (U : eval_expr ge sp e m le\n  (shrimm\n     (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil)) (Eletvar 0))\n     (Int.repr p))\n  (Vint (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p)))) (W : eval_expr ge sp e m le\n  (add\n     (shrimm\n        (add (mulhs (Eletvar 0) (Eop (Ointconst (Int.repr M)) Enil))\n           (Eletvar 0)) (Int.repr p))\n     (shruimm (Eletvar 0) (Int.repr (Int.zwordsize - 1))))\n  (Vint\n     (Int.add (Int.shr (Int.add (Int.mulhs x (Int.repr M)) x) (Int.repr p))\n        (Int.shru x (Int.repr 31)))))","proofString":"exact W."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.divs x (Vint n2) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.divs x (Vint n2) = Some z)","proofString":"generalize H0; intros DIV.\ndestruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\neapply eval_shrximm; eauto.\neapply Val.divs_pow2; eauto.\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divs i n2)); split; auto.\neconstructor; eauto.\neapply eval_divs_mul; eauto.\neapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 DIV : Val.divs x (Vint n2) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 DIV : Val.divs x (Vint n2) = Some z)","proofString":"destruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\neapply eval_shrximm; eauto.\neapply Val.divs_pow2; eauto.\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divs i n2)); split; auto.\neconstructor; eauto.\neapply eval_divs_mul; eauto.\neapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some z) (DIV : (if\n  Int.eq n2 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.divs i n2))) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some z) (DIV : (if\n  Int.eq n2 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.divs i n2))) = Some z)","proofString":"destruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\neapply eval_shrximm; eauto.\neapply Val.divs_pow2; eauto.\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divs i n2)); split; auto.\neconstructor; eauto.\neapply eval_divs_mul; eauto.\neapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then shrximm e1 l\n        else divs_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then divs_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (divs_mul p m0)\n         | None => divs_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false)","proofString":"destruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\neapply eval_shrximm; eauto.\neapply Val.divs_pow2; eauto.\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divs i n2)); split; auto.\neconstructor; eauto.\neapply eval_divs_mul; eauto.\neapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 31)\n     then shrximm e1 l\n     else divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 31)\n     then shrximm e1 l\n     else divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"destruct (Int.ltu l (Int.repr 31)) eqn:LT31.\neapply eval_shrximm; eauto.\neapply Val.divs_pow2; eauto.\neapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) : exists v : val,\n  eval_expr ge sp e m le (shrximm e1 l) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrximm e1 l) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true)","proofString":"eapply eval_shrximm; eauto.\neapply Val.divs_pow2; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) : Val.shrx (Vint i) (Vint l) = Some (Vint (Int.divs i n2)).","conclusion":"Val.shrx (Vint i) (Vint l) = Some (Vint (Int.divs i n2))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true)","proofString":"eapply Val.divs_pow2; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false) : exists v : val,\n  eval_expr ge sp e m le (divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false)","proofString":"eapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false)","proofString":"EvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divs_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divs_mul_params (Int.signed n2) with\n      | Some (p, m0) => Elet e1 (divs_mul p m0)\n      | None => divs_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\ Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divs_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divs_mul_params (Int.signed n2) with\n      | Some (p, m0) => Elet e1 (divs_mul p m0)\n      | None => divs_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\ Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_divs_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divs i n2)); split; auto.\neconstructor; eauto.\neapply eval_divs_mul; eauto.\neapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le (divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"eapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divs_mul_params (Int.signed n2) with\n    | Some (p, m0) => Elet e1 (divs_mul p m0)\n    | None => divs_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\ Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divs_mul_params (Int.signed n2) with\n    | Some (p, m0) => Elet e1 (divs_mul p m0)\n    | None => divs_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\ Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\nexists (Vint (Int.divs i n2)); split; auto.\neconstructor; eauto.\neapply eval_divs_mul; eauto.\neapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet e1 (divs_mul p M)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet e1 (divs_mul p M)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M))","proofString":"exists (Vint (Int.divs i n2)); split; auto.\neconstructor; eauto.\neapply eval_divs_mul; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M)) : eval_expr ge sp e m le (Elet e1 (divs_mul p M)) (Vint (Int.divs i n2)).","conclusion":"eval_expr ge sp e m le (Elet e1 (divs_mul p M)) (Vint (Int.divs i n2))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M))","proofString":"econstructor; eauto.\neapply eval_divs_mul; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M)) : eval_expr ge sp e m (Vint i :: le) (divs_mul p M) (Vint (Int.divs i n2)).","conclusion":"eval_expr ge sp e m (Vint i :: le) (divs_mul p M) (Vint (Int.divs i n2))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M))","proofString":"eapply eval_divs_mul; eauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None) : exists v : val,\n  eval_expr ge sp e m le (divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (divs_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Vint (Int.divs i n2)) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None)","proofString":"eapply eval_divs_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then divs_base a b\n            else Eop (Ointconst (Int.divs n1 n2)) Enil\n        | None => divsimm a n2\n        end\n    | None => divs_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then divs_base a b\n            else Eop (Ointconst (Int.divs n1 n2)) Enil\n        | None => divsimm a n2\n        end\n    | None => divs_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z)","proofString":"destruct (is_intconst b) as [n2|] eqn:B.\nexploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divs_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_divsimm; eauto.\neapply eval_divs_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divs_base a b\n        else Eop (Ointconst (Int.divs n1 n2)) Enil\n    | None => divsimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divs_base a b\n        else Eop (Ointconst (Int.divs n1 n2)) Enil\n    | None => divsimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"exploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divs_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_divsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divs_base a b\n        else Eop (Ointconst (Int.divs n1 n2)) Enil\n    | None => divsimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divs_base a b\n        else Eop (Ointconst (Int.divs n1 n2)) Enil\n    | None => divsimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"intros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divs_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_divsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divs_base a b\n        else Eop (Ointconst (Int.divs n1 n2)) Enil\n    | None => divsimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then divs_base a b\n        else Eop (Ointconst (Int.divs n1 n2)) Enil\n    | None => divsimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2)","proofString":"destruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divs_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_divsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divs_base a b\n     else Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divs_base a b\n     else Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"exploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divs_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divs_base a b\n     else Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divs_base a b\n     else Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"intros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divs_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divs_base a b\n     else Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then divs_base a b\n     else Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1)","proofString":"destruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_divs_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true) : exists v : val, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true)","proofString":"eapply eval_divs_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false)","proofString":"subst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.divs (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.divs (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"simpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if\n  Int.eq n2 Int.zero\n  || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.divs n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if\n  Int.eq n2 Int.zero\n  || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.divs n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"destruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.divs n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.divs n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.divs n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (divsimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divsimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None)","proofString":"subst.\neapply eval_divsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.divs x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (divsimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divsimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.divs x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None)","proofString":"eapply eval_divsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (B : is_intconst b = None) : exists v : val, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) (B : is_intconst b = None)","proofString":"eapply eval_divs_base; eauto."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z)","proofString":"exploit Val.mods_divs; eauto.\nintros [y [A B]].\ngeneralize A; intros DIV.\ndestruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\nexploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z) : (exists v : val,\n   Val.divs x (Vint n2) = Some v /\\ z = Val.sub x (Val.mul v (Vint n2))) ->\nexists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"(exists v : val,\n   Val.divs x (Vint n2) = Some v /\\ z = Val.sub x (Val.mul v (Vint n2))) ->\nexists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z)","proofString":"intros [y [A B]].\ngeneralize A; intros DIV.\ndestruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\nexploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z) (y : val) (A : Val.divs x (Vint n2) = Some y) (B : z = Val.sub x (Val.mul y (Vint n2))) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z) (y : val) (A : Val.divs x (Vint n2) = Some y) (B : z = Val.sub x (Val.mul y (Vint n2)))","proofString":"generalize A; intros DIV.\ndestruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\nexploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z) (y : val) (A : Val.divs x (Vint n2) = Some y) (B : z = Val.sub x (Val.mul y (Vint n2))) (DIV : Val.divs x (Vint n2) = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (x : val) (n2 : int) (z : val) (H : eval_expr ge sp e m le e1 x) (H0 : Val.mods x (Vint n2) = Some z) (y : val) (A : Val.divs x (Vint n2) = Some y) (B : z = Val.sub x (Val.mul y (Vint n2))) (DIV : Val.divs x (Vint n2) = Some y)","proofString":"destruct x; simpl in DIV; try discriminate.\ndestruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\nexploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.mods (Vint i) (Vint n2) = Some z) (y : val) (A : Val.divs (Vint i) (Vint n2) = Some y) (B : z = Val.sub (Vint i) (Val.mul y (Vint n2))) (DIV : (if\n  Int.eq n2 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.divs i n2))) = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (z : val) (H : eval_expr ge sp e m le e1 (Vint i)) (H0 : Val.mods (Vint i) (Vint n2) = Some z) (y : val) (A : Val.divs (Vint i) (Vint n2) = Some y) (B : z = Val.sub (Vint i) (Val.mul y (Vint n2))) (DIV : (if\n  Int.eq n2 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.divs i n2))) = Some y)","proofString":"destruct (Int.eq n2 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone) eqn:Z2; inv DIV.\ndestruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\nexploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int.is_power2 n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 31)\n        then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n        else mods_base e1 (Eop (Ointconst n2) Enil)\n    | None =>\n        if Compopts.optim_for_size tt\n        then mods_base e1 (Eop (Ointconst n2) Enil)\n        else\n         match divs_mul_params (Int.signed n2) with\n         | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n         | None => mods_base e1 (Eop (Ointconst n2) Enil)\n         end\n    end v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false)","proofString":"destruct (Int.is_power2 n2) as [l | ] eqn:P2.\ndestruct (Int.ltu l (Int.repr 31)) eqn:LT31.\nexploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (Compopts.optim_for_size tt).\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 31)\n     then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n     else mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 31)\n     then Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2)\n     else mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l)","proofString":"destruct (Int.ltu l (Int.repr 31)) eqn:LT31.\nexploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) : exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2))\n    v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2))\n    v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true)","proofString":"exploit (eval_shrximm ge sp e m (Vint i :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neapply Val.divs_pow2; eauto.\nintros [v1 [X LD]].\ninv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) (v1 : val) (X : eval_expr ge sp e m (Vint i :: le) (shrximm (Eletvar 0) l) v1) (LD : Val.lessdef (Vint (Int.divs i n2)) v1) : exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2))\n    v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2))\n    v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) (v1 : val) (X : eval_expr ge sp e m (Vint i :: le) (shrximm (Eletvar 0) l) v1) (LD : Val.lessdef (Vint (Int.divs i n2)) v1)","proofString":"inv LD.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) (X : eval_expr ge sp e m (Vint i :: le) (shrximm (Eletvar 0) l)\n  (Vint (Int.divs i n2))) : exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2))\n    v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (shrximm (Eletvar 0) l) n2))\n    v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) (X : eval_expr ge sp e m (Vint i :: le) (shrximm (Eletvar 0) l)\n  (Vint (Int.divs i n2)))","proofString":"econstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div.\neexact X.\nsimpl; eauto.\nsimpl.\nauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) (X : eval_expr ge sp e m (Vint i :: le) (shrximm (Eletvar 0) l)\n  (Vint (Int.divs i n2))) : Val.lessdef (Vint (Int.sub i (Int.mul (Int.divs i n2) n2)))\n  (Vint (Int.sub i (Int.mul (Int.divs i n2) n2))).","conclusion":"Val.lessdef (Vint (Int.sub i (Int.mul (Int.divs i n2) n2)))\n  (Vint (Int.sub i (Int.mul (Int.divs i n2) n2)))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = true) (X : eval_expr ge sp e m (Vint i :: le) (shrximm (Eletvar 0) l)\n  (Vint (Int.divs i n2)))","proofString":"auto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false) : exists v : val,\n  eval_expr ge sp e m le (mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false)","proofString":"eapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (l : int) (P2 : Int.is_power2 n2 = Some l) (LT31 : Int.ltu l (Int.repr 31) = false)","proofString":"EvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then mods_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divs_mul_params (Int.signed n2) with\n      | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n      | None => mods_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then mods_base e1 (Eop (Ointconst n2) Enil)\n     else\n      match divs_mul_params (Int.signed n2) with\n      | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n      | None => mods_base e1 (Eop (Ointconst n2) Enil)\n      end) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_mods_base; eauto.\nEvalOp.\ndestruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le (mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"eapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divs_mul_params (Int.signed n2) with\n    | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n    | None => mods_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divs_mul_params (Int.signed n2) with\n    | Some (p, m0) => Elet e1 (mod_from_div (divs_mul p m0) n2)\n    | None => mods_base e1 (Eop (Ointconst n2) Enil)\n    end v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None)","proofString":"destruct (divs_mul_params (Int.signed n2)) as [[p M] | ] eqn:PARAMS.\neconstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto.\neapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (divs_mul p M) n2)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet e1 (mod_from_div (divs_mul p M) n2)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M))","proofString":"econstructor; split.\neconstructor.\neauto.\napply eval_mod_from_div with (x := i); auto.\neapply eval_divs_mul with (x := i); eauto.\nsimpl.\nauto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M)) : Val.lessdef (Vint (Int.sub i (Int.mul (Int.divs i n2) n2)))\n  (Vint (Int.sub i (Int.mul (Int.divs i n2) n2))).","conclusion":"Val.lessdef (Vint (Int.sub i (Int.mul (Int.divs i n2) n2)))\n  (Vint (Int.sub i (Int.mul (Int.divs i n2) n2)))","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (p M : Z) (PARAMS : divs_mul_params (Int.signed n2) = Some (p, M))","proofString":"auto."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None) : exists v : val,\n  eval_expr ge sp e m le (mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mods_base e1 (Eop (Ointconst n2) Enil)) v /\\\n  Val.lessdef (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2))) v","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None)","proofString":"eapply eval_mods_base; eauto.\nEvalOp."},{"statement":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None) : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2).","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n2) Enil) (Vint n2)","hypotheses":"(le : letenv) (e1 : expr) (i n2 : int) (H : eval_expr ge sp e m le e1 (Vint i)) (A : Val.divs (Vint i) (Vint n2) = Some (Vint (Int.divs i n2))) (H0 : Val.mods (Vint i) (Vint n2) =\nSome (Val.sub (Vint i) (Val.mul (Vint (Int.divs i n2)) (Vint n2)))) (Z2 : Int.eq n2 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone = false) (P2 : Int.is_power2 n2 = None) (PARAMS : divs_mul_params (Int.signed n2) = None)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then mods_base a b\n            else Eop (Ointconst (Int.mods n1 n2)) Enil\n        | None => modsimm a n2\n        end\n    | None => mods_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n2 =>\n        match is_intconst a with\n        | Some n1 =>\n            if Int.eq n2 Int.zero\n            then mods_base a b\n            else Eop (Ointconst (Int.mods n1 n2)) Enil\n        | None => modsimm a n2\n        end\n    | None => mods_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z)","proofString":"destruct (is_intconst b) as [n2|] eqn:B.\nexploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_mods_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_modsimm; eauto.\neapply eval_mods_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then mods_base a b\n        else Eop (Ointconst (Int.mods n1 n2)) Enil\n    | None => modsimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then mods_base a b\n        else Eop (Ointconst (Int.mods n1 n2)) Enil\n    | None => modsimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"exploit is_intconst_sound; eauto.\nintros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_mods_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_modsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (B : is_intconst b = Some n2) : y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then mods_base a b\n        else Eop (Ointconst (Int.mods n1 n2)) Enil\n    | None => modsimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"y = Vint n2 ->\nexists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then mods_base a b\n        else Eop (Ointconst (Int.mods n1 n2)) Enil\n    | None => modsimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (B : is_intconst b = Some n2)","proofString":"intros EB; clear B.\ndestruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_mods_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_modsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then mods_base a b\n        else Eop (Ointconst (Int.mods n1 n2)) Enil\n    | None => modsimm a n2\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst a with\n    | Some n1 =>\n        if Int.eq n2 Int.zero\n        then mods_base a b\n        else Eop (Ointconst (Int.mods n1 n2)) Enil\n    | None => modsimm a n2\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2)","proofString":"destruct (is_intconst a) as [n1|] eqn:A.\nexploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_mods_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists.\nsubst.\neapply eval_modsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then mods_base a b\n     else Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then mods_base a b\n     else Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"exploit is_intconst_sound; eauto.\nintros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_mods_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1) : x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then mods_base a b\n     else Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"x = Vint n1 ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then mods_base a b\n     else Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (A : is_intconst a = Some n1)","proofString":"intros EA; clear A.\ndestruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_mods_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then mods_base a b\n     else Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then mods_base a b\n     else Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1)","proofString":"destruct (Int.eq n2 Int.zero) eqn:Z.\neapply eval_mods_base; eauto.\nsubst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true) : exists v : val, eval_expr ge sp e m le (mods_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (mods_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = true)","proofString":"eapply eval_mods_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (n1 : int) (EA : x = Vint n1) (Z : Int.eq n2 Int.zero = false)","proofString":"subst.\nsimpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.mods (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : Val.mods (Vint n1) (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"simpl in H1.\ndestruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if\n  Int.eq n2 Int.zero\n  || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.mods n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H1 : (if\n  Int.eq n2 Int.zero\n  || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n then None\n else Some (Vint (Int.mods n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"destruct (Int.eq n2 Int.zero || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone); inv H1.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.mods n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mods n1 n2)) Enil) v /\\\n  Val.lessdef (Vint (Int.mods n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int) (H : eval_expr ge sp e m le a (Vint n1)) (n2 : int) (H0 : eval_expr ge sp e m le b (Vint n2)) (Z : Int.eq n2 Int.zero = false)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (modsimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modsimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (n2 : int) (EB : y = Vint n2) (A : is_intconst a = None)","proofString":"subst.\neapply eval_modsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.mods x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None) : exists v : val, eval_expr ge sp e m le (modsimm a n2) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modsimm a n2) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int) (H1 : Val.mods x (Vint n2) = Some z) (H0 : eval_expr ge sp e m le b (Vint n2)) (A : is_intconst a = None)","proofString":"eapply eval_modsimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (B : is_intconst b = None) : exists v : val, eval_expr ge sp e m le (mods_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (mods_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (B : is_intconst b = None)","proofString":"eapply eval_mods_base; eauto."},{"statement":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))).","conclusion":"eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"exploit eval_mullimm; eauto.\ninstantiate (1 := n).\nintros (v1 & A1 & B1).\nassert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)) by (constructor; auto).\nexploit eval_subl ; auto ; try apply HELPERS.\nexact A0.\nexact A1.\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nexact A2."},{"statement":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) : (exists v : val,\n   eval_expr ge sp e m le (mullimm n a) v /\\\n   Val.lessdef (Val.mull (Vlong y) (Vlong n)) v) ->\neval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (mullimm n a) v /\\\n   Val.lessdef (Val.mull (Vlong y) (Vlong n)) v) ->\neval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"intros (v1 & A1 & B1).\nassert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)) by (constructor; auto).\nexploit eval_subl ; auto ; try apply HELPERS.\nexact A0.\nexact A1.\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nexact A2."},{"statement":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullimm n a) v1) (B1 : Val.lessdef (Val.mull (Vlong y) (Vlong n)) v1) : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))).","conclusion":"eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullimm n a) v1) (B1 : Val.lessdef (Val.mull (Vlong y) (Vlong n)) v1)","proofString":"assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)) by (constructor; auto).\nexploit eval_subl ; auto ; try apply HELPERS.\nexact A0.\nexact A1.\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nexact A2."},{"statement":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullimm n a) v1) (B1 : Val.lessdef (Val.mull (Vlong y) (Vlong n)) v1) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))).","conclusion":"eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullimm n a) v1) (B1 : Val.lessdef (Val.mull (Vlong y) (Vlong n)) v1) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x))","proofString":"exploit eval_subl ; auto ; try apply HELPERS.\nexact A0.\nexact A1.\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nexact A2."},{"statement":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullimm n a) v1) (B1 : Val.lessdef (Val.mull (Vlong y) (Vlong n)) v1) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v2 : val) (A2 : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a)) v2) (B2 : Val.lessdef (Val.subl (Vlong x) v1) v2) : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))).","conclusion":"eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullimm n a) v1) (B1 : Val.lessdef (Val.mull (Vlong y) (Vlong n)) v1) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v2 : val) (A2 : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a)) v2) (B2 : Val.lessdef (Val.subl (Vlong x) v1) v2)","proofString":"simpl in B1; inv B1.\nsimpl in B2; inv B2.\nexact A2."},{"statement":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (A1 : eval_expr ge sp e m le (mullimm n a) (Vlong (Int64.mul y n))) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v2 : val) (A2 : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a)) v2) (B2 : Val.lessdef (Val.subl (Vlong x) (Vlong (Int64.mul y n))) v2) : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))).","conclusion":"eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (A1 : eval_expr ge sp e m le (mullimm n a) (Vlong (Int64.mul y n))) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v2 : val) (A2 : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a)) v2) (B2 : Val.lessdef (Val.subl (Vlong x) (Vlong (Int64.mul y n))) v2)","proofString":"simpl in B2; inv B2.\nexact A2."},{"statement":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (A1 : eval_expr ge sp e m le (mullimm n a) (Vlong (Int64.mul y n))) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A2 : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))) : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))).","conclusion":"eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n)))","hypotheses":"(le : letenv) (a : expr) (n x y : int64) (H : eval_expr ge sp e m le a (Vlong y)) (H0 : nth_error le 0 = Some (Vlong x)) (A1 : eval_expr ge sp e m le (mullimm n a) (Vlong (Int64.mul y n))) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A2 : eval_expr ge sp e m le (subl (Eletvar 0) (mullimm n a))\n  (Vlong (Int64.sub x (Int64.mul y n))))","proofString":"exact A2."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) : eval_expr ge sp e m le (divlu_mull p M) (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le (divlu_mull p M) (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"unfold divlu_mull.\nexploit (divlu_mul_shift x); eauto.\nintros [A B].\nassert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)) by (constructor; auto).\nexploit eval_mullhu.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A1.\ninstantiate (1 := Int.repr p).\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"exploit (divlu_mul_shift x); eauto.\nintros [A B].\nassert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)) by (constructor; auto).\nexploit eval_mullhu.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A1.\ninstantiate (1 := Int.repr p).\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) : 0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p) ->\neval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"0 <= p < 64 /\\\nInt64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p) ->\neval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"intros [A B].\nassert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)) by (constructor; auto).\nexploit eval_mullhu.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A1.\ninstantiate (1 := Int.repr p).\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))","proofString":"assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)) by (constructor; auto).\nexploit eval_mullhu.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A1.\ninstantiate (1 := Int.repr p).\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x))","proofString":"exploit eval_mullhu.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A1.\ninstantiate (1 := Int.repr p).\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) : (exists v : val,\n   eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v /\\\n   Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v) ->\neval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v /\\\n   Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v) ->\neval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x))","proofString":"intros (v1 & A1 & B1).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A1.\ninstantiate (1 := Int.repr p).\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v1) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v1)","proofString":"exploit eval_shrluimm.\ntry apply HELPERS.\neexact A1.\ninstantiate (1 := Int.repr p).\nintros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v1) : (exists v : val,\n   eval_expr ge sp e m le\n     (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v /\\\n   Val.lessdef (Val.shrlu v1 (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le\n     (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v /\\\n   Val.lessdef (Val.shrlu v1 (Vint (Int.repr p))) v) ->\neval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v1)","proofString":"intros (v2 & A2 & B2).\nsimpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.repr p))) v2) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhu (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.repr p))) v2)","proofString":"simpl in B1; inv B1.\nsimpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (Val.shrlu (Vlong (Int64.mulhu x (Int64.repr M))) (Vint (Int.repr p))) v2) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (Val.shrlu (Vlong (Int64.mulhu x (Int64.repr M))) (Vint (Int.repr p))) v2)","proofString":"simpl in B2.\nreplace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2)","proofString":"replace (Int.ltu (Int.repr p) Int64.iwordsize') with true in B2.\ninv B2.\nrewrite B.\nassumption.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)))\n  v2) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)))\n  v2)","proofString":"inv B2.\nrewrite B.\nassumption."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)))) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y)).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.divu x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))))","proofString":"rewrite B.\nassumption."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)))) : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))).","conclusion":"eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p))\n  (Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))))","proofString":"assumption."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) : true = Int.ltu (Int.repr p) Int64.iwordsize'.","conclusion":"true = Int.ltu (Int.repr p) Int64.iwordsize'","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2)","proofString":"unfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) : true =\n(if zlt (Int.unsigned (Int.repr p)) (Int.unsigned Int64.iwordsize')\n then true\n else false).","conclusion":"true =\n(if zlt (Int.unsigned (Int.repr p)) (Int.unsigned Int64.iwordsize')\n then true\n else false)","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2)","proofString":"rewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\ntauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) : true = (if zlt p (Int.unsigned Int64.iwordsize') then true else false).","conclusion":"true = (if zlt p (Int.unsigned Int64.iwordsize') then true else false)","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2)","proofString":"rewrite zlt_true; auto.\ntauto."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) : p < Int.unsigned Int64.iwordsize'.","conclusion":"p < Int.unsigned Int64.iwordsize'","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2)","proofString":"tauto."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2)","proofString":"assert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) (H1 : 64 < Int.max_unsigned) : 0 <= p <= Int.max_unsigned.","conclusion":"0 <= p <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divlu_mul_params (Int64.unsigned y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A : 0 <= p < 64) (B : Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhu (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhu x (Int64.repr M)))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (shrluimm (mullhu (Eletvar 0) (Int64.repr M)) (Int.repr p)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.repr p) Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.mulhu x (Int64.repr M)) (Int.repr p))\n   else Vundef) v2) (H1 : 64 < Int.max_unsigned)","proofString":"lia."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.divu n1 n2)\n        | None =>\n            match Int64.is_power2' n2 with\n            | Some l => shrluimm a l\n            | None =>\n                if Compopts.optim_for_size tt\n                then divlu_base a b\n                else\n                 match divlu_mul_params (Int64.unsigned n2) with\n                 | Some (p, m0) => Elet a (divlu_mull p m0)\n                 | None => divlu_base a b\n                 end\n            end\n        end\n    | None => divlu_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.divu n1 n2)\n        | None =>\n            match Int64.is_power2' n2 with\n            | Some l => shrluimm a l\n            | None =>\n                if Compopts.optim_for_size tt\n                then divlu_base a b\n                else\n                 match divlu_mul_params (Int64.unsigned n2) with\n                 | Some (p, m0) => Elet a (divlu_mull p m0)\n                 | None => divlu_base a b\n                 end\n            end\n        end\n    | None => divlu_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z)","proofString":"destruct (is_longconst b) as [n2|] eqn:N2.\nassert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\nexploit Val.divlu_pow2; eauto.\nintros EQ; subst z.\napply eval_shrluimm; auto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto.\neapply eval_divlu_base; eauto.\neapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divu n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l => shrluimm a l\n        | None =>\n            if Compopts.optim_for_size tt\n            then divlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (divlu_mull p m0)\n             | None => divlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divu n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l => shrluimm a l\n        | None =>\n            if Compopts.optim_for_size tt\n            then divlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (divlu_mull p m0)\n             | None => divlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2)","proofString":"assert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\nexploit Val.divlu_pow2; eauto.\nintros EQ; subst z.\napply eval_shrluimm; auto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto.\neapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divu n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l => shrluimm a l\n        | None =>\n            if Compopts.optim_for_size tt\n            then divlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (divlu_mull p m0)\n             | None => divlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divu n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l => shrluimm a l\n        | None =>\n            if Compopts.optim_for_size tt\n            then divlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (divlu_mull p m0)\n             | None => divlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2)","proofString":"subst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\nexploit Val.divlu_pow2; eauto.\nintros EQ; subst z.\napply eval_shrluimm; auto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto.\neapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divu n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l => shrluimm a l\n        | None =>\n            if Compopts.optim_for_size tt\n            then divlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (divlu_mull p m0)\n             | None => divlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divu n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l => shrluimm a l\n        | None =>\n            if Compopts.optim_for_size tt\n            then divlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (divlu_mull p m0)\n             | None => divlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2)","proofString":"destruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\nexploit Val.divlu_pow2; eauto.\nintros EQ; subst z.\napply eval_shrluimm; auto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto.\neapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1)","proofString":"assert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1)","proofString":"subst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.divlu (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.divlu (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"simpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.divu n1 n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.divu n1 n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"destruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.divu n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divu n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.divu n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"econstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) : exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n2 with\n    | Some l => shrluimm a l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divlu_base a b\n        else\n         match divlu_mul_params (Int64.unsigned n2) with\n         | Some (p, m0) => Elet a (divlu_mull p m0)\n         | None => divlu_base a b\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n2 with\n    | Some l => shrluimm a l\n    | None =>\n        if Compopts.optim_for_size tt\n        then divlu_base a b\n        else\n         match divlu_mul_params (Int64.unsigned n2) with\n         | Some (p, m0) => Elet a (divlu_mull p m0)\n         | None => divlu_base a b\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None)","proofString":"destruct (Int64.is_power2' n2) as [l|] eqn:POW.\nexploit Val.divlu_pow2; eauto.\nintros EQ; subst z.\napply eval_shrluimm; auto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto.\neapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) : exists v : val, eval_expr ge sp e m le (shrluimm a l) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (shrluimm a l) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l)","proofString":"exploit Val.divlu_pow2; eauto.\nintros EQ; subst z.\napply eval_shrluimm; auto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) : Val.shrlu x (Vint l) = z ->\nexists v : val, eval_expr ge sp e m le (shrluimm a l) v /\\ Val.lessdef z v.","conclusion":"Val.shrlu x (Vint l) = z ->\nexists v : val, eval_expr ge sp e m le (shrluimm a l) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l)","proofString":"intros EQ; subst z.\napply eval_shrluimm; auto."},{"statement":"(le : letenv) (a b : expr) (x : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (l : int) (H1 : Val.divlu x (Vlong n2) = Some (Val.shrlu x (Vint l))) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (shrluimm a l) v /\\\n  Val.lessdef (Val.shrlu x (Vint l)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrluimm a l) v /\\\n  Val.lessdef (Val.shrlu x (Vint l)) v","hypotheses":"(le : letenv) (a b : expr) (x : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (l : int) (H1 : Val.divlu x (Vlong n2) = Some (Val.shrlu x (Vint l))) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = Some l)","proofString":"apply eval_shrluimm; auto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divlu_base a b\n     else\n      match divlu_mul_params (Int64.unsigned n2) with\n      | Some (p, m0) => Elet a (divlu_mull p m0)\n      | None => divlu_base a b\n      end) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divlu_base a b\n     else\n      match divlu_mul_params (Int64.unsigned n2) with\n      | Some (p, m0) => Elet a (divlu_mull p m0)\n      | None => divlu_base a b\n      end) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_divlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto.\neapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val, eval_expr ge sp e m le (divlu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divlu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"eapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divlu_mul_params (Int64.unsigned n2) with\n    | Some (p, m0) => Elet a (divlu_mull p m0)\n    | None => divlu_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divlu_mul_params (Int64.unsigned n2) with\n    | Some (p, m0) => Elet a (divlu_mull p m0)\n    | None => divlu_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"destruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto.\neapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (divlu_mull p M)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (divlu_mull p M)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"destruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.divu i n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (divlu_mull p M)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (divlu_mull p M)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.divu i n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"destruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (divlu_mull p M)) v /\\\n  Val.lessdef (Vlong (Int64.divu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (divlu_mull p M)) v /\\\n  Val.lessdef (Vlong (Int64.divu i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"econstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divlu_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : eval_expr ge sp e m le (Elet a (divlu_mull p M)) (Vlong (Int64.divu i n2)).","conclusion":"eval_expr ge sp e m le (Elet a (divlu_mull p M)) (Vlong (Int64.divu i n2))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"econstructor.\neauto.\neapply eval_divlu_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (PARAMS : divlu_mul_params (Int64.unsigned n2) = None) : exists v : val, eval_expr ge sp e m le (divlu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divlu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (PARAMS : divlu_mul_params (Int64.unsigned n2) = None)","proofString":"eapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (N2 : is_longconst b = None) : exists v : val, eval_expr ge sp e m le (divlu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divlu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (N2 : is_longconst b = None)","proofString":"eapply eval_divlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.modu n1 n2)\n        | None =>\n            match Int64.is_power2 n2 with\n            | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n            | None =>\n                if Compopts.optim_for_size tt\n                then modlu_base a b\n                else\n                 match divlu_mul_params (Int64.unsigned n2) with\n                 | Some (p, m0) =>\n                     Elet a (modl_from_divl (divlu_mull p m0) n2)\n                 | None => modlu_base a b\n                 end\n            end\n        end\n    | None => modlu_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.modu n1 n2)\n        | None =>\n            match Int64.is_power2 n2 with\n            | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n            | None =>\n                if Compopts.optim_for_size tt\n                then modlu_base a b\n                else\n                 match divlu_mul_params (Int64.unsigned n2) with\n                 | Some (p, m0) =>\n                     Elet a (modl_from_divl (divlu_mull p m0) n2)\n                 | None => modlu_base a b\n                 end\n            end\n        end\n    | None => modlu_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z)","proofString":"destruct (is_longconst b) as [n2|] eqn:N2.\nassert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2 n2) as [l|] eqn:POW.\nexploit Val.modlu_pow2; eauto.\nintros EQ; subst z.\neapply eval_andl; eauto.\napply eval_longconst.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z.\neapply eval_modlu_base; eauto.\neapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.modu n1 n2)\n    | None =>\n        match Int64.is_power2 n2 with\n        | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n        | None =>\n            if Compopts.optim_for_size tt\n            then modlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n             | None => modlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.modu n1 n2)\n    | None =>\n        match Int64.is_power2 n2 with\n        | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n        | None =>\n            if Compopts.optim_for_size tt\n            then modlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n             | None => modlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2)","proofString":"assert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2 n2) as [l|] eqn:POW.\nexploit Val.modlu_pow2; eauto.\nintros EQ; subst z.\neapply eval_andl; eauto.\napply eval_longconst.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z.\neapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.modu n1 n2)\n    | None =>\n        match Int64.is_power2 n2 with\n        | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n        | None =>\n            if Compopts.optim_for_size tt\n            then modlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n             | None => modlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.modu n1 n2)\n    | None =>\n        match Int64.is_power2 n2 with\n        | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n        | None =>\n            if Compopts.optim_for_size tt\n            then modlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n             | None => modlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2)","proofString":"subst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2 n2) as [l|] eqn:POW.\nexploit Val.modlu_pow2; eauto.\nintros EQ; subst z.\neapply eval_andl; eauto.\napply eval_longconst.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z.\neapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.modu n1 n2)\n    | None =>\n        match Int64.is_power2 n2 with\n        | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n        | None =>\n            if Compopts.optim_for_size tt\n            then modlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n             | None => modlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.modu n1 n2)\n    | None =>\n        match Int64.is_power2 n2 with\n        | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n        | None =>\n            if Compopts.optim_for_size tt\n            then modlu_base a b\n            else\n             match divlu_mul_params (Int64.unsigned n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n             | None => modlu_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2)","proofString":"destruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2 n2) as [l|] eqn:POW.\nexploit Val.modlu_pow2; eauto.\nintros EQ; subst z.\neapply eval_andl; eauto.\napply eval_longconst.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z.\neapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1)","proofString":"assert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1)","proofString":"subst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.modlu (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.modlu (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"simpl in H1.\ndestruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.modu n1 n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.modu n1 n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"destruct (Int64.eq n2 Int64.zero); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.modu n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.modu n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.modu n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"econstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) : exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2 n2 with\n    | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n    | None =>\n        if Compopts.optim_for_size tt\n        then modlu_base a b\n        else\n         match divlu_mul_params (Int64.unsigned n2) with\n         | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n         | None => modlu_base a b\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2 n2 with\n    | Some _ => andl a (longconst (Int64.sub n2 Int64.one))\n    | None =>\n        if Compopts.optim_for_size tt\n        then modlu_base a b\n        else\n         match divlu_mul_params (Int64.unsigned n2) with\n         | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n         | None => modlu_base a b\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None)","proofString":"destruct (Int64.is_power2 n2) as [l|] eqn:POW.\nexploit Val.modlu_pow2; eauto.\nintros EQ; subst z.\neapply eval_andl; eauto.\napply eval_longconst.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z.\neapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (andl a (longconst (Int64.sub n2 Int64.one))) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andl a (longconst (Int64.sub n2 Int64.one))) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l)","proofString":"exploit Val.modlu_pow2; eauto.\nintros EQ; subst z.\neapply eval_andl; eauto.\napply eval_longconst."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l) : Val.andl x (Vlong (Int64.sub n2 Int64.one)) = z ->\nexists v : val,\n  eval_expr ge sp e m le (andl a (longconst (Int64.sub n2 Int64.one))) v /\\\n  Val.lessdef z v.","conclusion":"Val.andl x (Vlong (Int64.sub n2 Int64.one)) = z ->\nexists v : val,\n  eval_expr ge sp e m le (andl a (longconst (Int64.sub n2 Int64.one))) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l)","proofString":"intros EQ; subst z.\neapply eval_andl; eauto.\napply eval_longconst."},{"statement":"(le : letenv) (a b : expr) (x : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some (Val.andl x (Vlong (Int64.sub n2 Int64.one)))) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le (andl a (longconst (Int64.sub n2 Int64.one))) v /\\\n  Val.lessdef (Val.andl x (Vlong (Int64.sub n2 Int64.one))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andl a (longconst (Int64.sub n2 Int64.one))) v /\\\n  Val.lessdef (Val.andl x (Vlong (Int64.sub n2 Int64.one))) v","hypotheses":"(le : letenv) (a b : expr) (x : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some (Val.andl x (Vlong (Int64.sub n2 Int64.one)))) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l)","proofString":"eapply eval_andl; eauto.\napply eval_longconst."},{"statement":"(le : letenv) (a b : expr) (x : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some (Val.andl x (Vlong (Int64.sub n2 Int64.one)))) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l) : eval_expr ge sp e m le (longconst (Int64.sub n2 Int64.one))\n  (Vlong (Int64.sub n2 Int64.one)).","conclusion":"eval_expr ge sp e m le (longconst (Int64.sub n2 Int64.one))\n  (Vlong (Int64.sub n2 Int64.one))","hypotheses":"(le : letenv) (a b : expr) (x : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some (Val.andl x (Vlong (Int64.sub n2 Int64.one)))) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int64) (POW : Int64.is_power2 n2 = Some l)","proofString":"apply eval_longconst."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then modlu_base a b\n     else\n      match divlu_mul_params (Int64.unsigned n2) with\n      | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n      | None => modlu_base a b\n      end) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then modlu_base a b\n     else\n      match divlu_mul_params (Int64.unsigned n2) with\n      | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n      | None => modlu_base a b\n      end) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_modlu_base; eauto.\ndestruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z.\neapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) : exists v : val, eval_expr ge sp e m le (modlu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modlu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None)","proofString":"eapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divlu_mul_params (Int64.unsigned n2) with\n    | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n    | None => modlu_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divlu_mul_params (Int64.unsigned n2) with\n    | Some (p, m0) => Elet a (modl_from_divl (divlu_mull p m0) n2)\n    | None => modlu_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None)","proofString":"destruct (divlu_mul_params (Int64.unsigned n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z.\neapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"destruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z."},{"statement":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.modu i n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.modu i n2))) =\nSome z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"destruct (Int64.eq n2 Int64.zero) eqn:Z; inv H1.\nrewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef (Vlong (Int64.modu i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef (Vlong (Int64.modu i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"rewrite Int64.modu_divu.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto.\nred; intros; subst n2; discriminate Z."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef (Vlong (Int64.sub i (Int64.mul (Int64.divu i n2) n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2)) v /\\\n  Val.lessdef (Vlong (Int64.sub i (Int64.mul (Int64.divu i n2) n2))) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"econstructor; split; eauto.\neconstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2))\n  (Vlong (Int64.sub i (Int64.mul (Int64.divu i n2) n2))).","conclusion":"eval_expr ge sp e m le (Elet a (modl_from_divl (divlu_mull p M) n2))\n  (Vlong (Int64.sub i (Int64.mul (Int64.divu i n2) n2)))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"econstructor.\neauto.\neapply eval_modl_from_divl; eauto.\neapply eval_divlu_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : eval_expr ge sp e m (Vlong i :: le) (divlu_mull p M)\n  (Vlong (Int64.divu i n2)).","conclusion":"eval_expr ge sp e m (Vlong i :: le) (divlu_mull p M)\n  (Vlong (Int64.divu i n2))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"eapply eval_divlu_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M)) : n2 <> Int64.zero.","conclusion":"n2 <> Int64.zero","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (Z : Int64.eq n2 Int64.zero = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (p M : BinNums.Z) (PARAMS : divlu_mul_params (Int64.unsigned n2) = Some (p, M))","proofString":"red; intros; subst n2; discriminate Z."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (PARAMS : divlu_mul_params (Int64.unsigned n2) = None) : exists v : val, eval_expr ge sp e m le (modlu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modlu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modlu x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2 n2 = None) (PARAMS : divlu_mul_params (Int64.unsigned n2) = None)","proofString":"eapply eval_modlu_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (N2 : is_longconst b = None) : exists v : val, eval_expr ge sp e m le (modlu_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modlu_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (N2 : is_longconst b = None)","proofString":"eapply eval_modlu_base; eauto."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) : eval_expr ge sp e m le (divls_mull p M) (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le (divls_mull p M) (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"unfold divls_mull.\nassert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).\nconstructor; auto.\nexploit eval_mullhs.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_addl.\nauto.\neexact A1.\neexact A0.\nintros (v2 & A2 & B2).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int.repr 63).\nintros (v3 & A3 & B3).\nset (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) : eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).\nconstructor; auto.\nexploit eval_mullhs.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_addl.\nauto.\neexact A1.\neexact A0.\nintros (v2 & A2 & B2).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int.repr 63).\nintros (v3 & A3 & B3).\nset (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) : eval_expr ge sp e m le (Eletvar 0) (Vlong x).","conclusion":"eval_expr ge sp e m le (Eletvar 0) (Vlong x)","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x))","proofString":"constructor; auto."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) : eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x))","proofString":"exploit eval_mullhs.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int64.repr M).\nintros (v1 & A1 & B1).\nexploit eval_addl.\nauto.\neexact A1.\neexact A0.\nintros (v2 & A2 & B2).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int.repr 63).\nintros (v3 & A3 & B3).\nset (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) : (exists v : val,\n   eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v /\\\n   Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v) ->\neval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v /\\\n   Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v) ->\neval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x))","proofString":"intros (v1 & A1 & B1).\nexploit eval_addl.\nauto.\neexact A1.\neexact A0.\nintros (v2 & A2 & B2).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int.repr 63).\nintros (v3 & A3 & B3).\nset (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) : eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1)","proofString":"exploit eval_addl.\nauto.\neexact A1.\neexact A0.\nintros (v2 & A2 & B2).\nexploit eval_shrluimm.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int.repr 63).\nintros (v3 & A3 & B3).\nset (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) : eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2)","proofString":"exploit eval_shrluimm.\ntry apply HELPERS.\neexact A0.\ninstantiate (1 := Int.repr 63).\nintros (v3 & A3 & B3).\nset (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) : (exists v : val,\n   eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v /\\\n   Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v) ->\neval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v /\\\n   Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v) ->\neval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2)","proofString":"intros (v3 & A3 & B3).\nset (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) : eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl\n     (shrlimm\n        (if zlt M Int64.half_modulus\n         then mullhs (Eletvar 0) (Int64.repr M)\n         else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n        (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3)","proofString":"set (a4 := if zlt M Int64.half_modulus             then mullhs (Eletvar 0) (Int64.repr M)             else addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0)).\nset (v4 := if zlt M Int64.half_modulus then v1 else v2).\nassert (A4: eval_expr ge sp e m le a4 v4).\nunfold a4, v4; destruct (zlt M Int64.half_modulus); auto.\nexploit eval_shrlimm.\ntry apply HELPERS.\neexact A4.\ninstantiate (1 := Int.repr p).\nintros (v5 & A5 & B5).\nexploit eval_addl.\nauto.\neexact A5.\neexact A3.\nintros (v6 & A6 & B6).\nassert (RANGE: forall x, 0 <= x < 64 -> Int.ltu (Int.repr x) Int64.iwordsize' = true).\nintros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\nsimpl in B3; rewrite RANGE in B3 by lia; inv B3.\ndestruct (zlt M Int64.half_modulus).\nexploit (divls_mul_shift_1 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6.\nexploit (divls_mul_shift_2 x); eauto.\nintros [A B].\nsimpl in B5; rewrite RANGE in B5 by auto; inv B5.\nsimpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true.","conclusion":"forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6)","proofString":"intros.\nunfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64) : Int.ltu (Int.repr x0) Int64.iwordsize' = true.","conclusion":"Int.ltu (Int.repr x0) Int64.iwordsize' = true","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64)","proofString":"unfold Int.ltu.\nrewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64) : (if zlt (Int.unsigned (Int.repr x0)) (Int.unsigned Int64.iwordsize')\n then true\n else false) = true.","conclusion":"(if zlt (Int.unsigned (Int.repr x0)) (Int.unsigned Int64.iwordsize')\n then true\n else false) = true","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64)","proofString":"rewrite Int.unsigned_repr.\nrewrite zlt_true by tauto.\nauto.\nassert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64) : (if zlt x0 (Int.unsigned Int64.iwordsize') then true else false) = true.","conclusion":"(if zlt x0 (Int.unsigned Int64.iwordsize') then true else false) = true","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64)","proofString":"rewrite zlt_true by tauto.\nauto."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64) : true = true.","conclusion":"true = true","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64)","proofString":"auto."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64) : 0 <= x0 <= Int.max_unsigned.","conclusion":"0 <= x0 <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64)","proofString":"assert (64 < Int.max_unsigned) by (compute; auto).\nlia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64) (H2 : 64 < Int.max_unsigned) : 0 <= x0 <= Int.max_unsigned.","conclusion":"0 <= x0 <= Int.max_unsigned","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (v1 : val) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M)) v1) (B1 : Val.lessdef (Val.mullhs (Vlong x) (Vlong (Int64.repr M))) v1) (v2 : val) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  v2) (B2 : Val.lessdef (Val.addl v1 (Vlong x)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63)) v3) (B3 : Val.lessdef (Val.shrlu (Vlong x) (Vint (Int.repr 63))) v3) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (v5 : val) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p)) v5) (B5 : Val.lessdef (Val.shrl v4 (Vint (Int.repr p))) v5) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef (Val.addl v5 v3) v6) (x0 : Z) (H1 : 0 <= x0 < 64) (H2 : 64 < Int.max_unsigned)","proofString":"lia."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (l : M < Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p)))) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef\n  (Val.addl (Vlong (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p)))\n     (Vlong (Int64.shru' x (Int.repr 63)))) v6) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))) : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (l : M < Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p)))) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef\n  (Val.addl (Vlong (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p)))\n     (Vlong (Int64.shru' x (Int.repr 63)))) v6) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)))","proofString":"simpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (l : M < Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p)))) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63)))\n  (Vlong\n     (Int64.add (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p))\n        (Int64.shru' x (Int.repr 63))))) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))) : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (l : M < Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p)))) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63)))\n  (Vlong\n     (Int64.add (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p))\n        (Int64.shru' x (Int.repr 63))))) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add (Int64.shr' (Int64.mulhs x (Int64.repr M)) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)))","proofString":"rewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (g : M >= Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong\n     (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p)))) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef\n  (Val.addl\n     (Vlong\n        (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p)))\n     (Vlong (Int64.shru' x (Int.repr 63)))) v6) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))) : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (g : M >= Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong\n     (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p)))) (v6 : val) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63))) v6) (B6 : Val.lessdef\n  (Val.addl\n     (Vlong\n        (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p)))\n     (Vlong (Int64.shru' x (Int.repr 63)))) v6) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)))","proofString":"simpl in B6; inv B6.\nrewrite B; exact A6."},{"statement":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (g : M >= Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong\n     (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p)))) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63)))\n  (Vlong\n     (Int64.add\n        (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p))\n        (Int64.shru' x (Int.repr 63))))) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63))) : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y)).","conclusion":"eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p))\n     (shrluimm (Eletvar 0) (Int.repr (Int64.zwordsize - 1))))\n  (Vlong (Int64.divs x y))","hypotheses":"(le : list val) (x y : int64) (p M : Z) (H : divls_mul_params (Int64.signed y) = Some (p, M)) (H0 : nth_error le 0 = Some (Vlong x)) (A0 : eval_expr ge sp e m le (Eletvar 0) (Vlong x)) (A1 : eval_expr ge sp e m le (mullhs (Eletvar 0) (Int64.repr M))\n  (Vlong (Int64.mulhs x (Int64.repr M)))) (A2 : eval_expr ge sp e m le (addl (mullhs (Eletvar 0) (Int64.repr M)) (Eletvar 0))\n  (Vlong (Int64.add (Int64.mulhs x (Int64.repr M)) x))) (A3 : eval_expr ge sp e m le (shrluimm (Eletvar 0) (Int.repr 63))\n  (Vlong (Int64.shru' x (Int.repr 63)))) (g : M >= Int64.half_modulus) (a4 : expr) (v4 : val) (A4 : eval_expr ge sp e m le a4 v4) (A5 : eval_expr ge sp e m le (shrlimm a4 (Int.repr p))\n  (Vlong\n     (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p)))) (A6 : eval_expr ge sp e m le\n  (addl (shrlimm a4 (Int.repr p)) (shrluimm (Eletvar 0) (Int.repr 63)))\n  (Vlong\n     (Int64.add\n        (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p))\n        (Int64.shru' x (Int.repr 63))))) (RANGE : forall x0 : Z, 0 <= x0 < 64 -> Int.ltu (Int.repr x0) Int64.iwordsize' = true) (A : 0 <= p < 64) (B : Int64.divs x y =\nInt64.add\n  (Int64.shr' (Int64.add (Int64.mulhs x (Int64.repr M)) x) (Int.repr p))\n  (Int64.shru' x (Int.repr 63)))","proofString":"rewrite B; exact A6."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.divs n1 n2)\n        | None =>\n            match Int64.is_power2' n2 with\n            | Some l =>\n                if Int.ltu l (Int.repr 63)\n                then shrxlimm a l\n                else divls_base a b\n            | None =>\n                if Compopts.optim_for_size tt\n                then divls_base a b\n                else\n                 match divls_mul_params (Int64.signed n2) with\n                 | Some (p, m0) => Elet a (divls_mull p m0)\n                 | None => divls_base a b\n                 end\n            end\n        end\n    | None => divls_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.divs n1 n2)\n        | None =>\n            match Int64.is_power2' n2 with\n            | Some l =>\n                if Int.ltu l (Int.repr 63)\n                then shrxlimm a l\n                else divls_base a b\n            | None =>\n                if Compopts.optim_for_size tt\n                then divls_base a b\n                else\n                 match divls_mul_params (Int64.signed n2) with\n                 | Some (p, m0) => Elet a (divls_mull p m0)\n                 | None => divls_base a b\n                 end\n            end\n        end\n    | None => divls_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z)","proofString":"destruct (is_longconst b) as [n2|] eqn:N2.\nassert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\nexploit Val.divls_pow2; eauto.\nintros EQ.\neapply eval_shrxlimm; eauto.\neapply eval_divls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto.\neapply eval_divls_base; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divs n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then divls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (divls_mull p m0)\n             | None => divls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divs n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then divls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (divls_mull p m0)\n             | None => divls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2)","proofString":"assert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\nexploit Val.divls_pow2; eauto.\nintros EQ.\neapply eval_shrxlimm; eauto.\neapply eval_divls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divs n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then divls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (divls_mull p m0)\n             | None => divls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divs n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then divls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (divls_mull p m0)\n             | None => divls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2)","proofString":"subst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\nexploit Val.divls_pow2; eauto.\nintros EQ.\neapply eval_shrxlimm; eauto.\neapply eval_divls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divs n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then divls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (divls_mull p m0)\n             | None => divls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.divs n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then divls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (divls_mull p m0)\n             | None => divls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2)","proofString":"destruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\nexploit Val.divls_pow2; eauto.\nintros EQ.\neapply eval_shrxlimm; eauto.\neapply eval_divls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1)","proofString":"assert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1)","proofString":"subst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.divls (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.divls (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"simpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.divs n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.divs n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"destruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.divs n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.divs n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.divs n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"econstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) : exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n    | None =>\n        if Compopts.optim_for_size tt\n        then divls_base a b\n        else\n         match divls_mul_params (Int64.signed n2) with\n         | Some (p, m0) => Elet a (divls_mull p m0)\n         | None => divls_base a b\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b\n    | None =>\n        if Compopts.optim_for_size tt\n        then divls_base a b\n        else\n         match divls_mul_params (Int64.signed n2) with\n         | Some (p, m0) => Elet a (divls_mull p m0)\n         | None => divls_base a b\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None)","proofString":"destruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\nexploit Val.divls_pow2; eauto.\nintros EQ.\neapply eval_shrxlimm; eauto.\neapply eval_divls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_divls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 63) then shrxlimm a l else divls_base a b) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l)","proofString":"destruct (Int.ltu l (Int.repr 63)) eqn:LT.\nexploit Val.divls_pow2; eauto.\nintros EQ.\neapply eval_shrxlimm; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) : exists v : val, eval_expr ge sp e m le (shrxlimm a l) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (shrxlimm a l) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true)","proofString":"exploit Val.divls_pow2; eauto.\nintros EQ.\neapply eval_shrxlimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) : Val.shrxl x (Vint l) = Some z ->\nexists v : val, eval_expr ge sp e m le (shrxlimm a l) v /\\ Val.lessdef z v.","conclusion":"Val.shrxl x (Vint l) = Some z ->\nexists v : val, eval_expr ge sp e m le (shrxlimm a l) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true)","proofString":"intros EQ.\neapply eval_shrxlimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (EQ : Val.shrxl x (Vint l) = Some z) : exists v : val, eval_expr ge sp e m le (shrxlimm a l) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (shrxlimm a l) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (EQ : Val.shrxl x (Vint l) = Some z)","proofString":"eapply eval_shrxlimm; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = false) : exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = false)","proofString":"eapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divls_base a b\n     else\n      match divls_mul_params (Int64.signed n2) with\n      | Some (p, m0) => Elet a (divls_mull p m0)\n      | None => divls_base a b\n      end) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then divls_base a b\n     else\n      match divls_mul_params (Int64.signed n2) with\n      | Some (p, m0) => Elet a (divls_mull p m0)\n      | None => divls_base a b\n      end) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_divls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"eapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divls_mul_params (Int64.signed n2) with\n    | Some (p, m0) => Elet a (divls_mull p m0)\n    | None => divls_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divls_mul_params (Int64.signed n2) with\n    | Some (p, m0) => Elet a (divls_mull p m0)\n    | None => divls_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"destruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto.\neapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (divls_mull p M)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (divls_mull p M)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"destruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.divs i n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (divls_mull p M)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (divls_mull p M)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.divs i n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"destruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (divls_mull p M)) v /\\\n  Val.lessdef (Vlong (Int64.divs i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (divls_mull p M)) v /\\\n  Val.lessdef (Vlong (Int64.divs i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"econstructor; split; eauto.\neconstructor.\neauto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : eval_expr ge sp e m le (Elet a (divls_mull p M)) (Vlong (Int64.divs i n2)).","conclusion":"eval_expr ge sp e m le (Elet a (divls_mull p M)) (Vlong (Int64.divs i n2))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"econstructor.\neauto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (PARAMS : divls_mul_params (Int64.signed n2) = None) : exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.divls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (PARAMS : divls_mul_params (Int64.signed n2) = None)","proofString":"eapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (N2 : is_longconst b = None) : exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (divls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (N2 : is_longconst b = None)","proofString":"eapply eval_divls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.mods n1 n2)\n        | None =>\n            match Int64.is_power2' n2 with\n            | Some l =>\n                if Int.ltu l (Int.repr 63)\n                then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n                else modls_base a b\n            | None =>\n                if Compopts.optim_for_size tt\n                then modls_base a b\n                else\n                 match divls_mul_params (Int64.signed n2) with\n                 | Some (p, m0) =>\n                     Elet a (modl_from_divl (divls_mull p m0) n2)\n                 | None => modls_base a b\n                 end\n            end\n        end\n    | None => modls_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst b with\n    | Some n2 =>\n        match is_longconst a with\n        | Some n1 => longconst (Int64.mods n1 n2)\n        | None =>\n            match Int64.is_power2' n2 with\n            | Some l =>\n                if Int.ltu l (Int.repr 63)\n                then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n                else modls_base a b\n            | None =>\n                if Compopts.optim_for_size tt\n                then modls_base a b\n                else\n                 match divls_mul_params (Int64.signed n2) with\n                 | Some (p, m0) =>\n                     Elet a (modl_from_divl (divls_mull p m0) n2)\n                 | None => modls_base a b\n                 end\n            end\n        end\n    | None => modls_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z)","proofString":"destruct (is_longconst b) as [n2|] eqn:N2.\nassert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto.\neapply eval_modls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto.\neapply eval_modls_base; eauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.mods n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63)\n            then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n            else modls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then modls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n             | None => modls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.mods n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63)\n            then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n            else modls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then modls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n             | None => modls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2)","proofString":"assert (y = Vlong n2) by (eapply is_longconst_sound; eauto).\nsubst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto.\neapply eval_modls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.mods n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63)\n            then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n            else modls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then modls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n             | None => modls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.mods n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63)\n            then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n            else modls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then modls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n             | None => modls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (n2 : int64) (N2 : is_longconst b = Some n2) (H2 : y = Vlong n2)","proofString":"subst y.\ndestruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto.\neapply eval_modls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.mods n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63)\n            then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n            else modls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then modls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n             | None => modls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 => longconst (Int64.mods n1 n2)\n    | None =>\n        match Int64.is_power2' n2 with\n        | Some l =>\n            if Int.ltu l (Int.repr 63)\n            then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n            else modls_base a b\n        | None =>\n            if Compopts.optim_for_size tt\n            then modls_base a b\n            else\n             match divls_mul_params (Int64.signed n2) with\n             | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n             | None => modls_base a b\n             end\n        end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2)","proofString":"destruct (is_longconst a) as [n1|] eqn:N1.\nassert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor.\ndestruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto.\neapply eval_modls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1)","proofString":"assert (x = Vlong n1) by (eapply is_longconst_sound; eauto).\nsubst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (n1 : int64) (N1 : is_longconst a = Some n1) (H2 : x = Vlong n1)","proofString":"subst x.\nsimpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.modls (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : Val.modls (Vlong n1) (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"simpl in H1.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.mods n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (z : val) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.mods n1 n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"destruct (Int64.eq n2 Int64.zero         || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods n1 n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mods n1 n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods n1 n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (H : eval_expr ge sp e m le a (Vlong n1)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = Some n1)","proofString":"econstructor; split.\napply eval_longconst.\nconstructor."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) : exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 63)\n        then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n        else modls_base a b\n    | None =>\n        if Compopts.optim_for_size tt\n        then modls_base a b\n        else\n         match divls_mul_params (Int64.signed n2) with\n         | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n         | None => modls_base a b\n         end\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n2 with\n    | Some l =>\n        if Int.ltu l (Int.repr 63)\n        then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n        else modls_base a b\n    | None =>\n        if Compopts.optim_for_size tt\n        then modls_base a b\n        else\n         match divls_mul_params (Int64.signed n2) with\n         | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n         | None => modls_base a b\n         end\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None)","proofString":"destruct (Int64.is_power2' n2) as [l|] eqn:POW.\ndestruct (Int.ltu l (Int.repr 63)) eqn:LT.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto.\neapply eval_modls_base; eauto.\ndestruct (Compopts.optim_for_size tt).\neapply eval_modls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 63)\n     then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n     else modls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu l (Int.repr 63)\n     then Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)\n     else modls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l)","proofString":"destruct (Int.ltu l (Int.repr 63)) eqn:LT.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true)","proofString":"destruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.mods i n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.mods i n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true)","proofString":"destruct (Int64.eq n2 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone) eqn:D; inv H1.\nassert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true)","proofString":"assert (Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))).\nsimpl; rewrite D; auto.\nexploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2)).","conclusion":"Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true)","proofString":"simpl; rewrite D; auto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2)))","proofString":"exploit Val.divls_pow2; eauto.\nintros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))) : Val.shrxl (Vlong i) (Vint l) = Some (Vlong (Int64.divs i n2)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v.","conclusion":"Val.shrxl (Vlong i) (Vint l) = Some (Vlong (Int64.divs i n2)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2)))","proofString":"intros EQ.\nset (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))) (EQ : Val.shrxl (Vlong i) (Vint l) = Some (Vlong (Int64.divs i n2))) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (modl_from_divl (shrxlimm (Eletvar 0) l) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))) (EQ : Val.shrxl (Vlong i) (Vint l) = Some (Vlong (Int64.divs i n2)))","proofString":"set (le' := Vlong i :: le).\nassert (A: eval_expr ge sp e m le' (Eletvar O) (Vlong i)) by (constructor; auto).\nexploit eval_shrxlimm; eauto.\nintros (v1 & A1 & B1).\ninv B1.\neconstructor; split.\neconstructor.\neauto.\neapply eval_modl_from_divl.\neexact A1.\nreflexivity.\nrewrite Int64.mods_divs.\nauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))) (EQ : Val.shrxl (Vlong i) (Vint l) = Some (Vlong (Int64.divs i n2))) (le' : list val) (A : eval_expr ge sp e m le' (Eletvar 0) (Vlong i)) (A1 : eval_expr ge sp e m le' (shrxlimm (Eletvar 0) l) (Vlong (Int64.divs i n2))) : Val.lessdef (Vlong (Int64.sub i (Int64.mul (Int64.divs i n2) n2)))\n  (Vlong (Int64.sub i (Int64.mul (Int64.divs i n2) n2))).","conclusion":"Val.lessdef (Vlong (Int64.sub i (Int64.mul (Int64.divs i n2) n2)))\n  (Vlong (Int64.sub i (Int64.mul (Int64.divs i n2) n2)))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (D : Int64.eq n2 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone = false) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = true) (H1 : Val.divls (Vlong i) (Vlong n2) = Some (Vlong (Int64.divs i n2))) (EQ : Val.shrxl (Vlong i) (Vint l) = Some (Vlong (Int64.divs i n2))) (le' : list val) (A : eval_expr ge sp e m le' (Eletvar 0) (Vlong i)) (A1 : eval_expr ge sp e m le' (shrxlimm (Eletvar 0) l) (Vlong (Int64.divs i n2)))","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = false) : exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (l : int) (POW : Int64.is_power2' n2 = Some l) (LT : Int.ltu l (Int.repr 63) = false)","proofString":"eapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then modls_base a b\n     else\n      match divls_mul_params (Int64.signed n2) with\n      | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n      | None => modls_base a b\n      end) v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Compopts.optim_for_size tt\n     then modls_base a b\n     else\n      match divls_mul_params (Int64.signed n2) with\n      | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n      | None => modls_base a b\n      end) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"destruct (Compopts.optim_for_size tt).\neapply eval_modls_base; eauto.\ndestruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"eapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    match divls_mul_params (Int64.signed n2) with\n    | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n    | None => modls_base a b\n    end v /\\ Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match divls_mul_params (Int64.signed n2) with\n    | Some (p, m0) => Elet a (modl_from_divl (divls_mull p m0) n2)\n    | None => modls_base a b\n    end v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None)","proofString":"destruct (divls_mul_params (Int64.signed n2)) as [[p M]|] eqn:PARAMS.\ndestruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto.\neapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"destruct x; simpl in H1; try discriminate.\ndestruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.mods i n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H1 : (if\n  Int64.eq n2 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n then None\n else Some (Vlong (Int64.mods i n2))) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"destruct (Int64.eq n2 Int64.zero             || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone); inv H1.\neconstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2)) v /\\\n  Val.lessdef (Vlong (Int64.mods i n2)) v","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"econstructor; split; eauto.\neconstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2))\n  (Vlong (Int64.mods i n2)).","conclusion":"eval_expr ge sp e m le (Elet a (modl_from_divl (divls_mull p M) n2))\n  (Vlong (Int64.mods i n2))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"econstructor.\neauto.\nrewrite Int64.mods_divs.\neapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : eval_expr ge sp e m (Vlong i :: le) (modl_from_divl (divls_mull p M) n2)\n  (Vlong (Int64.sub i (Int64.mul (Int64.divs i n2) n2))).","conclusion":"eval_expr ge sp e m (Vlong i :: le) (modl_from_divl (divls_mull p M) n2)\n  (Vlong (Int64.sub i (Int64.mul (Int64.divs i n2) n2)))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"eapply eval_modl_from_divl; auto.\neapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M)) : eval_expr ge sp e m (Vlong i :: le) (divls_mull p M)\n  (Vlong (Int64.divs i n2)).","conclusion":"eval_expr ge sp e m (Vlong i :: le) (divls_mull p M)\n  (Vlong (Int64.divs i n2))","hypotheses":"(le : letenv) (a b : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (n2 : int64) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (p M : Z) (PARAMS : divls_mul_params (Int64.signed n2) = Some (p, M))","proofString":"eapply eval_divls_mull; eauto."},{"statement":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (PARAMS : divls_mul_params (Int64.signed n2) = None) : exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x z : val) (H : eval_expr ge sp e m le a x) (n2 : int64) (H1 : Val.modls x (Vlong n2) = Some z) (H0 : eval_expr ge sp e m le b (Vlong n2)) (N2 : is_longconst b = Some n2) (N1 : is_longconst a = None) (POW : Int64.is_power2' n2 = None) (PARAMS : divls_mul_params (Int64.signed n2) = None)","proofString":"eapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (N2 : is_longconst b = None) : exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (modls_base a b) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (N2 : is_longconst b = None)","proofString":"eapply eval_modls_base; eauto."},{"statement":"(le : letenv) (a b : expr) (x y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (divf a b) v /\\ Val.lessdef (Val.divf x y) v.","conclusion":"eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (divf a b) v /\\ Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a b : expr) (x y : val)","proofString":"unfold divf.\ndestruct (divf_match b); intros.\nunfold divfimm.\ndestruct (Float.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match divf_match b with\n    | divf_case1 n2 => divfimm a n2\n    | divf_default e2 => Eop Odivf (a ::: e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.divf x y) v.","conclusion":"eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match divf_match b with\n    | divf_case1 n2 => divfimm a n2\n    | divf_default e2 => Eop Odivf (a ::: e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a b : expr) (x y : val)","proofString":"destruct (divf_match b); intros.\nunfold divfimm.\ndestruct (Float.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (divfimm a n2) v /\\ Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (divfimm a n2) v /\\ Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y)","proofString":"unfold divfimm.\ndestruct (Float.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le\n    match Float.exact_inverse n2 with\n    | Some n' => Eop Omulf (a ::: Eop (Ofloatconst n') Enil ::: Enil)\n    | None => Eop Odivf (a ::: Eop (Ofloatconst n2) Enil ::: Enil)\n    end v /\\ Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Float.exact_inverse n2 with\n    | Some n' => Eop Omulf (a ::: Eop (Ofloatconst n') Enil ::: Enil)\n    | None => Eop Odivf (a ::: Eop (Ofloatconst n2) Enil ::: Enil)\n    end v /\\ Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y)","proofString":"destruct (Float.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2')","proofString":"inv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') (vl : list val) (H4 : eval_exprlist ge sp e m le Enil vl) (H6 : eval_operation ge sp (Ofloatconst n2) vl m = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') (vl : list val) (H4 : eval_exprlist ge sp e m le Enil vl) (H6 : eval_operation ge sp (Ofloatconst n2) vl m = Some y)","proofString":"inv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') (H6 : eval_operation ge sp (Ofloatconst n2) nil m = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') (H6 : eval_operation ge sp (Ofloatconst n2) nil m = Some y)","proofString":"simpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') (H6 : Some (Vfloat n2) = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') (H6 : Some (Vfloat n2) = Some y)","proofString":"inv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x (Vfloat n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulf (a ::: Eop (Ofloatconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x (Vfloat n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (n2 : float) (H : eval_expr ge sp e m le a x) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2')","proofString":"econstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (f n2 : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2') : Val.lessdef (Vfloat (Float.div f n2)) (Vfloat (Float.mul f n2')).","conclusion":"Val.lessdef (Vfloat (Float.div f n2)) (Vfloat (Float.mul f n2'))","hypotheses":"(le : letenv) (a : expr) (f n2 : float) (H : eval_expr ge sp e m le a (Vfloat f)) (n2' : float) (EINV : Float.exact_inverse n2 = Some n2')","proofString":"erewrite Float.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y) (EINV : Float.exact_inverse n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Odivf (a ::: Eop (Ofloatconst n2) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Odivf (a ::: Eop (Ofloatconst n2) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ofloatconst n2) Enil) y) (EINV : Float.exact_inverse n2 = None)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivf (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Odivf (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.divf x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (divfs a b) v /\\ Val.lessdef (Val.divfs x y) v.","conclusion":"eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (divfs a b) v /\\ Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a b : expr) (x y : val)","proofString":"unfold divfs.\ndestruct (divfs_match b); intros.\nunfold divfsimm.\ndestruct (Float32.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match divfs_match b with\n    | divfs_case1 n2 => divfsimm a n2\n    | divfs_default e2 => Eop Odivfs (a ::: e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.divfs x y) v.","conclusion":"eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match divfs_match b with\n    | divfs_case1 n2 => divfsimm a n2\n    | divfs_default e2 => Eop Odivfs (a ::: e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a b : expr) (x y : val)","proofString":"destruct (divfs_match b); intros.\nunfold divfsimm.\ndestruct (Float32.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (divfsimm a n2) v /\\ Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (divfsimm a n2) v /\\ Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y)","proofString":"unfold divfsimm.\ndestruct (Float32.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le\n    match Float32.exact_inverse n2 with\n    | Some n' => Eop Omulfs (a ::: Eop (Osingleconst n') Enil ::: Enil)\n    | None => Eop Odivfs (a ::: Eop (Osingleconst n2) Enil ::: Enil)\n    end v /\\ Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Float32.exact_inverse n2 with\n    | Some n' => Eop Omulfs (a ::: Eop (Osingleconst n') Enil ::: Enil)\n    | None => Eop Odivfs (a ::: Eop (Osingleconst n2) Enil ::: Enil)\n    end v /\\ Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y)","proofString":"destruct (Float32.exact_inverse n2) as [n2' | ] eqn:EINV.\ninv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2')","proofString":"inv H0.\ninv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') (vl : list val) (H4 : eval_exprlist ge sp e m le Enil vl) (H6 : eval_operation ge sp (Osingleconst n2) vl m = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') (vl : list val) (H4 : eval_exprlist ge sp e m le Enil vl) (H6 : eval_operation ge sp (Osingleconst n2) vl m = Some y)","proofString":"inv H4.\nsimpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') (H6 : eval_operation ge sp (Osingleconst n2) nil m = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') (H6 : eval_operation ge sp (Osingleconst n2) nil m = Some y)","proofString":"simpl in H6.\ninv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') (H6 : Some (Vsingle n2) = Some y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') (H6 : Some (Vsingle n2) = Some y)","proofString":"inv H6.\neconstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x (Vsingle n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Omulfs (a ::: Eop (Osingleconst n2') Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x (Vsingle n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2')","proofString":"econstructor; split.\nrepeat (econstructor; eauto).\ndestruct x; simpl; auto.\nerewrite Float32.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (f n2 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2') : Val.lessdef (Vsingle (Float32.div f n2)) (Vsingle (Float32.mul f n2')).","conclusion":"Val.lessdef (Vsingle (Float32.div f n2)) (Vsingle (Float32.mul f n2'))","hypotheses":"(le : letenv) (a : expr) (f n2 : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n2' : float32) (EINV : Float32.exact_inverse n2 = Some n2')","proofString":"erewrite Float32.div_mul_inverse; eauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y) (EINV : Float32.exact_inverse n2 = None) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Odivfs (a ::: Eop (Osingleconst n2) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Odivfs (a ::: Eop (Osingleconst n2) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (n2 : float32) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Osingleconst n2) Enil) y) (EINV : Float32.exact_inverse n2 = None)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivfs (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Odivfs (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.divfs x y) v","hypotheses":"(le : letenv) (a : expr) (x y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."}]}