{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Switch.v","fileSamples":[{"statement":"(default act : nat) (cases : table) (lo hi : Z) (H : match cases with\n| nil => (act =? default)%nat\n| (key1, act1) :: _ => zeq key1 lo && zeq lo hi && (act =? act1)%nat\nend = true) : wf_comptree (CTaction act).","proofString":"constructor."},{"statement":"(default : nat) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true -> wf_comptree t) (cases : table) (lo hi : Z) (H1 : (let (o, others) := split_eq key cases in\n match o with\n | Some act' =>\n     (act =? act')%nat &&\n     validate default others t (refine_low_bound key lo)\n       (refine_high_bound key hi)\n | None => false\n end) = true) (H0 : key < modulus) (H : 0 <= key) : wf_comptree (CTifeq key act t).","proofString":"destruct (split_eq key cases) as [[act'|] others]; try discriminate; InvBooleans.\nconstructor; eauto."},{"statement":"(default : nat) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true -> wf_comptree t) (cases : table) (lo hi : Z) (act' : nat) (others : table) (H0 : key < modulus) (H : 0 <= key) (H2 : (act =? act')%nat = true) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) : wf_comptree (CTifeq key act t).","proofString":"constructor; eauto."},{"statement":"(default : nat) (key : Z) (t1 t2 : comptree) (IHt1 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t1 lo0 hi0 = true -> wf_comptree t1) (IHt2 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t2 lo0 hi0 = true -> wf_comptree t2) (cases : table) (lo hi : Z) (H1 : (let (lcases, rcases) := split_lt key cases in\n validate default lcases t1 lo (key - 1) && validate default rcases t2 key hi) =\ntrue) (H0 : key < modulus) (H : 0 <= key) : wf_comptree (CTiflt key t1 t2).","proofString":"destruct (split_lt key cases) as [lc rc]; InvBooleans.\nconstructor; eauto."},{"statement":"(default : nat) (key : Z) (t1 t2 : comptree) (IHt1 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t1 lo0 hi0 = true -> wf_comptree t1) (IHt2 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t2 lo0 hi0 = true -> wf_comptree t2) (cases : table) (lo hi : Z) (lc rc : table) (H0 : key < modulus) (H : 0 <= key) (H2 : validate default lc t1 lo (key - 1) = true) (H3 : validate default rc t2 key hi = true) : wf_comptree (CTiflt key t1 t2).","proofString":"constructor; eauto."},{"statement":"(default : nat) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true -> wf_comptree t) (cases : table) (lo hi : Z) (H1 : (let (inside, outside) := split_between default ofs sz cases in\n validate_jumptable inside acts ofs && validate default outside t lo hi) =\ntrue) (H : ofs < modulus) (H0 : 0 <= ofs) (H6 : 0 <= sz) (H5 : sz < modulus) (H4 : ofs + sz <= modulus) (H3 : sz <= list_length_z acts) (H2 : sz < Int.modulus) : wf_comptree (CTjumptable ofs sz acts t).","proofString":"destruct (split_between default ofs sz cases) as [ins out]; InvBooleans.\nconstructor; eauto."},{"statement":"(default : nat) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true -> wf_comptree t) (cases : table) (lo hi : Z) (ins : ZMap.t nat) (out : table) (H : ofs < modulus) (H0 : 0 <= ofs) (H6 : 0 <= sz) (H5 : sz < modulus) (H4 : ofs + sz <= modulus) (H3 : sz <= list_length_z acts) (H2 : sz < Int.modulus) (H7 : validate_jumptable ins acts ofs = true) (H8 : validate default out t lo hi = true) : wf_comptree (CTjumptable ofs sz acts t).","proofString":"constructor; eauto."},{"statement":"(v : Z) (default : nat) (n : Z) (optact : option nat) (cases' : table) : (None, nil) = (optact, cases') ->\ndefault =\n(if zeq v n\n then match optact with\n      | Some act => act\n      | None => default\n      end\n else switch_target v default cases').","proofString":"intros.\ninv H.\nsimpl.\ndestruct (zeq v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) (optact : option nat) (cases' : table) (H : (None, nil) = (optact, cases')) : default =\n(if zeq v n\n then match optact with\n      | Some act => act\n      | None => default\n      end\n else switch_target v default cases').","proofString":"inv H.\nsimpl.\ndestruct (zeq v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) : default = (if zeq v n then default else switch_target v default nil).","proofString":"simpl.\ndestruct (zeq v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) : default = (if zeq v n then default else default).","proofString":"destruct (zeq v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) (a : Z * nat) (cases : list (Z * nat)) (IHcases : forall (optact0 : option nat) (cases'0 : table),\nsplit_eq n cases = (optact0, cases'0) ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act => act\n      | None => default\n      end\n else switch_target v default cases'0)) (optact : option nat) (cases' : table) : (let (key, act) := a in\n let (same, others) := split_eq n cases in\n if zeq key n then (Some act, others) else (same, (key, act) :: others)) =\n(optact, cases') ->\n(let (key, action) := a in\n if zeq v key then action else switch_target v default cases) =\n(if zeq v n\n then match optact with\n      | Some act => act\n      | None => default\n      end\n else switch_target v default cases').","proofString":"destruct a as [key act].\ndestruct (split_eq n cases) as [same other] eqn:SEQ.\nrewrite (IHcases same other) by auto.\ndestruct (zeq key n); intros EQ; inv EQ.\ndestruct (zeq v n); auto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zeq_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (IHcases : forall (optact0 : option nat) (cases'0 : table),\nsplit_eq n cases = (optact0, cases'0) ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases'0)) (optact : option nat) (cases' : table) : (let (same, others) := split_eq n cases in\n if zeq key n then (Some act, others) else (same, (key, act) :: others)) =\n(optact, cases') ->\n(if zeq v key then act else switch_target v default cases) =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases').","proofString":"destruct (split_eq n cases) as [same other] eqn:SEQ.\nrewrite (IHcases same other) by auto.\ndestruct (zeq key n); intros EQ; inv EQ.\ndestruct (zeq v n); auto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zeq_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (same : option nat) (other : table) (SEQ : split_eq n cases = (same, other)) (IHcases : forall (optact0 : option nat) (cases'0 : table),\n(same, other) = (optact0, cases'0) ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases'0)) (optact : option nat) (cases' : table) : (if zeq key n then (Some act, other) else (same, (key, act) :: other)) =\n(optact, cases') ->\n(if zeq v key then act else switch_target v default cases) =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases').","proofString":"rewrite (IHcases same other) by auto.\ndestruct (zeq key n); intros EQ; inv EQ.\ndestruct (zeq v n); auto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zeq_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (same : option nat) (other : table) (SEQ : split_eq n cases = (same, other)) (IHcases : forall (optact0 : option nat) (cases'0 : table),\n(same, other) = (optact0, cases'0) ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases'0)) (optact : option nat) (cases' : table) : (if zeq key n then (Some act, other) else (same, (key, act) :: other)) =\n(optact, cases') ->\n(if zeq v key\n then act\n else\n  if zeq v n\n  then match same with\n       | Some act0 => act0\n       | None => default\n       end\n  else switch_target v default other) =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases').","proofString":"destruct (zeq key n); intros EQ; inv EQ.\ndestruct (zeq v n); auto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zeq_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n : Z) (act : nat) (cases : list (Z * nat)) (same : option nat) (cases' : table) (IHcases : forall (optact : option nat) (cases'0 : table),\n(same, cases') = (optact, cases'0) ->\nswitch_target v default cases =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases'0)) (SEQ : split_eq n cases = (same, cases')) : (if zeq v n\n then act\n else\n  if zeq v n\n  then match same with\n       | Some act0 => act0\n       | None => default\n       end\n  else switch_target v default cases') =\n(if zeq v n then act else switch_target v default cases').","proofString":"destruct (zeq v n); auto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (other : table) (optact : option nat) (IHcases : forall (optact0 : option nat) (cases' : table),\n(optact, other) = (optact0, cases') ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases')) (SEQ : split_eq n cases = (optact, other)) (n0 : key <> n) : (if zeq v key\n then act\n else\n  if zeq v n\n  then match optact with\n       | Some act0 => act0\n       | None => default\n       end\n  else switch_target v default other) =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default ((key, act) :: other)).","proofString":"simpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zeq_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (other : table) (optact : option nat) (IHcases : forall (optact0 : option nat) (cases' : table),\n(optact, other) = (optact0, cases') ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases')) (SEQ : split_eq n cases = (optact, other)) (n0 : key <> n) : (if zeq v key\n then act\n else\n  if zeq v n\n  then match optact with\n       | Some act0 => act0\n       | None => default\n       end\n  else switch_target v default other) =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else if zeq v key then act else switch_target v default other).","proofString":"destruct (zeq v key).\nsubst v.\nrewrite zeq_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (other : table) (optact : option nat) (IHcases : forall (optact0 : option nat) (cases' : table),\n(optact, other) = (optact0, cases') ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases')) (SEQ : split_eq n cases = (optact, other)) (n0 : key <> n) (e : v = key) : act =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else act).","proofString":"subst v.\nrewrite zeq_false by auto.\nauto."},{"statement":"(default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (other : table) (optact : option nat) (IHcases : forall (optact0 : option nat) (cases' : table),\n(optact, other) = (optact0, cases') ->\nswitch_target key default cases =\n(if zeq key n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target key default cases')) (SEQ : split_eq n cases = (optact, other)) (n0 : key <> n) : act =\n(if zeq key n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else act).","proofString":"rewrite zeq_false by auto.\nauto."},{"statement":"(default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (other : table) (optact : option nat) (IHcases : forall (optact0 : option nat) (cases' : table),\n(optact, other) = (optact0, cases') ->\nswitch_target key default cases =\n(if zeq key n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target key default cases')) (SEQ : split_eq n cases = (optact, other)) (n0 : key <> n) : act = act.","proofString":"auto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (other : table) (optact : option nat) (IHcases : forall (optact0 : option nat) (cases' : table),\n(optact, other) = (optact0, cases') ->\nswitch_target v default cases =\n(if zeq v n\n then match optact0 with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default cases')) (SEQ : split_eq n cases = (optact, other)) (n0 : key <> n) (n1 : v <> key) : (if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default other) =\n(if zeq v n\n then match optact with\n      | Some act0 => act0\n      | None => default\n      end\n else switch_target v default other).","proofString":"auto."},{"statement":"(v : Z) (default : nat) (n : Z) (lcases rcases : table) : (nil, nil) = (lcases, rcases) ->\ndefault =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases).","proofString":"intros.\ninv H.\nsimpl.\ndestruct (zlt v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) (lcases rcases : table) (H : (nil, nil) = (lcases, rcases)) : default =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases).","proofString":"inv H.\nsimpl.\ndestruct (zlt v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) : default =\n(if zlt v n then switch_target v default nil else switch_target v default nil).","proofString":"simpl.\ndestruct (zlt v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) : default = (if zlt v n then default else default).","proofString":"destruct (zlt v n); auto."},{"statement":"(v : Z) (default : nat) (n : Z) (a : Z * nat) (cases : list (Z * nat)) (IHcases : forall lcases0 rcases0 : table,\nsplit_lt n cases = (lcases0, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases0)) (lcases rcases : table) : (let (key, act) := a in\n let (l, r) := split_lt n cases in\n if zlt key n then ((key, act) :: l, r) else (l, (key, act) :: r)) =\n(lcases, rcases) ->\n(let (key, action) := a in\n if zeq v key then action else switch_target v default cases) =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases).","proofString":"destruct a as [key act].\ndestruct (split_lt n cases) as [lc rc] eqn:SEQ.\nrewrite (IHcases lc rc) by auto.\ndestruct (zlt key n); intros EQ; inv EQ; simpl.\ndestruct (zeq v key).\nrewrite zlt_true by lia.\nauto.\nauto.\ndestruct (zeq v key).\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (IHcases : forall lcases0 rcases0 : table,\nsplit_lt n cases = (lcases0, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases0)) (lcases rcases : table) : (let (l, r) := split_lt n cases in\n if zlt key n then ((key, act) :: l, r) else (l, (key, act) :: r)) =\n(lcases, rcases) ->\n(if zeq v key then act else switch_target v default cases) =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases).","proofString":"destruct (split_lt n cases) as [lc rc] eqn:SEQ.\nrewrite (IHcases lc rc) by auto.\ndestruct (zlt key n); intros EQ; inv EQ; simpl.\ndestruct (zeq v key).\nrewrite zlt_true by lia.\nauto.\nauto.\ndestruct (zeq v key).\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (lc rc : table) (SEQ : split_lt n cases = (lc, rc)) (IHcases : forall lcases0 rcases0 : table,\n(lc, rc) = (lcases0, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases0)) (lcases rcases : table) : (if zlt key n then ((key, act) :: lc, rc) else (lc, (key, act) :: rc)) =\n(lcases, rcases) ->\n(if zeq v key then act else switch_target v default cases) =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases).","proofString":"rewrite (IHcases lc rc) by auto.\ndestruct (zlt key n); intros EQ; inv EQ; simpl.\ndestruct (zeq v key).\nrewrite zlt_true by lia.\nauto.\nauto.\ndestruct (zeq v key).\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (lc rc : table) (SEQ : split_lt n cases = (lc, rc)) (IHcases : forall lcases0 rcases0 : table,\n(lc, rc) = (lcases0, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases0)) (lcases rcases : table) : (if zlt key n then ((key, act) :: lc, rc) else (lc, (key, act) :: rc)) =\n(lcases, rcases) ->\n(if zeq v key\n then act\n else\n  if zlt v n then switch_target v default lc else switch_target v default rc) =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases).","proofString":"destruct (zlt key n); intros EQ; inv EQ; simpl.\ndestruct (zeq v key).\nrewrite zlt_true by lia.\nauto.\nauto.\ndestruct (zeq v key).\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (lc rcases : table) (IHcases : forall lcases rcases0 : table,\n(lc, rcases) = (lcases, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases0)) (SEQ : split_lt n cases = (lc, rcases)) (l : key < n) : (if zeq v key\n then act\n else\n  if zlt v n\n  then switch_target v default lc\n  else switch_target v default rcases) =\n(if zlt v n\n then if zeq v key then act else switch_target v default lc\n else switch_target v default rcases).","proofString":"destruct (zeq v key).\nrewrite zlt_true by lia.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (lc rcases : table) (IHcases : forall lcases rcases0 : table,\n(lc, rcases) = (lcases, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases0)) (SEQ : split_lt n cases = (lc, rcases)) (l : key < n) (e : v = key) : act = (if zlt v n then act else switch_target v default rcases).","proofString":"rewrite zlt_true by lia.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (lc rcases : table) (IHcases : forall lcases rcases0 : table,\n(lc, rcases) = (lcases, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases0)) (SEQ : split_lt n cases = (lc, rcases)) (l : key < n) (e : v = key) : act = act.","proofString":"auto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (lc rcases : table) (IHcases : forall lcases rcases0 : table,\n(lc, rcases) = (lcases, rcases0) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rcases0)) (SEQ : split_lt n cases = (lc, rcases)) (l : key < n) (n0 : v <> key) : (if zlt v n\n then switch_target v default lc\n else switch_target v default rcases) =\n(if zlt v n\n then switch_target v default lc\n else switch_target v default rcases).","proofString":"auto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (rc lcases : table) (IHcases : forall lcases0 rcases : table,\n(lcases, rc) = (lcases0, rcases) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases)) (SEQ : split_lt n cases = (lcases, rc)) (g : key >= n) : (if zeq v key\n then act\n else\n  if zlt v n\n  then switch_target v default lcases\n  else switch_target v default rc) =\n(if zlt v n\n then switch_target v default lcases\n else if zeq v key then act else switch_target v default rc).","proofString":"destruct (zeq v key).\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (rc lcases : table) (IHcases : forall lcases0 rcases : table,\n(lcases, rc) = (lcases0, rcases) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases)) (SEQ : split_lt n cases = (lcases, rc)) (g : key >= n) (e : v = key) : act = (if zlt v n then switch_target v default lcases else act).","proofString":"rewrite zlt_false by lia.\nauto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (rc lcases : table) (IHcases : forall lcases0 rcases : table,\n(lcases, rc) = (lcases0, rcases) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases)) (SEQ : split_lt n cases = (lcases, rc)) (g : key >= n) (e : v = key) : act = act.","proofString":"auto."},{"statement":"(v : Z) (default : nat) (n key : Z) (act : nat) (cases : list (Z * nat)) (rc lcases : table) (IHcases : forall lcases0 rcases : table,\n(lcases, rc) = (lcases0, rcases) ->\nswitch_target v default cases =\n(if zlt v n\n then switch_target v default lcases0\n else switch_target v default rcases)) (SEQ : split_lt n cases = (lcases, rc)) (g : key >= n) (n0 : v <> key) : (if zlt v n\n then switch_target v default lcases\n else switch_target v default rc) =\n(if zlt v n\n then switch_target v default lcases\n else switch_target v default rc).","proofString":"auto."},{"statement":"(v : Z) (default : nat) (ofs sz : Z) (inside : ZMap.t nat) (outside : table) (SEQ : (ZMap.init default, nil) = (inside, outside)) : default =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside).","proofString":"inv SEQ.\nrewrite ZMap.gi.\nsimpl.\ndestruct (zlt ((v - ofs) mod modulus) sz); auto."},{"statement":"(v : Z) (default : nat) (ofs sz : Z) : default =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v (ZMap.init default)\n else switch_target v default nil).","proofString":"rewrite ZMap.gi.\nsimpl.\ndestruct (zlt ((v - ofs) mod modulus) sz); auto."},{"statement":"(v : Z) (default : nat) (ofs sz : Z) : default =\n(if zlt ((v - ofs) mod modulus) sz\n then default\n else switch_target v default nil).","proofString":"simpl.\ndestruct (zlt ((v - ofs) mod modulus) sz); auto."},{"statement":"(v : Z) (default : nat) (ofs sz : Z) : default = (if zlt ((v - ofs) mod modulus) sz then default else default).","proofString":"destruct (zlt ((v - ofs) mod modulus) sz); auto."},{"statement":"(v : Z) (default : nat) (ofs sz : Z) (a : Z * nat) (cases : list (Z * nat)) (IHcases : forall (inside0 : ZMap.t nat) (outside0 : table),\nsplit_between default ofs sz cases = (inside0, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside0)) (inside : ZMap.t nat) (outside : table) (SEQ : (let (key, act) := a in\n let (inside0, outside0) := split_between default ofs sz cases in\n if zlt ((key - ofs) mod modulus) sz\n then (ZMap.set key act inside0, outside0)\n else (inside0, (key, act) :: outside0)) = (inside, outside)) : (let (key, action) := a in\n if zeq v key then action else switch_target v default cases) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside).","proofString":"destruct a as [key act].\ndestruct (split_between default ofs sz cases) as [ins outs].\nerewrite IHcases; eauto.\ndestruct (zlt ((key - ofs) mod modulus) sz); inv SEQ.\nrewrite ZMap.gsspec.\nunfold ZIndexed.eq.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_true by auto.\nauto.\nauto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (IHcases : forall (inside0 : ZMap.t nat) (outside0 : table),\nsplit_between default ofs sz cases = (inside0, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside0)) (inside : ZMap.t nat) (outside : table) (SEQ : (let (inside0, outside0) := split_between default ofs sz cases in\n if zlt ((key - ofs) mod modulus) sz\n then (ZMap.set key act inside0, outside0)\n else (inside0, (key, act) :: outside0)) = (inside, outside)) : (if zeq v key then act else switch_target v default cases) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside).","proofString":"destruct (split_between default ofs sz cases) as [ins outs].\nerewrite IHcases; eauto.\ndestruct (zlt ((key - ofs) mod modulus) sz); inv SEQ.\nrewrite ZMap.gsspec.\nunfold ZIndexed.eq.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_true by auto.\nauto.\nauto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outs : table) (IHcases : forall (inside0 : ZMap.t nat) (outside0 : table),\n(ins, outs) = (inside0, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside0)) (inside : ZMap.t nat) (outside : table) (SEQ : (if zlt ((key - ofs) mod modulus) sz\n then (ZMap.set key act ins, outs)\n else (ins, (key, act) :: outs)) = (inside, outside)) : (if zeq v key then act else switch_target v default cases) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside).","proofString":"erewrite IHcases; eauto.\ndestruct (zlt ((key - ofs) mod modulus) sz); inv SEQ.\nrewrite ZMap.gsspec.\nunfold ZIndexed.eq.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_true by auto.\nauto.\nauto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outs : table) (IHcases : forall (inside0 : ZMap.t nat) (outside0 : table),\n(ins, outs) = (inside0, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside0)) (inside : ZMap.t nat) (outside : table) (SEQ : (if zlt ((key - ofs) mod modulus) sz\n then (ZMap.set key act ins, outs)\n else (ins, (key, act) :: outs)) = (inside, outside)) : (if zeq v key\n then act\n else\n  if zlt ((v - ofs) mod modulus) sz\n  then ZMap.get v ins\n  else switch_target v default outs) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside).","proofString":"destruct (zlt ((key - ofs) mod modulus) sz); inv SEQ.\nrewrite ZMap.gsspec.\nunfold ZIndexed.eq.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_true by auto.\nauto.\nauto.\nsimpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outside : table) (IHcases : forall (inside : ZMap.t nat) (outside0 : table),\n(ins, outside) = (inside, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside0)) (l : (key - ofs) mod modulus < sz) : (if zeq v key\n then act\n else\n  if zlt ((v - ofs) mod modulus) sz\n  then ZMap.get v ins\n  else switch_target v default outside) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v (ZMap.set key act ins)\n else switch_target v default outside).","proofString":"rewrite ZMap.gsspec.\nunfold ZIndexed.eq.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_true by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outside : table) (IHcases : forall (inside : ZMap.t nat) (outside0 : table),\n(ins, outside) = (inside, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside0)) (l : (key - ofs) mod modulus < sz) : (if zeq v key\n then act\n else\n  if zlt ((v - ofs) mod modulus) sz\n  then ZMap.get v ins\n  else switch_target v default outside) =\n(if zlt ((v - ofs) mod modulus) sz\n then if ZIndexed.eq v key then act else ZMap.get v ins\n else switch_target v default outside).","proofString":"unfold ZIndexed.eq.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_true by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outside : table) (IHcases : forall (inside : ZMap.t nat) (outside0 : table),\n(ins, outside) = (inside, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside0)) (l : (key - ofs) mod modulus < sz) : (if zeq v key\n then act\n else\n  if zlt ((v - ofs) mod modulus) sz\n  then ZMap.get v ins\n  else switch_target v default outside) =\n(if zlt ((v - ofs) mod modulus) sz\n then if zeq v key then act else ZMap.get v ins\n else switch_target v default outside).","proofString":"destruct (zeq v key).\nsubst v.\nrewrite zlt_true by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outside : table) (IHcases : forall (inside : ZMap.t nat) (outside0 : table),\n(ins, outside) = (inside, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside0)) (l : (key - ofs) mod modulus < sz) (e : v = key) : act =\n(if zlt ((v - ofs) mod modulus) sz\n then act\n else switch_target v default outside).","proofString":"subst v.\nrewrite zlt_true by auto.\nauto."},{"statement":"(default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outside : table) (IHcases : forall (inside : ZMap.t nat) (outside0 : table),\n(ins, outside) = (inside, outside0) ->\nswitch_target key default cases =\n(if zlt ((key - ofs) mod modulus) sz\n then ZMap.get key inside\n else switch_target key default outside0)) (l : (key - ofs) mod modulus < sz) : act =\n(if zlt ((key - ofs) mod modulus) sz\n then act\n else switch_target key default outside).","proofString":"rewrite zlt_true by auto.\nauto."},{"statement":"(default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outside : table) (IHcases : forall (inside : ZMap.t nat) (outside0 : table),\n(ins, outside) = (inside, outside0) ->\nswitch_target key default cases =\n(if zlt ((key - ofs) mod modulus) sz\n then ZMap.get key inside\n else switch_target key default outside0)) (l : (key - ofs) mod modulus < sz) : act = act.","proofString":"auto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (ins : ZMap.t nat) (outside : table) (IHcases : forall (inside : ZMap.t nat) (outside0 : table),\n(ins, outside) = (inside, outside0) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outside0)) (l : (key - ofs) mod modulus < sz) (n : v <> key) : (if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v ins\n else switch_target v default outside) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v ins\n else switch_target v default outside).","proofString":"auto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (outs : table) (inside : ZMap.t nat) (IHcases : forall (inside0 : ZMap.t nat) (outside : table),\n(inside, outs) = (inside0, outside) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside)) (g : (key - ofs) mod modulus >= sz) : (if zeq v key\n then act\n else\n  if zlt ((v - ofs) mod modulus) sz\n  then ZMap.get v inside\n  else switch_target v default outs) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default ((key, act) :: outs)).","proofString":"simpl.\ndestruct (zeq v key).\nsubst v.\nrewrite zlt_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (outs : table) (inside : ZMap.t nat) (IHcases : forall (inside0 : ZMap.t nat) (outside : table),\n(inside, outs) = (inside0, outside) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside)) (g : (key - ofs) mod modulus >= sz) : (if zeq v key\n then act\n else\n  if zlt ((v - ofs) mod modulus) sz\n  then ZMap.get v inside\n  else switch_target v default outs) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else if zeq v key then act else switch_target v default outs).","proofString":"destruct (zeq v key).\nsubst v.\nrewrite zlt_false by auto.\nauto.\nauto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (outs : table) (inside : ZMap.t nat) (IHcases : forall (inside0 : ZMap.t nat) (outside : table),\n(inside, outs) = (inside0, outside) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside)) (g : (key - ofs) mod modulus >= sz) (e : v = key) : act = (if zlt ((v - ofs) mod modulus) sz then ZMap.get v inside else act).","proofString":"subst v.\nrewrite zlt_false by auto.\nauto."},{"statement":"(default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (outs : table) (inside : ZMap.t nat) (IHcases : forall (inside0 : ZMap.t nat) (outside : table),\n(inside, outs) = (inside0, outside) ->\nswitch_target key default cases =\n(if zlt ((key - ofs) mod modulus) sz\n then ZMap.get key inside0\n else switch_target key default outside)) (g : (key - ofs) mod modulus >= sz) : act = (if zlt ((key - ofs) mod modulus) sz then ZMap.get key inside else act).","proofString":"rewrite zlt_false by auto.\nauto."},{"statement":"(default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (outs : table) (inside : ZMap.t nat) (IHcases : forall (inside0 : ZMap.t nat) (outside : table),\n(inside, outs) = (inside0, outside) ->\nswitch_target key default cases =\n(if zlt ((key - ofs) mod modulus) sz\n then ZMap.get key inside0\n else switch_target key default outside)) (g : (key - ofs) mod modulus >= sz) : act = act.","proofString":"auto."},{"statement":"(v : Z) (default : nat) (ofs sz key : Z) (act : nat) (cases : list (Z * nat)) (outs : table) (inside : ZMap.t nat) (IHcases : forall (inside0 : ZMap.t nat) (outside : table),\n(inside, outs) = (inside0, outside) ->\nswitch_target v default cases =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside0\n else switch_target v default outside)) (g : (key - ofs) mod modulus >= sz) (n : v <> key) : (if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outs) =\n(if zlt ((v - ofs) mod modulus) sz\n then ZMap.get v inside\n else switch_target v default outs).","proofString":"auto."},{"statement":"(cases : ZMap.t nat) (base v : Z) (H : true = true) (H0 : 0 <= v < 0) : None = Some (ZMap.get (base + v) cases).","proofString":"extlia."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H : (a =? ZMap.get base cases)%nat && validate_jumptable cases tbl (Z.succ base) =\ntrue) (H0 : 0 <= v < list_length_z (a :: tbl)) : (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) =\nSome (ZMap.get (base + v) cases).","proofString":"InvBooleans.\nrewrite list_length_z_cons in H0.\napply Nat.eqb_eq in H1.\ndestruct (zeq v 0).\nreplace (base + v) with base by lia.\ncongruence.\nreplace (base + v) with (Z.succ base + Z.pred v) by lia.\napply IHtbl.\nauto.\nlia."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z (a :: tbl)) (H1 : (a =? ZMap.get base cases)%nat = true) (H2 : validate_jumptable cases tbl (Z.succ base) = true) : (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) =\nSome (ZMap.get (base + v) cases).","proofString":"rewrite list_length_z_cons in H0.\napply Nat.eqb_eq in H1.\ndestruct (zeq v 0).\nreplace (base + v) with base by lia.\ncongruence.\nreplace (base + v) with (Z.succ base + Z.pred v) by lia.\napply IHtbl.\nauto.\nlia."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : (a =? ZMap.get base cases)%nat = true) (H2 : validate_jumptable cases tbl (Z.succ base) = true) : (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) =\nSome (ZMap.get (base + v) cases).","proofString":"apply Nat.eqb_eq in H1.\ndestruct (zeq v 0).\nreplace (base + v) with base by lia.\ncongruence.\nreplace (base + v) with (Z.succ base + Z.pred v) by lia.\napply IHtbl.\nauto.\nlia."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : a = ZMap.get base cases) (H2 : validate_jumptable cases tbl (Z.succ base) = true) : (if zeq v 0 then Some a else list_nth_z tbl (Z.pred v)) =\nSome (ZMap.get (base + v) cases).","proofString":"destruct (zeq v 0).\nreplace (base + v) with base by lia.\ncongruence.\nreplace (base + v) with (Z.succ base + Z.pred v) by lia.\napply IHtbl.\nauto.\nlia."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : a = ZMap.get base cases) (H2 : validate_jumptable cases tbl (Z.succ base) = true) (e : v = 0) : Some a = Some (ZMap.get (base + v) cases).","proofString":"replace (base + v) with base by lia.\ncongruence."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : a = ZMap.get base cases) (H2 : validate_jumptable cases tbl (Z.succ base) = true) (e : v = 0) : Some a = Some (ZMap.get base cases).","proofString":"congruence."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : a = ZMap.get base cases) (H2 : validate_jumptable cases tbl (Z.succ base) = true) (n : v <> 0) : list_nth_z tbl (Z.pred v) = Some (ZMap.get (base + v) cases).","proofString":"replace (base + v) with (Z.succ base + Z.pred v) by lia.\napply IHtbl.\nauto.\nlia."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : a = ZMap.get base cases) (H2 : validate_jumptable cases tbl (Z.succ base) = true) (n : v <> 0) : list_nth_z tbl (Z.pred v) = Some (ZMap.get (Z.succ base + Z.pred v) cases).","proofString":"apply IHtbl.\nauto.\nlia."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : a = ZMap.get base cases) (H2 : validate_jumptable cases tbl (Z.succ base) = true) (n : v <> 0) : validate_jumptable cases tbl (Z.succ base) = true.","proofString":"auto."},{"statement":"(cases : ZMap.t nat) (a : nat) (tbl : list nat) (IHtbl : forall base0 v0 : Z,\nvalidate_jumptable cases tbl base0 = true ->\n0 <= v0 < list_length_z tbl ->\nlist_nth_z tbl v0 = Some (ZMap.get (base0 + v0) cases)) (base v : Z) (H0 : 0 <= v < list_length_z tbl + 1) (H1 : a = ZMap.get base cases) (H2 : validate_jumptable cases tbl (Z.succ base) = true) (n : v <> 0) : 0 <= Z.pred v < list_length_z tbl.","proofString":"lia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : list_nth_z tbl ((v - ofs) mod modulus) = Some (ZMap.get v cases).","proofString":"rewrite (validate_jumptable_correct_rec cases tbl ofs); auto.\nf_equal.\nf_equal.\nrewrite Z.mod_small.\nlia.\ndestruct (zle ofs v).\nlia.\nassert (M: ((v - ofs) + 1 * modulus) mod modulus = (v - ofs) + modulus).\nrewrite Z.mod_small.\nlia.\nlia.\nrewrite Z_mod_plus in M by auto.\nrewrite M in H0.\nlia.\ngeneralize (Z_mod_lt (v - ofs) modulus modulus_pos).\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : Some (ZMap.get (ofs + (v - ofs) mod modulus) cases) = Some (ZMap.get v cases).","proofString":"f_equal.\nf_equal.\nrewrite Z.mod_small.\nlia.\ndestruct (zle ofs v).\nlia.\nassert (M: ((v - ofs) + 1 * modulus) mod modulus = (v - ofs) + modulus).\nrewrite Z.mod_small.\nlia.\nlia.\nrewrite Z_mod_plus in M by auto.\nrewrite M in H0.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : ZMap.get (ofs + (v - ofs) mod modulus) cases = ZMap.get v cases.","proofString":"f_equal.\nrewrite Z.mod_small.\nlia.\ndestruct (zle ofs v).\nlia.\nassert (M: ((v - ofs) + 1 * modulus) mod modulus = (v - ofs) + modulus).\nrewrite Z.mod_small.\nlia.\nlia.\nrewrite Z_mod_plus in M by auto.\nrewrite M in H0.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : ofs + (v - ofs) mod modulus = v.","proofString":"rewrite Z.mod_small.\nlia.\ndestruct (zle ofs v).\nlia.\nassert (M: ((v - ofs) + 1 * modulus) mod modulus = (v - ofs) + modulus).\nrewrite Z.mod_small.\nlia.\nlia.\nrewrite Z_mod_plus in M by auto.\nrewrite M in H0.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : ofs + (v - ofs) = v.","proofString":"lia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : 0 <= v - ofs < modulus.","proofString":"destruct (zle ofs v).\nlia.\nassert (M: ((v - ofs) + 1 * modulus) mod modulus = (v - ofs) + modulus).\nrewrite Z.mod_small.\nlia.\nlia.\nrewrite Z_mod_plus in M by auto.\nrewrite M in H0.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (l : ofs <= v) : 0 <= v - ofs < modulus.","proofString":"lia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (g : ofs > v) : 0 <= v - ofs < modulus.","proofString":"assert (M: ((v - ofs) + 1 * modulus) mod modulus = (v - ofs) + modulus).\nrewrite Z.mod_small.\nlia.\nlia.\nrewrite Z_mod_plus in M by auto.\nrewrite M in H0.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (g : ofs > v) : (v - ofs + 1 * modulus) mod modulus = v - ofs + modulus.","proofString":"rewrite Z.mod_small.\nlia.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (g : ofs > v) : v - ofs + 1 * modulus = v - ofs + modulus.","proofString":"lia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (g : ofs > v) : 0 <= v - ofs + 1 * modulus < modulus.","proofString":"lia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (g : ofs > v) (M : (v - ofs + 1 * modulus) mod modulus = v - ofs + modulus) : 0 <= v - ofs < modulus.","proofString":"rewrite Z_mod_plus in M by auto.\nrewrite M in H0.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (g : ofs > v) (M : (v - ofs) mod modulus = v - ofs + modulus) : 0 <= v - ofs < modulus.","proofString":"rewrite M in H0.\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : v - ofs + modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) (g : ofs > v) (M : (v - ofs) mod modulus = v - ofs + modulus) : 0 <= v - ofs < modulus.","proofString":"lia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : 0 <= (v - ofs) mod modulus < list_length_z tbl.","proofString":"generalize (Z_mod_lt (v - ofs) modulus modulus_pos).\nlia."},{"statement":"(cases : ZMap.t nat) (tbl : list nat) (ofs v sz : Z) (H : validate_jumptable cases tbl ofs = true) (H0 : (v - ofs) mod modulus < sz) (H1 : 0 <= sz) (H2 : 0 <= ofs) (H3 : ofs + sz <= modulus) (H4 : 0 <= v < modulus) (H5 : sz <= list_length_z tbl) : 0 <= (v - ofs) mod modulus < modulus ->\n0 <= (v - ofs) mod modulus < list_length_z tbl.","proofString":"lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) : forall (t : comptree) (cases : table) (lo hi : Z),\nvalidate default cases t lo hi = true ->\nlo <= v <= hi -> comptree_match v t = Some (switch_target v default cases).","proofString":"induction t; simpl; intros until hi.\ndestruct cases as [ | [key1 act1] cases1]; intros.\napply Nat.eqb_eq in H.\nsubst act.\nreflexivity.\nInvBooleans.\napply Nat.eqb_eq in H2.\nsubst.\nsimpl.\ndestruct (zeq v hi).\nauto.\nextlia.\ndestruct (split_eq key cases) as [optact others] eqn:EQ.\nintros.\ndestruct optact as [act1|]; InvBooleans; try discriminate.\napply Nat.eqb_eq in H.\nrewrite (split_eq_prop v default _ _ _ _ EQ).\ndestruct (zeq v key).\ncongruence.\neapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia.\ndestruct (split_lt key cases) as [lcases rcases] eqn:EQ; intros; InvBooleans.\nrewrite (split_lt_prop v default _ _ _ _ EQ).\ndestruct (zlt v key).\neapply IHt1.\neauto.\nlia.\neapply IHt2.\neauto.\nlia.\ndestruct (split_between default ofs sz cases) as [ins outs] eqn:EQ; intros; InvBooleans.\nrewrite (split_between_prop v _ _ _ _ _ _ EQ).\nassert (0 <= (v - ofs) mod modulus < modulus) by (apply Z_mod_lt; lia).\ndestruct (zlt ((v - ofs) mod modulus) sz).\nrewrite Z.mod_small by lia.\neapply validate_jumptable_correct; eauto.\neapply IHt; eauto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act : nat) (cases : table) (lo hi : Z) : match cases with\n| nil => (act =? default)%nat\n| (key1, act1) :: _ => zeq key1 lo && zeq lo hi && (act =? act1)%nat\nend = true ->\nlo <= v <= hi -> Some act = Some (switch_target v default cases).","proofString":"destruct cases as [ | [key1 act1] cases1]; intros.\napply Nat.eqb_eq in H.\nsubst act.\nreflexivity.\nInvBooleans.\napply Nat.eqb_eq in H2.\nsubst.\nsimpl.\ndestruct (zeq v hi).\nauto.\nextlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act : nat) (lo hi : Z) (H : (act =? default)%nat = true) (H0 : lo <= v <= hi) : Some act = Some (switch_target v default nil).","proofString":"apply Nat.eqb_eq in H.\nsubst act.\nreflexivity."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act : nat) (lo hi : Z) (H : act = default) (H0 : lo <= v <= hi) : Some act = Some (switch_target v default nil).","proofString":"subst act.\nreflexivity."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (lo hi : Z) (H0 : lo <= v <= hi) : Some default = Some (switch_target v default nil).","proofString":"reflexivity."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act : nat) (key1 : Z) (act1 : nat) (cases1 : list (Z * nat)) (lo hi : Z) (H : zeq key1 lo && zeq lo hi && (act =? act1)%nat = true) (H0 : lo <= v <= hi) : Some act = Some (switch_target v default ((key1, act1) :: cases1)).","proofString":"InvBooleans.\napply Nat.eqb_eq in H2.\nsubst.\nsimpl.\ndestruct (zeq v hi).\nauto.\nextlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act : nat) (key1 : Z) (act1 : nat) (cases1 : list (Z * nat)) (lo hi : Z) (H0 : lo <= v <= hi) (H2 : (act =? act1)%nat = true) (H1 : lo = hi) (H : key1 = lo) : Some act = Some (switch_target v default ((key1, act1) :: cases1)).","proofString":"apply Nat.eqb_eq in H2.\nsubst.\nsimpl.\ndestruct (zeq v hi).\nauto.\nextlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act : nat) (key1 : Z) (act1 : nat) (cases1 : list (Z * nat)) (lo hi : Z) (H0 : lo <= v <= hi) (H2 : act = act1) (H1 : lo = hi) (H : key1 = lo) : Some act = Some (switch_target v default ((key1, act1) :: cases1)).","proofString":"subst.\nsimpl.\ndestruct (zeq v hi).\nauto.\nextlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act1 : nat) (cases1 : list (Z * nat)) (hi : Z) (H0 : hi <= v <= hi) : Some act1 = Some (switch_target v default ((hi, act1) :: cases1)).","proofString":"simpl.\ndestruct (zeq v hi).\nauto.\nextlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act1 : nat) (cases1 : list (Z * nat)) (hi : Z) (H0 : hi <= v <= hi) : Some act1 = Some (if zeq v hi then act1 else switch_target v default cases1).","proofString":"destruct (zeq v hi).\nauto.\nextlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act1 : nat) (cases1 : list (Z * nat)) (hi : Z) (H0 : hi <= v <= hi) (e : v = hi) : Some act1 = Some act1.","proofString":"auto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (act1 : nat) (cases1 : list (Z * nat)) (hi : Z) (H0 : hi <= v <= hi) (n : v <> hi) : Some act1 = Some (switch_target v default cases1).","proofString":"extlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) : zle 0 key && zlt key modulus &&\n(let (o, others) := split_eq key cases in\n match o with\n | Some act' =>\n     (act =? act')%nat &&\n     validate default others t (refine_low_bound key lo)\n       (refine_high_bound key hi)\n | None => false\n end) = true ->\nlo <= v <= hi ->\n(if zeq v key then Some act else comptree_match v t) =\nSome (switch_target v default cases).","proofString":"destruct (split_eq key cases) as [optact others] eqn:EQ.\nintros.\ndestruct optact as [act1|]; InvBooleans; try discriminate.\napply Nat.eqb_eq in H.\nrewrite (split_eq_prop v default _ _ _ _ EQ).\ndestruct (zeq v key).\ncongruence.\neapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (optact : option nat) (others : table) (EQ : split_eq key cases = (optact, others)) : zle 0 key && zlt key modulus &&\nmatch optact with\n| Some act' =>\n    (act =? act')%nat &&\n    validate default others t (refine_low_bound key lo)\n      (refine_high_bound key hi)\n| None => false\nend = true ->\nlo <= v <= hi ->\n(if zeq v key then Some act else comptree_match v t) =\nSome (switch_target v default cases).","proofString":"intros.\ndestruct optact as [act1|]; InvBooleans; try discriminate.\napply Nat.eqb_eq in H.\nrewrite (split_eq_prop v default _ _ _ _ EQ).\ndestruct (zeq v key).\ncongruence.\neapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (optact : option nat) (others : table) (EQ : split_eq key cases = (optact, others)) (H : zle 0 key && zlt key modulus &&\nmatch optact with\n| Some act' =>\n    (act =? act')%nat &&\n    validate default others t (refine_low_bound key lo)\n      (refine_high_bound key hi)\n| None => false\nend = true) (H0 : lo <= v <= hi) : (if zeq v key then Some act else comptree_match v t) =\nSome (switch_target v default cases).","proofString":"destruct optact as [act1|]; InvBooleans; try discriminate.\napply Nat.eqb_eq in H.\nrewrite (split_eq_prop v default _ _ _ _ EQ).\ndestruct (zeq v key).\ncongruence.\neapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : (act =? act1)%nat = true) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) : (if zeq v key then Some act else comptree_match v t) =\nSome (switch_target v default cases).","proofString":"apply Nat.eqb_eq in H.\nrewrite (split_eq_prop v default _ _ _ _ EQ).\ndestruct (zeq v key).\ncongruence.\neapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) : (if zeq v key then Some act else comptree_match v t) =\nSome (switch_target v default cases).","proofString":"rewrite (split_eq_prop v default _ _ _ _ EQ).\ndestruct (zeq v key).\ncongruence.\neapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) : (if zeq v key then Some act else comptree_match v t) =\nSome (if zeq v key then act1 else switch_target v default others).","proofString":"destruct (zeq v key).\ncongruence.\neapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) (e : v = key) : Some act = Some act1.","proofString":"congruence."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) (n : v <> key) : comptree_match v t = Some (switch_target v default others).","proofString":"eapply IHt; eauto.\nunfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) (n : v <> key) : refine_low_bound key lo <= v <= refine_high_bound key hi.","proofString":"unfold refine_low_bound, refine_high_bound.\nsplit.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) (n : v <> key) : (if zeq key lo then lo + 1 else lo) <= v <=\n(if zeq key hi then hi - 1 else hi).","proofString":"split.\ndestruct (zeq key lo); lia.\ndestruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) (n : v <> key) : (if zeq key lo then lo + 1 else lo) <= v.","proofString":"destruct (zeq key lo); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (act : nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (act1 : nat) (others : table) (EQ : split_eq key cases = (Some act1, others)) (H0 : lo <= v <= hi) (H : act = act1) (H3 : validate default others t (refine_low_bound key lo)\n  (refine_high_bound key hi) = true) (H1 : key < modulus) (H2 : 0 <= key) (n : v <> key) : v <= (if zeq key hi then hi - 1 else hi).","proofString":"destruct (zeq key hi); lia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (t1 t2 : comptree) (IHt1 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t1 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t1 = Some (switch_target v default cases0)) (IHt2 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t2 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t2 = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) : zle 0 key && zlt key modulus &&\n(let (lcases, rcases) := split_lt key cases in\n validate default lcases t1 lo (key - 1) && validate default rcases t2 key hi) =\ntrue ->\nlo <= v <= hi ->\n(if zlt v key then comptree_match v t1 else comptree_match v t2) =\nSome (switch_target v default cases).","proofString":"destruct (split_lt key cases) as [lcases rcases] eqn:EQ; intros; InvBooleans.\nrewrite (split_lt_prop v default _ _ _ _ EQ).\ndestruct (zlt v key).\neapply IHt1.\neauto.\nlia.\neapply IHt2.\neauto.\nlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (t1 t2 : comptree) (IHt1 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t1 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t1 = Some (switch_target v default cases0)) (IHt2 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t2 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t2 = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (lcases rcases : table) (EQ : split_lt key cases = (lcases, rcases)) (H0 : lo <= v <= hi) (H : validate default lcases t1 lo (key - 1) = true) (H3 : validate default rcases t2 key hi = true) (H1 : key < modulus) (H2 : 0 <= key) : (if zlt v key then comptree_match v t1 else comptree_match v t2) =\nSome (switch_target v default cases).","proofString":"rewrite (split_lt_prop v default _ _ _ _ EQ).\ndestruct (zlt v key).\neapply IHt1.\neauto.\nlia.\neapply IHt2.\neauto.\nlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (t1 t2 : comptree) (IHt1 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t1 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t1 = Some (switch_target v default cases0)) (IHt2 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t2 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t2 = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (lcases rcases : table) (EQ : split_lt key cases = (lcases, rcases)) (H0 : lo <= v <= hi) (H : validate default lcases t1 lo (key - 1) = true) (H3 : validate default rcases t2 key hi = true) (H1 : key < modulus) (H2 : 0 <= key) : (if zlt v key then comptree_match v t1 else comptree_match v t2) =\nSome\n  (if zlt v key\n   then switch_target v default lcases\n   else switch_target v default rcases).","proofString":"destruct (zlt v key).\neapply IHt1.\neauto.\nlia.\neapply IHt2.\neauto.\nlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (t1 t2 : comptree) (IHt1 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t1 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t1 = Some (switch_target v default cases0)) (IHt2 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t2 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t2 = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (lcases rcases : table) (EQ : split_lt key cases = (lcases, rcases)) (H0 : lo <= v <= hi) (H : validate default lcases t1 lo (key - 1) = true) (H3 : validate default rcases t2 key hi = true) (H1 : key < modulus) (H2 : 0 <= key) (l : v < key) : comptree_match v t1 = Some (switch_target v default lcases).","proofString":"eapply IHt1.\neauto.\nlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (key : Z) (t1 t2 : comptree) (IHt1 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t1 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t1 = Some (switch_target v default cases0)) (IHt2 : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t2 lo0 hi0 = true ->\nlo0 <= v <= hi0 ->\ncomptree_match v t2 = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (lcases rcases : table) (EQ : split_lt key cases = (lcases, rcases)) (H0 : lo <= v <= hi) (H : validate default lcases t1 lo (key - 1) = true) (H3 : validate default rcases t2 key hi = true) (H1 : key < modulus) (H2 : 0 <= key) (g : v >= key) : comptree_match v t2 = Some (switch_target v default rcases).","proofString":"eapply IHt2.\neauto.\nlia."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) : zle 0 ofs && zlt ofs modulus && zle 0 sz && zlt sz modulus &&\nzle (ofs + sz) modulus && zle sz (list_length_z acts) && \nzlt sz Int.modulus &&\n(let (inside, outside) := split_between default ofs sz cases in\n validate_jumptable inside acts ofs && validate default outside t lo hi) =\ntrue ->\nlo <= v <= hi ->\n(if zlt ((v - ofs) mod modulus) sz\n then list_nth_z acts (((v - ofs) mod modulus) mod Int.modulus)\n else comptree_match v t) = Some (switch_target v default cases).","proofString":"destruct (split_between default ofs sz cases) as [ins outs] eqn:EQ; intros; InvBooleans.\nrewrite (split_between_prop v _ _ _ _ _ _ EQ).\nassert (0 <= (v - ofs) mod modulus < modulus) by (apply Z_mod_lt; lia).\ndestruct (zlt ((v - ofs) mod modulus) sz).\nrewrite Z.mod_small by lia.\neapply validate_jumptable_correct; eauto.\neapply IHt; eauto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (ins : ZMap.t nat) (outs : table) (EQ : split_between default ofs sz cases = (ins, outs)) (H0 : lo <= v <= hi) (H : validate_jumptable ins acts ofs = true) (H3 : validate default outs t lo hi = true) (H2 : ofs < modulus) (H1 : 0 <= ofs) (H8 : 0 <= sz) (H7 : sz < modulus) (H6 : ofs + sz <= modulus) (H5 : sz <= list_length_z acts) (H4 : sz < Int.modulus) : (if zlt ((v - ofs) mod modulus) sz\n then list_nth_z acts (((v - ofs) mod modulus) mod Int.modulus)\n else comptree_match v t) = Some (switch_target v default cases).","proofString":"rewrite (split_between_prop v _ _ _ _ _ _ EQ).\nassert (0 <= (v - ofs) mod modulus < modulus) by (apply Z_mod_lt; lia).\ndestruct (zlt ((v - ofs) mod modulus) sz).\nrewrite Z.mod_small by lia.\neapply validate_jumptable_correct; eauto.\neapply IHt; eauto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (ins : ZMap.t nat) (outs : table) (EQ : split_between default ofs sz cases = (ins, outs)) (H0 : lo <= v <= hi) (H : validate_jumptable ins acts ofs = true) (H3 : validate default outs t lo hi = true) (H2 : ofs < modulus) (H1 : 0 <= ofs) (H8 : 0 <= sz) (H7 : sz < modulus) (H6 : ofs + sz <= modulus) (H5 : sz <= list_length_z acts) (H4 : sz < Int.modulus) : (if zlt ((v - ofs) mod modulus) sz\n then list_nth_z acts (((v - ofs) mod modulus) mod Int.modulus)\n else comptree_match v t) =\nSome\n  (if zlt ((v - ofs) mod modulus) sz\n   then ZMap.get v ins\n   else switch_target v default outs).","proofString":"assert (0 <= (v - ofs) mod modulus < modulus) by (apply Z_mod_lt; lia).\ndestruct (zlt ((v - ofs) mod modulus) sz).\nrewrite Z.mod_small by lia.\neapply validate_jumptable_correct; eauto.\neapply IHt; eauto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (ins : ZMap.t nat) (outs : table) (EQ : split_between default ofs sz cases = (ins, outs)) (H0 : lo <= v <= hi) (H : validate_jumptable ins acts ofs = true) (H3 : validate default outs t lo hi = true) (H2 : ofs < modulus) (H1 : 0 <= ofs) (H8 : 0 <= sz) (H7 : sz < modulus) (H6 : ofs + sz <= modulus) (H5 : sz <= list_length_z acts) (H4 : sz < Int.modulus) (H9 : 0 <= (v - ofs) mod modulus < modulus) : (if zlt ((v - ofs) mod modulus) sz\n then list_nth_z acts (((v - ofs) mod modulus) mod Int.modulus)\n else comptree_match v t) =\nSome\n  (if zlt ((v - ofs) mod modulus) sz\n   then ZMap.get v ins\n   else switch_target v default outs).","proofString":"destruct (zlt ((v - ofs) mod modulus) sz).\nrewrite Z.mod_small by lia.\neapply validate_jumptable_correct; eauto.\neapply IHt; eauto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (ins : ZMap.t nat) (outs : table) (EQ : split_between default ofs sz cases = (ins, outs)) (H0 : lo <= v <= hi) (H : validate_jumptable ins acts ofs = true) (H3 : validate default outs t lo hi = true) (H2 : ofs < modulus) (H1 : 0 <= ofs) (H8 : 0 <= sz) (H7 : sz < modulus) (H6 : ofs + sz <= modulus) (H5 : sz <= list_length_z acts) (H4 : sz < Int.modulus) (H9 : 0 <= (v - ofs) mod modulus < modulus) (l : (v - ofs) mod modulus < sz) : list_nth_z acts (((v - ofs) mod modulus) mod Int.modulus) =\nSome (ZMap.get v ins).","proofString":"rewrite Z.mod_small by lia.\neapply validate_jumptable_correct; eauto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (ins : ZMap.t nat) (outs : table) (EQ : split_between default ofs sz cases = (ins, outs)) (H0 : lo <= v <= hi) (H : validate_jumptable ins acts ofs = true) (H3 : validate default outs t lo hi = true) (H2 : ofs < modulus) (H1 : 0 <= ofs) (H8 : 0 <= sz) (H7 : sz < modulus) (H6 : ofs + sz <= modulus) (H5 : sz <= list_length_z acts) (H4 : sz < Int.modulus) (H9 : 0 <= (v - ofs) mod modulus < modulus) (l : (v - ofs) mod modulus < sz) : list_nth_z acts ((v - ofs) mod modulus) = Some (ZMap.get v ins).","proofString":"eapply validate_jumptable_correct; eauto."},{"statement":"(default : nat) (v : Z) (VRANGE : 0 <= v < modulus) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (cases0 : table) (lo0 hi0 : Z),\nvalidate default cases0 t lo0 hi0 = true ->\nlo0 <= v <= hi0 -> comptree_match v t = Some (switch_target v default cases0)) (cases : table) (lo hi : Z) (ins : ZMap.t nat) (outs : table) (EQ : split_between default ofs sz cases = (ins, outs)) (H0 : lo <= v <= hi) (H : validate_jumptable ins acts ofs = true) (H3 : validate default outs t lo hi = true) (H2 : ofs < modulus) (H1 : 0 <= ofs) (H8 : 0 <= sz) (H7 : sz < modulus) (H6 : ofs + sz <= modulus) (H5 : sz <= list_length_z acts) (H4 : sz < Int.modulus) (H9 : 0 <= (v - ofs) mod modulus < modulus) (g : (v - ofs) mod modulus >= sz) : comptree_match v t = Some (switch_target v default outs).","proofString":"eapply IHt; eauto."},{"statement":"(default : nat) (t : comptree) (cases : table) (H : validate default cases t 0 (modulus - 1) = true) : wf_comptree t.","proofString":"eapply validate_wf; eauto."},{"statement":"(default : nat) (t : comptree) (cases : table) (H : validate default cases t 0 (modulus - 1) = true) : forall v : Z,\n0 <= v < modulus -> comptree_match v t = Some (switch_target v default cases).","proofString":"intros; eapply validate_correct_rec; eauto.\nlia."},{"statement":"(default : nat) (t : comptree) (cases : table) (H : validate default cases t 0 (modulus - 1) = true) (v : Z) (H0 : 0 <= v < modulus) : 0 <= v <= modulus - 1.","proofString":"lia."}]}