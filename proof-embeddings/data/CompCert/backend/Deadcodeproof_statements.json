{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Deadcodeproof.v","fileSamples":[{"statement":"(prog tprog : program) (H : transf_program prog = OK tprog) : match_prog prog tprog.","proofString":"eapply match_transform_partial_program_contextual; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (H : magree m1 m2 P) (H0 : forall (b : block) (ofs : Z), Q b ofs -> P b ofs) : magree m1 m2 Q.","proofString":"destruct H.\nconstructor; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (ma_perm0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m1 b ofs k p -> Mem.perm m2 b ofs k p) (ma_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs k p ->\nMem.perm m1 b ofs k p \\/ ~ Mem.perm m1 b ofs Max Nonempty) (ma_memval0 : forall (b : block) (ofs : Z),\nMem.perm m1 b ofs Cur Readable ->\nP b ofs ->\nmemval_lessdef (ZMap.get ofs (Mem.mem_contents m1) # b)\n  (ZMap.get ofs (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (H0 : forall (b : block) (ofs : Z), Q b ofs -> P b ofs) : magree m1 m2 Q.","proofString":"constructor; auto."},{"statement":"(m1 m2 : mem) (P : locset) (H : Mem.extends m1 m2) : magree m1 m2 P.","proofString":"destruct H.\ndestruct mext_inj.\nconstructor; intros.\nreplace ofs with (ofs + 0) by lia.\neapply mi_perm; eauto.\nauto.\neauto.\nexploit mi_memval; eauto.\nunfold inject_id; eauto.\nrewrite Z.add_0_r.\nauto.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mext_inj : Mem.mem_inj inject_id m1 m2) (mext_perm_inv : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs k p ->\nMem.perm m1 b ofs k p \\/ ~ Mem.perm m1 b ofs Max Nonempty) : magree m1 m2 P.","proofString":"destruct mext_inj.\nconstructor; intros.\nreplace ofs with (ofs + 0) by lia.\neapply mi_perm; eauto.\nauto.\neauto.\nexploit mi_memval; eauto.\nunfold inject_id; eauto.\nrewrite Z.add_0_r.\nauto.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs k p -> Mem.perm m2 b2 (ofs + delta) k p) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs k p ->\nMem.perm m1 b ofs k p \\/ ~ Mem.perm m1 b ofs Max Nonempty) : magree m1 m2 P.","proofString":"constructor; intros.\nreplace ofs with (ofs + 0) by lia.\neapply mi_perm; eauto.\nauto.\neauto.\nexploit mi_memval; eauto.\nunfold inject_id; eauto.\nrewrite Z.add_0_r.\nauto.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 k0 p0 -> Mem.perm m2 b2 (ofs0 + delta) k0 p0) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs0 (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m2 b0 ofs0 k0 p0 ->\nMem.perm m1 b0 ofs0 k0 p0 \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.perm m1 b ofs k p) : Mem.perm m2 b ofs k p.","proofString":"replace ofs with (ofs + 0) by lia.\neapply mi_perm; eauto.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 k0 p0 -> Mem.perm m2 b2 (ofs0 + delta) k0 p0) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs0 (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m2 b0 ofs0 k0 p0 ->\nMem.perm m1 b0 ofs0 k0 p0 \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.perm m1 b ofs k p) : Mem.perm m2 b (ofs + 0) k p.","proofString":"eapply mi_perm; eauto.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 k0 p0 -> Mem.perm m2 b2 (ofs0 + delta) k0 p0) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs0 (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m2 b0 ofs0 k0 p0 ->\nMem.perm m1 b0 ofs0 k0 p0 \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.perm m1 b ofs k p) : inject_id b = Some (b, 0).","proofString":"auto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs0 : Z) (k0 : perm_kind) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 k0 p0 -> Mem.perm m2 b2 (ofs0 + delta) k0 p0) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p0 : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p0 ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs0 (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b0 : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m2 b0 ofs0 k0 p0 ->\nMem.perm m1 b0 ofs0 k0 p0 \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (H : Mem.perm m2 b ofs k p) : Mem.perm m1 b ofs k p \\/ ~ Mem.perm m1 b ofs Max Nonempty.","proofString":"eauto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 k p -> Mem.perm m2 b2 (ofs0 + delta) k p) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs0 (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b0 ofs0 k p ->\nMem.perm m1 b0 ofs0 k p \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (H : Mem.perm m1 b ofs Cur Readable) (H0 : P b ofs) : memval_lessdef (ZMap.get ofs (Mem.mem_contents m1) # b)\n  (ZMap.get ofs (Mem.mem_contents m2) # b).","proofString":"exploit mi_memval; eauto.\nunfold inject_id; eauto.\nrewrite Z.add_0_r.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs0 : Z) (k : perm_kind) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 k p -> Mem.perm m2 b2 (ofs0 + delta) k p) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs0 : Z) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs0 (ofs0 + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs0 : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs0 Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs0 (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs0 + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b0 ofs0 k p ->\nMem.perm m1 b0 ofs0 k p \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty) (b : block) (ofs : Z) (H : Mem.perm m1 b ofs Cur Readable) (H0 : P b ofs) : memval_inject inject_id (ZMap.get ofs (Mem.mem_contents m1) # b)\n  (ZMap.get ofs (Mem.mem_contents m2) # b) ->\nmemval_lessdef (ZMap.get ofs (Mem.mem_contents m1) # b)\n  (ZMap.get ofs (Mem.mem_contents m2) # b).","proofString":"auto."},{"statement":"(m1 m2 : mem) (P : locset) (mext_next : Mem.nextblock m1 = Mem.nextblock m2) (mi_perm : forall (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs k p -> Mem.perm m2 b2 (ofs + delta) k p) (mi_align : forall (b1 b2 : block) (delta : Z) (chunk : memory_chunk) \n  (ofs : Z) (p : permission),\ninject_id b1 = Some (b2, delta) ->\nMem.range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->\n(align_chunk chunk | delta)) (mi_memval : forall (b1 : block) (ofs : Z) (b2 : block) (delta : Z),\ninject_id b1 = Some (b2, delta) ->\nMem.perm m1 b1 ofs Cur Readable ->\nmemval_inject inject_id (ZMap.get ofs (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (Mem.mem_contents m2) # b2)) (mext_perm_inv : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs k p ->\nMem.perm m1 b ofs k p \\/ ~ Mem.perm m1 b ofs Max Nonempty) : Mem.nextblock m2 = Mem.nextblock m1.","proofString":"auto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs : Z), P b ofs) (H0 : magree m1 m2 P) : Mem.extends m1 m2.","proofString":"destruct H0.\nconstructor; auto.\nconstructor; unfold inject_id; intros.\ninv H0.\nrewrite Z.add_0_r.\neauto.\ninv H0.\napply Z.divide_0_r.\ninv H0.\nrewrite Z.add_0_r.\neapply ma_memval0; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs : Z), P b ofs) (ma_perm0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m1 b ofs k p -> Mem.perm m2 b ofs k p) (ma_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs k p ->\nMem.perm m1 b ofs k p \\/ ~ Mem.perm m1 b ofs Max Nonempty) (ma_memval0 : forall (b : block) (ofs : Z),\nMem.perm m1 b ofs Cur Readable ->\nP b ofs ->\nmemval_lessdef (ZMap.get ofs (Mem.mem_contents m1) # b)\n  (ZMap.get ofs (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) : Mem.extends m1 m2.","proofString":"constructor; auto.\nconstructor; unfold inject_id; intros.\ninv H0.\nrewrite Z.add_0_r.\neauto.\ninv H0.\napply Z.divide_0_r.\ninv H0.\nrewrite Z.add_0_r.\neapply ma_memval0; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs : Z), P b ofs) (ma_perm0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m1 b ofs k p -> Mem.perm m2 b ofs k p) (ma_perm_inv0 : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs k p ->\nMem.perm m1 b ofs k p \\/ ~ Mem.perm m1 b ofs Max Nonempty) (ma_memval0 : forall (b : block) (ofs : Z),\nMem.perm m1 b ofs Cur Readable ->\nP b ofs ->\nmemval_lessdef (ZMap.get ofs (Mem.mem_contents m1) # b)\n  (ZMap.get ofs (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) : Mem.mem_inj inject_id m1 m2.","proofString":"constructor; unfold inject_id; intros.\ninv H0.\nrewrite Z.add_0_r.\neauto.\ninv H0.\napply Z.divide_0_r.\ninv H0.\nrewrite Z.add_0_r.\neapply ma_memval0; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m1 b ofs0 k0 p0 -> Mem.perm m2 b ofs0 k0 p0) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m2 b ofs0 k0 p0 ->\nMem.perm m1 b ofs0 k0 p0 \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (b1 b2 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.perm m1 b1 ofs k p) : Mem.perm m2 b2 (ofs + delta) k p.","proofString":"inv H0.\nrewrite Z.add_0_r.\neauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m1 b ofs0 k0 p0 -> Mem.perm m2 b ofs0 k0 p0) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m2 b ofs0 k0 p0 ->\nMem.perm m1 b ofs0 k0 p0 \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (b2 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Mem.perm m1 b2 ofs k p) : Mem.perm m2 b2 (ofs + 0) k p.","proofString":"rewrite Z.add_0_r.\neauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m1 b ofs0 k0 p0 -> Mem.perm m2 b ofs0 k0 p0) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m2 b ofs0 k0 p0 ->\nMem.perm m1 b ofs0 k0 p0 \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (b2 : block) (ofs : Z) (k : perm_kind) (p : permission) (H1 : Mem.perm m1 b2 ofs k p) : Mem.perm m2 b2 ofs k p.","proofString":"eauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p0 : permission),\nMem.perm m1 b ofs0 k p0 -> Mem.perm m2 b ofs0 k p0) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p0 : permission),\nMem.perm m2 b ofs0 k p0 ->\nMem.perm m1 b ofs0 k p0 \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (b1 b2 : block) (delta : Z) (chunk : memory_chunk) (ofs : Z) (p : permission) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | delta).","proofString":"inv H0.\napply Z.divide_0_r."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p0 : permission),\nMem.perm m1 b ofs0 k p0 -> Mem.perm m2 b ofs0 k p0) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p0 : permission),\nMem.perm m2 b ofs0 k p0 ->\nMem.perm m1 b ofs0 k p0 \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (b2 : block) (chunk : memory_chunk) (ofs : Z) (p : permission) (H1 : Mem.range_perm m1 b2 ofs (ofs + size_chunk chunk) Max p) : (align_chunk chunk | 0).","proofString":"apply Z.divide_0_r."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m1 b ofs0 k p -> Mem.perm m2 b ofs0 k p) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs0 k p ->\nMem.perm m1 b ofs0 k p \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (b1 : block) (ofs : Z) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.perm m1 b1 ofs Cur Readable) : memval_inject (fun b : block => Some (b, 0))\n  (ZMap.get ofs (Mem.mem_contents m1) # b1)\n  (ZMap.get (ofs + delta) (Mem.mem_contents m2) # b2).","proofString":"inv H0.\nrewrite Z.add_0_r.\neapply ma_memval0; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m1 b ofs0 k p -> Mem.perm m2 b ofs0 k p) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs0 k p ->\nMem.perm m1 b ofs0 k p \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (ofs : Z) (b2 : block) (H1 : Mem.perm m1 b2 ofs Cur Readable) : memval_inject (fun b : block => Some (b, 0))\n  (ZMap.get ofs (Mem.mem_contents m1) # b2)\n  (ZMap.get (ofs + 0) (Mem.mem_contents m2) # b2).","proofString":"rewrite Z.add_0_r.\neapply ma_memval0; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (H : forall (b : block) (ofs0 : Z), P b ofs0) (ma_perm0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m1 b ofs0 k p -> Mem.perm m2 b ofs0 k p) (ma_perm_inv0 : forall (b : block) (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m2 b ofs0 k p ->\nMem.perm m1 b ofs0 k p \\/ ~ Mem.perm m1 b ofs0 Max Nonempty) (ma_memval0 : forall (b : block) (ofs0 : Z),\nMem.perm m1 b ofs0 Cur Readable ->\nP b ofs0 ->\nmemval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b)) (ma_nextblock0 : Mem.nextblock m2 = Mem.nextblock m1) (ofs : Z) (b2 : block) (H1 : Mem.perm m1 b2 ofs Cur Readable) : memval_inject (fun b : block => Some (b, 0))\n  (ZMap.get ofs (Mem.mem_contents m1) # b2)\n  (ZMap.get ofs (Mem.mem_contents m2) # b2).","proofString":"eapply ma_memval0; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) : exists v' : val, Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.","proofString":"exploit Mem.load_valid_access; eauto.\nintros [A B].\nexploit Mem.load_loadbytes; eauto.\nintros [bytes [C D]].\nexploit magree_loadbytes; eauto.\nintros [bytes' [E F]].\nexists (decode_val chunk bytes'); split.\napply Mem.loadbytes_load; auto.\napply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) : Mem.valid_access m1 chunk b ofs Readable ->\nexists v' : val, Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.","proofString":"intros [A B].\nexploit Mem.load_loadbytes; eauto.\nintros [bytes [C D]].\nexploit magree_loadbytes; eauto.\nintros [bytes' [E F]].\nexists (decode_val chunk bytes'); split.\napply Mem.loadbytes_load; auto.\napply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) : exists v' : val, Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.","proofString":"exploit Mem.load_loadbytes; eauto.\nintros [bytes [C D]].\nexploit magree_loadbytes; eauto.\nintros [bytes' [E F]].\nexists (decode_val chunk bytes'); split.\napply Mem.loadbytes_load; auto.\napply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) : (exists bytes : list memval,\n   Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes /\\\n   v = decode_val chunk bytes) ->\nexists v' : val, Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.","proofString":"intros [bytes [C D]].\nexploit magree_loadbytes; eauto.\nintros [bytes' [E F]].\nexists (decode_val chunk bytes'); split.\napply Mem.loadbytes_load; auto.\napply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (bytes : list memval) (C : Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes) (D : v = decode_val chunk bytes) : exists v' : val, Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.","proofString":"exploit magree_loadbytes; eauto.\nintros [bytes' [E F]].\nexists (decode_val chunk bytes'); split.\napply Mem.loadbytes_load; auto.\napply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (bytes : list memval) (C : Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes) (D : v = decode_val chunk bytes) : (exists bytes' : list memval,\n   Mem.loadbytes m2 b ofs (size_chunk chunk) = Some bytes' /\\\n   list_forall2 memval_lessdef bytes bytes') ->\nexists v' : val, Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.","proofString":"intros [bytes' [E F]].\nexists (decode_val chunk bytes'); split.\napply Mem.loadbytes_load; auto.\napply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (bytes : list memval) (C : Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes) (D : v = decode_val chunk bytes) (bytes' : list memval) (E : Mem.loadbytes m2 b ofs (size_chunk chunk) = Some bytes') (F : list_forall2 memval_lessdef bytes bytes') : exists v' : val, Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.","proofString":"exists (decode_val chunk bytes'); split.\napply Mem.loadbytes_load; auto.\napply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (bytes : list memval) (C : Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes) (D : v = decode_val chunk bytes) (bytes' : list memval) (E : Mem.loadbytes m2 b ofs (size_chunk chunk) = Some bytes') (F : list_forall2 memval_lessdef bytes bytes') : Mem.load chunk m2 b ofs = Some (decode_val chunk bytes').","proofString":"apply Mem.loadbytes_load; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (bytes : list memval) (C : Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes) (D : v = decode_val chunk bytes) (bytes' : list memval) (E : Mem.loadbytes m2 b ofs (size_chunk chunk) = Some bytes') (F : list_forall2 memval_lessdef bytes bytes') : Val.lessdef v (decode_val chunk bytes').","proofString":"apply val_inject_id.\nsubst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v : val) (H : magree m1 m2 P) (H0 : Mem.load chunk m1 b ofs = Some v) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (bytes : list memval) (C : Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes) (D : v = decode_val chunk bytes) (bytes' : list memval) (E : Mem.loadbytes m2 b ofs (size_chunk chunk) = Some bytes') (F : list_forall2 memval_lessdef bytes bytes') : Val.inject inject_id v (decode_val chunk bytes').","proofString":"subst v.\napply decode_val_inject; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (H : magree m1 m2 P) (bytes : list memval) (H0 : Mem.load chunk m1 b ofs = Some (decode_val chunk bytes)) (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> P b i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Readable) (B : (align_chunk chunk | ofs)) (C : Mem.loadbytes m1 b ofs (size_chunk chunk) = Some bytes) (bytes' : list memval) (E : Mem.loadbytes m2 b ofs (size_chunk chunk) = Some bytes') (F : list_forall2 memval_lessdef bytes bytes') : Val.inject inject_id (decode_val chunk bytes) (decode_val chunk bytes').","proofString":"apply decode_val_inject; auto."},{"statement":"forall (access : Z -> Prop) (bytes1 bytes2 : list memval),\nlist_forall2 memval_lessdef bytes1 bytes2 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes1) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes1 p c1))\n  (ZMap.get q (Mem.setN bytes2 p c2)).","proofString":"induction 1; intros; simpl.\napply H; auto.\nsimpl.\nlia.\nsimpl length in H1; rewrite Nat2Z.inj_succ in H1.\napply IHlist_forall2; auto.\nintros.\nrewrite ! ZMap.gsspec.\ndestruct (ZIndexed.eq i p).\nauto.\napply H1; auto.\nunfold ZIndexed.t in *; lia."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i ->\n memval_lessdef (ZMap.get i c0) (ZMap.get i c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i : Z,\naccess i ->\ni < p \\/ p + Z.of_nat (Datatypes.length (a1 :: al)) <= i ->\nmemval_lessdef (ZMap.get i c1) (ZMap.get i c2)) (q : Z) (H2 : access q) : memval_lessdef (ZMap.get q (Mem.setN al (p + 1) (ZMap.set p a1 c1)))\n  (ZMap.get q (Mem.setN bl (p + 1) (ZMap.set p b1 c2))).","proofString":"simpl length in H1; rewrite Nat2Z.inj_succ in H1.\napply IHlist_forall2; auto.\nintros.\nrewrite ! ZMap.gsspec.\ndestruct (ZIndexed.eq i p).\nauto.\napply H1; auto.\nunfold ZIndexed.t in *; lia."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i ->\n memval_lessdef (ZMap.get i c0) (ZMap.get i c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i : Z,\naccess i ->\ni < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i ->\nmemval_lessdef (ZMap.get i c1) (ZMap.get i c2)) (q : Z) (H2 : access q) : memval_lessdef (ZMap.get q (Mem.setN al (p + 1) (ZMap.set p a1 c1)))\n  (ZMap.get q (Mem.setN bl (p + 1) (ZMap.set p b1 c2))).","proofString":"apply IHlist_forall2; auto.\nintros.\nrewrite ! ZMap.gsspec.\ndestruct (ZIndexed.eq i p).\nauto.\napply H1; auto.\nunfold ZIndexed.t in *; lia."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i ->\n memval_lessdef (ZMap.get i c0) (ZMap.get i c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i : Z,\naccess i ->\ni < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i ->\nmemval_lessdef (ZMap.get i c1) (ZMap.get i c2)) (q : Z) (H2 : access q) : forall i : Z,\naccess i ->\ni < p + 1 \\/ p + 1 + Z.of_nat (Datatypes.length al) <= i ->\nmemval_lessdef (ZMap.get i (ZMap.set p a1 c1))\n  (ZMap.get i (ZMap.set p b1 c2)).","proofString":"intros.\nrewrite ! ZMap.gsspec.\ndestruct (ZIndexed.eq i p).\nauto.\napply H1; auto.\nunfold ZIndexed.t in *; lia."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i0 ->\n memval_lessdef (ZMap.get i0 c0) (ZMap.get i0 c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i0 : Z,\naccess i0 ->\ni0 < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i0 ->\nmemval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) (q : Z) (H2 : access q) (i : Z) (H3 : access i) (H4 : i < p + 1 \\/ p + 1 + Z.of_nat (Datatypes.length al) <= i) : memval_lessdef (ZMap.get i (ZMap.set p a1 c1))\n  (ZMap.get i (ZMap.set p b1 c2)).","proofString":"rewrite ! ZMap.gsspec.\ndestruct (ZIndexed.eq i p).\nauto.\napply H1; auto.\nunfold ZIndexed.t in *; lia."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i0 ->\n memval_lessdef (ZMap.get i0 c0) (ZMap.get i0 c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i0 : Z,\naccess i0 ->\ni0 < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i0 ->\nmemval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) (q : Z) (H2 : access q) (i : Z) (H3 : access i) (H4 : i < p + 1 \\/ p + 1 + Z.of_nat (Datatypes.length al) <= i) : memval_lessdef (if ZIndexed.eq i p then a1 else ZMap.get i c1)\n  (if ZIndexed.eq i p then b1 else ZMap.get i c2).","proofString":"destruct (ZIndexed.eq i p).\nauto.\napply H1; auto.\nunfold ZIndexed.t in *; lia."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i0 ->\n memval_lessdef (ZMap.get i0 c0) (ZMap.get i0 c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i0 : Z,\naccess i0 ->\ni0 < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i0 ->\nmemval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) (q : Z) (H2 : access q) (i : Z) (H3 : access i) (H4 : i < p + 1 \\/ p + 1 + Z.of_nat (Datatypes.length al) <= i) (e : i = p) : memval_lessdef a1 b1.","proofString":"auto."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i0 ->\n memval_lessdef (ZMap.get i0 c0) (ZMap.get i0 c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i0 : Z,\naccess i0 ->\ni0 < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i0 ->\nmemval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) (q : Z) (H2 : access q) (i : Z) (H3 : access i) (H4 : i < p + 1 \\/ p + 1 + Z.of_nat (Datatypes.length al) <= i) (n : i <> p) : memval_lessdef (ZMap.get i c1) (ZMap.get i c2).","proofString":"apply H1; auto.\nunfold ZIndexed.t in *; lia."},{"statement":"(access : Z -> Prop) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_lessdef a1 b1) (H0 : list_forall2 memval_lessdef al bl) (IHlist_forall2 : forall (p0 : Z) (c0 c3 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p0 \\/ p0 + Z.of_nat (Datatypes.length al) <= i0 ->\n memval_lessdef (ZMap.get i0 c0) (ZMap.get i0 c3)) ->\nforall q0 : Z,\naccess q0 ->\nmemval_lessdef (ZMap.get q0 (Mem.setN al p0 c0))\n  (ZMap.get q0 (Mem.setN bl p0 c3))) (p : Z) (c1 c2 : ZMap.t memval) (H1 : forall i0 : Z,\naccess i0 ->\ni0 < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i0 ->\nmemval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) (q : Z) (H2 : access q) (i : Z) (H3 : access i) (H4 : i < p + 1 \\/ p + 1 + Z.of_nat (Datatypes.length al) <= i) (n : i <> p) : i < p \\/ p + Z.succ (Z.of_nat (Datatypes.length al)) <= i.","proofString":"unfold ZIndexed.t in *; lia."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes1 bytes2 : list memval),\nlist_forall2 memval_lessdef bytes1 bytes2 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes1) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes1 p c1))\n  (ZMap.get q (Mem.setN bytes2 p c2))) : forall (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z)\n  (bytes1 : list memval) (m1' : mem) (bytes2 : list memval),\nmagree m1 m2 P ->\nMem.storebytes m1 b ofs bytes1 = Some m1' ->\n(forall (b' : block) (i : Z),\n Q b' i ->\n b' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i ->\n P b' i) ->\nlist_forall2 memval_lessdef bytes1 bytes2 ->\nexists m2' : mem,\n  Mem.storebytes m2 b ofs bytes2 = Some m2' /\\ magree m1' m2' Q.","proofString":"intros.\ndestruct (Mem.range_perm_storebytes m2 b ofs bytes2) as [m2' ST2].\nerewrite <- list_forall2_length by eauto.\nred; intros.\neapply ma_perm; eauto.\neapply Mem.storebytes_range_perm; eauto.\nexists m2'; split; auto.\nconstructor; intros.\neapply Mem.perm_storebytes_1; eauto.\neapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto.\nexploit ma_perm_inv; eauto using Mem.perm_storebytes_2.\nintuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2.\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ ST2).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ ST2).\neapply ma_nextblock; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) : exists m2' : mem,\n  Mem.storebytes m2 b ofs bytes2 = Some m2' /\\ magree m1' m2' Q.","proofString":"destruct (Mem.range_perm_storebytes m2 b ofs bytes2) as [m2' ST2].\nerewrite <- list_forall2_length by eauto.\nred; intros.\neapply ma_perm; eauto.\neapply Mem.storebytes_range_perm; eauto.\nexists m2'; split; auto.\nconstructor; intros.\neapply Mem.perm_storebytes_1; eauto.\neapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto.\nexploit ma_perm_inv; eauto using Mem.perm_storebytes_2.\nintuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2.\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ ST2).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ ST2).\neapply ma_nextblock; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) : Mem.range_perm m2 b ofs (ofs + Z.of_nat (Datatypes.length bytes2)) Cur\n  Writable.","proofString":"erewrite <- list_forall2_length by eauto.\nred; intros.\neapply ma_perm; eauto.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) : Mem.range_perm m2 b ofs (ofs + Z.of_nat (Datatypes.length bytes1)) Cur\n  Writable.","proofString":"red; intros.\neapply ma_perm; eauto.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (ofs0 : Z) (H3 : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : Mem.perm m2 b ofs0 Cur Writable.","proofString":"eapply ma_perm; eauto.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (ofs0 : Z) (H3 : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1)) : Mem.perm m1 b ofs0 Cur Writable.","proofString":"eapply Mem.storebytes_range_perm; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') : exists m2'0 : mem,\n  Mem.storebytes m2 b ofs bytes2 = Some m2'0 /\\ magree m1' m2'0 Q.","proofString":"exists m2'; split; auto.\nconstructor; intros.\neapply Mem.perm_storebytes_1; eauto.\neapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto.\nexploit ma_perm_inv; eauto using Mem.perm_storebytes_2.\nintuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2.\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ ST2).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ ST2).\neapply ma_nextblock; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') : magree m1' m2' Q.","proofString":"constructor; intros.\neapply Mem.perm_storebytes_1; eauto.\neapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto.\nexploit ma_perm_inv; eauto using Mem.perm_storebytes_2.\nintuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2.\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ ST2).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ ST2).\neapply ma_nextblock; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p0 : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p0 c1))\n  (ZMap.get q (Mem.setN bytes3 p0 c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m1' b0 ofs0 k p) : Mem.perm m2' b0 ofs0 k p.","proofString":"eapply Mem.perm_storebytes_1; eauto.\neapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p0 : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p0 c1))\n  (ZMap.get q (Mem.setN bytes3 p0 c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m1' b0 ofs0 k p) : Mem.perm m2 b0 ofs0 k p.","proofString":"eapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p0 : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p0 c1))\n  (ZMap.get q (Mem.setN bytes3 p0 c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m1' b0 ofs0 k p) : Mem.perm m1 b0 ofs0 k p.","proofString":"eapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p0 : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p0 c1))\n  (ZMap.get q (Mem.setN bytes3 p0 c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m2' b0 ofs0 k p) : Mem.perm m1' b0 ofs0 k p \\/ ~ Mem.perm m1' b0 ofs0 Max Nonempty.","proofString":"exploit ma_perm_inv; eauto using Mem.perm_storebytes_2.\nintuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p0 : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p0 \\/ p0 + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p0 c1))\n  (ZMap.get q (Mem.setN bytes3 p0 c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m2' b0 ofs0 k p) : Mem.perm m1 b0 ofs0 k p \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty ->\nMem.perm m1' b0 ofs0 k p \\/ ~ Mem.perm m1' b0 ofs0 Max Nonempty.","proofString":"intuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (H3 : Mem.perm m1' b0 ofs0 Cur Readable) (H4 : Q b0 ofs0) : memval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1') # b0)\n  (ZMap.get ofs0 (Mem.mem_contents m2') # b0).","proofString":"rewrite (Mem.storebytes_mem_contents _ _ _ _ _ H0).\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ ST2).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (H3 : Mem.perm m1' b0 ofs0 Cur Readable) (H4 : Q b0 ofs0) : memval_lessdef\n  (ZMap.get ofs0\n     ((Mem.mem_contents m1) # b <-\n      (Mem.setN bytes1 ofs (Mem.mem_contents m1) # b)) # b0)\n  (ZMap.get ofs0 (Mem.mem_contents m2') # b0).","proofString":"rewrite (Mem.storebytes_mem_contents _ _ _ _ _ ST2).\nrewrite ! PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (H3 : Mem.perm m1' b0 ofs0 Cur Readable) (H4 : Q b0 ofs0) : memval_lessdef\n  (ZMap.get ofs0\n     ((Mem.mem_contents m1) # b <-\n      (Mem.setN bytes1 ofs (Mem.mem_contents m1) # b)) # b0)\n  (ZMap.get ofs0\n     ((Mem.mem_contents m2) # b <-\n      (Mem.setN bytes2 ofs (Mem.mem_contents m2) # b)) # b0).","proofString":"rewrite ! PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (H3 : Mem.perm m1' b0 ofs0 Cur Readable) (H4 : Q b0 ofs0) : memval_lessdef\n  (ZMap.get ofs0\n     (if peq b0 b\n      then Mem.setN bytes1 ofs (Mem.mem_contents m1) # b\n      else (Mem.mem_contents m1) # b0))\n  (ZMap.get ofs0\n     (if peq b0 b\n      then Mem.setN bytes2 ofs (Mem.mem_contents m2) # b\n      else (Mem.mem_contents m2) # b0)).","proofString":"destruct (peq b0 b).\nsubst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (H3 : Mem.perm m1' b0 ofs0 Cur Readable) (H4 : Q b0 ofs0) (e : b0 = b) : memval_lessdef\n  (ZMap.get ofs0 (Mem.setN bytes1 ofs (Mem.mem_contents m1) # b))\n  (ZMap.get ofs0 (Mem.setN bytes2 ofs (Mem.mem_contents m2) # b)).","proofString":"subst b0.\napply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (ofs0 : Z) (H4 : Q b ofs0) (H3 : Mem.perm m1' b ofs0 Cur Readable) : memval_lessdef\n  (ZMap.get ofs0 (Mem.setN bytes1 ofs (Mem.mem_contents m1) # b))\n  (ZMap.get ofs0 (Mem.setN bytes2 ofs (Mem.mem_contents m2) # b)).","proofString":"apply SETN with (access := fun ofs => Mem.perm m1' b ofs Cur Readable /\\ Q b ofs); auto.\nintros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (ofs0 : Z) (H4 : Q b ofs0) (H3 : Mem.perm m1' b ofs0 Cur Readable) : forall i : Z,\nMem.perm m1' b i Cur Readable /\\ Q b i ->\ni < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i ->\nmemval_lessdef (ZMap.get i (Mem.mem_contents m1) # b)\n  (ZMap.get i (Mem.mem_contents m2) # b).","proofString":"intros.\ndestruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i0 ->\n memval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i0 : Z),\nQ b' i0 ->\nb' <> b \\/ i0 < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i0 ->\nP b' i0) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (ofs0 : Z) (H4 : Q b ofs0) (H3 : Mem.perm m1' b ofs0 Cur Readable) (i : Z) (H5 : Mem.perm m1' b i Cur Readable /\\ Q b i) (H6 : i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i) : memval_lessdef (ZMap.get i (Mem.mem_contents m1) # b)\n  (ZMap.get i (Mem.mem_contents m2) # b).","proofString":"destruct H5.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i0 ->\n memval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i0 : Z),\nQ b' i0 ->\nb' <> b \\/ i0 < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i0 ->\nP b' i0) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (ofs0 : Z) (H4 : Q b ofs0) (H3 : Mem.perm m1' b ofs0 Cur Readable) (i : Z) (H5 : Mem.perm m1' b i Cur Readable) (H7 : Q b i) (H6 : i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i) : memval_lessdef (ZMap.get i (Mem.mem_contents m1) # b)\n  (ZMap.get i (Mem.mem_contents m2) # b).","proofString":"eapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i0 : Z,\n access i0 ->\n i0 < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i0 ->\n memval_lessdef (ZMap.get i0 c1) (ZMap.get i0 c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i0 : Z),\nQ b' i0 ->\nb' <> b \\/ i0 < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i0 ->\nP b' i0) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (ofs0 : Z) (H4 : Q b ofs0) (H3 : Mem.perm m1' b ofs0 Cur Readable) (i : Z) (H5 : Mem.perm m1' b i Cur Readable) (H7 : Q b i) (H6 : i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i) : Mem.perm m1 b i Cur Readable.","proofString":"eapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (H3 : Mem.perm m1' b0 ofs0 Cur Readable) (H4 : Q b0 ofs0) (n : b0 <> b) : memval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b0)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b0).","proofString":"eapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') (b0 : block) (ofs0 : Z) (H3 : Mem.perm m1' b0 ofs0 Cur Readable) (H4 : Q b0 ofs0) (n : b0 <> b) : Mem.perm m1 b0 ofs0 Cur Readable.","proofString":"eapply Mem.perm_storebytes_2; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') : Mem.nextblock m2' = Mem.nextblock m1'.","proofString":"rewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ ST2).\neapply ma_nextblock; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') : Mem.nextblock m2' = Mem.nextblock m1.","proofString":"rewrite (Mem.nextblock_storebytes _ _ _ _ _ ST2).\neapply ma_nextblock; eauto."},{"statement":"(SETN : forall (access : Z -> Prop) (bytes0 bytes3 : list memval),\nlist_forall2 memval_lessdef bytes0 bytes3 ->\nforall (p : Z) (c1 c2 : ZMap.t memval),\n(forall i : Z,\n access i ->\n i < p \\/ p + Z.of_nat (Datatypes.length bytes0) <= i ->\n memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\nforall q : Z,\naccess q ->\nmemval_lessdef (ZMap.get q (Mem.setN bytes0 p c1))\n  (ZMap.get q (Mem.setN bytes3 p c2))) (m1 m2 : mem) (P Q : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (bytes2 : list memval) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/ i < ofs \\/ ofs + Z.of_nat (Datatypes.length bytes1) <= i -> P b' i) (H2 : list_forall2 memval_lessdef bytes1 bytes2) (m2' : mem) (ST2 : Mem.storebytes m2 b ofs bytes2 = Some m2') : Mem.nextblock m2 = Mem.nextblock m1.","proofString":"eapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) : exists m2' : mem, Mem.store chunk m2 b ofs v2 = Some m2' /\\ magree m1' m2' Q.","proofString":"exploit Mem.store_valid_access_3; eauto.\nintros [A B].\nexploit Mem.store_storebytes; eauto.\nintros SB1.\nexploit magree_storebytes_parallel.\neauto.\neauto.\ninstantiate (1 := Q).\nintros.\nrewrite encode_val_length in H4.\nrewrite <- size_chunk_conv in H4.\napply H2; auto.\neapply store_argument_sound; eauto.\nintros [m2' [SB2 AG]].\nexists m2'; split; auto.\napply Mem.storebytes_store; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) : Mem.valid_access m1 chunk b ofs Writable ->\nexists m2' : mem, Mem.store chunk m2 b ofs v2 = Some m2' /\\ magree m1' m2' Q.","proofString":"intros [A B].\nexploit Mem.store_storebytes; eauto.\nintros SB1.\nexploit magree_storebytes_parallel.\neauto.\neauto.\ninstantiate (1 := Q).\nintros.\nrewrite encode_val_length in H4.\nrewrite <- size_chunk_conv in H4.\napply H2; auto.\neapply store_argument_sound; eauto.\nintros [m2' [SB2 AG]].\nexists m2'; split; auto.\napply Mem.storebytes_store; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) : exists m2' : mem, Mem.store chunk m2 b ofs v2 = Some m2' /\\ magree m1' m2' Q.","proofString":"exploit Mem.store_storebytes; eauto.\nintros SB1.\nexploit magree_storebytes_parallel.\neauto.\neauto.\ninstantiate (1 := Q).\nintros.\nrewrite encode_val_length in H4.\nrewrite <- size_chunk_conv in H4.\napply H2; auto.\neapply store_argument_sound; eauto.\nintros [m2' [SB2 AG]].\nexists m2'; split; auto.\napply Mem.storebytes_store; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1' ->\nexists m2' : mem, Mem.store chunk m2 b ofs v2 = Some m2' /\\ magree m1' m2' Q.","proofString":"intros SB1.\nexploit magree_storebytes_parallel.\neauto.\neauto.\ninstantiate (1 := Q).\nintros.\nrewrite encode_val_length in H4.\nrewrite <- size_chunk_conv in H4.\napply H2; auto.\neapply store_argument_sound; eauto.\nintros [m2' [SB2 AG]].\nexists m2'; split; auto.\napply Mem.storebytes_store; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) (SB1 : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1') : exists m2' : mem, Mem.store chunk m2 b ofs v2 = Some m2' /\\ magree m1' m2' Q.","proofString":"exploit magree_storebytes_parallel.\neauto.\neauto.\ninstantiate (1 := Q).\nintros.\nrewrite encode_val_length in H4.\nrewrite <- size_chunk_conv in H4.\napply H2; auto.\neapply store_argument_sound; eauto.\nintros [m2' [SB2 AG]].\nexists m2'; split; auto.\napply Mem.storebytes_store; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) (SB1 : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1') : forall (b' : block) (i : Z),\nQ b' i ->\nb' <> b \\/\ni < ofs \\/ ofs + Z.of_nat (Datatypes.length (encode_val chunk v1)) <= i ->\nP b' i.","proofString":"intros.\nrewrite encode_val_length in H4.\nrewrite <- size_chunk_conv in H4.\napply H2; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b'0 : block) (i0 : Z),\nQ b'0 i0 -> b'0 <> b \\/ i0 < ofs \\/ ofs + size_chunk chunk <= i0 -> P b'0 i0) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) (SB1 : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1') (b' : block) (i : Z) (H3 : Q b' i) (H4 : b' <> b \\/\ni < ofs \\/ ofs + Z.of_nat (Datatypes.length (encode_val chunk v1)) <= i) : P b' i.","proofString":"rewrite encode_val_length in H4.\nrewrite <- size_chunk_conv in H4.\napply H2; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b'0 : block) (i0 : Z),\nQ b'0 i0 -> b'0 <> b \\/ i0 < ofs \\/ ofs + size_chunk chunk <= i0 -> P b'0 i0) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) (SB1 : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1') (b' : block) (i : Z) (H3 : Q b' i) (H4 : b' <> b \\/ i < ofs \\/ ofs + Z.of_nat (size_chunk_nat chunk) <= i) : P b' i.","proofString":"rewrite <- size_chunk_conv in H4.\napply H2; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b'0 : block) (i0 : Z),\nQ b'0 i0 -> b'0 <> b \\/ i0 < ofs \\/ ofs + size_chunk chunk <= i0 -> P b'0 i0) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) (SB1 : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1') (b' : block) (i : Z) (H3 : Q b' i) (H4 : b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i) : P b' i.","proofString":"apply H2; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) (SB1 : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1') (m2' : mem) (SB2 : Mem.storebytes m2 b ofs (encode_val chunk v2) = Some m2') (AG : magree m1' m2' Q) : exists m2'0 : mem,\n  Mem.store chunk m2 b ofs v2 = Some m2'0 /\\ magree m1' m2'0 Q.","proofString":"exists m2'; split; auto.\napply Mem.storebytes_store; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (v2 : val) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : vagree v1 v2 (store_argument chunk)) (H2 : forall (b' : block) (i : Z),\nQ b' i -> b' <> b \\/ i < ofs \\/ ofs + size_chunk chunk <= i -> P b' i) (A : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur Writable) (B : (align_chunk chunk | ofs)) (SB1 : Mem.storebytes m1 b ofs (encode_val chunk v1) = Some m1') (m2' : mem) (SB2 : Mem.storebytes m2 b ofs (encode_val chunk v2) = Some m2') (AG : magree m1' m2' Q) : Mem.store chunk m2 b ofs v2 = Some m2'.","proofString":"apply Mem.storebytes_store; auto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) : magree m1' m2 P.","proofString":"constructor; intros.\neapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto.\nexploit ma_perm_inv; eauto.\nintuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2.\nrewrite (Mem.storebytes_mem_contents _ _ _ _ _ H0).\nrewrite PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\nrewrite Mem.setN_outside.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\nrewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs0 k p) : Mem.perm m2 b0 ofs0 k p.","proofString":"eapply ma_perm; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs0 k p) : Mem.perm m1 b0 ofs0 k p.","proofString":"eapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2 b0 ofs0 k p) : Mem.perm m1' b0 ofs0 k p \\/ ~ Mem.perm m1' b0 ofs0 Max Nonempty.","proofString":"exploit ma_perm_inv; eauto.\nintuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2 b0 ofs0 k p) : Mem.perm m1 b0 ofs0 k p \\/ ~ Mem.perm m1 b0 ofs0 Max Nonempty ->\nMem.perm m1' b0 ofs0 k p \\/ ~ Mem.perm m1' b0 ofs0 Max Nonempty.","proofString":"intuition eauto using Mem.perm_storebytes_1, Mem.perm_storebytes_2."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (H2 : Mem.perm m1' b0 ofs0 Cur Readable) (H3 : P b0 ofs0) : memval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1') # b0)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b0).","proofString":"rewrite (Mem.storebytes_mem_contents _ _ _ _ _ H0).\nrewrite PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\nrewrite Mem.setN_outside.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (H2 : Mem.perm m1' b0 ofs0 Cur Readable) (H3 : P b0 ofs0) : memval_lessdef\n  (ZMap.get ofs0\n     ((Mem.mem_contents m1) # b <-\n      (Mem.setN bytes1 ofs (Mem.mem_contents m1) # b)) # b0)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b0).","proofString":"rewrite PMap.gsspec.\ndestruct (peq b0 b).\nsubst b0.\nrewrite Mem.setN_outside.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (H2 : Mem.perm m1' b0 ofs0 Cur Readable) (H3 : P b0 ofs0) : memval_lessdef\n  (ZMap.get ofs0\n     (if peq b0 b\n      then Mem.setN bytes1 ofs (Mem.mem_contents m1) # b\n      else (Mem.mem_contents m1) # b0))\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b0).","proofString":"destruct (peq b0 b).\nsubst b0.\nrewrite Mem.setN_outside.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (H2 : Mem.perm m1' b0 ofs0 Cur Readable) (H3 : P b0 ofs0) (e : b0 = b) : memval_lessdef\n  (ZMap.get ofs0 (Mem.setN bytes1 ofs (Mem.mem_contents m1) # b))\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b0).","proofString":"subst b0.\nrewrite Mem.setN_outside.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) : memval_lessdef\n  (ZMap.get ofs0 (Mem.setN bytes1 ofs (Mem.mem_contents m1) # b))\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b).","proofString":"rewrite Mem.setN_outside.\neapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto.\ndestruct (zlt ofs0 ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) : memval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b).","proofString":"eapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) : Mem.perm m1 b ofs0 Cur Readable.","proofString":"eapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (Datatypes.length bytes1).","proofString":"destruct (zlt ofs0 ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) (g : ofs0 >= ofs) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (Datatypes.length bytes1).","proofString":"destruct (zle (ofs + Z.of_nat (length bytes1)) ofs0); try lia.\nelim (H1 ofs0).\nlia.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) (g : ofs0 >= ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes1) > ofs0) : ofs0 < ofs \\/ ofs0 >= ofs + Z.of_nat (Datatypes.length bytes1).","proofString":"elim (H1 ofs0).\nlia.\nauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) (g : ofs0 >= ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes1) > ofs0) : ofs <= ofs0 < ofs + Z.of_nat (Datatypes.length bytes1).","proofString":"lia."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (ofs0 : Z) (H3 : P b ofs0) (H2 : Mem.perm m1' b ofs0 Cur Readable) (g : ofs0 >= ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes1) > ofs0) : P b ofs0.","proofString":"auto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (H2 : Mem.perm m1' b0 ofs0 Cur Readable) (H3 : P b0 ofs0) (n : b0 <> b) : memval_lessdef (ZMap.get ofs0 (Mem.mem_contents m1) # b0)\n  (ZMap.get ofs0 (Mem.mem_contents m2) # b0).","proofString":"eapply ma_memval; eauto.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) (b0 : block) (ofs0 : Z) (H2 : Mem.perm m1' b0 ofs0 Cur Readable) (H3 : P b0 ofs0) (n : b0 <> b) : Mem.perm m1 b0 ofs0 Cur Readable.","proofString":"eapply Mem.perm_storebytes_2; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) : Mem.nextblock m2 = Mem.nextblock m1'.","proofString":"rewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.storebytes m1 b ofs bytes1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + Z.of_nat (Datatypes.length bytes1) -> ~ P b i) : Mem.nextblock m2 = Mem.nextblock m1.","proofString":"eapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : forall i : Z, ofs <= i < ofs + size_chunk chunk -> ~ P b i) : magree m1' m2 P.","proofString":"eapply magree_storebytes_left; eauto.\neapply Mem.store_storebytes; eauto.\nintros.\nrewrite encode_val_length in H2.\nrewrite <- size_chunk_conv in H2.\napply H1; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : forall i0 : Z, ofs <= i0 < ofs + size_chunk chunk -> ~ P b i0) (i : Z) (H2 : ofs <= i < ofs + Z.of_nat (Datatypes.length (encode_val chunk v1))) : ~ P b i.","proofString":"rewrite encode_val_length in H2.\nrewrite <- size_chunk_conv in H2.\napply H1; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : forall i0 : Z, ofs <= i0 < ofs + size_chunk chunk -> ~ P b i0) (i : Z) (H2 : ofs <= i < ofs + Z.of_nat (size_chunk_nat chunk)) : ~ P b i.","proofString":"rewrite <- size_chunk_conv in H2.\napply H1; auto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (v1 : val) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.store chunk m1 b ofs v1 = Some m1') (H1 : forall i0 : Z, ofs <= i0 < ofs + size_chunk chunk -> ~ P b i0) (i : Z) (H2 : ofs <= i < ofs + size_chunk chunk) : ~ P b i.","proofString":"apply H1; auto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) : exists m2' : mem, Mem.free m2 b lo hi = Some m2' /\\ magree m1' m2' Q.","proofString":"destruct (Mem.range_perm_free m2 b lo hi) as [m2' FREE].\nred; intros.\neapply ma_perm; eauto.\neapply Mem.free_range_perm; eauto.\nexists m2'; split; auto.\nconstructor; intros.\nassert (Mem.perm m2 b0 ofs k p).\neapply ma_perm; eauto.\neapply Mem.perm_free_3; eauto.\nexploit Mem.perm_free_inv; eauto.\nintros [[A B] | A]; auto.\nsubst b0.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto.\nexploit ma_perm_inv; eauto using Mem.perm_free_3.\nintros [A|A].\neapply Mem.perm_free_inv in A; eauto.\ndestruct A as [[A B] | A]; auto.\nsubst b0; right; eapply Mem.perm_free_2; eauto.\nright; intuition eauto using Mem.perm_free_3.\nrewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_memval; eauto.\neapply Mem.perm_free_3; eauto.\napply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto.\nrewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) : Mem.range_perm m2 b lo hi Cur Freeable.","proofString":"red; intros.\neapply ma_perm; eauto.\neapply Mem.free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (ofs : Z) (H2 : lo <= ofs < hi) : Mem.perm m2 b ofs Cur Freeable.","proofString":"eapply ma_perm; eauto.\neapply Mem.free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (ofs : Z) (H2 : lo <= ofs < hi) : Mem.perm m1 b ofs Cur Freeable.","proofString":"eapply Mem.free_range_perm; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') : exists m2'0 : mem, Mem.free m2 b lo hi = Some m2'0 /\\ magree m1' m2'0 Q.","proofString":"exists m2'; split; auto.\nconstructor; intros.\nassert (Mem.perm m2 b0 ofs k p).\neapply ma_perm; eauto.\neapply Mem.perm_free_3; eauto.\nexploit Mem.perm_free_inv; eauto.\nintros [[A B] | A]; auto.\nsubst b0.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto.\nexploit ma_perm_inv; eauto using Mem.perm_free_3.\nintros [A|A].\neapply Mem.perm_free_inv in A; eauto.\ndestruct A as [[A B] | A]; auto.\nsubst b0; right; eapply Mem.perm_free_2; eauto.\nright; intuition eauto using Mem.perm_free_3.\nrewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_memval; eauto.\neapply Mem.perm_free_3; eauto.\napply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto.\nrewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') : magree m1' m2' Q.","proofString":"constructor; intros.\nassert (Mem.perm m2 b0 ofs k p).\neapply ma_perm; eauto.\neapply Mem.perm_free_3; eauto.\nexploit Mem.perm_free_inv; eauto.\nintros [[A B] | A]; auto.\nsubst b0.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto.\nexploit ma_perm_inv; eauto using Mem.perm_free_3.\nintros [A|A].\neapply Mem.perm_free_inv in A; eauto.\ndestruct A as [[A B] | A]; auto.\nsubst b0; right; eapply Mem.perm_free_2; eauto.\nright; intuition eauto using Mem.perm_free_3.\nrewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_memval; eauto.\neapply Mem.perm_free_3; eauto.\napply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto.\nrewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs k p) : Mem.perm m2' b0 ofs k p.","proofString":"assert (Mem.perm m2 b0 ofs k p).\neapply ma_perm; eauto.\neapply Mem.perm_free_3; eauto.\nexploit Mem.perm_free_inv; eauto.\nintros [[A B] | A]; auto.\nsubst b0.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs k p) : Mem.perm m2 b0 ofs k p.","proofString":"eapply ma_perm; eauto.\neapply Mem.perm_free_3; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs k p) : Mem.perm m1 b0 ofs k p.","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs k p) (H3 : Mem.perm m2 b0 ofs k p) : Mem.perm m2' b0 ofs k p.","proofString":"exploit Mem.perm_free_inv; eauto.\nintros [[A B] | A]; auto.\nsubst b0.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs k p) (H3 : Mem.perm m2 b0 ofs k p) : b0 = b /\\ lo <= ofs < hi \\/ Mem.perm m2' b0 ofs k p ->\nMem.perm m2' b0 ofs k p.","proofString":"intros [[A B] | A]; auto.\nsubst b0.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m1' b0 ofs k p) (H3 : Mem.perm m2 b0 ofs k p) (A : b0 = b) (B : lo <= ofs < hi) : Mem.perm m2' b0 ofs k p.","proofString":"subst b0.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (ofs : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m2 b ofs k p) (H2 : Mem.perm m1' b ofs k p) (B : lo <= ofs < hi) : Mem.perm m2' b ofs k p.","proofString":"eelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2' b0 ofs k p) : Mem.perm m1' b0 ofs k p \\/ ~ Mem.perm m1' b0 ofs Max Nonempty.","proofString":"exploit ma_perm_inv; eauto using Mem.perm_free_3.\nintros [A|A].\neapply Mem.perm_free_inv in A; eauto.\ndestruct A as [[A B] | A]; auto.\nsubst b0; right; eapply Mem.perm_free_2; eauto.\nright; intuition eauto using Mem.perm_free_3."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2' b0 ofs k p) : Mem.perm m1 b0 ofs k p \\/ ~ Mem.perm m1 b0 ofs Max Nonempty ->\nMem.perm m1' b0 ofs k p \\/ ~ Mem.perm m1' b0 ofs Max Nonempty.","proofString":"intros [A|A].\neapply Mem.perm_free_inv in A; eauto.\ndestruct A as [[A B] | A]; auto.\nsubst b0; right; eapply Mem.perm_free_2; eauto.\nright; intuition eauto using Mem.perm_free_3."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2' b0 ofs k p) (A : Mem.perm m1 b0 ofs k p) : Mem.perm m1' b0 ofs k p \\/ ~ Mem.perm m1' b0 ofs Max Nonempty.","proofString":"eapply Mem.perm_free_inv in A; eauto.\ndestruct A as [[A B] | A]; auto.\nsubst b0; right; eapply Mem.perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2' b0 ofs k p) (A : b0 = b /\\ lo <= ofs < hi \\/ Mem.perm m1' b0 ofs k p) : Mem.perm m1' b0 ofs k p \\/ ~ Mem.perm m1' b0 ofs Max Nonempty.","proofString":"destruct A as [[A B] | A]; auto.\nsubst b0; right; eapply Mem.perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2' b0 ofs k p) (A : b0 = b) (B : lo <= ofs < hi) : Mem.perm m1' b0 ofs k p \\/ ~ Mem.perm m1' b0 ofs Max Nonempty.","proofString":"subst b0; right; eapply Mem.perm_free_2; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m2' b0 ofs k p) (A : ~ Mem.perm m1 b0 ofs Max Nonempty) : Mem.perm m1' b0 ofs k p \\/ ~ Mem.perm m1' b0 ofs Max Nonempty.","proofString":"right; intuition eauto using Mem.perm_free_3."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) : memval_lessdef (ZMap.get ofs (Mem.mem_contents m1') # b0)\n  (ZMap.get ofs (Mem.mem_contents m2') # b0).","proofString":"rewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_memval; eauto.\neapply Mem.perm_free_3; eauto.\napply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) : memval_lessdef\n  (ZMap.get ofs (Mem.mem_contents (Mem.unchecked_free m1 b lo hi)) # b0)\n  (ZMap.get ofs (Mem.mem_contents m2') # b0).","proofString":"rewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_memval; eauto.\neapply Mem.perm_free_3; eauto.\napply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) : memval_lessdef\n  (ZMap.get ofs (Mem.mem_contents (Mem.unchecked_free m1 b lo hi)) # b0)\n  (ZMap.get ofs (Mem.mem_contents (Mem.unchecked_free m2 b lo hi)) # b0).","proofString":"simpl.\neapply ma_memval; eauto.\neapply Mem.perm_free_3; eauto.\napply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) : memval_lessdef (ZMap.get ofs (Mem.mem_contents m1) # b0)\n  (ZMap.get ofs (Mem.mem_contents m2) # b0).","proofString":"eapply ma_memval; eauto.\neapply Mem.perm_free_3; eauto.\napply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) : Mem.perm m1 b0 ofs Cur Readable.","proofString":"eapply Mem.perm_free_3; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) : P b0 ofs.","proofString":"apply H1; auto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) : b0 <> b \\/ ~ lo <= ofs < hi.","proofString":"destruct (eq_block b0 b); auto.\nsubst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (b0 : block) (ofs : Z) (H2 : Mem.perm m1' b0 ofs Cur Readable) (H3 : Q b0 ofs) (e : b0 = b) : b0 <> b \\/ ~ lo <= ofs < hi.","proofString":"subst b0.\nright.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (ofs : Z) (H3 : Q b ofs) (H2 : Mem.perm m1' b ofs Cur Readable) : b <> b \\/ ~ lo <= ofs < hi.","proofString":"right.\nred; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (ofs : Z) (H3 : Q b ofs) (H2 : Mem.perm m1' b ofs Cur Readable) : ~ lo <= ofs < hi.","proofString":"red; intros.\neelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') (ofs : Z) (H3 : Q b ofs) (H2 : Mem.perm m1' b ofs Cur Readable) (H4 : lo <= ofs < hi) : False.","proofString":"eelim Mem.perm_free_2.\neexact H0.\neauto.\neauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') : Mem.nextblock m2' = Mem.nextblock m1'.","proofString":"rewrite (Mem.free_result _ _ _ _ _ H0).\nrewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') : Mem.nextblock m2' = Mem.nextblock (Mem.unchecked_free m1 b lo hi).","proofString":"rewrite (Mem.free_result _ _ _ _ _ FREE).\nsimpl.\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') : Mem.nextblock (Mem.unchecked_free m2 b lo hi) =\nMem.nextblock (Mem.unchecked_free m1 b lo hi).","proofString":"simpl.\neapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P Q : locset) (b : block) (lo hi : Z) (m1' : mem) (H : magree m1 m2 P) (H0 : Mem.free m1 b lo hi = Some m1') (H1 : forall (b' : block) (i : Z), Q b' i -> b' <> b \\/ ~ lo <= i < hi -> P b' i) (m2' : mem) (FREE : Mem.free m2 b lo hi = Some m2') : Mem.nextblock m2 = Mem.nextblock m1.","proofString":"eapply ma_nextblock; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : magree m1 m2 P) (H0 : Mem.valid_access m1 chunk b ofs p) : Mem.valid_access m2 chunk b ofs p.","proofString":"destruct H0; split; auto.\nred; intros.\neapply ma_perm; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : magree m1 m2 P) (H0 : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) : Mem.range_perm m2 b ofs (ofs + size_chunk chunk) Cur p.","proofString":"red; intros.\neapply ma_perm; eauto."},{"statement":"(m1 m2 : mem) (P : locset) (chunk : memory_chunk) (b : block) (ofs : Z) (p : permission) (H : magree m1 m2 P) (H0 : Mem.range_perm m1 b ofs (ofs + size_chunk chunk) Cur p) (H1 : (align_chunk chunk | ofs)) (ofs0 : Z) (H2 : ofs <= ofs0 < ofs + size_chunk chunk) : Mem.perm m2 b ofs0 Cur p.","proofString":"eapply ma_perm; eauto."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) (r0 : positive) : vagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"generalize (H r0).\nunfold add_need_all.\nrewrite NE.gsspec.\ndestruct (peq r0 r); auto with na."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) (r0 : positive) : vagree e # r0 e' # r0 (NE.get r0 (add_need_all r ne)) ->\nvagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"unfold add_need_all.\nrewrite NE.gsspec.\ndestruct (peq r0 r); auto with na."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) (r0 : positive) : vagree e # r0 e' # r0 (NE.get r0 (NE.set r All ne)) ->\nvagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"rewrite NE.gsspec.\ndestruct (peq r0 r); auto with na."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) (r0 : positive) : vagree e # r0 e' # r0 (if peq r0 r then All else NE.get r0 ne) ->\nvagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"destruct (peq r0 r); auto with na."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) : Val.lessdef e # r e' # r.","proofString":"generalize (H r); unfold add_need_all.\nrewrite NE.gsspec, peq_true.\nauto with na."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) : vagree e # r e' # r (NE.get r (NE.set r All ne)) -> Val.lessdef e # r e' # r.","proofString":"rewrite NE.gsspec, peq_true.\nauto with na."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) : vagree e # r e' # r All -> Val.lessdef e # r e' # r.","proofString":"auto with na."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (r0 : positive) : vagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"generalize (H r0); unfold add_need.\nrewrite NE.gsspec.\ndestruct (peq r0 r); auto.\nsubst r0.\nintros.\neapply nge_agree; eauto.\napply nge_lub_r."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (r0 : positive) : vagree e # r0 e' # r0 (NE.get r0 (NE.set r (nlub nv (NE.get r ne)) ne)) ->\nvagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"rewrite NE.gsspec.\ndestruct (peq r0 r); auto.\nsubst r0.\nintros.\neapply nge_agree; eauto.\napply nge_lub_r."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (r0 : positive) : vagree e # r0 e' # r0\n  (if peq r0 r then nlub nv (NE.get r ne) else NE.get r0 ne) ->\nvagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"destruct (peq r0 r); auto.\nsubst r0.\nintros.\neapply nge_agree; eauto.\napply nge_lub_r."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (r0 : positive) (e0 : r0 = r) : vagree e # r0 e' # r0 (nlub nv (NE.get r ne)) ->\nvagree e # r0 e' # r0 (NE.get r0 ne).","proofString":"subst r0.\nintros.\neapply nge_agree; eauto.\napply nge_lub_r."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) : vagree e # r e' # r (nlub nv (NE.get r ne)) ->\nvagree e # r e' # r (NE.get r ne).","proofString":"intros.\neapply nge_agree; eauto.\napply nge_lub_r."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (H0 : vagree e # r e' # r (nlub nv (NE.get r ne))) : vagree e # r e' # r (NE.get r ne).","proofString":"eapply nge_agree; eauto.\napply nge_lub_r."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (H0 : vagree e # r e' # r (nlub nv (NE.get r ne))) : nge (nlub nv (NE.get r ne)) (NE.get r ne).","proofString":"apply nge_lub_r."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) : vagree e # r e' # r nv.","proofString":"generalize (H r); unfold add_need.\nrewrite NE.gsspec, peq_true.\nintros.\neapply nge_agree; eauto.\napply nge_lub_l."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) : vagree e # r e' # r (NE.get r (NE.set r (nlub nv (NE.get r ne)) ne)) ->\nvagree e # r e' # r nv.","proofString":"rewrite NE.gsspec, peq_true.\nintros.\neapply nge_agree; eauto.\napply nge_lub_l."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) : vagree e # r e' # r (nlub nv (NE.get r ne)) -> vagree e # r e' # r nv.","proofString":"intros.\neapply nge_agree; eauto.\napply nge_lub_l."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (H0 : vagree e # r e' # r (nlub nv (NE.get r ne))) : vagree e # r e' # r nv.","proofString":"eapply nge_agree; eauto.\napply nge_lub_l."},{"statement":"(e e' : regset) (r : reg) (nv : nval) (ne : nenv) (H : eagree e e' (add_need r nv ne)) (H0 : vagree e # r e' # r (nlub nv (NE.get r ne))) : nge (nlub nv (NE.get r ne)) nv.","proofString":"apply nge_lub_l."},{"statement":"(e e' : regset) (ne : nenv) (H : eagree e e' ne) : eagree e e' ne.","proofString":"auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs_all rl ne0) -> eagree e0 e'0 ne0) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : eagree e e' ne.","proofString":"apply IHrl.\neapply add_need_all_eagree; eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs_all rl ne0) -> eagree e0 e'0 ne0) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : eagree e e' (add_needs_all rl ne).","proofString":"eapply add_need_all_eagree; eauto."},{"statement":"(e e' : regset) (ne : nenv) (H : eagree e e' ne) : Val.lessdef_list nil nil.","proofString":"constructor."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs_all rl ne0) -> Val.lessdef_list e0 ## rl e'0 ## rl) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : Val.lessdef_list (e # a :: e ## rl) (e' # a :: e' ## rl).","proofString":"constructor.\neapply add_need_all_lessdef; eauto.\neapply IHrl.\neapply add_need_all_eagree; eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs_all rl ne0) -> Val.lessdef_list e0 ## rl e'0 ## rl) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : Val.lessdef e # a e' # a.","proofString":"eapply add_need_all_lessdef; eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs_all rl ne0) -> Val.lessdef_list e0 ## rl e'0 ## rl) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : Val.lessdef_list e ## rl e' ## rl.","proofString":"eapply IHrl.\neapply add_need_all_eagree; eauto."},{"statement":"(nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e' ne) : eagree e e' ne.","proofString":"auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl0 : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl0 ne0) -> eagree e0 e'0 ne0) (nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e'\n  match nvl with\n  | nil => add_need_all a (add_needs_all rl ne)\n  | nv1 :: nvs => add_need a nv1 (add_needs rl nvs ne)\n  end) : eagree e e' ne.","proofString":"destruct nvl.\napply add_needs_all_eagree with (a :: rl); auto.\neapply IHrl.\neapply add_need_eagree; eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl ne0) -> eagree e0 e'0 ne0) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : eagree e e' ne.","proofString":"apply add_needs_all_eagree with (a :: rl); auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl0 : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl0 ne0) -> eagree e0 e'0 ne0) (n : nval) (nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need a n (add_needs rl nvl ne))) : eagree e e' ne.","proofString":"eapply IHrl.\neapply add_need_eagree; eauto."},{"statement":"(nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e' ne) : vagree_list nil nil nvl.","proofString":"constructor."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl0 : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl0 ne0) -> vagree_list e0 ## rl e'0 ## rl nvl0) (nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e'\n  match nvl with\n  | nil => add_need_all a (add_needs_all rl ne)\n  | nv1 :: nvs => add_need a nv1 (add_needs rl nvs ne)\n  end) : vagree_list (e # a :: e ## rl) (e' # a :: e' ## rl) nvl.","proofString":"destruct nvl.\napply vagree_lessdef_list.\neapply add_needs_all_lessdef with (rl := a :: rl); eauto.\nconstructor.\neapply add_need_vagree; eauto.\neapply IHrl.\neapply add_need_eagree; eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl ne0) -> vagree_list e0 ## rl e'0 ## rl nvl) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : vagree_list (e # a :: e ## rl) (e' # a :: e' ## rl) nil.","proofString":"apply vagree_lessdef_list.\neapply add_needs_all_lessdef with (rl := a :: rl); eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl ne0) -> vagree_list e0 ## rl e'0 ## rl nvl) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need_all a (add_needs_all rl ne))) : Val.lessdef_list (e # a :: e ## rl) (e' # a :: e' ## rl).","proofString":"eapply add_needs_all_lessdef with (rl := a :: rl); eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl0 : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl0 ne0) -> vagree_list e0 ## rl e'0 ## rl nvl0) (n : nval) (nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need a n (add_needs rl nvl ne))) : vagree_list (e # a :: e ## rl) (e' # a :: e' ## rl) (n :: nvl).","proofString":"constructor.\neapply add_need_vagree; eauto.\neapply IHrl.\neapply add_need_eagree; eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl0 : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl0 ne0) -> vagree_list e0 ## rl e'0 ## rl nvl0) (n : nval) (nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need a n (add_needs rl nvl ne))) : vagree e # a e' # a n.","proofString":"eapply add_need_vagree; eauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (nvl0 : list nval) (e0 e'0 : regset) (ne0 : nenv),\neagree e0 e'0 (add_needs rl nvl0 ne0) -> vagree_list e0 ## rl e'0 ## rl nvl0) (n : nval) (nvl : list nval) (e e' : regset) (ne : nenv) (H : eagree e e' (add_need a n (add_needs rl nvl ne))) : vagree_list e ## rl e' ## rl nvl.","proofString":"eapply IHrl.\neapply add_need_eagree; eauto."},{"statement":"(e e' : regset) (ros : reg + ident) (ne : nenv) (H : eagree e e' (add_ros_need_all ros ne)) : eagree e e' ne.","proofString":"destruct ros; simpl in *.\neapply add_need_all_eagree; eauto.\nauto."},{"statement":"(e e' : regset) (r : reg) (ne : nenv) (H : eagree e e' (add_need_all r ne)) : eagree e e' ne.","proofString":"eapply add_need_all_eagree; eauto."},{"statement":"(e e' : regset) (i : ident) (ne : nenv) (H : eagree e e' ne) : eagree e e' ne.","proofString":"auto."},{"statement":"(vl1 vl2 : list val) (ne : nenv) (LD : Val.lessdef_list vl1 vl2) : eagree (Regmap.init Vundef) (Regmap.init Vundef) ne.","proofString":"red; auto with na."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (vl0 vl3 : list val) (ne0 : nenv),\nVal.lessdef_list vl0 vl3 -> eagree (init_regs vl0 rl) (init_regs vl3 rl) ne0) (vl1 vl2 : list val) (ne : nenv) (LD : Val.lessdef_list vl1 vl2) : eagree\n  match vl1 with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end\n  match vl2 with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end ne.","proofString":"inv LD.\nred; auto with na.\napply eagree_update; auto with na."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (vl1 vl2 : list val) (ne0 : nenv),\nVal.lessdef_list vl1 vl2 -> eagree (init_regs vl1 rl) (init_regs vl2 rl) ne0) (ne : nenv) : eagree (Regmap.init Vundef) (Regmap.init Vundef) ne.","proofString":"red; auto with na."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall (vl1 vl2 : list val) (ne0 : nenv),\nVal.lessdef_list vl1 vl2 -> eagree (init_regs vl1 rl) (init_regs vl2 rl) ne0) (ne : nenv) (v1 v2 : val) (vl0 vl3 : list val) (H : Val.lessdef v1 v2) (H0 : Val.lessdef_list vl0 vl3) : eagree (init_regs vl0 rl) # a <- v1 (init_regs vl3 rl) # a <- v2 ne.","proofString":"apply eagree_update; auto with na."},{"statement":"(dm : defmap) (rm : romem) (f x : function) (EQ : transf_function dm rm f = OK x) : funsig (Internal x) = funsig (Internal f).","proofString":"unfold transf_function in EQ.\ndestruct analyze; inv EQ; auto."},{"statement":"(dm : defmap) (rm : romem) (f x : function) (EQ : match analyze f dm (ValueAnalysis.analyze rm f) with\n| Some an =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code :=\n          PTree.map (transf_instr dm (ValueAnalysis.analyze rm f) an)\n            (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"Neededness analysis failed\")\nend = OK x) : funsig (Internal x) = funsig (Internal f).","proofString":"destruct analyze; inv EQ; auto."},{"statement":"(dm : defmap) (rm : romem) (e : external_function) : funsig (External e) = funsig (External e).","proofString":"auto."},{"statement":"(dm : defmap) (rm : romem) (f tf : function) (H : match analyze f dm (ValueAnalysis.analyze rm f) with\n| Some an =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code :=\n          PTree.map (transf_instr dm (ValueAnalysis.analyze rm f) an)\n            (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"Neededness analysis failed\")\nend = OK tf) : fn_stacksize tf = fn_stacksize f.","proofString":"destruct analyze; inv H; auto."},{"statement":"(cu : AST.program fundef unit) (f tf : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (H : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (H0 : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (H1 : (fn_code f) ! pc = Some instr) : (fn_code tf) ! pc =\nSome (transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).","proofString":"unfold transf_function in H.\nunfold vanalyze in H0.\nrewrite H0 in H.\ninv H; simpl.\nrewrite PTree.gmap.\nrewrite H1; auto."},{"statement":"(cu : AST.program fundef unit) (f tf : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (H : match\n  analyze f (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f)\nwith\n| Some an0 =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code :=\n          PTree.map\n            (transf_instr (prog_defmap cu)\n               (ValueAnalysis.analyze (romem_for cu) f) an0) \n            (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"Neededness analysis failed\")\nend = OK tf) (H0 : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (H1 : (fn_code f) ! pc = Some instr) : (fn_code tf) ! pc =\nSome (transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).","proofString":"unfold vanalyze in H0.\nrewrite H0 in H.\ninv H; simpl.\nrewrite PTree.gmap.\nrewrite H1; auto."},{"statement":"(cu : AST.program fundef unit) (f tf : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (H : match\n  analyze f (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f)\nwith\n| Some an0 =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code :=\n          PTree.map\n            (transf_instr (prog_defmap cu)\n               (ValueAnalysis.analyze (romem_for cu) f) an0) \n            (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"Neededness analysis failed\")\nend = OK tf) (H0 : analyze f (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f) = Some an) (H1 : (fn_code f) ! pc = Some instr) : (fn_code tf) ! pc =\nSome (transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).","proofString":"rewrite H0 in H.\ninv H; simpl.\nrewrite PTree.gmap.\nrewrite H1; auto."},{"statement":"(cu : AST.program fundef unit) (f tf : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (H : OK\n  {|\n    fn_sig := fn_sig f;\n    fn_params := fn_params f;\n    fn_stacksize := fn_stacksize f;\n    fn_code :=\n      PTree.map\n        (transf_instr (prog_defmap cu)\n           (ValueAnalysis.analyze (romem_for cu) f) an) \n        (fn_code f);\n    fn_entrypoint := fn_entrypoint f\n  |} = OK tf) (H0 : analyze f (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f) = Some an) (H1 : (fn_code f) ! pc = Some instr) : (fn_code tf) ! pc =\nSome (transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).","proofString":"inv H; simpl.\nrewrite PTree.gmap.\nrewrite H1; auto."},{"statement":"(cu : AST.program fundef unit) (f : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (H0 : analyze f (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f) = Some an) (H1 : (fn_code f) ! pc = Some instr) : (PTree.map\n   (transf_instr (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f) an)\n   (fn_code f)) ! pc =\nSome (transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).","proofString":"rewrite PTree.gmap.\nrewrite H1; auto."},{"statement":"(cu : AST.program fundef unit) (f : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (H0 : analyze f (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f) = Some an) (H1 : (fn_code f) ! pc = Some instr) : option_map\n  (transf_instr (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f) an\n     pc) (fn_code f) ! pc =\nSome (transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).","proofString":"rewrite H1; auto."},{"statement":"(nv : nval) (H : is_dead nv = false) (H0 : nv = Nothing) : False.","proofString":"subst nv; discriminate."},{"statement":"(m : int) : Int.eq m Int.zero = true -> I m = I Int.zero.","proofString":"predSpec Int.eq Int.eq_spec m Int.zero; congruence."},{"statement":"(ros : reg + ident) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (H : find_function ge ros rs = Some fd) (H0 : eagree rs trs (add_ros_need_all ros ne)) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  find_function tge ros trs = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"destruct ros as [r|id]; simpl in *.\nassert (LD: Val.lessdef rs#r trs#r) by eauto with na.\ninv LD.\napply functions_translated; auto.\nrewrite <- H2 in H; discriminate.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id); try discriminate.\napply function_ptr_translated; auto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (H : Genv.find_funct ge rs # r = Some fd) (H0 : eagree rs trs (add_need_all r ne)) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge trs # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"assert (LD: Val.lessdef rs#r trs#r) by eauto with na.\ninv LD.\napply functions_translated; auto.\nrewrite <- H2 in H; discriminate."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (H : Genv.find_funct ge rs # r = Some fd) (H0 : eagree rs trs (add_need_all r ne)) (LD : Val.lessdef rs # r trs # r) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge trs # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"inv LD.\napply functions_translated; auto.\nrewrite <- H2 in H; discriminate."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (H : Genv.find_funct ge rs # r = Some fd) (H0 : eagree rs trs (add_need_all r ne)) (H3 : rs # r = trs # r) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge rs # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"apply functions_translated; auto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (H : Genv.find_funct ge rs # r = Some fd) (H0 : eagree rs trs (add_need_all r ne)) (H2 : Vundef = rs # r) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct tge trs # r = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"rewrite <- H2 in H; discriminate."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : eagree rs trs ne) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  match Genv.find_symbol tge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id); try discriminate.\napply function_ptr_translated; auto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H0 : eagree rs trs ne) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  match Genv.find_symbol ge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"destruct (Genv.find_symbol ge id); try discriminate.\napply function_ptr_translated; auto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (trs : regset) (ne : nenv) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : eagree rs trs ne) : exists (cu : AST.program fundef unit) (tfd : fundef),\n  Genv.find_funct_ptr tge b = Some tfd /\\\n  transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n  linkorder cu prog.","proofString":"apply function_ptr_translated; auto."},{"statement":"(cu : AST.program fundef unit) (f : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (pc' : node) (H : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) : NA.ge an # pc (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc').","proofString":"eapply DS.fixpoint_solution; eauto.\nintros.\nunfold transfer; rewrite H2.\ndestruct a.\napply DS.L.eq_refl."},{"statement":"(cu : AST.program fundef unit) (f : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (pc' : node) (H : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) : forall (n : positive) (a : DS.L.t),\n(fn_code f) ! n = None ->\nDS.L.eq (transfer f (prog_defmap cu) (vanalyze cu f) n a) DS.L.bot.","proofString":"intros.\nunfold transfer; rewrite H2.\ndestruct a.\napply DS.L.eq_refl."},{"statement":"(cu : AST.program fundef unit) (f : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (pc' : node) (H : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) (n : positive) (a : DS.L.t) (H2 : (fn_code f) ! n = None) : DS.L.eq (transfer f (prog_defmap cu) (vanalyze cu f) n a) DS.L.bot.","proofString":"unfold transfer; rewrite H2.\ndestruct a.\napply DS.L.eq_refl."},{"statement":"(cu : AST.program fundef unit) (f : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (pc' : node) (H : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) (n : positive) (a : DS.L.t) (H2 : (fn_code f) ! n = None) : DS.L.eq (let (_, _) := a in NA.bot) DS.L.bot.","proofString":"destruct a.\napply DS.L.eq_refl."},{"statement":"(cu : AST.program fundef unit) (f : function) (an : PMap.t NA.t) (pc : positive) (instr : instruction) (pc' : node) (H : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) (n : positive) (n0 : nenv) (n1 : nmem) (H2 : (fn_code f) ! n = None) : DS.L.eq NA.bot DS.L.bot.","proofString":"apply DS.L.eq_refl."},{"statement":"(s : list stackframe) (f : function) (sp : block) (pc : positive) (e : regset) (m : mem) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (an : PMap.t NA.t) (pc' : node) (cu : program) (instr : instruction) (ne : nenv) (nm : nmem) (LINK : linkorder cu prog) (STACKS : list_forall2 match_stackframes s ts) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (INSTR : (fn_code f) ! pc = Some instr) (SUCC : In pc' (successors_instr instr)) (ANPC : an # pc = (ne, nm)) (ENV : eagree e te ne) (MEM : magree m tm (nlive ge sp nm)) : match_states (State s f (Vptr sp Ptrofs.zero) pc' e m)\n  (State ts tf (Vptr sp Ptrofs.zero) pc' te tm).","proofString":"exploit analyze_successors; eauto.\nrewrite ANPC; simpl.\nintros [A B].\neconstructor; eauto.\neapply eagree_ge; eauto.\neapply magree_monotone; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : block) (pc : positive) (e : regset) (m : mem) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (an : PMap.t NA.t) (pc' : node) (cu : program) (instr : instruction) (ne : nenv) (nm : nmem) (LINK : linkorder cu prog) (STACKS : list_forall2 match_stackframes s ts) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (INSTR : (fn_code f) ! pc = Some instr) (SUCC : In pc' (successors_instr instr)) (ANPC : an # pc = (ne, nm)) (ENV : eagree e te ne) (MEM : magree m tm (nlive ge sp nm)) : NA.ge an # pc (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc') ->\nmatch_states (State s f (Vptr sp Ptrofs.zero) pc' e m)\n  (State ts tf (Vptr sp Ptrofs.zero) pc' te tm).","proofString":"rewrite ANPC; simpl.\nintros [A B].\neconstructor; eauto.\neapply eagree_ge; eauto.\neapply magree_monotone; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : block) (pc : positive) (e : regset) (m : mem) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (an : PMap.t NA.t) (pc' : node) (cu : program) (instr : instruction) (ne : nenv) (nm : nmem) (LINK : linkorder cu prog) (STACKS : list_forall2 match_stackframes s ts) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (INSTR : (fn_code f) ! pc = Some instr) (SUCC : In pc' (successors_instr instr)) (ANPC : an # pc = (ne, nm)) (ENV : eagree e te ne) (MEM : magree m tm (nlive ge sp nm)) : NA.ge (ne, nm) (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc') ->\nmatch_states (State s f (Vptr sp Ptrofs.zero) pc' e m)\n  (State ts tf (Vptr sp Ptrofs.zero) pc' te tm).","proofString":"intros [A B].\neconstructor; eauto.\neapply eagree_ge; eauto.\neapply magree_monotone; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : block) (pc : positive) (e : regset) (m : mem) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (an : PMap.t NA.t) (pc' : node) (cu : program) (instr : instruction) (ne : nenv) (nm : nmem) (LINK : linkorder cu prog) (STACKS : list_forall2 match_stackframes s ts) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (INSTR : (fn_code f) ! pc = Some instr) (SUCC : In pc' (successors_instr instr)) (ANPC : an # pc = (ne, nm)) (ENV : eagree e te ne) (MEM : magree m tm (nlive ge sp nm)) (A : NE.ge (fst (ne, nm))\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))) (B : forall (ge0 : genv) (sp0 b : block) (ofs : Z),\nnlive ge0 sp0\n  (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc')) b ofs ->\nnlive ge0 sp0 (snd (ne, nm)) b ofs) : match_states (State s f (Vptr sp Ptrofs.zero) pc' e m)\n  (State ts tf (Vptr sp Ptrofs.zero) pc' te tm).","proofString":"econstructor; eauto.\neapply eagree_ge; eauto.\neapply magree_monotone; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : block) (pc : positive) (e : regset) (m : mem) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (an : PMap.t NA.t) (pc' : node) (cu : program) (instr : instruction) (ne : nenv) (nm : nmem) (LINK : linkorder cu prog) (STACKS : list_forall2 match_stackframes s ts) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (INSTR : (fn_code f) ! pc = Some instr) (SUCC : In pc' (successors_instr instr)) (ANPC : an # pc = (ne, nm)) (ENV : eagree e te ne) (MEM : magree m tm (nlive ge sp nm)) (A : NE.ge (fst (ne, nm))\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))) (B : forall (ge0 : genv) (sp0 b : block) (ofs : Z),\nnlive ge0 sp0\n  (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc')) b ofs ->\nnlive ge0 sp0 (snd (ne, nm)) b ofs) : eagree e te (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc')).","proofString":"eapply eagree_ge; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : block) (pc : positive) (e : regset) (m : mem) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (an : PMap.t NA.t) (pc' : node) (cu : program) (instr : instruction) (ne : nenv) (nm : nmem) (LINK : linkorder cu prog) (STACKS : list_forall2 match_stackframes s ts) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (INSTR : (fn_code f) ! pc = Some instr) (SUCC : In pc' (successors_instr instr)) (ANPC : an # pc = (ne, nm)) (ENV : eagree e te ne) (MEM : magree m tm (nlive ge sp nm)) (A : NE.ge (fst (ne, nm))\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))) (B : forall (ge0 : genv) (sp0 b : block) (ofs : Z),\nnlive ge0 sp0\n  (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc')) b ofs ->\nnlive ge0 sp0 (snd (ne, nm)) b ofs) : magree m tm\n  (nlive ge sp\n     (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))).","proofString":"eapply magree_monotone; eauto."},{"statement":"(e1 e2 : regset) (v1 v2 : val) (res : builtin_res reg) (ne : NE.t) (H : Val.lessdef v1 v2) (H0 : eagree e1 e2 (kill_builtin_res res ne)) : eagree (regmap_setres res v1 e1) (regmap_setres res v2 e2) ne.","proofString":"destruct res; simpl in *; auto.\napply eagree_update; eauto.\napply vagree_lessdef; auto."},{"statement":"(e1 e2 : regset) (v1 v2 : val) (x : reg) (ne : NE.t) (H : Val.lessdef v1 v2) (H0 : eagree e1 e2 (kill x ne)) : eagree e1 # x <- v1 e2 # x <- v2 ne.","proofString":"apply eagree_update; eauto.\napply vagree_lessdef; auto."},{"statement":"(e1 e2 : regset) (v1 v2 : val) (x : reg) (ne : NE.t) (H : Val.lessdef v1 v2) (H0 : eagree e1 e2 (kill x ne)) : vagree v1 v2 (nreg ne x).","proofString":"apply vagree_lessdef; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (x : positive) (nv : nval) (ne1 : nenv) (nm2 : nmem) (EA : eagree e e' (add_need x nv ne1)) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA x) v' /\\\n  vagree e # x v' nv /\\ eagree e e' ne1 /\\ magree m m' (nlive ge sp nm2).","proofString":"exists e'#x; intuition auto.\nconstructor.\neauto 2 with na.\neauto 2 with na."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (x : positive) (nv : nval) (ne1 : nenv) (nm2 : nmem) (EA : eagree e e' (add_need x nv ne1)) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA x) e' # x.","proofString":"constructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (x : positive) (nv : nval) (ne1 : nenv) (nm2 : nmem) (EA : eagree e e' (add_need x nv ne1)) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : vagree e # x e' # x nv.","proofString":"eauto 2 with na."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (x : positive) (nv : nval) (ne1 : nenv) (nm2 : nmem) (EA : eagree e e' (add_need x nv ne1)) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eagree e e' ne1.","proofString":"eauto 2 with na."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : int) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_int n) v' /\\\n  vagree (Vint n) v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm2).","proofString":"exists (Vint n); intuition auto.\nconstructor.\napply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : int) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_int n) (Vint n).","proofString":"constructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : int) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : vagree (Vint n) (Vint n) nv.","proofString":"apply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : int64) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_long n) v' /\\\n  vagree (Vlong n) v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm2).","proofString":"exists (Vlong n); intuition auto.\nconstructor.\napply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : int64) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_long n) (Vlong n).","proofString":"constructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : int64) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : vagree (Vlong n) (Vlong n) nv.","proofString":"apply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : float) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_float n) v' /\\\n  vagree (Vfloat n) v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm2).","proofString":"exists (Vfloat n); intuition auto.\nconstructor.\napply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : float) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_float n) (Vfloat n).","proofString":"constructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : float) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : vagree (Vfloat n) (Vfloat n) nv.","proofString":"apply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : float32) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_single n) v' /\\\n  vagree (Vsingle n) v' nv /\\\n  eagree e e' ne2 /\\ magree m m' (nlive ge sp nm2).","proofString":"exists (Vsingle n); intuition auto.\nconstructor.\napply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : float32) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_single n) (Vsingle n).","proofString":"constructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (n : float32) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : vagree (Vsingle n) (Vsingle n) nv.","proofString":"apply vagree_same."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadstack chunk ofs) v' /\\\n  vagree v v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"simpl in H.\nexploit magree_load; eauto.\nintros.\neapply nlive_add; eauto with va.\nrewrite Ptrofs.add_zero_l in H0; auto.\nintros (v' & A & B).\nexists v'; intuition auto.\nconstructor; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadstack chunk ofs) v' /\\\n  vagree v v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"exploit magree_load; eauto.\nintros.\neapply nlive_add; eauto with va.\nrewrite Ptrofs.add_zero_l in H0; auto.\nintros (v' & A & B).\nexists v'; intuition auto.\nconstructor; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : forall i : Z,\nPtrofs.unsigned (Ptrofs.add Ptrofs.zero ofs) <= i <\nPtrofs.unsigned (Ptrofs.add Ptrofs.zero ofs) + size_chunk chunk ->\nnlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)) sp i.","proofString":"intros.\neapply nlive_add; eauto with va.\nrewrite Ptrofs.add_zero_l in H0; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (i : Z) (H0 : Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs) <= i <\nPtrofs.unsigned (Ptrofs.add Ptrofs.zero ofs) + size_chunk chunk) : nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)) sp i.","proofString":"eapply nlive_add; eauto with va.\nrewrite Ptrofs.add_zero_l in H0; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (i : Z) (H0 : Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs) <= i <\nPtrofs.unsigned (Ptrofs.add Ptrofs.zero ofs) + size_chunk chunk) : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk.","proofString":"rewrite Ptrofs.add_zero_l in H0; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : (exists v' : val,\n   Mem.load chunk m' sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) =\n   Some v' /\\ Val.lessdef v v') ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadstack chunk ofs) v' /\\\n  vagree v v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"intros (v' & A & B).\nexists v'; intuition auto.\nconstructor; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v') (B : Val.lessdef v v') : exists v'0 : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadstack chunk ofs) v'0 /\\\n  vagree v v'0 nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"exists v'; intuition auto.\nconstructor; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v') (B : Val.lessdef v v') : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_loadstack chunk ofs) v'.","proofString":"constructor; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v') (B : Val.lessdef v v') : vagree v v' nv.","proofString":"apply vagree_lessdef; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v') (B : Val.lessdef v v') : magree m m' (nlive ge sp nm1).","proofString":"eapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v') (B : Val.lessdef v v') : forall (b : block) (ofs0 : Z),\nnlive ge sp nm1 b ofs0 ->\nnlive ge sp (nmem_add nm1 (Stk ofs) (size_chunk chunk)) b ofs0.","proofString":"intros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (ofs : ptrofs) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addrstack ofs) v' /\\\n  vagree (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) v' nv /\\\n  eagree e e' ne2 /\\ magree m m' (nlive ge sp nm2).","proofString":"exists (Vptr sp (Ptrofs.add Ptrofs.zero ofs)); intuition auto with na.\nconstructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (ofs : ptrofs) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_addrstack ofs) (Vptr sp (Ptrofs.add Ptrofs.zero ofs)).","proofString":"constructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  vagree v v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"unfold Senv.symbol_address in H; simpl in H.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; simpl in H; try discriminate.\nexploit magree_load; eauto.\nintros.\neapply nlive_add; eauto.\nconstructor.\napply GM; auto.\nintros (v' & A & B).\nexists v'; intuition auto.\nconstructor.\nsimpl.\nunfold Senv.symbol_address; simpl; rewrite FS; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  vagree v v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; simpl in H; try discriminate.\nexploit magree_load; eauto.\nintros.\neapply nlive_add; eauto.\nconstructor.\napply GM; auto.\nintros (v' & A & B).\nexists v'; intuition auto.\nconstructor.\nsimpl.\nunfold Senv.symbol_address; simpl; rewrite FS; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  vagree v v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"exploit magree_load; eauto.\nintros.\neapply nlive_add; eauto.\nconstructor.\napply GM; auto.\nintros (v' & A & B).\nexists v'; intuition auto.\nconstructor.\nsimpl.\nunfold Senv.symbol_address; simpl; rewrite FS; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : forall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\nnlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)) b i.","proofString":"intros.\neapply nlive_add; eauto.\nconstructor.\napply GM; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (i : Z) (H0 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)) b i.","proofString":"eapply nlive_add; eauto.\nconstructor.\napply GM; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (i : Z) (H0 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : pmatch bc b ofs (Gl id ofs).","proofString":"constructor.\napply GM; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (i : Z) (H0 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : bc b = BCglob id.","proofString":"apply GM; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : (exists v' : val,\n   Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v' /\\ Val.lessdef v v') ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  vagree v v' nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"intros (v' & A & B).\nexists v'; intuition auto.\nconstructor.\nsimpl.\nunfold Senv.symbol_address; simpl; rewrite FS; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : exists v'0 : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v'0 /\\\n  vagree v v'0 nv /\\ eagree e e' ne2 /\\ magree m m' (nlive ge sp nm1).","proofString":"exists v'; intuition auto.\nconstructor.\nsimpl.\nunfold Senv.symbol_address; simpl; rewrite FS; auto.\napply vagree_lessdef; auto.\neapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_loadglobal chunk id ofs) v'.","proofString":"constructor.\nsimpl.\nunfold Senv.symbol_address; simpl; rewrite FS; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : Mem.loadv chunk m' (Senv.symbol_address ge id ofs) = Some v'.","proofString":"simpl.\nunfold Senv.symbol_address; simpl; rewrite FS; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : Mem.loadv chunk m' (Senv.symbol_address ge id ofs) = Some v'.","proofString":"unfold Senv.symbol_address; simpl; rewrite FS; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : vagree v v' nv.","proofString":"apply vagree_lessdef; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : magree m m' (nlive ge sp nm1).","proofString":"eapply magree_monotone; eauto.\nintros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (b : block) (FS : Genv.find_symbol ge id = Some b) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (nv : nval) (nm1 : nmem) (ne2 : nenv) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)))) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : forall (b0 : block) (ofs0 : Z),\nnlive ge sp nm1 b0 ofs0 ->\nnlive ge sp (nmem_add nm1 (Gl id ofs) (size_chunk chunk)) b0 ofs0.","proofString":"intros; eapply incl_nmem_add; eauto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (id : ident) (ofs : ptrofs) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addrglobal id ofs) v' /\\\n  vagree (Senv.symbol_address ge id ofs) v' nv /\\\n  eagree e e' ne2 /\\ magree m m' (nlive ge sp nm2).","proofString":"exists (Senv.symbol_address ge id ofs); intuition auto with na.\nconstructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (id : ident) (ofs : ptrofs) (nv : nval) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_addrglobal id ofs) (Senv.symbol_address ge id ofs).","proofString":"constructor."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (H2 : transfer_builtin_arg All (transfer_builtin_arg All (ne1, nm1) hi) lo =\n(ne2, nm2)) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  vagree (Val.longofwords vhi vlo) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"destruct (transfer_builtin_arg All (ne1, nm1) hi) as [ne' nm'] eqn:TR.\nexploit IHeval_builtin_arg2; eauto.\nintros (vlo' & A & B & C & D).\nexploit IHeval_builtin_arg1; eauto.\nintros (vhi' & P & Q & R & S).\nexists (Val.longofwords vhi' vlo'); intuition auto.\nconstructor; auto.\napply vagree_lessdef.\napply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  vagree (Val.longofwords vhi vlo) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"exploit IHeval_builtin_arg2; eauto.\nintros (vlo' & A & B & C & D).\nexploit IHeval_builtin_arg1; eauto.\nintros (vhi' & P & Q & R & S).\nexists (Val.longofwords vhi' vlo'); intuition auto.\nconstructor; auto.\napply vagree_lessdef.\napply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) : (exists v' : val,\n   eval_builtin_arg ge (fun r : positive => e' # r) \n     (Vptr sp Ptrofs.zero) m' lo v' /\\\n   vagree vlo v' All /\\ eagree e e' ne' /\\ magree m m' (nlive ge sp nm')) ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  vagree (Val.longofwords vhi vlo) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"intros (vlo' & A & B & C & D).\nexploit IHeval_builtin_arg1; eauto.\nintros (vhi' & P & Q & R & S).\nexists (Val.longofwords vhi' vlo'); intuition auto.\nconstructor; auto.\napply vagree_lessdef.\napply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) (vlo' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' lo\n  vlo') (B : vagree vlo vlo' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  vagree (Val.longofwords vhi vlo) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"exploit IHeval_builtin_arg1; eauto.\nintros (vhi' & P & Q & R & S).\nexists (Val.longofwords vhi' vlo'); intuition auto.\nconstructor; auto.\napply vagree_lessdef.\napply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) (vlo' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' lo\n  vlo') (B : vagree vlo vlo' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) : (exists v' : val,\n   eval_builtin_arg ge (fun r : positive => e' # r) \n     (Vptr sp Ptrofs.zero) m' hi v' /\\\n   vagree vhi v' All /\\ eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1)) ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  vagree (Val.longofwords vhi vlo) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"intros (vhi' & P & Q & R & S).\nexists (Val.longofwords vhi' vlo'); intuition auto.\nconstructor; auto.\napply vagree_lessdef.\napply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) (vlo' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' lo\n  vlo') (B : vagree vlo vlo' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) (vhi' : val) (P : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' hi\n  vhi') (Q : vagree vhi vhi' All) (R : eagree e e' ne1) (S : magree m m' (nlive ge sp nm1)) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  vagree (Val.longofwords vhi vlo) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"exists (Val.longofwords vhi' vlo'); intuition auto.\nconstructor; auto.\napply vagree_lessdef.\napply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) (vlo' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' lo\n  vlo') (B : vagree vlo vlo' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) (vhi' : val) (P : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' hi\n  vhi') (Q : vagree vhi vhi' All) (R : eagree e e' ne1) (S : magree m m' (nlive ge sp nm1)) : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m'\n  (BA_splitlong hi lo) (Val.longofwords vhi' vlo').","proofString":"constructor; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) (vlo' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' lo\n  vlo') (B : vagree vlo vlo' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) (vhi' : val) (P : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' hi\n  vhi') (Q : vagree vhi vhi' All) (R : eagree e e' ne1) (S : magree m m' (nlive ge sp nm1)) : vagree (Val.longofwords vhi vlo) (Val.longofwords vhi' vlo') nv.","proofString":"apply vagree_lessdef.\napply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) hi = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v' /\\\n  vagree vhi v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) lo = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v' /\\\n  vagree vlo v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) hi = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') lo = (ne2, nm2)) (vlo' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' lo\n  vlo') (B : vagree vlo vlo' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) (vhi' : val) (P : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' hi\n  vhi') (Q : vagree vhi vhi' All) (R : eagree e e' ne1) (S : magree m m' (nlive ge sp nm1)) : Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords vhi' vlo').","proofString":"apply Val.longofwords_lessdef; apply lessdef_vagree; auto."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a1 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a1 v' /\\\n  vagree v1 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a2 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v' /\\\n  vagree v2 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (H2 : transfer_builtin_arg All (transfer_builtin_arg All (ne1, nm1) a1) a2 =\n(ne2, nm2)) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  vagree (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"destruct (transfer_builtin_arg All (ne1, nm1) a1) as [ne' nm'] eqn:TR.\nexploit IHeval_builtin_arg2; eauto.\nintros (v2' & A & B & C & D).\nexploit IHeval_builtin_arg1; eauto.\nintros (v1' & P & Q & R & S).\neconstructor; intuition auto.\neconstructor; eauto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef, vagree_lessdef, lessdef_vagree."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a1 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a1 v' /\\\n  vagree v1 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a2 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v' /\\\n  vagree v2 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) a1 = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') a2 = (ne2, nm2)) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  vagree (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"exploit IHeval_builtin_arg2; eauto.\nintros (v2' & A & B & C & D).\nexploit IHeval_builtin_arg1; eauto.\nintros (v1' & P & Q & R & S).\neconstructor; intuition auto.\neconstructor; eauto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef, vagree_lessdef, lessdef_vagree."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a1 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a1 v' /\\\n  vagree v1 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a2 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v' /\\\n  vagree v2 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) a1 = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') a2 = (ne2, nm2)) : (exists v' : val,\n   eval_builtin_arg ge (fun r : positive => e' # r) \n     (Vptr sp Ptrofs.zero) m' a2 v' /\\\n   vagree v2 v' All /\\ eagree e e' ne' /\\ magree m m' (nlive ge sp nm')) ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  vagree (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"intros (v2' & A & B & C & D).\nexploit IHeval_builtin_arg1; eauto.\nintros (v1' & P & Q & R & S).\neconstructor; intuition auto.\neconstructor; eauto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef, vagree_lessdef, lessdef_vagree."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a1 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a1 v' /\\\n  vagree v1 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a2 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v' /\\\n  vagree v2 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) a1 = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') a2 = (ne2, nm2)) (v2' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' a2\n  v2') (B : vagree v2 v2' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  vagree (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"exploit IHeval_builtin_arg1; eauto.\nintros (v1' & P & Q & R & S).\neconstructor; intuition auto.\neconstructor; eauto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef, vagree_lessdef, lessdef_vagree."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a1 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a1 v' /\\\n  vagree v1 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a2 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v' /\\\n  vagree v2 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) a1 = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') a2 = (ne2, nm2)) (v2' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' a2\n  v2') (B : vagree v2 v2' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) : (exists v' : val,\n   eval_builtin_arg ge (fun r : positive => e' # r) \n     (Vptr sp Ptrofs.zero) m' a1 v' /\\\n   vagree v1 v' All /\\ eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1)) ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  vagree (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"intros (v1' & P & Q & R & S).\neconstructor; intuition auto.\neconstructor; eauto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef, vagree_lessdef, lessdef_vagree."},{"statement":"(bc : block_classification) (e : Regmap.t val) (e' : regset) (sp : block) (m m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (IHeval_builtin_arg1 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a1 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a1 v' /\\\n  vagree v1 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (IHeval_builtin_arg2 : forall (nv0 : nval) (ne0 : nenv) (nm0 : nmem) (ne3 : nenv) (nm3 : nmem),\ntransfer_builtin_arg nv0 (ne0, nm0) a2 = (ne3, nm3) ->\neagree e e' ne3 ->\nmagree m m' (nlive ge sp nm3) ->\ngenv_match bc ge ->\nbc sp = BCstack ->\nexists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v' /\\\n  vagree v2 v' nv0 /\\ eagree e e' ne0 /\\ magree m m' (nlive ge sp nm0)) (nv : nval) (ne1 : nenv) (nm1 : nmem) (ne2 : nenv) (nm2 : nmem) (EA : eagree e e' ne2) (MA : magree m m' (nlive ge sp nm2)) (GM : genv_match bc ge) (SPM : bc sp = BCstack) (ne' : nenv) (nm' : nmem) (TR : transfer_builtin_arg All (ne1, nm1) a1 = (ne', nm')) (H2 : transfer_builtin_arg All (ne', nm') a2 = (ne2, nm2)) (v2' : val) (A : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' a2\n  v2') (B : vagree v2 v2' All) (C : eagree e e' ne') (D : magree m m' (nlive ge sp nm')) (v1' : val) (P : eval_builtin_arg ge (fun r : positive => e' # r) (Vptr sp Ptrofs.zero) m' a1\n  v1') (Q : vagree v1 v1' All) (R : eagree e e' ne1) (S : magree m m' (nlive ge sp nm1)) : exists v' : val,\n  eval_builtin_arg ge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  vagree (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' nv /\\\n  eagree e e' ne1 /\\ magree m m' (nlive ge sp nm1).","proofString":"econstructor; intuition auto.\neconstructor; eauto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef, vagree_lessdef, lessdef_vagree."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) : forall (a : builtin_arg positive) (v : val),\neval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a v ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a v'.","proofString":"assert (LD: forall chunk addr v,              Mem.loadv chunk m addr = Some v ->              exists v', Mem.loadv chunk m' addr = Some v').\nintros.\ndestruct addr; simpl in H; try discriminate.\neapply Mem.valid_access_load.\neapply magree_valid_access; eauto.\neapply Mem.load_valid_access; eauto.\ninduction 1; try (econstructor; now constructor).\nexploit LD; eauto.\nintros (v' & A).\nexists v'; constructor; auto.\nexploit LD; eauto.\nintros (v' & A).\nexists v'; constructor.\nunfold Senv.symbol_address, Senv.find_symbol.\nrewrite symbols_preserved.\nassumption.\ndestruct IHeval_builtin_arg1 as (v1' & A1).\ndestruct IHeval_builtin_arg2 as (v2' & A2).\nexists (Val.longofwords v1' v2'); constructor; auto.\ndestruct IHeval_builtin_arg1 as (v1' & A1).\ndestruct IHeval_builtin_arg2 as (v2' & A2).\neconstructor; econstructor; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v'.","proofString":"intros.\ndestruct addr; simpl in H; try discriminate.\neapply Mem.valid_access_load.\neapply magree_valid_access; eauto.\neapply Mem.load_valid_access; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (chunk : memory_chunk) (addr v : val) (H : Mem.loadv chunk m addr = Some v) : exists v' : val, Mem.loadv chunk m' addr = Some v'.","proofString":"destruct addr; simpl in H; try discriminate.\neapply Mem.valid_access_load.\neapply magree_valid_access; eauto.\neapply Mem.load_valid_access; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (chunk : memory_chunk) (b : block) (i : ptrofs) (v : val) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) : exists v' : val, Mem.loadv chunk m' (Vptr b i) = Some v'.","proofString":"eapply Mem.valid_access_load.\neapply magree_valid_access; eauto.\neapply Mem.load_valid_access; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (chunk : memory_chunk) (b : block) (i : ptrofs) (v : val) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) : Mem.valid_access m' chunk b (Ptrofs.unsigned i) Readable.","proofString":"eapply magree_valid_access; eauto.\neapply Mem.load_valid_access; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (chunk : memory_chunk) (b : block) (i : ptrofs) (v : val) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) : Mem.valid_access m chunk b (Ptrofs.unsigned i) Readable.","proofString":"eapply Mem.load_valid_access; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v') : forall (a : builtin_arg positive) (v : val),\neval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a v ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a v'.","proofString":"induction 1; try (econstructor; now constructor).\nexploit LD; eauto.\nintros (v' & A).\nexists v'; constructor; auto.\nexploit LD; eauto.\nintros (v' & A).\nexists v'; constructor.\nunfold Senv.symbol_address, Senv.find_symbol.\nrewrite symbols_preserved.\nassumption.\ndestruct IHeval_builtin_arg1 as (v1' & A1).\ndestruct IHeval_builtin_arg2 as (v2' & A2).\nexists (Val.longofwords v1' v2'); constructor; auto.\ndestruct IHeval_builtin_arg1 as (v1' & A1).\ndestruct IHeval_builtin_arg2 as (v2' & A2).\neconstructor; econstructor; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v' : val, Mem.loadv chunk0 m' addr = Some v') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadstack chunk ofs) v'.","proofString":"exploit LD; eauto.\nintros (v' & A).\nexists v'; constructor; auto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v' : val, Mem.loadv chunk0 m' addr = Some v') (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : (exists v' : val,\n   Mem.loadv chunk m' (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v') ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadstack chunk ofs) v'.","proofString":"intros (v' & A).\nexists v'; constructor; auto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v'0 : val, Mem.loadv chunk0 m' addr = Some v'0) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v') : exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadstack chunk ofs) v'0.","proofString":"exists v'; constructor; auto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v' : val, Mem.loadv chunk0 m' addr = Some v') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v'.","proofString":"exploit LD; eauto.\nintros (v' & A).\nexists v'; constructor.\nunfold Senv.symbol_address, Senv.find_symbol.\nrewrite symbols_preserved.\nassumption."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v' : val, Mem.loadv chunk0 m' addr = Some v') (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : (exists v' : val,\n   Mem.loadv chunk m' (Senv.symbol_address ge id ofs) = Some v') ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v'.","proofString":"intros (v' & A).\nexists v'; constructor.\nunfold Senv.symbol_address, Senv.find_symbol.\nrewrite symbols_preserved.\nassumption."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v'0 : val, Mem.loadv chunk0 m' addr = Some v'0) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Senv.symbol_address ge id ofs) = Some v') : exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v'0.","proofString":"exists v'; constructor.\nunfold Senv.symbol_address, Senv.find_symbol.\nrewrite symbols_preserved.\nassumption."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v'0 : val, Mem.loadv chunk0 m' addr = Some v'0) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Senv.symbol_address ge id ofs) = Some v') : Mem.loadv chunk m' (Senv.symbol_address tge id ofs) = Some v'.","proofString":"unfold Senv.symbol_address, Senv.find_symbol.\nrewrite symbols_preserved.\nassumption."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v'0 : val, Mem.loadv chunk0 m' addr = Some v'0) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Senv.symbol_address ge id ofs) = Some v') : Mem.loadv chunk m'\n  match\n    (let\n       (find_symbol, public_symbol, invert_symbol, block_is_volatile,\n        nextblock, _, _, _, _, _, _) := Genv.to_senv tge in\n     find_symbol) id\n  with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end = Some v'.","proofString":"rewrite symbols_preserved.\nassumption."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk0 : memory_chunk) (addr v0 : val),\nMem.loadv chunk0 m addr = Some v0 ->\nexists v'0 : val, Mem.loadv chunk0 m' addr = Some v'0) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (v' : val) (A : Mem.loadv chunk m' (Senv.symbol_address ge id ofs) = Some v') : Mem.loadv chunk m'\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end = Some v'.","proofString":"assumption."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' hi v') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v'.","proofString":"destruct IHeval_builtin_arg1 as (v1' & A1).\ndestruct IHeval_builtin_arg2 as (v2' & A2).\nexists (Val.longofwords v1' v2'); constructor; auto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => e' # r) \n  (Vptr sp Ptrofs.zero) m' hi v1') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' lo v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v'.","proofString":"destruct IHeval_builtin_arg2 as (v2' & A2).\nexists (Val.longofwords v1' v2'); constructor; auto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v') (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => e' # r) \n  (Vptr sp Ptrofs.zero) m' hi v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => e' # r) \n  (Vptr sp Ptrofs.zero) m' lo v2') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_splitlong hi lo) v'.","proofString":"exists (Val.longofwords v1' v2'); constructor; auto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (IHeval_builtin_arg1 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a1 v') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v'.","proofString":"destruct IHeval_builtin_arg1 as (v1' & A1).\ndestruct IHeval_builtin_arg2 as (v2' & A2).\neconstructor; econstructor; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => e' # r) \n  (Vptr sp Ptrofs.zero) m' a1 v1') (IHeval_builtin_arg2 : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' a2 v') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v'.","proofString":"destruct IHeval_builtin_arg2 as (v2' & A2).\neconstructor; econstructor; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (MA : magree m m' P) (LD : forall (chunk : memory_chunk) (addr v : val),\nMem.loadv chunk m addr = Some v ->\nexists v' : val, Mem.loadv chunk m' addr = Some v') (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a2 v2) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => e' # r) \n  (Vptr sp Ptrofs.zero) m' a1 v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => e' # r) \n  (Vptr sp Ptrofs.zero) m' a2 v2') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (BA_addptr a1 a2) v'.","proofString":"econstructor; econstructor; eauto."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (H : magree m m' P) : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' nil vl'.","proofString":"exists (@nil val); constructor."},{"statement":"(sp : block) (e : Regmap.t val) (m : mem) (e' : Regmap.t val) (m' : mem) (P : locset) (H : magree m m' P) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H0 : eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m a1 b1) (H1 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' al vl') : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => e' # r) \n    (Vptr sp Ptrofs.zero) m' (a1 :: al) vl'.","proofString":"exploit can_eval_builtin_arg; eauto.\nintros (v' & A).\ndestruct IHlist_forall2 as (vl' & B).\nexists (v' :: vl'); constructor; eauto."},{"statement":"(v1 v2 v1' v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (t : trace) (v : val) (m' : mem) (H : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t v m') (H0 : Val.lessdef v1 v1') (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) : v = Vundef /\\\n(exists tm' : mem,\n   volatile_store_sem chunk ge (v1' :: v2' :: nil) tm t Vundef tm' /\\\n   magree m' tm' (nlive ge sp nm)).","proofString":"inv H.\nsplit; auto.\ninv H0.\ninv H9.\nexists tm; split; auto.\neconstructor.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto.\nexploit magree_store_parallel.\neauto.\neauto.\neauto.\ninstantiate (1 := nlive ge sp nm).\nauto.\nintros (tm' & P & Q).\nexists tm'; split.\neconstructor.\neconstructor; eauto.\nauto."},{"statement":"(v2 v1' v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (t : trace) (m' : mem) (b : block) (ofs : ptrofs) (H0 : Val.lessdef (Vptr b ofs) v1') (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H9 : volatile_store ge chunk m b ofs v2 t m') : Vundef = Vundef /\\\n(exists tm' : mem,\n   volatile_store_sem chunk ge (v1' :: v2' :: nil) tm t Vundef tm' /\\\n   magree m' tm' (nlive ge sp nm)).","proofString":"split; auto.\ninv H0.\ninv H9.\nexists tm; split; auto.\neconstructor.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto.\nexploit magree_store_parallel.\neauto.\neauto.\neauto.\ninstantiate (1 := nlive ge sp nm).\nauto.\nintros (tm' & P & Q).\nexists tm'; split.\neconstructor.\neconstructor; eauto.\nauto."},{"statement":"(v2 v1' v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (t : trace) (m' : mem) (b : block) (ofs : ptrofs) (H0 : Val.lessdef (Vptr b ofs) v1') (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H9 : volatile_store ge chunk m b ofs v2 t m') : exists tm' : mem,\n  volatile_store_sem chunk ge (v1' :: v2' :: nil) tm t Vundef tm' /\\\n  magree m' tm' (nlive ge sp nm).","proofString":"inv H0.\ninv H9.\nexists tm; split; auto.\neconstructor.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto.\nexploit magree_store_parallel.\neauto.\neauto.\neauto.\ninstantiate (1 := nlive ge sp nm).\nauto.\nintros (tm' & P & Q).\nexists tm'; split.\neconstructor.\neconstructor; eauto.\nauto."},{"statement":"(v2 v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (t : trace) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H9 : volatile_store ge chunk m b ofs v2 t m') : exists tm' : mem,\n  volatile_store_sem chunk ge (Vptr b ofs :: v2' :: nil) tm t Vundef tm' /\\\n  magree m' tm' (nlive ge sp nm).","proofString":"inv H9.\nexists tm; split; auto.\neconstructor.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto.\nexploit magree_store_parallel.\neauto.\neauto.\neauto.\ninstantiate (1 := nlive ge sp nm).\nauto.\nintros (tm' & P & Q).\nexists tm'; split.\neconstructor.\neconstructor; eauto.\nauto."},{"statement":"(v2 v2' : val) (tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m' tm (nlive ge sp nm)) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v2)) : exists tm' : mem,\n  volatile_store_sem chunk ge (Vptr b ofs :: v2' :: nil) tm\n    (Event_vstore chunk id ofs ev :: nil) Vundef tm' /\\\n  magree m' tm' (nlive ge sp nm).","proofString":"exists tm; split; auto.\neconstructor.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto."},{"statement":"(v2 v2' : val) (tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m' tm (nlive ge sp nm)) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v2)) : volatile_store_sem chunk ge (Vptr b ofs :: v2' :: nil) tm\n  (Event_vstore chunk id ofs ev :: nil) Vundef tm.","proofString":"econstructor.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto."},{"statement":"(v2 v2' : val) (tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m' tm (nlive ge sp nm)) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v2)) : volatile_store ge chunk tm b ofs v2' (Event_vstore chunk id ofs ev :: nil) tm.","proofString":"econstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto."},{"statement":"(v2 v2' : val) (tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m' tm (nlive ge sp nm)) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v2)) : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v2').","proofString":"eapply eventval_match_lessdef; eauto.\napply store_argument_load_result; auto."},{"statement":"(v2 v2' : val) (tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m' tm (nlive ge sp nm)) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v2)) : Val.lessdef (Val.load_result chunk v2) (Val.load_result chunk v2').","proofString":"apply store_argument_load_result; auto."},{"statement":"(v2 v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v2 = Some m') : exists tm' : mem,\n  volatile_store_sem chunk ge (Vptr b ofs :: v2' :: nil) tm E0 Vundef tm' /\\\n  magree m' tm' (nlive ge sp nm).","proofString":"exploit magree_store_parallel.\neauto.\neauto.\neauto.\ninstantiate (1 := nlive ge sp nm).\nauto.\nintros (tm' & P & Q).\nexists tm'; split.\neconstructor.\neconstructor; eauto.\nauto."},{"statement":"(v2 v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v2 = Some m') : forall (b' : block) (i : Z),\nnlive ge sp nm b' i ->\nb' <> b \\/\ni < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + size_chunk chunk <= i ->\nnlive ge sp nm b' i.","proofString":"auto."},{"statement":"(v2 v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v2 = Some m') (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned ofs) v2' = Some tm') (Q : magree m' tm' (nlive ge sp nm)) : exists tm'0 : mem,\n  volatile_store_sem chunk ge (Vptr b ofs :: v2' :: nil) tm E0 Vundef tm'0 /\\\n  magree m' tm'0 (nlive ge sp nm).","proofString":"exists tm'; split.\neconstructor.\neconstructor; eauto.\nauto."},{"statement":"(v2 v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v2 = Some m') (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned ofs) v2' = Some tm') (Q : magree m' tm' (nlive ge sp nm)) : volatile_store_sem chunk ge (Vptr b ofs :: v2' :: nil) tm E0 Vundef tm'.","proofString":"econstructor.\neconstructor; eauto."},{"statement":"(v2 v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v2 = Some m') (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned ofs) v2' = Some tm') (Q : magree m' tm' (nlive ge sp nm)) : volatile_store ge chunk tm b ofs v2' E0 tm'.","proofString":"econstructor; eauto."},{"statement":"(v2 v2' : val) (m tm : mem) (chunk : memory_chunk) (sp : block) (nm : nmem) (m' : mem) (b : block) (ofs : ptrofs) (H1 : vagree v2 v2' (store_argument chunk)) (H2 : magree m tm (nlive ge sp nm)) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v2 = Some m') (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned ofs) v2' = Some tm') (Q : magree m' tm' (nlive ge sp nm)) : magree m' tm' (nlive ge sp nm).","proofString":"auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (r : positive) (H : eagree e1 e2 ne) (r0 : positive) : vagree (e1 # r <- Vundef) # r0 e2 # r0 (NE.get r0 ne).","proofString":"rewrite PMap.gsspec.\ndestruct (peq r0 r); auto with na."},{"statement":"(e1 e2 : regset) (ne : nenv) (r : positive) (H : eagree e1 e2 ne) (r0 : positive) : vagree (if peq r0 r then Vundef else e1 # r0) e2 # r0 (NE.get r0 ne).","proofString":"destruct (peq r0 r); auto with na."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) : exists (tvargs : list val) (tvres : val) (tm' : mem),\n  eval_builtin_args tge (fun r : positive => te # r) \n    (Vptr sp Ptrofs.zero) tm args tvargs /\\\n  external_call ef tge tvargs tm t tvres tm' /\\\n  eagree (regmap_setres res vres e) (regmap_setres res tvres te) ne2 /\\\n  magree m' tm' (nlive ge sp nm2).","proofString":"exploit transfer_builtin_args_sound; eauto.\nintros (tvargs & A & B & C & D).\nexploit external_call_mem_extends; eauto 2 with na.\neapply magree_extends; eauto.\nintros.\napply nlive_all.\nintros (vres' & tm' & P & Q & R & S).\ndo 3 econstructor.\nsplit.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsplit.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\nsplit.\napply eagree_set_res; auto.\neapply mextends_agree; eauto."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) : (exists vl' : list val,\n   eval_builtin_args ge (fun r : positive => te # r) \n     (Vptr sp Ptrofs.zero) tm args vl' /\\\n   Val.lessdef_list vargs vl' /\\\n   eagree e te (kill_builtin_res res ne2) /\\\n   magree m tm (nlive ge sp nmem_all)) ->\nexists (tvargs : list val) (tvres : val) (tm' : mem),\n  eval_builtin_args tge (fun r : positive => te # r) \n    (Vptr sp Ptrofs.zero) tm args tvargs /\\\n  external_call ef tge tvargs tm t tvres tm' /\\\n  eagree (regmap_setres res vres e) (regmap_setres res tvres te) ne2 /\\\n  magree m' tm' (nlive ge sp nm2).","proofString":"intros (tvargs & A & B & C & D).\nexploit external_call_mem_extends; eauto 2 with na.\neapply magree_extends; eauto.\nintros.\napply nlive_all.\nintros (vres' & tm' & P & Q & R & S).\ndo 3 econstructor.\nsplit.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsplit.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\nsplit.\napply eagree_set_res; auto.\neapply mextends_agree; eauto."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) (tvargs : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp Ptrofs.zero) tm args tvargs) (B : Val.lessdef_list vargs tvargs) (C : eagree e te (kill_builtin_res res ne2)) (D : magree m tm (nlive ge sp nmem_all)) : exists (tvargs0 : list val) (tvres : val) (tm' : mem),\n  eval_builtin_args tge (fun r : positive => te # r) \n    (Vptr sp Ptrofs.zero) tm args tvargs0 /\\\n  external_call ef tge tvargs0 tm t tvres tm' /\\\n  eagree (regmap_setres res vres e) (regmap_setres res tvres te) ne2 /\\\n  magree m' tm' (nlive ge sp nm2).","proofString":"exploit external_call_mem_extends; eauto 2 with na.\neapply magree_extends; eauto.\nintros.\napply nlive_all.\nintros (vres' & tm' & P & Q & R & S).\ndo 3 econstructor.\nsplit.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsplit.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\nsplit.\napply eagree_set_res; auto.\neapply mextends_agree; eauto."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) (tvargs : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp Ptrofs.zero) tm args tvargs) (B : Val.lessdef_list vargs tvargs) (C : eagree e te (kill_builtin_res res ne2)) (D : magree m tm (nlive ge sp nmem_all)) : forall (b : block) (ofs : Z), nlive ge sp nmem_all b ofs.","proofString":"intros.\napply nlive_all."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) (tvargs : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp Ptrofs.zero) tm args tvargs) (B : Val.lessdef_list vargs tvargs) (C : eagree e te (kill_builtin_res res ne2)) (D : magree m tm (nlive ge sp nmem_all)) (b : block) (ofs : Z) : nlive ge sp nmem_all b ofs.","proofString":"apply nlive_all."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) (tvargs : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp Ptrofs.zero) tm args tvargs) (B : Val.lessdef_list vargs tvargs) (C : eagree e te (kill_builtin_res res ne2)) (D : magree m tm (nlive ge sp nmem_all)) (vres' : val) (tm' : mem) (P : external_call ef ge tvargs tm t vres' tm') (Q : Val.lessdef vres vres') (R : Mem.extends m' tm') (S : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : exists (tvargs0 : list val) (tvres : val) (tm'0 : mem),\n  eval_builtin_args tge (fun r : positive => te # r) \n    (Vptr sp Ptrofs.zero) tm args tvargs0 /\\\n  external_call ef tge tvargs0 tm t tvres tm'0 /\\\n  eagree (regmap_setres res vres e) (regmap_setres res tvres te) ne2 /\\\n  magree m' tm'0 (nlive ge sp nm2).","proofString":"do 3 econstructor.\nsplit.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsplit.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\nsplit.\napply eagree_set_res; auto.\neapply mextends_agree; eauto."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) (tvargs : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp Ptrofs.zero) tm args tvargs) (B : Val.lessdef_list vargs tvargs) (C : eagree e te (kill_builtin_res res ne2)) (D : magree m tm (nlive ge sp nmem_all)) (vres' : val) (tm' : mem) (P : external_call ef ge tvargs tm t vres' tm') (Q : Val.lessdef vres vres') (R : Mem.extends m' tm') (S : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) (tvargs : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp Ptrofs.zero) tm args tvargs) (B : Val.lessdef_list vargs tvargs) (C : eagree e te (kill_builtin_res res ne2)) (D : magree m tm (nlive ge sp nmem_all)) (vres' : val) (tm' : mem) (P : external_call ef ge tvargs tm t vres' tm') (Q : Val.lessdef vres vres') (R : Mem.extends m' tm') (S : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : eagree (regmap_setres res vres e) (regmap_setres res vres' te) ne2.","proofString":"apply eagree_set_res; auto."},{"statement":"(e : Regmap.t val) (sp : block) (m : mem) (args : list (builtin_arg positive)) (vargs : list val) (ef : external_function) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (ne2 : NE.t) (nm2 : nmem) (ne1 : nenv) (nm1 : nmem) (bc : block_classification) (te : regset) (tm : mem) (H : eval_builtin_args ge (fun r : positive => e # r) (Vptr sp Ptrofs.zero) m args\n  vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : transfer_builtin_args (kill_builtin_res res ne2, nmem_all) args = (ne1, nm1)) (H2 : eagree e te ne1) (H3 : magree m tm (nlive ge sp nm1)) (H4 : genv_match bc ge) (H5 : bc sp = BCstack) (tvargs : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp Ptrofs.zero) tm args tvargs) (B : Val.lessdef_list vargs tvargs) (C : eagree e te (kill_builtin_res res ne2)) (D : magree m tm (nlive ge sp nmem_all)) (vres' : val) (tm' : mem) (P : external_call ef ge tvargs tm t vres' tm') (Q : Val.lessdef vres vres') (R : Mem.extends m' tm') (S : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : magree m' tm' (nlive ge sp nm2).","proofString":"eapply mextends_agree; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : In pc' (successors_instr (Inop pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else\n       if is_int_zero (nreg ne res)\n       then (kill res ne, nm)\n       else\n        (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne),\n         nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else\n          if is_int_zero (nreg ne res)\n          then (kill res ne, nm)\n          else\n           (add_needs args (needs_of_operation op (nreg ne res))\n              (kill res ne), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else\n    if is_int_zero (nreg ne res)\n    then Iop (Ointconst Int.zero) nil res pc'\n    else\n     if operation_is_redundant op (nreg ne res)\n     then\n      match args with\n      | nil => Iop op args res pc'\n      | arg :: _ => Iop Omove (arg :: nil) res pc'\n      end\n     else Iop op args res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (is_dead (nreg ne res)) eqn:DEAD;  [idtac|destruct (is_int_zero (nreg ne res)) eqn:INTZERO;  [idtac|destruct (operation_is_redundant op (nreg ne res)) eqn:REDUNDANT]].\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nleft; econstructor; split.\neapply exec_Iop with (v := Vint Int.zero); eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto.\nrewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero.\ndestruct args.\nsimpl in *.\nexploit needs_of_operation_sound.\neapply ma_perm; eauto.\neauto.\ninstantiate (1 := nreg ne res).\neauto with na.\neauto with na.\nintros [tv [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto.\nunfold fst in ENV.\nunfold snd in MEM.\nsimpl in H0.\nassert (VA: vagree v te#r (nreg ne res)).\neapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).\neauto.\neauto.\nexploit add_needs_vagree; eauto.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; reflexivity.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply eagree_update; eauto 2 with na.\nsimpl in *.\nexploit needs_of_operation_sound.\neapply ma_perm; eauto.\neauto.\neauto 2 with na.\neauto with na.\nintros [tv [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : In pc' (successors_instr (Iop op args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : eagree rs # res <- v te ne.","proofString":"apply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = true) (ENV : eagree rs te (fst (kill res ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (kill res ne, nm)))) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Iop with (v := Vint Int.zero); eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto.\nrewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = true) (ENV : eagree rs te (fst (kill res ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (kill res ne, nm)))) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil res pc')) : In pc' (successors_instr (Iop op args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = true) (ENV : eagree rs te (fst (kill res ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (kill res ne, nm)))) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil res pc')) : eagree rs # res <- v te # res <- (Vint Int.zero) ne.","proofString":"apply eagree_update; auto.\nrewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = true) (ENV : eagree rs te (fst (kill res ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (kill res ne, nm)))) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil res pc')) : vagree v (Vint Int.zero) (nreg ne res).","proofString":"rewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = true) (ENV : eagree rs te (fst (kill res ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (kill res ne, nm)))) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil res pc')) : vagree v (Vint Int.zero) (I Int.zero).","proofString":"destruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (i : int) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some (Vint i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = true) (ENV : eagree rs te (fst (kill res ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (kill res ne, nm)))) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil res pc')) : iagree i Int.zero Int.zero.","proofString":"apply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (fst\n     (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne),\n         nm)))) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc =\nSome\n  match args with\n  | nil => Iop op args res pc'\n  | arg :: _ => Iop Omove (arg :: nil) res pc'\n  end) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct args.\nsimpl in *.\nexploit needs_of_operation_sound.\neapply ma_perm; eauto.\neauto.\ninstantiate (1 := nreg ne res).\neauto with na.\neauto with na.\nintros [tv [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto.\nunfold fst in ENV.\nunfold snd in MEM.\nsimpl in H0.\nassert (VA: vagree v te#r (nreg ne res)).\neapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).\neauto.\neauto.\nexploit add_needs_vagree; eauto.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; reflexivity.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (fst\n     (add_needs nil (needs_of_operation op (nreg ne res)) (kill res ne), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (add_needs nil (needs_of_operation op (nreg ne res)) (kill res ne),\n         nm)))) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"simpl in *.\nexploit needs_of_operation_sound.\neapply ma_perm; eauto.\neauto.\ninstantiate (1 := nreg ne res).\neauto with na.\neauto with na.\nintros [tv [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te (kill res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit needs_of_operation_sound.\neapply ma_perm; eauto.\neauto.\ninstantiate (1 := nreg ne res).\neauto with na.\neauto with na.\nintros [tv [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te (kill res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil tm = Some tv) (B : vagree v tv (nreg ne res)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te (kill res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil tm = Some tv) (B : vagree v tv (nreg ne res)) : eval_operation tge (Vptr sp0 Ptrofs.zero) op te ## nil tm = Some tv.","proofString":"rewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te (kill res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil tm = Some tv) (B : vagree v tv (nreg ne res)) : eval_operation tge (Vptr sp0 Ptrofs.zero) op te ## nil tm =\neval_operation ge (Vptr sp0 Ptrofs.zero) op nil tm.","proofString":"apply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te (kill res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil tm = Some tv) (B : vagree v tv (nreg ne res)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te (kill res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil tm = Some tv) (B : vagree v tv (nreg ne res)) : In pc' (successors_instr (Iop op nil res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op nil res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te (kill res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop op nil res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op nil tm = Some tv) (B : vagree v tv (nreg ne res)) : eagree rs # res <- v te # res <- tv ne.","proofString":"apply eagree_update; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## (r :: args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (fst\n     (add_needs (r :: args) (needs_of_operation op (nreg ne res))\n        (kill res ne), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (add_needs (r :: args) (needs_of_operation op (nreg ne res))\n           (kill res ne), nm)))) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"unfold fst in ENV.\nunfold snd in MEM.\nsimpl in H0.\nassert (VA: vagree v te#r (nreg ne res)).\neapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).\neauto.\neauto.\nexploit add_needs_vagree; eauto.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; reflexivity.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## (r :: args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs (r :: args) (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (add_needs (r :: args) (needs_of_operation op (nreg ne res))\n           (kill res ne), nm)))) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"unfold snd in MEM.\nsimpl in H0.\nassert (VA: vagree v te#r (nreg ne res)).\neapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).\neauto.\neauto.\nexploit add_needs_vagree; eauto.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; reflexivity.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## (r :: args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs (r :: args) (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"simpl in H0.\nassert (VA: vagree v te#r (nreg ne res)).\neapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).\neauto.\neauto.\nexploit add_needs_vagree; eauto.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; reflexivity.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op (rs # r :: rs ## args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs (r :: args) (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert (VA: vagree v te#r (nreg ne res)).\neapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).\neauto.\neauto.\nexploit add_needs_vagree; eauto.\nleft; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; reflexivity.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op (rs # r :: rs ## args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs (r :: args) (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) : vagree v te # r (nreg ne res).","proofString":"eapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).\neauto.\neauto.\nexploit add_needs_vagree; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op (rs # r :: rs ## args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs (r :: args) (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) (VA : vagree v te # r (nreg ne res)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Iop; eauto.\nsimpl; reflexivity.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op (rs # r :: rs ## args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs (r :: args) (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) (VA : vagree v te # r (nreg ne res)) : In pc' (successors_instr (Iop op (r :: args) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (r : reg) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op (r :: args) res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op (rs # r :: rs ## args) m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs (r :: args) (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = true) (TI : (fn_code tf) ! pc = Some (Iop Omove (r :: nil) res pc')) (VA : vagree v te # r (nreg ne res)) : eagree rs # res <- v te # res <- (te # r) ne.","proofString":"eapply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (fst\n     (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne),\n         nm)))) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"simpl in *.\nexploit needs_of_operation_sound.\neapply ma_perm; eauto.\neauto.\neauto 2 with na.\neauto with na.\nintros [tv [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit needs_of_operation_sound.\neapply ma_perm; eauto.\neauto.\neauto 2 with na.\neauto with na.\nintros [tv [A B]].\nleft; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op te ## args tm = Some tv) (B : vagree v tv (nreg ne res)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Iop with (v := tv); eauto.\nrewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op te ## args tm = Some tv) (B : vagree v tv (nreg ne res)) : eval_operation tge (Vptr sp0 Ptrofs.zero) op te ## args tm = Some tv.","proofString":"rewrite <- A.\napply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op te ## args tm = Some tv) (B : vagree v tv (nreg ne res)) : eval_operation tge (Vptr sp0 Ptrofs.zero) op te ## args tm =\neval_operation ge (Vptr sp0 Ptrofs.zero) op te ## args tm.","proofString":"apply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op te ## args tm = Some tv) (B : vagree v tv (nreg ne res)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op te ## args tm = Some tv) (B : vagree v tv (nreg ne res)) : In pc' (successors_instr (Iop op args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne res) = false) (INTZERO : is_int_zero (nreg ne res) = false) (ENV : eagree rs te\n  (add_needs args (needs_of_operation op (nreg ne res)) (kill res ne))) (MEM : magree m tm (nlive ge sp0 nm)) (REDUNDANT : operation_is_redundant op (nreg ne res) = false) (TI : (fn_code tf) ! pc = Some (Iop op args res pc')) (tv : val) (A : eval_operation ge (Vptr sp0 Ptrofs.zero) op te ## args tm = Some tv) (B : vagree v tv (nreg ne res)) : eagree rs # res <- v te # res <- tv ne.","proofString":"apply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne dst)\n      then (ne, nm)\n      else\n       if is_int_zero (nreg ne dst)\n       then (kill dst ne, nm)\n       else\n        (add_needs_all args (kill dst ne),\n         nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n           (size_chunk chunk))))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne dst)\n         then (ne, nm)\n         else\n          if is_int_zero (nreg ne dst)\n          then (kill dst ne, nm)\n          else\n           (add_needs_all args (kill dst ne),\n            nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n              (size_chunk chunk)))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne dst)\n   then Inop pc'\n   else\n    if is_int_zero (nreg ne dst)\n    then Iop (Ointconst Int.zero) nil dst pc'\n    else Iload chunk addr args dst pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (is_dead (nreg ne dst)) eqn:DEAD;  [idtac|destruct (is_int_zero (nreg ne dst)) eqn:INTZERO];  simpl in *.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nleft; econstructor; split.\neapply exec_Iop with (v := Vint Int.zero); eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto.\nrewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero.\nexploit eval_addressing_lessdef.\neapply add_needs_all_lessdef; eauto.\neauto.\nintros (ta & U & V).\ninv V; try discriminate.\ndestruct ta; simpl in H1; try discriminate.\nexploit magree_load; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_add with bc i; assumption.\nintros (tv & P & Q).\nleft; econstructor; split.\neapply exec_Iload with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : In pc' (successors_instr (Iload chunk addr args dst pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : eagree rs # dst <- v te ne.","proofString":"apply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = true) (ENV : eagree rs te (kill dst ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil dst pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Iop with (v := Vint Int.zero); eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; auto.\nrewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = true) (ENV : eagree rs te (kill dst ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil dst pc')) : In pc' (successors_instr (Iload chunk addr args dst pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = true) (ENV : eagree rs te (kill dst ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil dst pc')) : eagree rs # dst <- v te # dst <- (Vint Int.zero) ne.","proofString":"apply eagree_update; auto.\nrewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = true) (ENV : eagree rs te (kill dst ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil dst pc')) : vagree v (Vint Int.zero) (nreg ne dst).","proofString":"rewrite is_int_zero_sound by auto.\ndestruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = true) (ENV : eagree rs te (kill dst ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil dst pc')) : vagree v (Vint Int.zero) (I Int.zero).","proofString":"destruct v; simpl; auto.\napply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a : val) (i : int) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some (Vint i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = true) (ENV : eagree rs te (kill dst ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Iop (Ointconst Int.zero) nil dst pc')) : iagree i Int.zero Int.zero.","proofString":"apply iagree_zero."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit eval_addressing_lessdef.\neapply add_needs_all_lessdef; eauto.\neauto.\nintros (ta & U & V).\ninv V; try discriminate.\ndestruct ta; simpl in H1; try discriminate.\nexploit magree_load; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_add with bc i; assumption.\nintros (tv & P & Q).\nleft; econstructor; split.\neapply exec_Iload with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (ta : val) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some ta) (V : Val.lessdef a ta) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv V; try discriminate.\ndestruct ta; simpl in H1; try discriminate.\nexploit magree_load; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_add with bc i; assumption.\nintros (tv & P & Q).\nleft; econstructor; split.\neapply exec_Iload with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (ta : val) (H1 : Mem.loadv chunk m ta = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some ta) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some ta) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct ta; simpl in H1; try discriminate.\nexploit magree_load; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_add with bc i; assumption.\nintros (tv & P & Q).\nleft; econstructor; split.\neapply exec_Iload with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit magree_load; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_add with bc i; assumption.\nintros (tv & P & Q).\nleft; econstructor; split.\neapply exec_Iload with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : forall i0 : Z,\nPtrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk ->\nnlive ge sp0\n  (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b i0.","proofString":"exploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_add with bc i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : (exists bc : block_classification,\n   pmatch bc b i\n     (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args) /\\\n   genv_match bc (Genv.globalenv prog) /\\ bc sp0 = BCstack) ->\nforall i0 : Z,\nPtrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk ->\nnlive ge sp0\n  (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b i0.","proofString":"intros (bc & A & B & C).\nintros.\napply nlive_add with bc i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (bc : block_classification) (A : pmatch bc b i\n  (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) : forall i0 : Z,\nPtrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk ->\nnlive ge sp0\n  (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b i0.","proofString":"intros.\napply nlive_add with bc i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (bc : block_classification) (A : pmatch bc b i\n  (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) (i0 : Z) (H2 : Ptrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk) : nlive ge sp0\n  (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b i0.","proofString":"apply nlive_add with bc i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : (exists v' : val,\n   Mem.load chunk tm b (Ptrofs.unsigned i) = Some v' /\\ Val.lessdef v v') ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (tv & P & Q).\nleft; econstructor; split.\neapply exec_Iload with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Iload with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update; eauto 2 with na.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr te ## args =\neval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args.","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) : In pc' (successors_instr (Iload chunk addr args dst pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) : eagree rs # dst <- v te # dst <- tv ne.","proofString":"apply eagree_update; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) : magree m tm (nlive ge sp0 nm).","proofString":"eapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) : forall (b0 : block) (ofs : Z),\nnlive ge sp0 nm b0 ofs ->\nnlive ge sp0\n  (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b0 ofs.","proofString":"intros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (DEAD : is_dead (nreg ne dst) = false) (INTZERO : is_int_zero (nreg ne dst) = false) (ENV : eagree rs te (add_needs_all args (kill dst ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Iload chunk addr args dst pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned i) = Some tv) (Q : Val.lessdef v tv) (b0 : block) (ofs : Z) (H2 : nlive ge sp0 nm b0 ofs) : nlive ge sp0\n  (nmem_add nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b0 ofs.","proofString":"apply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (if\n       nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n         (size_chunk chunk)\n      then\n       (add_needs_all args (add_need src (store_argument chunk) ne),\n        nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n          (size_chunk chunk))\n      else (ne, nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if\n          nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n            (size_chunk chunk)\n         then\n          (add_needs_all args (add_need src (store_argument chunk) ne),\n           nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n             (size_chunk chunk))\n         else (ne, nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if\n    nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n      (size_chunk chunk)\n   then Istore chunk addr args src pc'\n   else Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)             (size_chunk chunk)) eqn:CONTAINS.\nsimpl in *.\nexploit eval_addressing_lessdef.\neapply add_needs_all_lessdef; eauto.\neauto.\nintros (ta & U & V).\ninv V; try discriminate.\ndestruct ta; simpl in H1; try discriminate.\nexploit magree_store_parallel.\neauto.\neauto.\ninstantiate (1 := te#src).\neauto with na.\ninstantiate (1 := nlive ge sp0 nm).\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption.\nintros (tm' & P & Q).\nleft; econstructor; split.\neapply exec_Istore with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neauto 3 with na.\ndestruct a; simpl in H1; try discriminate.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply magree_store_left; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te\n  (fst\n     (add_needs_all args (add_need src (store_argument chunk) ne),\n      nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (add_needs_all args (add_need src (store_argument chunk) ne),\n         nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n           (size_chunk chunk))))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"simpl in *.\nexploit eval_addressing_lessdef.\neapply add_needs_all_lessdef; eauto.\neauto.\nintros (ta & U & V).\ninv V; try discriminate.\ndestruct ta; simpl in H1; try discriminate.\nexploit magree_store_parallel.\neauto.\neauto.\ninstantiate (1 := te#src).\neauto with na.\ninstantiate (1 := nlive ge sp0 nm).\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption.\nintros (tm' & P & Q).\nleft; econstructor; split.\neapply exec_Istore with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit eval_addressing_lessdef.\neapply add_needs_all_lessdef; eauto.\neauto.\nintros (ta & U & V).\ninv V; try discriminate.\ndestruct ta; simpl in H1; try discriminate.\nexploit magree_store_parallel.\neauto.\neauto.\ninstantiate (1 := te#src).\neauto with na.\ninstantiate (1 := nlive ge sp0 nm).\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption.\nintros (tm' & P & Q).\nleft; econstructor; split.\neapply exec_Istore with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (ta : val) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some ta) (V : Val.lessdef a ta) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv V; try discriminate.\ndestruct ta; simpl in H1; try discriminate.\nexploit magree_store_parallel.\neauto.\neauto.\ninstantiate (1 := te#src).\neauto with na.\ninstantiate (1 := nlive ge sp0 nm).\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption.\nintros (tm' & P & Q).\nleft; econstructor; split.\neapply exec_Istore with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (ta : val) (H1 : Mem.storev chunk m ta rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some ta) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some ta) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct ta; simpl in H1; try discriminate.\nexploit magree_store_parallel.\neauto.\neauto.\ninstantiate (1 := te#src).\neauto with na.\ninstantiate (1 := nlive ge sp0 nm).\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption.\nintros (tm' & P & Q).\nleft; econstructor; split.\neapply exec_Istore with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit magree_store_parallel.\neauto.\neauto.\ninstantiate (1 := te#src).\neauto with na.\ninstantiate (1 := nlive ge sp0 nm).\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption.\nintros (tm' & P & Q).\nleft; econstructor; split.\neapply exec_Istore with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : vagree rs # src te # src (store_argument chunk).","proofString":"eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : forall (b' : block) (i0 : Z),\nnlive ge sp0 nm b' i0 ->\nb' <> b \\/\ni0 < Ptrofs.unsigned i \\/ Ptrofs.unsigned i + size_chunk chunk <= i0 ->\nnlive ge sp0\n  (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b' i0.","proofString":"exploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) : (exists bc : block_classification,\n   pmatch bc b i\n     (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args) /\\\n   genv_match bc (Genv.globalenv prog) /\\ bc sp0 = BCstack) ->\nforall (b' : block) (i0 : Z),\nnlive ge sp0 nm b' i0 ->\nb' <> b \\/\ni0 < Ptrofs.unsigned i \\/ Ptrofs.unsigned i + size_chunk chunk <= i0 ->\nnlive ge sp0\n  (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b' i0.","proofString":"intros (bc & A & B & C).\nintros.\napply nlive_remove with bc b i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (bc : block_classification) (A : pmatch bc b i\n  (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) : forall (b' : block) (i0 : Z),\nnlive ge sp0 nm b' i0 ->\nb' <> b \\/\ni0 < Ptrofs.unsigned i \\/ Ptrofs.unsigned i + size_chunk chunk <= i0 ->\nnlive ge sp0\n  (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b' i0.","proofString":"intros.\napply nlive_remove with bc b i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (bc : block_classification) (A : pmatch bc b i\n  (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) (b' : block) (i0 : Z) (H2 : nlive ge sp0 nm b' i0) (H3 : b' <> b \\/\ni0 < Ptrofs.unsigned i \\/ Ptrofs.unsigned i + size_chunk chunk <= i0) : nlive ge sp0\n  (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n     (size_chunk chunk)) b' i0.","proofString":"apply nlive_remove with bc b i; assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned i) te # src = Some tm') (Q : magree m' tm' (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Istore with (a := Vptr b i).\neauto.\nrewrite <- U.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned i) te # src = Some tm') (Q : magree m' tm' (nlive ge sp0 nm)) : eval_addressing tge (Vptr sp0 Ptrofs.zero) addr te ## args =\neval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args.","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned i) te # src = Some tm') (Q : magree m' tm' (nlive ge sp0 nm)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned i) te # src = Some tm') (Q : magree m' tm' (nlive ge sp0 nm)) : In pc' (successors_instr (Istore chunk addr args src pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 b : block) (i : ptrofs) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = true) (ENV : eagree rs te (add_needs_all args (add_need src (store_argument chunk) ne))) (MEM : magree m tm\n  (nlive ge sp0\n     (nmem_remove nm (aaddressing (vanalyze cu f) # pc addr args)\n        (size_chunk chunk)))) (TI : (fn_code tf) ! pc = Some (Istore chunk addr args src pc')) (U : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr te ## args = Some (Vptr b i)) (tm' : mem) (P : Mem.store chunk tm b (Ptrofs.unsigned i) te # src = Some tm') (Q : magree m' tm' (nlive ge sp0 nm)) : eagree rs te ne.","proofString":"eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct a; simpl in H1; try discriminate.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply magree_store_left; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc' rs m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\neapply magree_store_left; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : In pc' (successors_instr (Istore chunk addr args src pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : magree m' tm (nlive ge sp0 nm).","proofString":"eapply magree_store_left; eauto.\nexploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : forall i0 : Z,\nPtrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk ->\n~ nlive ge sp0 nm b i0.","proofString":"exploit aaddressing_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists bc : block_classification,\n   pmatch bc b i\n     (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args) /\\\n   genv_match bc (Genv.globalenv prog) /\\ bc sp0 = BCstack) ->\nforall i0 : Z,\nPtrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk ->\n~ nlive ge sp0 nm b i0.","proofString":"intros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bc : block_classification) (A : pmatch bc b i\n  (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) : forall i0 : Z,\nPtrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk ->\n~ nlive ge sp0 nm b i0.","proofString":"intros.\neapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (CONTAINS : nmem_contains nm (aaddressing (vanalyze cu f) # pc addr args)\n  (size_chunk chunk) = false) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bc : block_classification) (A : pmatch bc b i\n  (aaddressing (ValueAnalysis.analyze (romem_for cu) f) # pc addr args)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) (i0 : Z) (H2 : Ptrofs.unsigned i <= i0 < Ptrofs.unsigned i + size_chunk chunk) : ~ nlive ge sp0 nm b i0.","proofString":"eapply nlive_contains; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     match is_known_runtime_function (prog_defmap cu) ros with\n     | Some _ =>\n         if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)\n     | None =>\n         (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)\n     end)) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        match is_known_runtime_function (prog_defmap cu) ros with\n        | Some _ =>\n            if is_dead (nreg ne res)\n            then (ne, nm)\n            else\n             (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)\n        | None =>\n            (add_needs_all args (add_ros_need_all ros (kill res ne)),\n             nmem_all)\n        end))) (TI : (fn_code tf) ! pc =\nSome\n  match is_known_runtime_function (prog_defmap cu) ros with\n  | Some _ =>\n      if is_dead (nreg ne res)\n      then Inop pc'\n      else Icall (funsig fd) ros args res pc'\n  | None => Icall (funsig fd) ros args res pc'\n  end) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) (fun S3 : state => match_states S3 S2')).","proofString":"destruct (is_known_runtime_function (prog_defmap cu) ros) as [bf|] eqn:KNOWN.\nexploit is_known_runtime_function_sound; eauto.\nintros (name & sg & EQ & LK).\nsubst fd.\nassert (EV: forall (P: state -> Prop),            (forall vres, builtin_function_sem bf rs##args = Some vres ->               P (State s f (Vptr sp0 Ptrofs.zero) pc' (rs#res <- vres) m)) ->            eventually 2%nat                (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)                           (External (EF_runtime name sg)) rs##args m) P).\nintros.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto.\ndestruct (is_dead (nreg ne res)) eqn:DEAD.\nright; econstructor; exists 2%nat; split.\napply plus_one.\napply exec_Inop; eauto.\napply EV.\nintros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nexploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate.\nexploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nleft; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neapply match_call_states with (cu := cu'); eauto.\nconstructor; auto.\neapply match_stackframes_intro with (cu := cu); eauto.\nintros.\nedestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na.\neauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig fd) ros args res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) (fun S3 : state => match_states S3 S2')).","proofString":"exploit is_known_runtime_function_sound; eauto.\nintros (name & sg & EQ & LK).\nsubst fd.\nassert (EV: forall (P: state -> Prop),            (forall vres, builtin_function_sem bf rs##args = Some vres ->               P (State s f (Vptr sp0 Ptrofs.zero) pc' (rs#res <- vres) m)) ->            eventually 2%nat                (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)                           (External (EF_runtime name sg)) rs##args m) P).\nintros.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto.\ndestruct (is_dead (nreg ne res)) eqn:DEAD.\nright; econstructor; exists 2%nat; split.\napply plus_one.\napply exec_Inop; eauto.\napply EV.\nintros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nexploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig fd) ros args res pc')) : (exists (name : string) (sg : signature),\n   fd = External (EF_runtime name sg) /\\\n   lookup_builtin_function name sg = Some bf) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) (fun S3 : state => match_states S3 S2')).","proofString":"intros (name & sg & EQ & LK).\nsubst fd.\nassert (EV: forall (P: state -> Prop),            (forall vres, builtin_function_sem bf rs##args = Some vres ->               P (State s f (Vptr sp0 Ptrofs.zero) pc' (rs#res <- vres) m)) ->            eventually 2%nat                (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)                           (External (EF_runtime name sg)) rs##args m) P).\nintros.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto.\ndestruct (is_dead (nreg ne res)) eqn:DEAD.\nright; econstructor; exists 2%nat; split.\napply plus_one.\napply exec_Inop; eauto.\napply EV.\nintros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nexploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig fd) ros args res pc')) (name : string) (sg : signature) (EQ : fd = External (EF_runtime name sg)) (LK : lookup_builtin_function name sg = Some bf) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) (fun S3 : state => match_states S3 S2')).","proofString":"subst fd.\nassert (EV: forall (P: state -> Prop),            (forall vres, builtin_function_sem bf rs##args = Some vres ->               P (State s f (Vptr sp0 Ptrofs.zero) pc' (rs#res <- vres) m)) ->            eventually 2%nat                (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)                           (External (EF_runtime name sg)) rs##args m) P).\nintros.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto.\ndestruct (is_dead (nreg ne res)) eqn:DEAD.\nright; econstructor; exists 2%nat; split.\napply plus_one.\napply exec_Inop; eauto.\napply EV.\nintros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nexploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert (EV: forall (P: state -> Prop),            (forall vres, builtin_function_sem bf rs##args = Some vres ->               P (State s f (Vptr sp0 Ptrofs.zero) pc' (rs#res <- vres) m)) ->            eventually 2%nat                (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)                           (External (EF_runtime name sg)) rs##args m) P).\nintros.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto.\ndestruct (is_dead (nreg ne res)) eqn:DEAD.\nright; econstructor; exists 2%nat; split.\napply plus_one.\napply exec_Inop; eauto.\napply EV.\nintros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nexploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P.","proofString":"intros.\napply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) : eventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P.","proofString":"apply eventually_later.\nintros rr F; inv F.\nintros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) : forall r : int,\n~\nfinal_state\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) r.","proofString":"intros rr F; inv F."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) : forall (t : trace) (s' : state),\nstep ge\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) t s' ->\nt = E0 /\\ Smallstep.eventually step final_state ge 1 s' P.","proofString":"intros t s1 S1.\ninv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) (t : trace) (s1 : state) (S1 : step ge\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) t s1) : t = E0 /\\ Smallstep.eventually step final_state ge 1 s1 P.","proofString":"inv S1.\nhnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) (t : trace) (res0 : val) (m' : mem) (H8 : external_call (EF_runtime name sg) ge rs ## args m t res0 m') : t = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  P.","proofString":"hnf in H8.\nrewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) (t : trace) (res0 : val) (m' : mem) (H8 : match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge rs ## args m t res0 m') : t = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  P.","proofString":"rewrite LK in H8.\ninv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) (t : trace) (res0 : val) (m' : mem) (H8 : known_builtin_sem bf ge rs ## args m t res0 m') : t = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  P.","proofString":"inv H8.\nsplit; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (m' : mem) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m' tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m')) (res0 : val) (H2 : builtin_function_sem bf rs ## args = Some res0) : E0 = E0 /\\\nSmallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  P.","proofString":"split; auto.\napply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (m' : mem) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m' tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m')) (res0 : val) (H2 : builtin_function_sem bf rs ## args = Some res0) : Smallstep.eventually step final_state ge 1\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  P.","proofString":"apply eventually_later.\nintros rr F; inv F.\nintros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (m' : mem) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m' tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m')) (res0 : val) (H2 : builtin_function_sem bf rs ## args = Some res0) : forall r : int,\n~\nfinal_state\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  r.","proofString":"intros rr F; inv F."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (m' : mem) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m' tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m')) (res0 : val) (H2 : builtin_function_sem bf rs ## args = Some res0) : forall (t : trace) (s' : state),\nstep ge\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  t s' -> t = E0 /\\ Smallstep.eventually step final_state ge 0 s' P.","proofString":"intros t s2 S2.\ninv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (m' : mem) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m' tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m')) (res0 : val) (H2 : builtin_function_sem bf rs ## args = Some res0) (t : trace) (s2 : state) (S2 : step ge\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) res0 m')\n  t s2) : t = E0 /\\ Smallstep.eventually step final_state ge 0 s2 P.","proofString":"inv S2.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (m' : mem) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m' tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m')) (res0 : val) (H2 : builtin_function_sem bf rs ## args = Some res0) : E0 = E0 /\\\nSmallstep.eventually step final_state ge 0\n  (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- res0 m') P.","proofString":"split; auto.\napply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (m' : mem) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m' tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (P : state -> Prop) (H1 : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nP (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m')) (res0 : val) (H2 : builtin_function_sem bf rs ## args = Some res0) : Smallstep.eventually step final_state ge 0\n  (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- res0 m') P.","proofString":"apply eventually_now; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (ENV : eagree rs te\n  (fst\n     (if is_dead (nreg ne res)\n      then (ne, nm)\n      else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if is_dead (nreg ne res)\n         then (ne, nm)\n         else (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))))) (TI : (fn_code tf) ! pc =\nSome\n  (if is_dead (nreg ne res)\n   then Inop pc'\n   else Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (is_dead (nreg ne res)) eqn:DEAD.\nright; econstructor; exists 2%nat; split.\napply plus_one.\napply exec_Inop; eauto.\napply EV.\nintros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na.\nexploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"right; econstructor; exists 2%nat; split.\napply plus_one.\napply exec_Inop; eauto.\napply EV.\nintros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : forall vres : val,\nbuiltin_function_sem bf rs ## args = Some vres ->\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)\n  (State ts tf (Vptr sp0 Ptrofs.zero) pc' te tm).","proofString":"intros.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres0 : val,\n builtin_function_sem bf rs ## args = Some vres0 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (vres : val) (H1 : builtin_function_sem bf rs ## args = Some vres) : match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)\n  (State ts tf (Vptr sp0 Ptrofs.zero) pc' te tm).","proofString":"eapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres0 : val,\n builtin_function_sem bf rs ## args = Some vres0 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (vres : val) (H1 : builtin_function_sem bf rs ## args = Some vres) : In pc'\n  (successors_instr\n     (Icall (funsig (External (EF_runtime name sg))) ros args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = true) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres0 : val,\n builtin_function_sem bf rs ## args = Some vres0 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (vres : val) (H1 : builtin_function_sem bf rs ## args = Some vres) : eagree rs # res <- vres te ne.","proofString":"apply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) : (exists (cu0 : AST.program fundef unit) (tfd : fundef),\n   find_function tge ros te = Some tfd /\\\n   transf_fundef (prog_defmap cu0) (romem_for cu0)\n     (External (EF_runtime name sg)) = OK tfd /\\ linkorder cu0 prog) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (cu' & tfd & A & B & C).\nsimpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu')\n  (External (EF_runtime name sg)) = OK tfd) (C : linkorder cu' prog) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"simpl in B; inv B.\ndestruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (EV : forall P : state -> Prop,\n(forall vres : val,\n builtin_function_sem bf rs ## args = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (builtin_function_sem bf rs##args) as [vres|] eqn:BFSEM.\nexploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na.\nright; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres : val) (BFSEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall vres0 : val,\n Some vres = Some vres0 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit builtin_function_sem_lessdef; eauto 2 with na.\nintros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres : val) (BFSEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall vres0 : val,\n Some vres = Some vres0 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) : (exists vres' : val,\n   builtin_function_sem bf te ## args = Some vres' /\\ Val.lessdef vres vres') ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (vres' & BFSEM' & LD).\nright; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres : val) (BFSEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall vres0 : val,\n Some vres = Some vres0 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) (vres' : val) (BFSEM' : builtin_function_sem bf te ## args = Some vres') (LD : Val.lessdef vres vres') : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"right; econstructor; exists 2%nat; split.\neapply plus_three.\neapply exec_Icall; eauto.\nconstructor.\nhnf.\nrewrite LK.\neconstructor; eauto.\nconstructor.\nauto.\napply EV.\nintros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres : val) (BFSEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall vres0 : val,\n Some vres = Some vres0 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) (vres' : val) (BFSEM' : builtin_function_sem bf te ## args = Some vres') (LD : Val.lessdef vres vres') : forall vres0 : val,\nSome vres = Some vres0 ->\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)\n  (State ts tf (Vptr sp0 Ptrofs.zero) pc' te # res <- vres' tm).","proofString":"intros.\ninv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres : val) (BFSEM : builtin_function_sem bf rs ## args = Some vres) (EV : forall P : state -> Prop,\n(forall vres1 : val,\n Some vres = Some vres1 ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres1 m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) (vres' : val) (BFSEM' : builtin_function_sem bf te ## args = Some vres') (LD : Val.lessdef vres vres') (vres0 : val) (H1 : Some vres = Some vres0) : match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)\n  (State ts tf (Vptr sp0 Ptrofs.zero) pc' te # res <- vres' tm).","proofString":"inv H1.\neapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres0 : val) (EV : forall P : state -> Prop,\n(forall vres : val,\n Some vres0 = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (BFSEM : builtin_function_sem bf rs ## args = Some vres0) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) (vres' : val) (BFSEM' : builtin_function_sem bf te ## args = Some vres') (LD : Val.lessdef vres0 vres') : match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres0 m)\n  (State ts tf (Vptr sp0 Ptrofs.zero) pc' te # res <- vres' tm).","proofString":"eapply match_succ_states with (cu := cu); eauto.\nsimpl; auto.\napply eagree_update; eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres0 : val) (EV : forall P : state -> Prop,\n(forall vres : val,\n Some vres0 = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (BFSEM : builtin_function_sem bf rs ## args = Some vres0) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) (vres' : val) (BFSEM' : builtin_function_sem bf te ## args = Some vres') (LD : Val.lessdef vres0 vres') : In pc'\n  (successors_instr\n     (Icall (funsig (External (EF_runtime name sg))) ros args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (vres0 : val) (EV : forall P : state -> Prop,\n(forall vres : val,\n Some vres0 = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (BFSEM : builtin_function_sem bf rs ## args = Some vres0) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) (vres' : val) (BFSEM' : builtin_function_sem bf te ## args = Some vres') (LD : Val.lessdef vres0 vres') : eagree rs # res <- vres0 te # res <- vres' ne.","proofString":"apply eagree_update; eauto 3 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (BFSEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall vres : val,\n None = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n        (External (EF_runtime name sg)) rs ## args m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"right; econstructor; exists 2%nat; split.\napply plus_one.\neapply exec_Icall; eauto.\napply EV.\nintros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (name : string) (sg : signature) (H0 : find_function ge ros rs = Some (External (EF_runtime name sg))) (H : (fn_code f) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = Some bf) (DEAD : is_dead (nreg ne res) = false) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nm)))) (TI : (fn_code tf) ! pc =\nSome (Icall (funsig (External (EF_runtime name sg))) ros args res pc')) (LK : lookup_builtin_function name sg = Some bf) (BFSEM : builtin_function_sem bf rs ## args = None) (EV : forall P : state -> Prop,\n(forall vres : val,\n None = Some vres ->\n P (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)) ->\neventually 2\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n     (External (EF_runtime name sg)) rs ## args m) P) (cu' : AST.program fundef unit) (A : find_function tge ros te = Some (External (EF_runtime name sg))) (C : linkorder cu' prog) : forall vres : val,\nNone = Some vres ->\nmatch_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- vres m)\n  (Callstate (Stackframe res tf (Vptr sp0 Ptrofs.zero) pc' te :: ts)\n     (External (EF_runtime name sg)) te ## args tm).","proofString":"intros; discriminate."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) (fun S3 : state => match_states S3 S2')).","proofString":"exploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & C).\nleft; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neapply match_call_states with (cu := cu'); eauto.\nconstructor; auto.\neapply match_stackframes_intro with (cu := cu); eauto.\nintros.\nedestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na.\neauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) : (exists (cu0 : AST.program fundef unit) (tfd : fundef),\n   find_function tge ros te = Some tfd /\\\n   transf_fundef (prog_defmap cu0) (romem_for cu0) fd = OK tfd /\\\n   linkorder cu0 prog) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) (fun S3 : state => match_states S3 S2')).","proofString":"intros (cu' & tfd & A & B & C).\nleft; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neapply match_call_states with (cu := cu'); eauto.\nconstructor; auto.\neapply match_stackframes_intro with (cu := cu); eauto.\nintros.\nedestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na.\neauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n        rs ## args m) (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Icall; eauto.\neapply sig_function_translated; eauto.\neapply match_call_states with (cu := cu'); eauto.\nconstructor; auto.\neapply match_stackframes_intro with (cu := cu); eauto.\nintros.\nedestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na.\neauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : funsig tfd = funsig fd.","proofString":"eapply sig_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : list_forall2 match_stackframes\n  (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n  (Stackframe res tf (Vptr sp0 Ptrofs.zero) pc' te :: ts).","proofString":"constructor; auto.\neapply match_stackframes_intro with (cu := cu); eauto.\nintros.\nedestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : match_stackframes (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs)\n  (Stackframe res tf (Vptr sp0 Ptrofs.zero) pc' te).","proofString":"eapply match_stackframes_intro with (cu := cu); eauto.\nintros.\nedestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : forall v tv : val,\nVal.lessdef v tv ->\neagree rs # res <- v te # res <- tv\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc')).","proofString":"intros.\nedestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) (v tv : val) (H1 : Val.lessdef v tv) : eagree rs # res <- v te # res <- tv\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc')).","proofString":"edestruct analyze_successors; eauto.\nsimpl; eauto.\neapply eagree_ge; eauto.\nrewrite ANPC.\nsimpl.\napply eagree_update; eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) (v tv : val) (H1 : Val.lessdef v tv) (H2 : NE.ge (fst an # pc)\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))) (H3 : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))\n  b ofs -> nlive ge0 sp (snd an # pc) b ofs) : eagree rs # res <- v te # res <- tv (fst an # pc).","proofString":"rewrite ANPC.\nsimpl.\napply eagree_update; eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) (v tv : val) (H1 : Val.lessdef v tv) (H2 : NE.ge (fst an # pc)\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))) (H3 : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))\n  b ofs -> nlive ge0 sp (snd an # pc) b ofs) : eagree rs # res <- v te # res <- tv (fst (ne, nm)).","proofString":"simpl.\napply eagree_update; eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) (v tv : val) (H1 : Val.lessdef v tv) (H2 : NE.ge (fst an # pc)\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))) (H3 : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc' an # pc'))\n  b ofs -> nlive ge0 sp (snd an # pc) b ofs) : eagree rs # res <- v te # res <- tv ne.","proofString":"apply eagree_update; eauto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : Val.lessdef_list rs ## args te ## args.","proofString":"eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : Mem.extends m tm.","proofString":"eapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (KNOWN : is_known_runtime_function (prog_defmap cu) ros = None) (ENV : eagree rs te\n  (fst (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)))) (TI : (fn_code tf) ! pc = Some (Icall (funsig fd) ros args res pc')) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (C : linkorder cu' prog) : forall (b : block) (ofs : Z),\nnlive ge sp0\n  (snd (add_needs_all args (add_ros_need_all ros (kill res ne)), nmem_all)) b\n  ofs.","proofString":"apply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) : (exists S2' : state,\n   step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (Callstate s fd rs ## args m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit find_function_translated; eauto 2 with na.\nintros (cu' & tfd & A & B & L).\nexploit magree_free.\neauto.\neauto.\ninstantiate (1 := nlive ge stk nmem_all).\nintros; eapply nlive_dead_stack; eauto.\nintros (tm' & C & D).\nleft; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\nerewrite stacksize_translated by eauto.\neexact C.\neapply match_call_states with (cu := cu'); eauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) : (exists (cu0 : AST.program fundef unit) (tfd : fundef),\n   find_function tge ros te = Some tfd /\\\n   transf_fundef (prog_defmap cu0) (romem_for cu0) fd = OK tfd /\\\n   linkorder cu0 prog) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (Callstate s fd rs ## args m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (cu' & tfd & A & B & L).\nexploit magree_free.\neauto.\neauto.\ninstantiate (1 := nlive ge stk nmem_all).\nintros; eapply nlive_dead_stack; eauto.\nintros (tm' & C & D).\nleft; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\nerewrite stacksize_translated by eauto.\neexact C.\neapply match_call_states with (cu := cu'); eauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (L : linkorder cu' prog) : (exists S2' : state,\n   step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (Callstate s fd rs ## args m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit magree_free.\neauto.\neauto.\ninstantiate (1 := nlive ge stk nmem_all).\nintros; eapply nlive_dead_stack; eauto.\nintros (tm' & C & D).\nleft; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\nerewrite stacksize_translated by eauto.\neexact C.\neapply match_call_states with (cu := cu'); eauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (L : linkorder cu' prog) : forall (b' : block) (i : Z),\nnlive ge stk nmem_all b' i ->\nb' <> stk \\/ ~ 0 <= i < fn_stacksize f ->\nnlive ge stk (nmem_dead_stack (fn_stacksize f)) b' i.","proofString":"intros; eapply nlive_dead_stack; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (L : linkorder cu' prog) (tm' : mem) (C : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (D : magree m' tm' (nlive ge stk nmem_all)) : (exists S2' : state,\n   step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (Callstate s fd rs ## args m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (Callstate s fd rs ## args m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Itailcall; eauto.\neapply sig_function_translated; eauto.\nerewrite stacksize_translated by eauto.\neexact C.\neapply match_call_states with (cu := cu'); eauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (L : linkorder cu' prog) (tm' : mem) (C : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (D : magree m' tm' (nlive ge stk nmem_all)) : funsig tfd = funsig fd.","proofString":"eapply sig_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (L : linkorder cu' prog) (tm' : mem) (C : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (D : magree m' tm' (nlive ge stk nmem_all)) : Mem.extends m' tm'.","proofString":"eapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_needs_all args (add_ros_need_all ros NE.bot))) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Itailcall (funsig fd) ros args)) (cu' : AST.program fundef unit) (tfd : fundef) (A : find_function tge ros te = Some tfd) (B : transf_fundef (prog_defmap cu') (romem_for cu') fd = OK tfd) (L : linkorder cu' prog) (tm' : mem) (C : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (D : magree m' tm' (nlive ge stk nmem_all)) : forall (b : block) (ofs : Z), nlive ge stk nmem_all b ofs.","proofString":"apply nlive_all."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (fst (transfer_builtin (vanalyze cu f) # pc ef args res ne nm))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin (vanalyze cu f) # pc ef args res ne nm)))) (TI : (fn_code tf) ! pc =\nSome\n  match ef with\n  | EF_builtin name sg =>\n      match lookup_builtin_function name sg with\n      | Some _ =>\n          if builtin_res_dead res ne\n          then Inop pc'\n          else Ibuiltin ef args res pc'\n      | None => Ibuiltin ef args res pc'\n      end\n  | EF_memcpy sz _ =>\n      match args with\n      | nil => Ibuiltin ef args res pc'\n      | dst :: _ :: nil =>\n          if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz\n          then Ibuiltin ef args res pc'\n          else Inop pc'\n      | dst :: nil | dst :: _ :: _ :: _ => Ibuiltin ef args res pc'\n      end\n  | _ => Ibuiltin ef args res pc'\n  end) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"revert ENV MEM TI.\nfunctional induction (transfer_builtin (vanalyze cu f)#pc ef args res ne nm);  simpl in *; intros.\ninv H0.\ninv H6.\nrename b1 into v1.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,              nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)                (size_chunk chunk)) a1) as (ne1, nm1) eqn: TR.\nInvSoundState.\nexploit transfer_builtin_arg_sound; eauto.\nintros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto.\ninv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\ndestruct (transfer_builtin_arg (store_argument chunk)              (kill_builtin_res res ne, nm) a2) as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\nrewrite e1 in TI.\ninv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\nrewrite e1 in TI.\ninv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nm) _x2) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_list_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nm) _x2) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\ninv B.\ninv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\ninv H1.\nexploit can_eval_builtin_args; eauto.\nintros (vargs' & A).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\nconstructor.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\nrewrite e1, e2 in TI.\nunfold builtin_or_external_sem in H1.\nrewrite e1 in H1.\ndestruct H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\nsimpl.\napply eagree_update_dead; auto with na.\nrewrite e1, e2 in TI.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nm) args0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\nunfold builtin_or_external_sem in H1; rewrite e1 in H1.\nassert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\nassert (external_call (EF_builtin name sg) ge vargs m t vres m') by auto.\nassert ((fn_code tf)!pc = Some(Ibuiltin (EF_builtin name sg) args0 res pc')).\ndestruct (Builtins.lookup_builtin_function name sg) eqn:BR; auto.\ncontradiction.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\nassert ((fn_code tf)!pc = Some(Ibuiltin _x _x0 res pc')).\ndestruct _x; auto.\ninv y.\ndestruct _x0; auto.\ndestruct _x0; auto.\ndestruct _x0; auto.\ncontradiction.\nclear y TI.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (a1 :: nil) vargs) (H1 : volatile_load_sem chunk ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (kill_builtin_res res ne,\n         nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk))\n        a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)\n              (size_chunk chunk)) a1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H0.\ninv H6.\nrename b1 into v1.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,              nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)                (size_chunk chunk)) a1) as (ne1, nm1) eqn: TR.\nInvSoundState.\nexploit transfer_builtin_arg_sound; eauto.\nintros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : volatile_load_sem chunk ge (b1 :: bl) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (kill_builtin_res res ne,\n         nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk))\n        a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)\n              (size_chunk chunk)) a1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H6 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  nil bl) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H6.\nrename b1 into v1.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,              nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)                (size_chunk chunk)) a1) as (ne1, nm1) eqn: TR.\nInvSoundState.\nexploit transfer_builtin_arg_sound; eauto.\nintros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (b1 : val) (H1 : volatile_load_sem chunk ge (b1 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (kill_builtin_res res ne,\n         nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk))\n        a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)\n              (size_chunk chunk)) a1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rename b1 into v1.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,              nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)                (size_chunk chunk)) a1) as (ne1, nm1) eqn: TR.\nInvSoundState.\nexploit transfer_builtin_arg_sound; eauto.\nintros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (v1 : val) (H1 : volatile_load_sem chunk ge (v1 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (kill_builtin_res res ne,\n         nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk))\n        a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)\n              (size_chunk chunk)) a1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_arg All              (kill_builtin_res res ne,              nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1)                (size_chunk chunk)) a1) as (ne1, nm1) eqn: TR.\nInvSoundState.\nexploit transfer_builtin_arg_sound; eauto.\nintros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (v1 : val) (H1 : volatile_load_sem chunk ge (v1 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"InvSoundState.\nexploit transfer_builtin_arg_sound; eauto.\nintros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (v1 : val) (H1 : volatile_load_sem chunk ge (v1 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transfer_builtin_arg_sound; eauto.\nintros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (v1 : val) (H1 : volatile_load_sem chunk ge (v1 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists v' : val,\n   eval_builtin_arg ge (fun r : positive => te # r) \n     (Vptr sp0 Ptrofs.zero) tm a1 v' /\\\n   vagree v1 v' All /\\\n   eagree rs te (kill_builtin_res res ne) /\\\n   magree m tm\n     (nlive ge sp0\n        (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (tv1 & A & B & C & D).\ninv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (v1 : val) (H1 : volatile_load_sem chunk ge (v1 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B : vagree v1 tv1 All) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H1.\nsimpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B : vagree (Vptr b ofs) tv1 All) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"simpl in B.\ninv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B : Val.lessdef (Vptr b ofs) tv1) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv B.\nassert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres).\ninv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto.\ndestruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) : exists tvres : val,\n  volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres.","proofString":"inv H2.\nexists (Val.load_result chunk v); split; auto.\nconstructor; auto.\nexploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (id : ident) (ev : eventval) (v : val) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) : exists tvres : val,\n  volatile_load ge chunk tm b ofs (Event_vload chunk id ofs ev :: nil) tvres /\\\n  Val.lessdef (Val.load_result chunk v) tvres.","proofString":"exists (Val.load_result chunk v); split; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (id : ident) (ev : eventval) (v : val) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) : volatile_load ge chunk tm b ofs (Event_vload chunk id ofs ev :: nil)\n  (Val.load_result chunk v).","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) : exists tvres : val,\n  volatile_load ge chunk tm b ofs E0 tvres /\\ Val.lessdef vres tvres.","proofString":"exploit magree_load; eauto.\nexploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption.\nintros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) : forall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\nnlive ge sp0\n  (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) b i.","proofString":"exploit aaddr_arg_sound_1; eauto.\nrewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) : pmatch bc b ofs (aaddr_arg (VA.State ae am) a1) ->\nforall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\nnlive ge sp0\n  (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) b i.","proofString":"rewrite <- AN.\nintros.\nintros.\neapply nlive_add; eassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) : pmatch bc b ofs (aaddr_arg (ValueAnalysis.analyze (romem_for cu) f) # pc a1) ->\nforall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\nnlive ge sp0\n  (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) b i.","proofString":"intros.\nintros.\neapply nlive_add; eassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (H2 : pmatch bc b ofs (aaddr_arg (ValueAnalysis.analyze (romem_for cu) f) # pc a1)) (i : Z) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : nlive ge sp0\n  (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) b i.","proofString":"intros.\neapply nlive_add; eassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (H2 : pmatch bc b ofs (aaddr_arg (ValueAnalysis.analyze (romem_for cu) f) # pc a1)) (i : Z) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : nlive ge sp0\n  (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) b i.","proofString":"eapply nlive_add; eassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) : (exists v' : val,\n   Mem.load chunk tm b (Ptrofs.unsigned ofs) = Some v' /\\ Val.lessdef vres v') ->\nexists tvres : val,\n  volatile_load ge chunk tm b ofs E0 tvres /\\ Val.lessdef vres tvres.","proofString":"intros (tv & P & Q).\nexists tv; split; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned ofs) = Some tv) (Q : Val.lessdef vres tv) : exists tvres : val,\n  volatile_load ge chunk tm b ofs E0 tvres /\\ Val.lessdef vres tvres.","proofString":"exists tv; split; auto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (tv : val) (P : Mem.load chunk tm b (Ptrofs.unsigned ofs) = Some tv) (Q : Val.lessdef vres tv) : volatile_load ge chunk tm b ofs E0 tv.","proofString":"constructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (X : exists tvres : val,\n  volatile_load ge chunk tm b ofs t tvres /\\ Val.lessdef vres tvres) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct X as (tvres & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (tvres : val) (P : volatile_load ge chunk tm b ofs t tvres) (Q : Val.lessdef vres tvres) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\nsimpl.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto.\neapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (tvres : val) (P : volatile_load ge chunk tm b ofs t tvres) (Q : Val.lessdef vres tvres) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (tvres : val) (P : volatile_load ge chunk tm b ofs t tvres) (Q : Val.lessdef vres tvres) : In pc' (successors_instr (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (tvres : val) (P : volatile_load ge chunk tm b ofs t tvres) (Q : Val.lessdef vres tvres) : eagree (regmap_setres res vres rs) (regmap_setres res tvres te) ne.","proofString":"apply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (tvres : val) (P : volatile_load ge chunk tm b ofs t tvres) (Q : Val.lessdef vres tvres) : magree m' tm (nlive ge sp0 nm).","proofString":"eapply magree_monotone; eauto.\nintros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (tvres : val) (P : volatile_load ge chunk tm b ofs t tvres) (Q : Val.lessdef vres tvres) : forall (b0 : block) (ofs0 : Z),\nnlive ge sp0 nm b0 ofs0 ->\nnlive ge sp0\n  (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) b0\n  ofs0.","proofString":"intros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_arg All\n  (kill_builtin_res res ne,\n   nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) a1 =\n(ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (b : block) (ofs : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (A : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  (Vptr b ofs)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm\n  (nlive ge sp0\n     (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)))) (H2 : volatile_load ge chunk m' b ofs t vres) (tvres : val) (P : volatile_load ge chunk tm b ofs t tvres) (Q : Val.lessdef vres tvres) (b0 : block) (ofs0 : Z) (H0 : nlive ge sp0 nm b0 ofs0) : nlive ge sp0\n  (nmem_add nm (aaddr_arg (vanalyze cu f) # pc a1) (size_chunk chunk)) b0\n  ofs0.","proofString":"apply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (a1 :: a2 :: nil) vargs) (H1 : volatile_store_sem chunk ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg (store_argument chunk)\n           (kill_builtin_res res ne, nm) a2) a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg (store_argument chunk)\n              (kill_builtin_res res ne, nm) a2) a1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\ndestruct (transfer_builtin_arg (store_argument chunk)              (kill_builtin_res res ne, nm) a2) as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : volatile_store_sem chunk ge (b1 :: bl) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg (store_argument chunk)\n           (kill_builtin_res res ne, nm) a2) a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg (store_argument chunk)\n              (kill_builtin_res res ne, nm) a2) a1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H6 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  (a2 :: nil) bl) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\ndestruct (transfer_builtin_arg (store_argument chunk)              (kill_builtin_res res ne, nm) a2) as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (b1 b0 : val) (bl0 : list val) (H1 : volatile_store_sem chunk ge (b1 :: b0 :: bl0) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg (store_argument chunk)\n           (kill_builtin_res res ne, nm) a2) a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg (store_argument chunk)\n              (kill_builtin_res res ne, nm) a2) a1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  b0) (H7 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  nil bl0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H7.\nrename b1 into v1.\nrename b0 into v2.\ndestruct (transfer_builtin_arg (store_argument chunk)              (kill_builtin_res res ne, nm) a2) as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (b1 b0 : val) (H1 : volatile_store_sem chunk ge (b1 :: b0 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg (store_argument chunk)\n           (kill_builtin_res res ne, nm) a2) a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg (store_argument chunk)\n              (kill_builtin_res res ne, nm) a2) a1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  b0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rename b1 into v1.\nrename b0 into v2.\ndestruct (transfer_builtin_arg (store_argument chunk)              (kill_builtin_res res ne, nm) a2) as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 b0 : val) (H1 : volatile_store_sem chunk ge (v1 :: b0 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg (store_argument chunk)\n           (kill_builtin_res res ne, nm) a2) a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg (store_argument chunk)\n              (kill_builtin_res res ne, nm) a2) a1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  b0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rename b0 into v2.\ndestruct (transfer_builtin_arg (store_argument chunk)              (kill_builtin_res res ne, nm) a2) as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg (store_argument chunk)\n           (kill_builtin_res res ne, nm) a2) a1))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg (store_argument chunk)\n              (kill_builtin_res res ne, nm) a2) a1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_arg (store_argument chunk)              (kill_builtin_res res ne, nm) a2) as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ENV : eagree rs te (fst (transfer_builtin_arg All (ne2, nm2) a1))) (MEM : magree m tm (nlive ge sp0 (snd (transfer_builtin_arg All (ne2, nm2) a1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_arg All (ne2, nm2) a1) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"InvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\nexploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a2\n  tv2) (B2 : vagree v2 tv2 (store_argument chunk)) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transf_volatile_store; eauto.\nintros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a2\n  tv2) (B2 : vagree v2 tv2 (store_argument chunk)) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 nm)) : vres = Vundef /\\\n(exists tm' : mem,\n   volatile_store_sem chunk ge (tv1 :: tv2 :: nil) tm t Vundef tm' /\\\n   magree m' tm' (nlive ge sp0 nm)) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (EQ & tm' & P & Q).\nsubst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a2\n  tv2) (B2 : vagree v2 tv2 (store_argument chunk)) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 nm)) (EQ : vres = Vundef) (tm' : mem) (P : volatile_store_sem chunk ge (tv1 :: tv2 :: nil) tm t Vundef tm') (Q : magree m' tm' (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"subst vres.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t Vundef m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a2\n  tv2) (B2 : vagree v2 tv2 (store_argument chunk)) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 nm)) (tm' : mem) (P : volatile_store_sem chunk ge (tv1 :: tv2 :: nil) tm t Vundef tm') (Q : magree m' tm' (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t Vundef m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a2\n  tv2) (B2 : vagree v2 tv2 (store_argument chunk)) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 nm)) (tm' : mem) (P : volatile_store_sem chunk ge (tv1 :: tv2 :: nil) tm t Vundef tm') (Q : magree m' tm' (nlive ge sp0 nm)) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t Vundef m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a2\n  tv2) (B2 : vagree v2 tv2 (store_argument chunk)) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 nm)) (tm' : mem) (P : volatile_store_sem chunk ge (tv1 :: tv2 :: nil) tm t Vundef tm') (Q : magree m' tm' (nlive ge sp0 nm)) : In pc'\n  (successors_instr (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (m' : mem) (res : builtin_res reg) (chunk : memory_chunk) (a1 a2 : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : volatile_store_sem chunk ge (v1 :: v2 :: nil) m t Vundef m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg (store_argument chunk) (kill_builtin_res res ne, nm) a2 =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) a1 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a2 :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a2\n  v2) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a1\n  tv1) (B1 : vagree v1 tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm a2\n  tv2) (B2 : vagree v2 tv2 (store_argument chunk)) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 nm)) (tm' : mem) (P : volatile_store_sem chunk ge (tv1 :: tv2 :: nil) tm t Vundef tm') (Q : magree m' tm' (nlive ge sp0 nm)) : eagree (regmap_setres res Vundef rs) (regmap_setres res Vundef te) ne.","proofString":"apply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (dst :: src :: nil) vargs) (H1 : extcall_memcpy_sem sz al ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = true) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n              (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg All\n              (kill_builtin_res res ne,\n               nmem_add\n                 (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n                 (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src)))) (TI : (fn_code tf) ! pc =\nSome\n  (if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz\n   then Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc'\n   else Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rewrite e1 in TI.\ninv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (dst :: src :: nil) vargs) (H1 : extcall_memcpy_sem sz al ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = true) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n              (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg All\n              (kill_builtin_res res ne,\n               nmem_add\n                 (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n                 (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : extcall_memcpy_sem sz al ge (b1 :: bl) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = true) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n              (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg All\n              (kill_builtin_res res ne,\n               nmem_add\n                 (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n                 (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  b1) (H6 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  (src :: nil) bl) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (b1 b0 : val) (bl0 : list val) (H1 : extcall_memcpy_sem sz al ge (b1 :: b0 :: bl0) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = true) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n              (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg All\n              (kill_builtin_res res ne,\n               nmem_add\n                 (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n                 (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  b1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  b0) (H7 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  nil bl0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (b1 b0 : val) (H1 : extcall_memcpy_sem sz al ge (b1 :: b0 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = true) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n              (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg All\n              (kill_builtin_res res ne,\n               nmem_add\n                 (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n                 (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  b1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  b0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (v1 b0 : val) (H1 : extcall_memcpy_sem sz al ge (v1 :: b0 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = true) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n              (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg All\n              (kill_builtin_res res ne,\n               nmem_add\n                 (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n                 (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  b0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : extcall_memcpy_sem sz al ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = true) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_arg All\n        (transfer_builtin_arg All\n           (kill_builtin_res res ne,\n            nmem_add (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n              (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_arg All\n           (transfer_builtin_arg All\n              (kill_builtin_res res ne,\n               nmem_add\n                 (nmem_remove nm (aaddr_arg (vanalyze cu f) # pc dst) sz)\n                 (aaddr_arg (vanalyze cu f) # pc src) sz) dst) src)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  v2) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"set (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ndestruct (transfer_builtin_arg All              (kill_builtin_res res ne,               nmem_add (nmem_remove nm adst sz) asrc sz) dst)           as (ne2, nm2) eqn: TR2.\ndestruct (transfer_builtin_arg All (ne2, nm2) src) as (ne1, nm1) eqn: TR1.\nInvSoundState.\nexploit transfer_builtin_arg_sound.\neexact H3.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv1 & A1 & B1 & C1 & D1).\nexploit transfer_builtin_arg_sound.\neexact H4.\neauto.\neauto.\neauto.\neauto.\neauto.\nintros (tv2 & A2 & B2 & C2 & D2).\ninv H1.\nexploit magree_loadbytes.\neauto.\neauto.\nintros.\neapply nlive_add; eauto.\nunfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nintros (tbytes & P & Q).\nexploit magree_storebytes_parallel.\neapply magree_monotone.\neexact D2.\ninstantiate (1 := nlive ge sp0 (nmem_remove nm adst sz)).\nintros.\napply incl_nmem_add; auto.\neauto.\ninstantiate (1 := nlive ge sp0 nm).\nintros.\neapply nlive_remove; eauto.\nunfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.\nerewrite Mem.loadbytes_length in H1 by eauto.\nrewrite Z2Nat.id in H1 by lia.\nauto.\neauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) : forall (b : block) (ofs : Z),\nnlive ge sp0 (nmem_remove nm adst sz) b ofs ->\nnlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz) b ofs.","proofString":"intros.\napply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) (b : block) (ofs : Z) (H0 : nlive ge sp0 (nmem_remove nm adst sz) b ofs) : nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz) b ofs.","proofString":"apply incl_nmem_add; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) (b' : block) (i : Z) (H0 : nlive ge sp0 nm b' i) (H1 : b' <> bdst \\/\ni < Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + Z.of_nat (Z.to_nat sz) <= i) : b' <> bdst \\/ i < Ptrofs.unsigned odst \\/ Ptrofs.unsigned odst + sz <= i.","proofString":"rewrite Z2Nat.id in H1 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) (b' : block) (i : Z) (H0 : nlive ge sp0 nm b' i) (H1 : b' <> bdst \\/ i < Ptrofs.unsigned odst \\/ Ptrofs.unsigned odst + sz <= i) : b' <> bdst \\/ i < Ptrofs.unsigned odst \\/ Ptrofs.unsigned odst + sz <= i.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) (tm' : mem) (A : Mem.storebytes tm bdst (Ptrofs.unsigned odst) tbytes = Some tm') (B : magree m' tm' (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge).\nexact symbols_preserved.\nconstructor.\neauto.\nconstructor.\neauto.\nconstructor.\neapply external_call_symbols_preserved.\napply senv_preserved.\nsimpl in B1; inv B1.\nsimpl in B2; inv B2.\neconstructor; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) (tm' : mem) (A : Mem.storebytes tm bdst (Ptrofs.unsigned odst) tbytes = Some tm') (B : magree m' tm' (nlive ge sp0 nm)) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) (tm' : mem) (A : Mem.storebytes tm bdst (Ptrofs.unsigned odst) tbytes = Some tm') (B : magree m' tm' (nlive ge sp0 nm)) : In pc'\n  (successors_instr (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = true) (asrc : aptr) (ne2 : nenv) (nm2 : nmem) (TR2 : transfer_builtin_arg All\n  (kill_builtin_res res ne, nmem_add (nmem_remove nm adst sz) asrc sz) dst =\n(ne2, nm2)) (ne1 : nenv) (nm1 : nmem) (TR1 : transfer_builtin_arg All (ne2, nm2) src = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tv1 : val) (A1 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  src tv1) (B1 : vagree (Vptr bsrc osrc) tv1 All) (C1 : eagree rs te ne2) (D1 : magree m tm (nlive ge sp0 nm2)) (tv2 : val) (A2 : eval_builtin_arg ge (fun r : positive => te # r) (Vptr sp0 Ptrofs.zero) tm\n  dst tv2) (B2 : vagree (Vptr bdst odst) tv2 All) (C2 : eagree rs te (kill_builtin_res res ne)) (D2 : magree m tm (nlive ge sp0 (nmem_add (nmem_remove nm adst sz) asrc sz))) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (tbytes : list memval) (P : Mem.loadbytes tm bsrc (Ptrofs.unsigned osrc) sz = Some tbytes) (Q : list_forall2 memval_lessdef bytes tbytes) (tm' : mem) (A : Mem.storebytes tm bdst (Ptrofs.unsigned odst) tbytes = Some tm') (B : magree m' tm' (nlive ge sp0 nm)) : eagree (regmap_setres res Vundef rs) (regmap_setres res Vundef te) ne.","proofString":"apply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (dst :: src :: nil) vargs) (H1 : extcall_memcpy_sem sz al ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc =\nSome\n  (if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz\n   then Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc'\n   else Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rewrite e1 in TI.\ninv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (dst :: src :: nil) vargs) (H1 : extcall_memcpy_sem sz al ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H0.\ninv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : extcall_memcpy_sem sz al ge (b1 :: bl) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  b1) (H6 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  (src :: nil) bl) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H6.\ninv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (b1 b0 : val) (bl0 : list val) (H1 : extcall_memcpy_sem sz al ge (b1 :: b0 :: bl0) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  b1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  b0) (H7 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  nil bl0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H7.\nrename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (b1 b0 : val) (H1 : extcall_memcpy_sem sz al ge (b1 :: b0 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  b1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  b0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rename b1 into v1.\nrename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (v1 b0 : val) (H1 : extcall_memcpy_sem sz al ge (v1 :: b0 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  b0) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rename b0 into v2.\nset (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (v1 v2 : val) (H1 : extcall_memcpy_sem sz al ge (v1 :: v2 :: nil) m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  v1) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  v2) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"set (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.\nset (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.\ninv H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\napply eagree_set_undef; auto.\neapply magree_storebytes_left; eauto.\nclear H3.\nexploit aaddr_arg_sound; eauto.\nintros (bc & A & B & C).\nintros.\neapply nlive_contains; eauto.\nerewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (asrc : aptr) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : In pc'\n  (successors_instr (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (asrc : aptr) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : eagree (regmap_setres res Vundef rs) te ne.","proofString":"destruct res; auto.\napply eagree_set_undef; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (x : reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) (BR x) pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H3 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m src\n  (Vptr bsrc osrc)) (asrc : aptr) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : eagree (regmap_setres (BR x) Vundef rs) te ne.","proofString":"apply eagree_set_undef; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (asrc : aptr) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (bc : block_classification) (A : pmatch bc bdst odst\n  (aaddr_arg (ValueAnalysis.analyze (romem_for cu) f) # pc dst)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) (i : Z) (H0 : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)) : Ptrofs.unsigned odst <= i < Ptrofs.unsigned odst + sz.","proofString":"erewrite Mem.loadbytes_length in H0 by eauto.\nrewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (asrc : aptr) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (bc : block_classification) (A : pmatch bc bdst odst\n  (aaddr_arg (ValueAnalysis.analyze (romem_for cu) f) # pc dst)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) (i : Z) (H0 : Ptrofs.unsigned odst <= i < Ptrofs.unsigned odst + Z.of_nat (Z.to_nat sz)) : Ptrofs.unsigned odst <= i < Ptrofs.unsigned odst + sz.","proofString":"rewrite Z2Nat.id in H0 by lia.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (m' : mem) (res : builtin_res reg) (sz al : Z) (dst src : builtin_arg reg) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (dst :: src :: nil) res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (adst : aptr) (e1 : nmem_contains nm adst sz = false) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) (bdst : block) (odst : ptrofs) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m dst\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (asrc : aptr) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (bc : block_classification) (A : pmatch bc bdst odst\n  (aaddr_arg (ValueAnalysis.analyze (romem_for cu) f) # pc dst)) (B : genv_match bc (Genv.globalenv prog)) (C : bc sp0 = BCstack) (i : Z) (H0 : Ptrofs.unsigned odst <= i < Ptrofs.unsigned odst + sz) : Ptrofs.unsigned odst <= i < Ptrofs.unsigned odst + sz.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (fst (transfer_builtin_args (kill_builtin_res res ne, nm) _x2))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nm) _x2)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_args (kill_builtin_res res ne, nm) _x2) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_list_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"InvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_list_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_list_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists vl' : list val,\n   eval_builtin_args ge (fun r : positive => te # r) \n     (Vptr sp0 Ptrofs.zero) tm _x2 vl' /\\\n   Val.lessdef_list vargs vl' /\\\n   eagree rs te (kill_builtin_res res ne) /\\ magree m tm (nlive ge sp0 nm)) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (tvl & A & B & C & D).\ninv H1.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_list_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H1.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_list_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (args : list eventval) (H2 : eventval_list_match ge args _x1 vargs) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 args :: E0) S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 args :: E0) S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_list_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (args : list eventval) (H2 : eventval_list_match ge args _x1 vargs) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (args : list eventval) (H2 : eventval_list_match ge args _x1 vargs) : eventval_list_match ge args _x1 tvl.","proofString":"eapply eventval_list_match_lessdef; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (args : list eventval) (H2 : eventval_list_match ge args _x1 vargs) : In pc' (successors_instr (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (args : list eventval) (H2 : eventval_list_match ge args _x1 vargs) : eagree (regmap_setres res Vundef rs) (regmap_setres res Vundef te) ne.","proofString":"apply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_val_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (fst (transfer_builtin_args (kill_builtin_res res ne, nm) _x2))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nm) _x2)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_args (kill_builtin_res res ne, nm) _x2) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\ninv B.\ninv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_val_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"InvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\ninv B.\ninv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_val_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\ninv H1.\ninv B.\ninv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_val_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists vl' : list val,\n   eval_builtin_args ge (fun r : positive => te # r) \n     (Vptr sp0 Ptrofs.zero) tm _x2 vl' /\\\n   Val.lessdef_list vargs vl' /\\\n   eagree rs te (kill_builtin_res res ne) /\\ magree m tm (nlive ge sp0 nm)) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (tvl & A & B & C & D).\ninv H1.\ninv B.\ninv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_annot_val_sem _x0 _x1 ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H1.\ninv B.\ninv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 (vres :: nil)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 tvl) (B : Val.lessdef_list (vres :: nil) tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (arg : eventval) (H2 : eventval_match ge arg _x1 vres) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 (arg :: nil) :: E0) S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 (arg :: nil) :: E0) S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv B.\ninv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 (vres :: nil)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (v2 : val) (vl2 : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 (v2 :: vl2)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (arg : eventval) (H2 : eventval_match ge arg _x1 vres) (H4 : Val.lessdef vres v2) (H6 : Val.lessdef_list nil vl2) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 (arg :: nil) :: E0) S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 (arg :: nil) :: E0) S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H6.\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 (vres :: nil)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (v2 : val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 (v2 :: nil)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (arg : eventval) (H2 : eventval_match ge arg _x1 vres) (H4 : Val.lessdef vres v2) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 (arg :: nil) :: E0) S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm)\n     (Event_annot _x0 (arg :: nil) :: E0) S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\nconstructor.\neapply eventval_match_lessdef; eauto 2 with na.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 (vres :: nil)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (v2 : val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 (v2 :: nil)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (arg : eventval) (H2 : eventval_match ge arg _x1 vres) (H4 : Val.lessdef vres v2) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 (vres :: nil)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (v2 : val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 (v2 :: nil)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (arg : eventval) (H2 : eventval_match ge arg _x1 vres) (H4 : Val.lessdef vres v2) : eventval_match ge arg _x1 v2.","proofString":"eapply eventval_match_lessdef; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 (vres :: nil)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (v2 : val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 (v2 :: nil)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (arg : eventval) (H2 : eventval_match ge arg _x1 vres) (H4 : Val.lessdef vres v2) : In pc' (successors_instr (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : string) (_x1 : typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 (vres :: nil)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) _x2 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m' tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_annot_val _x _x0 _x1) _x2 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m' sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' (romem_for cu)) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (v2 : val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 (v2 :: nil)) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m' tm (nlive ge sp0 nm)) (arg : eventval) (H2 : eventval_match ge arg _x1 vres) (H4 : Val.lessdef vres v2) : eagree (regmap_setres res vres rs) (regmap_setres res v2 te) ne.","proofString":"apply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : ident) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x2 vargs) (H1 : extcall_debug_sem ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (kill_builtin_res res ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H1.\nexploit can_eval_builtin_args; eauto.\nintros (vargs' & A).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\nconstructor.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : ident) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (kill_builtin_res res ne)) (MEM : magree m' tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit can_eval_builtin_args; eauto.\nintros (vargs' & A).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\nconstructor.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : ident) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (kill_builtin_res res ne)) (MEM : magree m' tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) (vargs' : list val) (A : eval_builtin_args tge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 vargs') : In pc' (successors_instr (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (vargs : list val) (m' : mem) (res : builtin_res reg) (_x : positive) (_x0 : ident) (_x1 : list typ) (_x2 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' _x2 vargs) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (kill_builtin_res res ne)) (MEM : magree m' tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_debug _x _x0 _x1) _x2 res pc')) (vargs' : list val) (A : eval_builtin_args tge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x2 vargs') : eagree (regmap_setres res Vundef rs) (regmap_setres res Vundef te) ne.","proofString":"apply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rewrite e1, e2 in TI.\nunfold builtin_or_external_sem in H1.\nrewrite e1 in H1.\ndestruct H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\nsimpl.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"unfold builtin_or_external_sem in H1.\nrewrite e1 in H1.\ndestruct H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\nsimpl.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rewrite e1 in H1.\ndestruct H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\nsimpl.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct H1.\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\nsimpl.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (vargs : list val) (m : mem) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (vres : val) (H1 : builtin_function_sem bf vargs = Some vres) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\ndestruct res; auto.\nsimpl.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (vargs : list val) (m : mem) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (vres : val) (H1 : builtin_function_sem bf vargs = Some vres) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : In pc' (successors_instr (Ibuiltin (EF_builtin name sg) args0 res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (vargs : list val) (m : mem) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (vres : val) (H1 : builtin_function_sem bf vargs = Some vres) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : eagree (regmap_setres res vres rs) te ne.","proofString":"destruct res; auto.\nsimpl.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (x : reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 (BR x) pc')) (sp0 : block) (vargs : list val) (m : mem) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (vres : val) (H1 : builtin_function_sem bf vargs = Some vres) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead (BR x) ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : eagree (regmap_setres (BR x) vres rs) te ne.","proofString":"simpl.\napply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (pc' : node) (x : reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 (BR x) pc')) (sp0 : block) (vargs : list val) (m : mem) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (vres : val) (H1 : builtin_function_sem bf vargs = Some vres) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead (BR x) ne = true) (ENV : eagree rs te ne) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Inop pc')) : eagree rs # x <- vres te ne.","proofString":"apply eagree_update_dead; auto with na."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nm) args0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nm) args0)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"rewrite e1, e2 in TI.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nm) args0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\nunfold builtin_or_external_sem in H1; rewrite e1 in H1.\nassert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nm) args0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nm) args0)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_args (kill_builtin_res res ne, nm) args0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\nunfold builtin_or_external_sem in H1; rewrite e1 in H1.\nassert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"InvSoundState.\nexploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\nunfold builtin_or_external_sem in H1; rewrite e1 in H1.\nassert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transfer_builtin_args_sound; eauto.\nintros (tvl & A & B & C & D).\nunfold builtin_or_external_sem in H1; rewrite e1 in H1.\nassert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists vl' : list val,\n   eval_builtin_args ge (fun r : positive => te # r) \n     (Vptr sp0 Ptrofs.zero) tm args0 vl' /\\\n   Val.lessdef_list vargs vl' /\\\n   eagree rs te (kill_builtin_res res ne) /\\ magree m tm (nlive ge sp0 nm)) ->\n(exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (tvl & A & B & C & D).\nunfold builtin_or_external_sem in H1; rewrite e1 in H1.\nassert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (bf : builtin_function) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm args0 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"unfold builtin_or_external_sem in H1; rewrite e1 in H1.\nassert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm args0 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert (m' = m) by (inv H1; auto).\nsubst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm args0 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) (H2 : m' = m) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"subst m'.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm args0 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit known_builtin_sem_lessdef; eauto.\nintros (vres' & P & Q).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\napply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\nsimpl; unfold builtin_or_external_sem; rewrite e1.\neauto.\neapply match_succ_states; eauto.\nsimpl; auto.\napply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm args0 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) (vres' : val) (P : known_builtin_sem bf tge tvl tm t vres' tm) (Q : Val.lessdef vres vres') : In pc' (successors_instr (Ibuiltin (EF_builtin name sg) args0 res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e1 : lookup_builtin_function name sg = Some bf) (e2 : builtin_res_dead res ne = false) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nm) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvl : list val) (A : eval_builtin_args ge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm args0 tvl) (B : Val.lessdef_list vargs tvl) (C : eagree rs te (kill_builtin_res res ne)) (D : magree m tm (nlive ge sp0 nm)) (vres' : val) (P : known_builtin_sem bf tge tvl tm t vres' tm) (Q : Val.lessdef vres vres') : eagree (regmap_setres res vres rs) (regmap_setres res vres' te) ne.","proofString":"apply eagree_set_res; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match lookup_builtin_function name sg with\n| Some _ => False\n| None => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert (external_call (EF_builtin name sg) ge vargs m t vres m') by auto.\nassert ((fn_code tf)!pc = Some(Ibuiltin (EF_builtin name sg) args0 res pc')).\ndestruct (Builtins.lookup_builtin_function name sg) eqn:BR; auto.\ncontradiction.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match lookup_builtin_function name sg with\n| Some _ => False\n| None => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) (H2 : external_call (EF_builtin name sg) ge vargs m t vres m') : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert ((fn_code tf)!pc = Some(Ibuiltin (EF_builtin name sg) args0 res pc')).\ndestruct (Builtins.lookup_builtin_function name sg) eqn:BR; auto.\ncontradiction.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match lookup_builtin_function name sg with\n| Some _ => False\n| None => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) (H2 : external_call (EF_builtin name sg) ge vargs m t vres m') : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc').","proofString":"destruct (Builtins.lookup_builtin_function name sg) eqn:BR; auto.\ncontradiction."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (b : builtin_function) (BR : lookup_builtin_function name sg = Some b) (y : False) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0)))) (TI : (fn_code tf) ! pc =\nSome\n  (if builtin_res_dead res ne\n   then Inop pc'\n   else Ibuiltin (EF_builtin name sg) args0 res pc')) (H2 : external_call (EF_builtin name sg) ge vargs m t vres m') : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc').","proofString":"contradiction."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match lookup_builtin_function name sg with\n| Some _ => False\n| None => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) (H2 : external_call (EF_builtin name sg) ge vargs m t vres m') (H3 : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match lookup_builtin_function name sg with\n| Some _ => False\n| None => True\nend) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) (H2 : external_call (EF_builtin name sg) ge vargs m t vres m') (H3 : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"InvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match lookup_builtin_function name sg with\n| Some _ => False\n| None => True\nend) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) (H2 : external_call (EF_builtin name sg) ge vargs m t vres m') (H3 : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (args0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args0 vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match lookup_builtin_function name sg with\n| Some _ => False\n| None => True\nend) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nmem_all) args0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) args0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) args0 res pc'\n  end) (H2 : external_call (EF_builtin name sg) ge vargs m t vres m') (H3 : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) args0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvargs : list val) (tvres : val) (tm' : mem) (A : eval_builtin_args tge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm args0 tvargs) (B : external_call (EF_builtin name sg) tge tvargs tm t tvres tm') (C : eagree (regmap_setres res vres rs) (regmap_setres res tvres te) ne) (D : magree m' tm' (nlive ge sp0 nm)) : In pc' (successors_instr (Ibuiltin (EF_builtin name sg) args0 res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : external_function) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin _x _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call _x ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match _x with\n| EF_vload _ => match _x0 with\n                | _ :: nil => False\n                | _ => True\n                end\n| EF_vstore _ | EF_memcpy _ _ =>\n    match _x0 with\n    | _ :: _ :: nil => False\n    | _ => True\n    end\n| EF_builtin _ _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ =>\n    False\n| _ => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0)))) (TI : (fn_code tf) ! pc =\nSome\n  match _x with\n  | EF_builtin name sg =>\n      match lookup_builtin_function name sg with\n      | Some _ =>\n          if builtin_res_dead res ne\n          then Inop pc'\n          else Ibuiltin _x _x0 res pc'\n      | None => Ibuiltin _x _x0 res pc'\n      end\n  | EF_memcpy sz _ =>\n      match _x0 with\n      | nil => Ibuiltin _x _x0 res pc'\n      | dst :: _ :: nil =>\n          if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz\n          then Ibuiltin _x _x0 res pc'\n          else Inop pc'\n      | dst :: nil | dst :: _ :: _ :: _ => Ibuiltin _x _x0 res pc'\n      end\n  | _ => Ibuiltin _x _x0 res pc'\n  end) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert ((fn_code tf)!pc = Some(Ibuiltin _x _x0 res pc')).\ndestruct _x; auto.\ninv y.\ndestruct _x0; auto.\ndestruct _x0; auto.\ndestruct _x0; auto.\ncontradiction.\nclear y TI.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : external_function) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin _x _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call _x ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match _x with\n| EF_vload _ => match _x0 with\n                | _ :: nil => False\n                | _ => True\n                end\n| EF_vstore _ | EF_memcpy _ _ =>\n    match _x0 with\n    | _ :: _ :: nil => False\n    | _ => True\n    end\n| EF_builtin _ _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ =>\n    False\n| _ => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0)))) (TI : (fn_code tf) ! pc =\nSome\n  match _x with\n  | EF_builtin name sg =>\n      match lookup_builtin_function name sg with\n      | Some _ =>\n          if builtin_res_dead res ne\n          then Inop pc'\n          else Ibuiltin _x _x0 res pc'\n      | None => Ibuiltin _x _x0 res pc'\n      end\n  | EF_memcpy sz _ =>\n      match _x0 with\n      | nil => Ibuiltin _x _x0 res pc'\n      | dst :: _ :: nil =>\n          if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz\n          then Ibuiltin _x _x0 res pc'\n          else Inop pc'\n      | dst :: nil | dst :: _ :: _ :: _ => Ibuiltin _x _x0 res pc'\n      end\n  | _ => Ibuiltin _x _x0 res pc'\n  end) : (fn_code tf) ! pc = Some (Ibuiltin _x _x0 res pc').","proofString":"destruct _x; auto.\ninv y.\ndestruct _x0; auto.\ndestruct _x0; auto.\ndestruct _x0; auto.\ncontradiction."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (name : string) (sg : signature) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : False) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0)))) (TI : (fn_code tf) ! pc =\nSome\n  match lookup_builtin_function name sg with\n  | Some _ =>\n      if builtin_res_dead res ne\n      then Inop pc'\n      else Ibuiltin (EF_builtin name sg) _x0 res pc'\n  | None => Ibuiltin (EF_builtin name sg) _x0 res pc'\n  end) : (fn_code tf) ! pc = Some (Ibuiltin (EF_builtin name sg) _x0 res pc').","proofString":"inv y."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call (EF_memcpy sz al) ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match _x0 with\n| _ :: _ :: nil => False\n| _ => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0)))) (TI : (fn_code tf) ! pc =\nSome\n  match _x0 with\n  | nil => Ibuiltin (EF_memcpy sz al) _x0 res pc'\n  | dst :: _ :: nil =>\n      if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz\n      then Ibuiltin (EF_memcpy sz al) _x0 res pc'\n      else Inop pc'\n  | dst :: nil | dst :: _ :: _ :: _ => Ibuiltin (EF_memcpy sz al) _x0 res pc'\n  end) : (fn_code tf) ! pc = Some (Ibuiltin (EF_memcpy sz al) _x0 res pc').","proofString":"destruct _x0; auto.\ndestruct _x0; auto.\ndestruct _x0; auto.\ncontradiction."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (b : builtin_arg reg) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) (b :: _x0) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (b :: _x0) vargs) (H1 : external_call (EF_memcpy sz al) ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match _x0 with\n| _ :: nil => False\n| _ => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) (b :: _x0)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_args (kill_builtin_res res ne, nmem_all) (b :: _x0))))) (TI : (fn_code tf) ! pc =\nSome\n  match _x0 with\n  | _ :: nil =>\n      if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc b) sz\n      then Ibuiltin (EF_memcpy sz al) (b :: _x0) res pc'\n      else Inop pc'\n  | _ => Ibuiltin (EF_memcpy sz al) (b :: _x0) res pc'\n  end) : (fn_code tf) ! pc = Some (Ibuiltin (EF_memcpy sz al) (b :: _x0) res pc').","proofString":"destruct _x0; auto.\ndestruct _x0; auto.\ncontradiction."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (b b0 : builtin_arg reg) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) (b :: b0 :: _x0) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (b :: b0 :: _x0) vargs) (H1 : external_call (EF_memcpy sz al) ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match _x0 with\n| nil => False\n| _ :: _ => True\nend) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_args (kill_builtin_res res ne, nmem_all)\n        (b :: b0 :: _x0)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_args (kill_builtin_res res ne, nmem_all)\n           (b :: b0 :: _x0))))) (TI : (fn_code tf) ! pc =\nSome\n  match _x0 with\n  | nil =>\n      if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc b) sz\n      then Ibuiltin (EF_memcpy sz al) (b :: b0 :: _x0) res pc'\n      else Inop pc'\n  | _ :: _ => Ibuiltin (EF_memcpy sz al) (b :: b0 :: _x0) res pc'\n  end) : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (b :: b0 :: _x0) res pc').","proofString":"destruct _x0; auto.\ncontradiction."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (sz al : Z) (b b0 : builtin_arg reg) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) (b :: b0 :: nil) res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m (b :: b0 :: nil) vargs) (H1 : external_call (EF_memcpy sz al) ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : False) (ENV : eagree rs te\n  (fst\n     (transfer_builtin_args (kill_builtin_res res ne, nmem_all)\n        (b :: b0 :: nil)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (transfer_builtin_args (kill_builtin_res res ne, nmem_all)\n           (b :: b0 :: nil))))) (TI : (fn_code tf) ! pc =\nSome\n  (if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc b) sz\n   then Ibuiltin (EF_memcpy sz al) (b :: b0 :: nil) res pc'\n   else Inop pc')) : (fn_code tf) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (b :: b0 :: nil) res pc').","proofString":"contradiction."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : external_function) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin _x _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call _x ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (y : match _x with\n| EF_vload _ => match _x0 with\n                | _ :: nil => False\n                | _ => True\n                end\n| EF_vstore _ | EF_memcpy _ _ =>\n    match _x0 with\n    | _ :: _ :: nil => False\n    | _ => True\n    end\n| EF_builtin _ _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ =>\n    False\n| _ => True\nend) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0)))) (TI : (fn_code tf) ! pc =\nSome\n  match _x with\n  | EF_builtin name sg =>\n      match lookup_builtin_function name sg with\n      | Some _ =>\n          if builtin_res_dead res ne\n          then Inop pc'\n          else Ibuiltin _x _x0 res pc'\n      | None => Ibuiltin _x _x0 res pc'\n      end\n  | EF_memcpy sz _ =>\n      match _x0 with\n      | nil => Ibuiltin _x _x0 res pc'\n      | dst :: _ :: nil =>\n          if nmem_contains nm (aaddr_arg (vanalyze cu f) # pc dst) sz\n          then Ibuiltin _x _x0 res pc'\n          else Inop pc'\n      | dst :: nil | dst :: _ :: _ :: _ => Ibuiltin _x _x0 res pc'\n      end\n  | _ => Ibuiltin _x _x0 res pc'\n  end) (H2 : (fn_code tf) ! pc = Some (Ibuiltin _x _x0 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"clear y TI.\ndestruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : external_function) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin _x _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call _x ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0)))) (H2 : (fn_code tf) ! pc = Some (Ibuiltin _x _x0 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0) as (ne1, nm1) eqn:TR.\nInvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : external_function) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin _x _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call _x ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (H2 : (fn_code tf) ! pc = Some (Ibuiltin _x _x0 res pc')) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"InvSoundState.\nexploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : external_function) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin _x _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call _x ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (H2 : (fn_code tf) ! pc = Some (Ibuiltin _x _x0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) t S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit transf_external_call; eauto.\nintros (tvargs & tvres & tm' & A & B & C & D).\nleft; econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (res : builtin_res reg) (_x : external_function) (_x0 : list (builtin_arg reg)) (H : (fn_code f) ! pc = Some (Ibuiltin _x _x0 res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m _x0 vargs) (H1 : external_call _x ge vargs m t vres m') (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : NE.t) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ne1 : nenv) (nm1 : nmem) (TR : transfer_builtin_args (kill_builtin_res res ne, nmem_all) _x0 = (ne1, nm1)) (ENV : eagree rs te (fst (ne1, nm1))) (MEM : magree m tm (nlive ge sp0 (snd (ne1, nm1)))) (H2 : (fn_code tf) ! pc = Some (Ibuiltin _x _x0 res pc')) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cu (Genv.globalenv prog) bc s m sp0) (AN : (ValueAnalysis.analyze (romem_for cu) f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m (romem_for cu)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp0 = BCstack) (tvargs : list val) (tvres : val) (tm' : mem) (A : eval_builtin_args tge (fun r : positive => te # r) \n  (Vptr sp0 Ptrofs.zero) tm _x0 tvargs) (B : external_call _x tge tvargs tm t tvres tm') (C : eagree (regmap_setres res vres rs) (regmap_setres res tvres te) ne) (D : magree m' tm' (nlive ge sp0 nm)) : In pc' (successors_instr (Ibuiltin _x _x0 res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te\n  (fst\n     (if peq ifso ifnot\n      then (ne, nm)\n      else (add_needs args (needs_of_condition cond) ne, nm)))) (MEM : magree m tm\n  (nlive ge sp0\n     (snd\n        (if peq ifso ifnot\n         then (ne, nm)\n         else (add_needs args (needs_of_condition cond) ne, nm))))) (TI : (fn_code tf) ! pc =\nSome (if peq ifso ifnot then Inop ifso else Icond cond args ifso ifnot)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct (peq ifso ifnot).\nreplace (if b then ifso else ifnot) with ifso by (destruct b; congruence).\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto.\nleft; econstructor; split.\neapply exec_Icond; eauto.\neapply needs_of_condition_sound.\neapply ma_perm; eauto.\neauto.\neauto with na.\neapply match_succ_states; eauto 2 with na.\nsimpl; destruct b; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e : ifso = ifnot) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop ifso)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"replace (if b then ifso else ifnot) with ifso by (destruct b; congruence).\nleft; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e : ifso = ifnot) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop ifso)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) ifso rs m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) ifso rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Inop; eauto.\neapply match_succ_states; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (e : ifso = ifnot) (ENV : eagree rs te (fst (ne, nm))) (MEM : magree m tm (nlive ge sp0 (snd (ne, nm)))) (TI : (fn_code tf) ! pc = Some (Inop ifso)) : In ifso (successors_instr (Icond cond args ifso ifnot)).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (n : ifso <> ifnot) (ENV : eagree rs te (fst (add_needs args (needs_of_condition cond) ne, nm))) (MEM : magree m tm\n  (nlive ge sp0 (snd (add_needs args (needs_of_condition cond) ne, nm)))) (TI : (fn_code tf) ! pc = Some (Icond cond args ifso ifnot)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2') \\/\n(exists (S2' : state) (n0 : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n0\n     (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Icond; eauto.\neapply needs_of_condition_sound.\neapply ma_perm; eauto.\neauto.\neauto with na.\neapply match_succ_states; eauto 2 with na.\nsimpl; destruct b; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (n : ifso <> ifnot) (ENV : eagree rs te (fst (add_needs args (needs_of_condition cond) ne, nm))) (MEM : magree m tm\n  (nlive ge sp0 (snd (add_needs args (needs_of_condition cond) ne, nm)))) (TI : (fn_code tf) ! pc = Some (Icond cond args ifso ifnot)) : In (if b then ifso else ifnot)\n  (successors_instr (Icond cond args ifso ifnot)).","proofString":"simpl; destruct b; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_need_all arg ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ijumptable arg tbl)) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(exists (S2' : state) (n0 : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n0 (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"assert (LD: Val.lessdef rs#arg te#arg) by eauto 2 with na.\nrewrite H0 in LD.\ninv LD.\nleft; econstructor; split.\neapply exec_Ijumptable; eauto.\neapply match_succ_states; eauto 2 with na.\nsimpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_need_all arg ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ijumptable arg tbl)) (LD : Val.lessdef rs # arg te # arg) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(exists (S2' : state) (n0 : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n0 (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"rewrite H0 in LD.\ninv LD.\nleft; econstructor; split.\neapply exec_Ijumptable; eauto.\neapply match_succ_states; eauto 2 with na.\nsimpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_need_all arg ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ijumptable arg tbl)) (LD : Val.lessdef (Vint n) te # arg) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(exists (S2' : state) (n0 : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n0 (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv LD.\nleft; econstructor; split.\neapply exec_Ijumptable; eauto.\neapply match_succ_states; eauto 2 with na.\nsimpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_need_all arg ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = te # arg) : (exists S2' : state,\n   step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2') \\/\n(exists (S2' : state) (n0 : nat),\n   plus step tge (State ts tf (Vptr sp0 Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n0 (State s f (Vptr sp0 Ptrofs.zero) pc' rs m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Ijumptable; eauto.\neapply match_succ_states; eauto 2 with na.\nsimpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_need_all arg ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = te # arg) : In pc' (successors_instr (Ijumptable arg tbl)).","proofString":"simpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (SS : sound_state prog (State s f (Vptr sp0 Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_need_all arg ne)) (MEM : magree m tm (nlive ge sp0 nm)) (TI : (fn_code tf) ! pc = Some (Ijumptable arg tbl)) (H4 : Vint n = te # arg) : In pc' tbl.","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_opt_need_all or ne)) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Ireturn or)) : (exists S2' : state,\n   step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (Returnstate s (regmap_optget or Vundef rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit magree_free.\neauto.\neauto.\ninstantiate (1 := nlive ge stk nmem_all).\nintros; eapply nlive_dead_stack; eauto.\nintros (tm' & A & B).\nleft; econstructor; split.\neapply exec_Ireturn; eauto.\nerewrite stacksize_translated by eauto.\neexact A.\nconstructor; auto.\ndestruct or; simpl; eauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_opt_need_all or ne)) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Ireturn or)) : forall (b' : block) (i : Z),\nnlive ge stk nmem_all b' i ->\nb' <> stk \\/ ~ 0 <= i < fn_stacksize f ->\nnlive ge stk (nmem_dead_stack (fn_stacksize f)) b' i.","proofString":"intros; eapply nlive_dead_stack; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_opt_need_all or ne)) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Ireturn or)) (tm' : mem) (A : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (B : magree m' tm' (nlive ge stk nmem_all)) : (exists S2' : state,\n   step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   match_states (Returnstate s (regmap_optget or Vundef rs) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc te tm) E0 S2' /\\\n   eventually n (Returnstate s (regmap_optget or Vundef rs) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neapply exec_Ireturn; eauto.\nerewrite stacksize_translated by eauto.\neexact A.\nconstructor; auto.\ndestruct or; simpl; eauto 2 with na.\neapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_opt_need_all or ne)) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Ireturn or)) (tm' : mem) (A : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (B : magree m' tm' (nlive ge stk nmem_all)) : Val.lessdef (regmap_optget or Vundef rs) (regmap_optget or Vundef te).","proofString":"destruct or; simpl; eauto 2 with na."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_opt_need_all or ne)) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Ireturn or)) (tm' : mem) (A : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (B : magree m' tm' (nlive ge stk nmem_all)) : Mem.extends m' tm'.","proofString":"eapply magree_extends; eauto.\napply nlive_all."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (SS : sound_state prog (State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (te : regset) (tm : mem) (cu : program) (an : PMap.t NA.t) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (ne : nenv) (nm : nmem) (ANPC : an # pc = (ne, nm)) (ENV : eagree rs te (add_opt_need_all or ne)) (MEM : magree m tm (nlive ge stk (nmem_dead_stack (fn_stacksize f)))) (TI : (fn_code tf) ! pc = Some (Ireturn or)) (tm' : mem) (A : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (B : magree m' tm' (nlive ge stk nmem_all)) : forall (b : block) (ofs : Z), nlive ge stk nmem_all b ofs.","proofString":"apply nlive_all."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (tf : fundef) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_fundef (prog_defmap cu) (romem_for cu) (Internal f) = OK tf) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) : (exists S2' : state,\n   step tge (Callstate ts tf targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts tf targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"monadInv FUN.\ngeneralize EQ.\nunfold transf_function.\nfold (vanalyze cu f).\nintros EQ'.\ndestruct analyze as [an|] eqn:AN; inv EQ'.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & A & B).\nleft; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (x : function) (EQ : transf_function (prog_defmap cu) (romem_for cu) f = OK x) : (exists S2' : state,\n   step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"generalize EQ.\nunfold transf_function.\nfold (vanalyze cu f).\nintros EQ'.\ndestruct analyze as [an|] eqn:AN; inv EQ'.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & A & B).\nleft; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (x : function) (EQ : transf_function (prog_defmap cu) (romem_for cu) f = OK x) : transf_function (prog_defmap cu) (romem_for cu) f = OK x ->\n(exists S2' : state,\n   step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"unfold transf_function.\nfold (vanalyze cu f).\nintros EQ'.\ndestruct analyze as [an|] eqn:AN; inv EQ'.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & A & B).\nleft; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (x : function) (EQ : transf_function (prog_defmap cu) (romem_for cu) f = OK x) : match\n  analyze f (prog_defmap cu) (ValueAnalysis.analyze (romem_for cu) f)\nwith\n| Some an =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code :=\n          PTree.map\n            (transf_instr (prog_defmap cu)\n               (ValueAnalysis.analyze (romem_for cu) f) an) \n            (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"Neededness analysis failed\")\nend = OK x ->\n(exists S2' : state,\n   step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"fold (vanalyze cu f).\nintros EQ'.\ndestruct analyze as [an|] eqn:AN; inv EQ'.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & A & B).\nleft; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (x : function) (EQ : transf_function (prog_defmap cu) (romem_for cu) f = OK x) : match analyze f (prog_defmap cu) (vanalyze cu f) with\n| Some an =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code :=\n          PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n            (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"Neededness analysis failed\")\nend = OK x ->\n(exists S2' : state,\n   step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros EQ'.\ndestruct analyze as [an|] eqn:AN; inv EQ'.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & A & B).\nleft; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (x : function) (EQ : transf_function (prog_defmap cu) (romem_for cu) f = OK x) (EQ' : match analyze f (prog_defmap cu) (vanalyze cu f) with\n| Some an =>\n    OK\n      {|\n        fn_sig := fn_sig f;\n        fn_params := fn_params f;\n        fn_stacksize := fn_stacksize f;\n        fn_code :=\n          PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n            (fn_code f);\n        fn_entrypoint := fn_entrypoint f\n      |}\n| None => Error (msg \"Neededness analysis failed\")\nend = OK x) : (exists S2' : state,\n   step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts (Internal x) targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"destruct analyze as [an|] eqn:AN; inv EQ'.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & A & B).\nleft; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (an : PMap.t NA.t) (EQ : transf_function (prog_defmap cu) (romem_for cu) f =\nOK\n  {|\n    fn_sig := fn_sig f;\n    fn_params := fn_params f;\n    fn_stacksize := fn_stacksize f;\n    fn_code :=\n      PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n        (fn_code f);\n    fn_entrypoint := fn_entrypoint f\n  |}) (AN : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) : (exists S2' : state,\n   step tge\n     (Callstate ts\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code :=\n               PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n                 (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge\n     (Callstate ts\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code :=\n               PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n                 (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (tm' & A & B).\nleft; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (an : PMap.t NA.t) (EQ : transf_function (prog_defmap cu) (romem_for cu) f =\nOK\n  {|\n    fn_sig := fn_sig f;\n    fn_params := fn_params f;\n    fn_stacksize := fn_stacksize f;\n    fn_code :=\n      PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n        (fn_code f);\n    fn_entrypoint := fn_entrypoint f\n  |}) (AN : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (tm' : Mem.mem') (A : Mem.alloc tm 0 (fn_stacksize f) = (tm', stk)) (B : Mem.extends m' tm') : (exists S2' : state,\n   step tge\n     (Callstate ts\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code :=\n               PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n                 (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) targs tm) E0 S2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge\n     (Callstate ts\n        (Internal\n           {|\n             fn_sig := fn_sig f;\n             fn_params := fn_params f;\n             fn_stacksize := fn_stacksize f;\n             fn_code :=\n               PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n                 (fn_code f);\n             fn_entrypoint := fn_entrypoint f\n           |}) targs tm) E0 S2' /\\\n   eventually n\n     (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n        (init_regs args (fn_params f)) m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neconstructor; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (an : PMap.t NA.t) (EQ : transf_function (prog_defmap cu) (romem_for cu) f =\nOK\n  {|\n    fn_sig := fn_sig f;\n    fn_params := fn_params f;\n    fn_stacksize := fn_stacksize f;\n    fn_code :=\n      PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n        (fn_code f);\n    fn_entrypoint := fn_entrypoint f\n  |}) (AN : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (tm' : Mem.mem') (A : Mem.alloc tm 0 (fn_stacksize f) = (tm', stk)) (B : Mem.extends m' tm') : match_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m')\n  (State ts\n     {|\n       fn_sig := fn_sig f;\n       fn_params := fn_params f;\n       fn_stacksize := fn_stacksize f;\n       fn_code :=\n         PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n           (fn_code f);\n       fn_entrypoint := fn_entrypoint f\n     |} (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs targs (fn_params f)) tm').","proofString":"econstructor; eauto.\napply eagree_init_regs; auto.\napply mextends_agree; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (an : PMap.t NA.t) (EQ : transf_function (prog_defmap cu) (romem_for cu) f =\nOK\n  {|\n    fn_sig := fn_sig f;\n    fn_params := fn_params f;\n    fn_stacksize := fn_stacksize f;\n    fn_code :=\n      PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n        (fn_code f);\n    fn_entrypoint := fn_entrypoint f\n  |}) (AN : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (tm' : Mem.mem') (A : Mem.alloc tm 0 (fn_stacksize f) = (tm', stk)) (B : Mem.extends m' tm') : eagree (init_regs args (fn_params f)) (init_regs targs (fn_params f))\n  (fst\n     (transfer f (prog_defmap cu) (vanalyze cu f) \n        (fn_entrypoint f) an # (fn_entrypoint f))).","proofString":"apply eagree_init_regs; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (SS : sound_state prog (Callstate s (Internal f) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (an : PMap.t NA.t) (EQ : transf_function (prog_defmap cu) (romem_for cu) f =\nOK\n  {|\n    fn_sig := fn_sig f;\n    fn_params := fn_params f;\n    fn_stacksize := fn_stacksize f;\n    fn_code :=\n      PTree.map (transf_instr (prog_defmap cu) (vanalyze cu f) an)\n        (fn_code f);\n    fn_entrypoint := fn_entrypoint f\n  |}) (AN : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (tm' : Mem.mem') (A : Mem.alloc tm 0 (fn_stacksize f) = (tm', stk)) (B : Mem.extends m' tm') : magree m' tm'\n  (nlive ge stk\n     (snd\n        (transfer f (prog_defmap cu) (vanalyze cu f) \n           (fn_entrypoint f) an # (fn_entrypoint f)))).","proofString":"apply mextends_agree; auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SS : sound_state prog (Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_fundef (prog_defmap cu) (romem_for cu) (External ef) = OK tf) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) : (exists S2' : state,\n   step tge (Callstate ts tf targs tm) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts tf targs tm) t S2' /\\\n   eventually n (Returnstate s res m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"exploit external_call_mem_extends; eauto.\nintros (res' & tm' & A & B & C & D).\nsimpl in FUN.\ninv FUN.\nleft; econstructor; split.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SS : sound_state prog (Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_fundef (prog_defmap cu) (romem_for cu) (External ef) = OK tf) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) : (exists (vres' : val) (m2' : mem),\n   external_call ef ge targs tm t vres' m2' /\\\n   Val.lessdef res vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) tm m2') ->\n(exists S2' : state,\n   step tge (Callstate ts tf targs tm) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts tf targs tm) t S2' /\\\n   eventually n (Returnstate s res m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"intros (res' & tm' & A & B & C & D).\nsimpl in FUN.\ninv FUN.\nleft; econstructor; split.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SS : sound_state prog (Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : transf_fundef (prog_defmap cu) (romem_for cu) (External ef) = OK tf) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (res' : val) (tm' : mem) (A : external_call ef ge targs tm t res' tm') (B : Val.lessdef res res') (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : (exists S2' : state,\n   step tge (Callstate ts tf targs tm) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts tf targs tm) t S2' /\\\n   eventually n (Returnstate s res m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"simpl in FUN.\ninv FUN.\nleft; econstructor; split.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SS : sound_state prog (Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (FUN : OK (External ef) = OK tf) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (res' : val) (tm' : mem) (A : external_call ef ge targs tm t res' tm') (B : Val.lessdef res res') (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : (exists S2' : state,\n   step tge (Callstate ts tf targs tm) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts tf targs tm) t S2' /\\\n   eventually n (Returnstate s res m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv FUN.\nleft; econstructor; split.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SS : sound_state prog (Callstate s (External ef) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (res' : val) (tm' : mem) (A : external_call ef ge targs tm t res' tm') (B : Val.lessdef res res') (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : (exists S2' : state,\n   step tge (Callstate ts (External ef) targs tm) t S2' /\\\n   match_states (Returnstate s res m') S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Callstate ts (External ef) targs tm) t S2' /\\\n   eventually n (Returnstate s res m')\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (SS : sound_state prog (Callstate s (External ef) args m)) (ts : list stackframe) (targs : list val) (tm : mem) (cu : program) (STACKS : list_forall2 match_stackframes s ts) (LINK : linkorder cu prog) (ARGS : Val.lessdef_list args targs) (MEM : Mem.extends m tm) (res' : val) (tm' : mem) (A : external_call ef ge targs tm t res' tm') (B : Val.lessdef res res') (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : Senv.equiv ge tge.","proofString":"apply senv_preserved."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (SS : sound_state prog (Returnstate (Stackframe res f sp pc rs :: s) vres m)) (ts : list stackframe) (tv : val) (tm : mem) (STACKS : list_forall2 match_stackframes (Stackframe res f sp pc rs :: s) ts) (RES : Val.lessdef vres tv) (MEM : Mem.extends m tm) : (exists S2' : state,\n   step tge (Returnstate ts tv tm) E0 S2' /\\\n   match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Returnstate ts tv tm) E0 S2' /\\\n   eventually n (State s f sp pc rs # res <- vres m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv STACKS.\ninv H1.\nleft; econstructor; split.\nconstructor.\neconstructor; eauto.\napply mextends_agree; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (SS : sound_state prog (Returnstate (Stackframe res f sp pc rs :: s) vres m)) (tv : val) (tm : mem) (RES : Val.lessdef vres tv) (MEM : Mem.extends m tm) (b1 : stackframe) (bl : list stackframe) (H1 : match_stackframes (Stackframe res f sp pc rs) b1) (H3 : list_forall2 match_stackframes s bl) : (exists S2' : state,\n   step tge (Returnstate (b1 :: bl) tv tm) E0 S2' /\\\n   match_states (State s f sp pc rs # res <- vres m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge (Returnstate (b1 :: bl) tv tm) E0 S2' /\\\n   eventually n (State s f sp pc rs # res <- vres m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"inv H1.\nleft; econstructor; split.\nconstructor.\neconstructor; eauto.\napply mextends_agree; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (sp0 : block) (SS : sound_state prog\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m)) (tv : val) (tm : mem) (RES : Val.lessdef vres tv) (MEM : Mem.extends m tm) (bl : list stackframe) (H3 : list_forall2 match_stackframes s bl) (tf : function) (te : Regmap.t val) (cu : program) (an : PMap.t NA.t) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (RES0 : forall v tv0 : val,\nVal.lessdef v tv0 ->\neagree rs # res <- v te # res <- tv0\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc an # pc))) : (exists S2' : state,\n   step tge\n     (Returnstate (Stackframe res tf (Vptr sp0 Ptrofs.zero) pc te :: bl) tv\n        tm) E0 S2' /\\\n   match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge\n     (Returnstate (Stackframe res tf (Vptr sp0 Ptrofs.zero) pc te :: bl) tv\n        tm) E0 S2' /\\\n   eventually n (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m)\n     (fun S3 : state => match_states S3 S2')).","proofString":"left; econstructor; split.\nconstructor.\neconstructor; eauto.\napply mextends_agree; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (sp0 : block) (SS : sound_state prog\n  (Returnstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc rs :: s) vres m)) (tv : val) (tm : mem) (RES : Val.lessdef vres tv) (MEM : Mem.extends m tm) (bl : list stackframe) (H3 : list_forall2 match_stackframes s bl) (tf : function) (te : Regmap.t val) (cu : program) (an : PMap.t NA.t) (LINK : linkorder cu prog) (FUN : transf_function (prog_defmap cu) (romem_for cu) f = OK tf) (ANL : analyze f (prog_defmap cu) (vanalyze cu f) = Some an) (RES0 : forall v tv0 : val,\nVal.lessdef v tv0 ->\neagree rs # res <- v te # res <- tv0\n  (fst (transfer f (prog_defmap cu) (vanalyze cu f) pc an # pc))) : magree m tm\n  (nlive ge sp0\n     (snd (transfer f (prog_defmap cu) (vanalyze cu f) pc an # pc))).","proofString":"apply mextends_agree; auto."},{"statement":"(st1 : state) (H : initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","proofString":"inversion H.\nexploit function_ptr_translated; eauto.\nintros (cu & tf & A & B & C).\nexists (Callstate nil tf nil m0); split.\neconstructor; eauto.\neapply (Genv.init_mem_match TRANSF); eauto.\nreplace (prog_main tprog) with (prog_main prog).\nrewrite symbols_preserved.\neauto.\nsymmetry; eapply match_program_main; eauto.\nrewrite <- H3.\neapply sig_function_translated; eauto.\neconstructor; eauto.\nconstructor.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : Genv.init_mem tprog = Some m0.","proofString":"eapply (Genv.init_mem_match TRANSF); eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : prog_main prog = prog_main tprog.","proofString":"symmetry; eapply match_program_main; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : funsig tf = signature_main.","proofString":"rewrite <- H3.\neapply sig_function_translated; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : funsig tf = funsig f.","proofString":"eapply sig_function_translated; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : match_states (Callstate nil f nil m0) (Callstate nil tf nil m0).","proofString":"econstructor; eauto.\nconstructor.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : list_forall2 match_stackframes nil nil.","proofString":"constructor."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef (prog_defmap cu) (romem_for cu) f = OK tf) (C : linkorder cu prog) : Mem.extends m0 m0.","proofString":"apply Mem.extends_refl."},{"statement":"(st1 st2 : state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r) : final_state st2 r.","proofString":"inv H0.\ninv H.\ninv STACKS.\ninv RES.\nconstructor."},{"statement":"(st2 : state) (r : int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) st2) : final_state st2 r.","proofString":"inv H.\ninv STACKS.\ninv RES.\nconstructor."},{"statement":"(r : int) (m : mem) (ts : list stackframe) (tv : val) (tm : mem) (STACKS : list_forall2 match_stackframes nil ts) (RES : Val.lessdef (Vint r) tv) (MEM : Mem.extends m tm) : final_state (Returnstate ts tv tm) r.","proofString":"inv STACKS.\ninv RES.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tm : mem) (RES : Val.lessdef (Vint r) tv) (MEM : Mem.extends m tm) : final_state (Returnstate nil tv tm) r.","proofString":"inv RES.\nconstructor."},{"statement":"(r : int) (m tm : mem) (MEM : Mem.extends m tm) : final_state (Returnstate nil (Vint r) tm) r.","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","proofString":"apply senv_preserved."},{"statement":"forall s1 : Smallstep.state (semantics prog),\nSmallstep.initial_state (semantics prog) s1 ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ sound_state prog s1.","proofString":"intros.\nexploit transf_initial_states; eauto.\nintros [s2 [A B]].\nexists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) : exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ sound_state prog s1.","proofString":"exploit transf_initial_states; eauto.\nintros [s2 [A B]].\nexists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) : (exists st2 : state, initial_state tprog st2 /\\ match_states s1 st2) ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ sound_state prog s1.","proofString":"intros [s2 [A B]].\nexists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) (s2 : state) (A : initial_state tprog s2) (B : match_states s1 s2) : exists s0 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s0 /\\\n  match_states s1 s0 /\\ sound_state prog s1.","proofString":"exists s2.\nauto using sound_initial."},{"statement":"(s1 : Smallstep.state (semantics prog)) (H : Smallstep.initial_state (semantics prog) s1) (s2 : state) (A : initial_state tprog s2) (B : match_states s1 s2) : Smallstep.initial_state (semantics tprog) s2 /\\\nmatch_states s1 s2 /\\ sound_state prog s1.","proofString":"auto using sound_initial."},{"statement":"forall (s1 : Smallstep.state (semantics prog))\n  (s2 : Smallstep.state (semantics tprog)) (r : int),\nmatch_states s1 s2 /\\ sound_state prog s1 ->\nSmallstep.final_state (semantics prog) s1 r ->\nSmallstep.final_state (semantics tprog) s2 r.","proofString":"intros.\ndestruct H.\neapply transf_final_states; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (s2 : Smallstep.state (semantics tprog)) (r : int) (H : match_states s1 s2 /\\ sound_state prog s1) (H0 : Smallstep.final_state (semantics prog) s1 r) : Smallstep.final_state (semantics tprog) s2 r.","proofString":"destruct H.\neapply transf_final_states; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (s2 : Smallstep.state (semantics tprog)) (r : int) (H : match_states s1 s2) (H1 : sound_state prog s1) (H0 : Smallstep.final_state (semantics prog) s1 r) : Smallstep.final_state (semantics tprog) s2 r.","proofString":"eapply transf_final_states; eauto."},{"statement":"forall (s1 : Smallstep.state (semantics prog)) (t : trace)\n  (s1' : Smallstep.state (semantics prog)),\nStep (semantics prog) s1 t s1' ->\nforall s2 : Smallstep.state (semantics tprog),\nmatch_states s1 s2 /\\ sound_state prog s1 ->\nexists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"intros.\ndestruct H0.\nexploit step_simulation; eauto.\nintros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2 /\\ sound_state prog s1) : exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"destruct H0.\nexploit step_simulation; eauto.\nintros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) : exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"exploit step_simulation; eauto.\nintros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) : (exists S2' : state, step tge s2 t S2' /\\ match_states s1' S2') \\/\n(exists (S2' : state) (n : nat),\n   plus step tge s2 t S2' /\\\n   eventually n s1' (fun S3 : state => match_states S3 S2')) ->\nexists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2' /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"intros [(s2' & A & B) | (s2' & n & A & B)].\nexists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step.\nexists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : exists (n : nat) (s2'0 : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2'0 /\\\n  Eventually (semantics prog) n s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2'0 /\\ sound_state prog s1'').","proofString":"exists 0%nat, s2'; split.\napply plus_one; auto.\napply eventually_now.\neauto using sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : Plus (semantics tprog) s2 t s2'.","proofString":"apply plus_one; auto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : Eventually (semantics prog) 0 s1'\n  (fun s1'' : Smallstep.state (semantics prog) =>\n   match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"apply eventually_now.\neauto using sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (A : step tge s2 t s2') (B : match_states s1' s2') : match_states s1' s2' /\\ sound_state prog s1'.","proofString":"eauto using sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun S3 : state => match_states S3 s2')) : exists (n0 : nat) (s2'0 : Smallstep.state (semantics tprog)),\n  Plus (semantics tprog) s2 t s2'0 /\\\n  Eventually (semantics prog) n0 s1'\n    (fun s1'' : Smallstep.state (semantics prog) =>\n     match_states s1'' s2'0 /\\ sound_state prog s1'').","proofString":"exists n, s2'; split; auto.\napply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun S3 : state => match_states S3 s2')) : Eventually (semantics prog) n s1'\n  (fun s1'' : Smallstep.state (semantics prog) =>\n   match_states s1'' s2' /\\ sound_state prog s1'').","proofString":"apply eventually_and_invariant; auto.\napply sound_step.\neapply sound_step; eauto."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun S3 : state => match_states S3 s2')) : forall (s : Smallstep.state (semantics prog)) (t0 : trace)\n  (s' : Smallstep.state (semantics prog)),\nStep (semantics prog) s t0 s' -> sound_state prog s -> sound_state prog s'.","proofString":"apply sound_step."},{"statement":"(s1 : Smallstep.state (semantics prog)) (t : trace) (s1' : Smallstep.state (semantics prog)) (H : Step (semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : match_states s1 s2) (H1 : sound_state prog s1) (s2' : state) (n : nat) (A : plus step tge s2 t s2') (B : eventually n s1' (fun S3 : state => match_states S3 s2')) : sound_state prog s1'.","proofString":"eapply sound_step; eauto."}]}