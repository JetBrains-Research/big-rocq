{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Calc/Round.v","fileSamples":[{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (He : (e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z) : cexp beta fexp x = fexp (Zdigits beta m + e).","conclusion":"cexp beta fexp x = fexp (Zdigits beta m + e)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (He : (e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z)","proofString":"unfold cexp.\napply inbetween_float_bounds in Bx.\nassert (0 <= m)%Z as Hm.\napply Zlt_succ_le.\neapply gt_0_F2R.\napply Rlt_trans with (1 := Px).\napply Bx.\ndestruct (Zle_lt_or_eq _ _ Hm) as [Hm'|<-].\nnow erewrite <- mag_F2R_bounds_Zdigits with (1 := Hm').\nclear Hm.\nassert (mag beta x <= e)%Z as Hx.\napply mag_le_bpow.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nnow rewrite <- F2R_bpow.\nnow apply Rlt_le.\nsimpl in He |- *.\nclear Bx.\ndestruct He as [He|He].\napply eq_sym, valid_exp with (2 := He).\nnow apply Z.le_trans with e.\napply valid_exp with (1 := He).\nnow apply Z.le_trans with e."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (He : (e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z) : fexp (mag beta x) = fexp (Zdigits beta m + e).","conclusion":"fexp (mag beta x) = fexp (Zdigits beta m + e)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (He : (e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z)","proofString":"apply inbetween_float_bounds in Bx.\nassert (0 <= m)%Z as Hm.\napply Zlt_succ_le.\neapply gt_0_F2R.\napply Rlt_trans with (1 := Px).\napply Bx.\ndestruct (Zle_lt_or_eq _ _ Hm) as [Hm'|<-].\nnow erewrite <- mag_F2R_bounds_Zdigits with (1 := Hm').\nclear Hm.\nassert (mag beta x <= e)%Z as Hx.\napply mag_le_bpow.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nnow rewrite <- F2R_bpow.\nnow apply Rlt_le.\nsimpl in He |- *.\nclear Bx.\ndestruct He as [He|He].\napply eq_sym, valid_exp with (2 := He).\nnow apply Z.le_trans with e.\napply valid_exp with (1 := He).\nnow apply Z.le_trans with e."},{"statement":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= cexp beta fexp x)%Z \\/ (e <= fexp e)%Z) (Hx : (mag beta x <= e)%Z) : fexp (mag beta x) = fexp e.","conclusion":"fexp (mag beta x) = fexp e","hypotheses":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= cexp beta fexp x)%Z \\/ (e <= fexp e)%Z) (Hx : (mag beta x <= e)%Z)","proofString":"destruct He as [He|He].\napply eq_sym, valid_exp with (2 := He).\nnow apply Z.le_trans with e.\napply valid_exp with (1 := He).\nnow apply Z.le_trans with e."},{"statement":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= cexp beta fexp x)%Z) (Hx : (mag beta x <= e)%Z) : fexp (mag beta x) = fexp e.","conclusion":"fexp (mag beta x) = fexp e","hypotheses":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= cexp beta fexp x)%Z) (Hx : (mag beta x <= e)%Z)","proofString":"apply eq_sym, valid_exp with (2 := He).\nnow apply Z.le_trans with e."},{"statement":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= cexp beta fexp x)%Z) (Hx : (mag beta x <= e)%Z) : (mag beta x <= fexp (mag beta x))%Z.","conclusion":"(mag beta x <= fexp (mag beta x))%Z","hypotheses":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= cexp beta fexp x)%Z) (Hx : (mag beta x <= e)%Z)","proofString":"now apply Z.le_trans with e."},{"statement":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= fexp e)%Z) (Hx : (mag beta x <= e)%Z) : fexp (mag beta x) = fexp e.","conclusion":"fexp (mag beta x) = fexp e","hypotheses":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= fexp e)%Z) (Hx : (mag beta x <= e)%Z)","proofString":"apply valid_exp with (1 := He).\nnow apply Z.le_trans with e."},{"statement":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= fexp e)%Z) (Hx : (mag beta x <= e)%Z) : (mag beta x <= fexp e)%Z.","conclusion":"(mag beta x <= fexp e)%Z","hypotheses":"(x : R) (e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (He : (e <= fexp e)%Z) (Hx : (mag beta x <= e)%Z)","proofString":"now apply Z.le_trans with e."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 <= x)%R) (Bx : inbetween_float beta m e x l) : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 <= x)%R) (Bx : inbetween_float beta m e x l)","proofString":"destruct Px as [Px|Px].\nsplit ; (intros [H|H] ; [left|now right]).\nrewrite <- cexp_inbetween_float with (1 := Px) (2 := Bx).\nexact H.\nnow left.\nrewrite cexp_inbetween_float with (1 := Px) (2 := Bx).\nexact H.\nnow right.\nassert (H := Bx).\ndestruct Bx as [|c Bx _].\nnow split ; right.\nrewrite <- Px in Bx.\ndestruct Bx as [Bx1 Bx2].\napply lt_0_F2R in Bx1.\napply gt_0_F2R in Bx2.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l)","proofString":"split ; (intros [H|H] ; [left|now right]).\nrewrite <- cexp_inbetween_float with (1 := Px) (2 := Bx).\nexact H.\nnow left.\nrewrite cexp_inbetween_float with (1 := Px) (2 := Bx).\nexact H.\nnow right."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= cexp beta fexp x)%Z) : (e <= fexp (Zdigits beta m + e))%Z.","conclusion":"(e <= fexp (Zdigits beta m + e))%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= cexp beta fexp x)%Z)","proofString":"rewrite <- cexp_inbetween_float with (1 := Px) (2 := Bx).\nexact H.\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= cexp beta fexp x)%Z) : (e <= cexp beta fexp x)%Z.","conclusion":"(e <= cexp beta fexp x)%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= cexp beta fexp x)%Z)","proofString":"exact H."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= cexp beta fexp x)%Z) : (e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z.","conclusion":"(e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= cexp beta fexp x)%Z)","proofString":"now left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= fexp (Zdigits beta m + e))%Z) : (e <= cexp beta fexp x)%Z.","conclusion":"(e <= cexp beta fexp x)%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"rewrite cexp_inbetween_float with (1 := Px) (2 := Bx).\nexact H.\nnow right."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= fexp (Zdigits beta m + e))%Z) : (e <= fexp (Zdigits beta m + e))%Z.","conclusion":"(e <= fexp (Zdigits beta m + e))%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"exact H."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= fexp (Zdigits beta m + e))%Z) : (e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z.","conclusion":"(e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : (0 < x)%R) (Bx : inbetween_float beta m e x l) (H : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"now right."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : 0%R = x) (Bx : inbetween_float beta m e x l) : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : 0%R = x) (Bx : inbetween_float beta m e x l)","proofString":"assert (H := Bx).\ndestruct Bx as [|c Bx _].\nnow split ; right.\nrewrite <- Px in Bx.\ndestruct Bx as [Bx1 Bx2].\napply lt_0_F2R in Bx1.\napply gt_0_F2R in Bx2.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : 0%R = x) (Bx H : inbetween_float beta m e x l) : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Px : 0%R = x) (Bx H : inbetween_float beta m e x l)","proofString":"destruct Bx as [|c Bx _].\nnow split ; right.\nrewrite <- Px in Bx.\ndestruct Bx as [Bx1 Bx2].\napply lt_0_F2R in Bx1.\napply gt_0_F2R in Bx2.\nlia."},{"statement":"(x : R) (m e : Z) (Px : 0%R = x) (c : comparison) (Bx1 : (m < 0)%Z) (Bx2 : (0 < m + 1)%Z) (H : inbetween_float beta m e x (SpecFloat.loc_Inexact c)) : (e <= cexp beta fexp x)%Z \\/ SpecFloat.loc_Inexact c = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/\nSpecFloat.loc_Inexact c = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp x)%Z \\/ SpecFloat.loc_Inexact c = SpecFloat.loc_Exact <->\n(e <= fexp (Zdigits beta m + e))%Z \\/\nSpecFloat.loc_Inexact c = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (Px : 0%R = x) (c : comparison) (Bx1 : (m < 0)%Z) (Bx2 : (0 < m + 1)%Z) (H : inbetween_float beta m e x (SpecFloat.loc_Inexact c))","proofString":"lia."},{"statement":"(rnd : R -> Z) (choice : Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 x0 l0 -> rnd x0 = choice m0 l0) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hl : inbetween_float beta m e x l) : (0 < bpow e)%R.","conclusion":"(0 < bpow e)%R","hypotheses":"(rnd : R -> Z) (choice : Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 x0 l0 -> rnd x0 = choice m0 l0) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hl : inbetween_float beta m e x l)","proofString":"apply bpow_gt_0."},{"statement":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) : (0 < bpow e)%R.","conclusion":"(0 < bpow e)%R","hypotheses":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l)","proofString":"apply bpow_gt_0."},{"statement":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) : (bpow e >= 0)%R.","conclusion":"(bpow e >= 0)%R","hypotheses":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l)","proofString":"apply Rle_ge.\napply bpow_ge_0."},{"statement":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) : (0 <= bpow e)%R.","conclusion":"(0 <= bpow e)%R","hypotheses":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l)","proofString":"apply bpow_ge_0."},{"statement":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (x < 0)%R) : (0 < bpow (- e))%R.","conclusion":"(0 < bpow (- e))%R","hypotheses":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (x < 0)%R)","proofString":"apply bpow_gt_0."},{"statement":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (0 <= x)%R) : Rlt_bool (scaled_mantissa beta fexp x) 0 = false.","conclusion":"Rlt_bool (scaled_mantissa beta fexp x) 0 = false","hypotheses":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"apply Rlt_bool_false.\napply Rmult_le_pos with (1 := Zx).\napply bpow_ge_0."},{"statement":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (0 <= x)%R) : (0 <= scaled_mantissa beta fexp x)%R.","conclusion":"(0 <= scaled_mantissa beta fexp x)%R","hypotheses":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"apply Rmult_le_pos with (1 := Zx).\napply bpow_ge_0."},{"statement":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (0 <= x)%R) : (0 <= bpow (- cexp beta fexp x))%R.","conclusion":"(0 <= bpow (- cexp beta fexp x))%R","hypotheses":"(rnd : R -> Z) (choice : bool -> Z -> SpecFloat.location -> Z) (Hc : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)) (x : R) (m : Z) (l : SpecFloat.location) (e : Z) (Hx : inbetween_float beta m e (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : Zfloor x = m.","conclusion":"Zfloor x = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"refine (Zfloor_imp m _ _).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : (IZR m <= x < IZR (m + 1))%R.","conclusion":"(IZR m <= x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"apply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : (IZR m < IZR (m + 1))%R.","conclusion":"(IZR m < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"apply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : (m < m + 1)%Z.","conclusion":"(m < m + 1)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"apply Zlt_succ."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> Zfloor x = m.","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> Zfloor x = m","hypotheses":"","proofString":"exact inbetween_int_DN."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) : Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m).","conclusion":"Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l)","proofString":"unfold Rabs in Hl.\ndestruct (Rcase_abs x) as [Zx|Zx] .\nrewrite Rlt_bool_true with (1 := Zx).\ninversion_clear Hl ; simpl.\nrewrite <- (Ropp_involutive x).\nrewrite H, <- opp_IZR.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\napply Rlt_le.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nring_simplify (- (m + 1) + 1)%Z.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nrewrite Rlt_bool_false.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H.\nnow apply Rge_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (if Rcase_abs x then (- x)%R else x) l) : Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m).","conclusion":"Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (if Rcase_abs x then (- x)%R else x) l)","proofString":"destruct (Rcase_abs x) as [Zx|Zx] .\nrewrite Rlt_bool_true with (1 := Zx).\ninversion_clear Hl ; simpl.\nrewrite <- (Ropp_involutive x).\nrewrite H, <- opp_IZR.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\napply Rlt_le.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nring_simplify (- (m + 1) + 1)%Z.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nrewrite Rlt_bool_false.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H.\nnow apply Rge_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l) : Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m).","conclusion":"Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l)","proofString":"rewrite Rlt_bool_true with (1 := Zx).\ninversion_clear Hl ; simpl.\nrewrite <- (Ropp_involutive x).\nrewrite H, <- opp_IZR.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\napply Rlt_le.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nring_simplify (- (m + 1) + 1)%Z.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l) : Zfloor x = SpecFloat.cond_Zopp true (cond_incr (round_sign_DN true l) m).","conclusion":"Zfloor x = SpecFloat.cond_Zopp true (cond_incr (round_sign_DN true l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l)","proofString":"inversion_clear Hl ; simpl.\nrewrite <- (Ropp_involutive x).\nrewrite H, <- opp_IZR.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\napply Rlt_le.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nring_simplify (- (m + 1) + 1)%Z.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m) : Zfloor x = (- m)%Z.","conclusion":"Zfloor x = (- m)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m)","proofString":"rewrite <- (Ropp_involutive x).\nrewrite H, <- opp_IZR.\napply Zfloor_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m) : Zfloor (- - x) = (- m)%Z.","conclusion":"Zfloor (- - x) = (- m)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m)","proofString":"rewrite H, <- opp_IZR.\napply Zfloor_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m) : Zfloor (IZR (- m)) = (- m)%Z.","conclusion":"Zfloor (IZR (- m)) = (- m)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m)","proofString":"apply Zfloor_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : Zfloor x = (- (m + 1))%Z.","conclusion":"Zfloor x = (- (m + 1))%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply Zfloor_imp.\nsplit.\napply Rlt_le.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nring_simplify (- (m + 1) + 1)%Z.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR (- (m + 1)) <= x < IZR (- (m + 1) + 1))%R.","conclusion":"(IZR (- (m + 1)) <= x < IZR (- (m + 1) + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"split.\napply Rlt_le.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nring_simplify (- (m + 1) + 1)%Z.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR (- (m + 1)) <= x)%R.","conclusion":"(IZR (- (m + 1)) <= x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply Rlt_le.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR (- (m + 1)) < x)%R.","conclusion":"(IZR (- (m + 1)) < x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"rewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (- IZR (m + 1) < x)%R.","conclusion":"(- IZR (m + 1) < x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (- x < - - IZR (m + 1))%R.","conclusion":"(- x < - - IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (x < IZR (- (m + 1) + 1))%R.","conclusion":"(x < IZR (- (m + 1) + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"ring_simplify (- (m + 1) + 1)%Z.\nrewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (x < IZR (- m))%R.","conclusion":"(x < IZR (- m))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"rewrite opp_IZR.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (x < - IZR m)%R.","conclusion":"(x < - IZR m)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (- - IZR m < - x)%R.","conclusion":"(- - IZR m < - x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l) : Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m).","conclusion":"Zfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l)","proofString":"rewrite Rlt_bool_false.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H.\nnow apply Rge_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l) : Zfloor x = SpecFloat.cond_Zopp false (cond_incr (round_sign_DN false l) m).","conclusion":"Zfloor x = SpecFloat.cond_Zopp false (cond_incr (round_sign_DN false l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l)","proofString":"inversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m) : Zfloor x = m.","conclusion":"Zfloor x = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m)","proofString":"rewrite H.\napply Zfloor_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m) : Zfloor (IZR m) = m.","conclusion":"Zfloor (IZR m) = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m)","proofString":"apply Zfloor_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : Zfloor x = m.","conclusion":"Zfloor x = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR m <= x < IZR (m + 1))%R.","conclusion":"(IZR m <= x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"split.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR m <= x)%R.","conclusion":"(IZR m <= x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"now apply Rlt_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : (x < IZR (m + 1))%R.","conclusion":"(x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l)","proofString":"now apply Rge_le."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m).","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZfloor x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_DN (Rlt_bool x 0) l) m)","hypotheses":"","proofString":"exact inbetween_int_DN_sign."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : Zceil x = cond_incr (round_UP l) m.","conclusion":"Zceil x = cond_incr (round_UP l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"assert (Hl': l = loc_Exact \\/ (l <> loc_Exact /\\ round_UP l = true)).\ncase l ; try (now left) ; now right ; split.\ndestruct Hl' as [Hl'|(Hl1, Hl2)].\nrewrite Hl'.\ndestruct Hl ; try easy.\nrewrite H.\nexact (Zceil_IZR _).\nrewrite Hl2.\nsimpl.\napply Zceil_imp.\nring_simplify (m + 1 - 1)%Z.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\napply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : l = SpecFloat.loc_Exact \\/ l <> SpecFloat.loc_Exact /\\ round_UP l = true.","conclusion":"l = SpecFloat.loc_Exact \\/ l <> SpecFloat.loc_Exact /\\ round_UP l = true","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"case l ; try (now left) ; now right ; split."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl' : l = SpecFloat.loc_Exact \\/ l <> SpecFloat.loc_Exact /\\ round_UP l = true) : Zceil x = cond_incr (round_UP l) m.","conclusion":"Zceil x = cond_incr (round_UP l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl' : l = SpecFloat.loc_Exact \\/ l <> SpecFloat.loc_Exact /\\ round_UP l = true)","proofString":"destruct Hl' as [Hl'|(Hl1, Hl2)].\nrewrite Hl'.\ndestruct Hl ; try easy.\nrewrite H.\nexact (Zceil_IZR _).\nrewrite Hl2.\nsimpl.\napply Zceil_imp.\nring_simplify (m + 1 - 1)%Z.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\napply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl' : l = SpecFloat.loc_Exact) : Zceil x = cond_incr (round_UP l) m.","conclusion":"Zceil x = cond_incr (round_UP l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl' : l = SpecFloat.loc_Exact)","proofString":"rewrite Hl'.\ndestruct Hl ; try easy.\nrewrite H.\nexact (Zceil_IZR _)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl' : l = SpecFloat.loc_Exact) : Zceil x = cond_incr (round_UP SpecFloat.loc_Exact) m.","conclusion":"Zceil x = cond_incr (round_UP SpecFloat.loc_Exact) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl' : l = SpecFloat.loc_Exact)","proofString":"destruct Hl ; try easy.\nrewrite H.\nexact (Zceil_IZR _)."},{"statement":"(x : R) (m : Z) (H : x = IZR m) (Hl' : SpecFloat.loc_Exact = SpecFloat.loc_Exact) : Zceil x = cond_incr (round_UP SpecFloat.loc_Exact) m.","conclusion":"Zceil x = cond_incr (round_UP SpecFloat.loc_Exact) m","hypotheses":"(x : R) (m : Z) (H : x = IZR m) (Hl' : SpecFloat.loc_Exact = SpecFloat.loc_Exact)","proofString":"rewrite H.\nexact (Zceil_IZR _)."},{"statement":"(x : R) (m : Z) (H : x = IZR m) (Hl' : SpecFloat.loc_Exact = SpecFloat.loc_Exact) : Zceil (IZR m) = cond_incr (round_UP SpecFloat.loc_Exact) m.","conclusion":"Zceil (IZR m) = cond_incr (round_UP SpecFloat.loc_Exact) m","hypotheses":"(x : R) (m : Z) (H : x = IZR m) (Hl' : SpecFloat.loc_Exact = SpecFloat.loc_Exact)","proofString":"exact (Zceil_IZR _)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true) : Zceil x = cond_incr (round_UP l) m.","conclusion":"Zceil x = cond_incr (round_UP l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true)","proofString":"rewrite Hl2.\nsimpl.\napply Zceil_imp.\nring_simplify (m + 1 - 1)%Z.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\napply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true) : Zceil x = cond_incr true m.","conclusion":"Zceil x = cond_incr true m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true)","proofString":"simpl.\napply Zceil_imp.\nring_simplify (m + 1 - 1)%Z.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\napply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true) : Zceil x = (m + 1)%Z.","conclusion":"Zceil x = (m + 1)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true)","proofString":"apply Zceil_imp.\nring_simplify (m + 1 - 1)%Z.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\napply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true) : (IZR (m + 1 - 1) < x <= IZR (m + 1))%R.","conclusion":"(IZR (m + 1 - 1) < x <= IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true)","proofString":"ring_simplify (m + 1 - 1)%Z.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\napply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true) : (IZR m < x <= IZR (m + 1))%R.","conclusion":"(IZR m < x <= IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true)","proofString":"refine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\napply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true) : (IZR m < x < IZR (m + 1))%R.","conclusion":"(IZR m < x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) (Hl1 : l <> SpecFloat.loc_Exact) (Hl2 : round_UP l = true)","proofString":"apply inbetween_bounds_not_Eq with (2 := Hl1) (1 := Hl)."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> Zceil x = cond_incr (round_UP l) m.","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> Zceil x = cond_incr (round_UP l) m","hypotheses":"","proofString":"exact inbetween_int_UP."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) : Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m).","conclusion":"Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l)","proofString":"unfold Rabs in Hl.\ndestruct (Rcase_abs x) as [Zx|Zx] .\nrewrite Rlt_bool_true with (1 := Zx).\nsimpl.\nunfold Zceil.\napply f_equal.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H.\nrewrite Rlt_bool_false.\nsimpl.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zceil_IZR.\napply Zceil_imp.\nsplit.\nchange (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ.\nnow apply Rlt_le.\nnow apply Rge_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (if Rcase_abs x then (- x)%R else x) l) : Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m).","conclusion":"Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (if Rcase_abs x then (- x)%R else x) l)","proofString":"destruct (Rcase_abs x) as [Zx|Zx] .\nrewrite Rlt_bool_true with (1 := Zx).\nsimpl.\nunfold Zceil.\napply f_equal.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H.\nrewrite Rlt_bool_false.\nsimpl.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zceil_IZR.\napply Zceil_imp.\nsplit.\nchange (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ.\nnow apply Rlt_le.\nnow apply Rge_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l) : Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m).","conclusion":"Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l)","proofString":"rewrite Rlt_bool_true with (1 := Zx).\nsimpl.\nunfold Zceil.\napply f_equal.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l) : Zceil x = SpecFloat.cond_Zopp true (cond_incr (round_sign_UP true l) m).","conclusion":"Zceil x = SpecFloat.cond_Zopp true (cond_incr (round_sign_UP true l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l)","proofString":"simpl.\nunfold Zceil.\napply f_equal.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l) : Zceil x = (- cond_incr (round_sign_UP true l) m)%Z.","conclusion":"Zceil x = (- cond_incr (round_sign_UP true l) m)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l)","proofString":"unfold Zceil.\napply f_equal.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l) : (- Zfloor (- x))%Z = (- cond_incr (round_sign_UP true l) m)%Z.","conclusion":"(- Zfloor (- x))%Z = (- cond_incr (round_sign_UP true l) m)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l)","proofString":"apply f_equal.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l) : Zfloor (- x) = cond_incr (round_sign_UP true l) m.","conclusion":"Zfloor (- x) = cond_incr (round_sign_UP true l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (Hl : inbetween_int m (- x) l)","proofString":"inversion_clear Hl ; simpl.\nrewrite H.\napply Zfloor_IZR.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m) : Zfloor (- x) = m.","conclusion":"Zfloor (- x) = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m)","proofString":"rewrite H.\napply Zfloor_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m) : Zfloor (IZR m) = m.","conclusion":"Zfloor (IZR m) = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (H : (- x)%R = IZR m)","proofString":"apply Zfloor_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : Zfloor (- x) = m.","conclusion":"Zfloor (- x) = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR m <= - x < IZR (m + 1))%R.","conclusion":"(IZR m <= - x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"split.\nnow apply Rlt_le.\napply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR m <= - x)%R.","conclusion":"(IZR m <= - x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"now apply Rlt_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0) : (- x < IZR (m + 1))%R.","conclusion":"(- x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l0 : comparison) (H : (IZR m < - x < IZR (m + 1))%R) (H0 : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply H."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l) : Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m).","conclusion":"Zceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l)","proofString":"rewrite Rlt_bool_false.\nsimpl.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zceil_IZR.\napply Zceil_imp.\nsplit.\nchange (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ.\nnow apply Rlt_le.\nnow apply Rge_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l) : Zceil x = SpecFloat.cond_Zopp false (cond_incr (round_sign_UP false l) m).","conclusion":"Zceil x = SpecFloat.cond_Zopp false (cond_incr (round_sign_UP false l) m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l)","proofString":"simpl.\ninversion_clear Hl ; simpl.\nrewrite H.\napply Zceil_IZR.\napply Zceil_imp.\nsplit.\nchange (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ.\nnow apply Rlt_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l) : Zceil x = cond_incr (round_sign_UP false l) m.","conclusion":"Zceil x = cond_incr (round_sign_UP false l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l)","proofString":"inversion_clear Hl ; simpl.\nrewrite H.\napply Zceil_IZR.\napply Zceil_imp.\nsplit.\nchange (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ.\nnow apply Rlt_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m) : Zceil x = m.","conclusion":"Zceil x = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m)","proofString":"rewrite H.\napply Zceil_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m) : Zceil (IZR m) = m.","conclusion":"Zceil (IZR m) = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (H : x = IZR m)","proofString":"apply Zceil_IZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : Zceil x = (m + 1)%Z.","conclusion":"Zceil x = (m + 1)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"apply Zceil_imp.\nsplit.\nchange (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ.\nnow apply Rlt_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR (m + 1 - 1) < x <= IZR (m + 1))%R.","conclusion":"(IZR (m + 1 - 1) < x <= IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"split.\nchange (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ.\nnow apply Rlt_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR (m + 1 - 1) < x)%R.","conclusion":"(IZR (m + 1 - 1) < x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"change (m + 1 - 1)%Z with (Z.pred (Z.succ m)).\nnow rewrite <- Zpred_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : (IZR (Z.pred (Z.succ m)) < x)%R.","conclusion":"(IZR (Z.pred (Z.succ m)) < x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"now rewrite <- Zpred_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0) : (x <= IZR (m + 1))%R.","conclusion":"(x <= IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (l0 : comparison) (H : (IZR m < x < IZR (m + 1))%R) (H0 : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l0)","proofString":"now apply Rlt_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Zx : (x >= 0)%R) (Hl : inbetween_int m x l)","proofString":"now apply Rge_le."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m).","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZceil x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_sign_UP (Rlt_bool x 0) l) m)","hypotheses":"","proofString":"exact inbetween_int_UP_sign."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : Ztrunc x = cond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m.","conclusion":"Ztrunc x = cond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"unfold Ztrunc.\nassert (Hm: Zfloor x = m).\napply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx)).\nrewrite Zceil_floor_neq.\nrewrite Hm.\nunfold cond_incr.\nsimpl.\ncase Rlt_bool_spec ; intros Hx' ;  case Zlt_bool_spec ; intros Hm' ; try apply refl_equal.\nelim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le.\nelim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : (if Rlt_bool x 0 then Zceil x else Zfloor x) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m.","conclusion":"(if Rlt_bool x 0 then Zceil x else Zfloor x) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"assert (Hm: Zfloor x = m).\napply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx)).\nrewrite Zceil_floor_neq.\nrewrite Hm.\nunfold cond_incr.\nsimpl.\ncase Rlt_bool_spec ; intros Hx' ;  case Zlt_bool_spec ; intros Hm' ; try apply refl_equal.\nelim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le.\nelim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : Zfloor x = m.","conclusion":"Zfloor x = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"apply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : (IZR m <= x < IZR (m + 1))%R.","conclusion":"(IZR m <= x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"exact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : (if Rlt_bool x 0 then Zceil x else Zfloor x) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m.","conclusion":"(if Rlt_bool x 0 then Zceil x else Zfloor x) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Zceil_floor_neq.\nrewrite Hm.\nunfold cond_incr.\nsimpl.\ncase Rlt_bool_spec ; intros Hx' ;  case Zlt_bool_spec ; intros Hm' ; try apply refl_equal.\nelim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le.\nelim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : (if Rlt_bool x 0 then (Zfloor x + 1)%Z else Zfloor x) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m.","conclusion":"(if Rlt_bool x 0 then (Zfloor x + 1)%Z else Zfloor x) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Hm.\nunfold cond_incr.\nsimpl.\ncase Rlt_bool_spec ; intros Hx' ;  case Zlt_bool_spec ; intros Hm' ; try apply refl_equal.\nelim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le.\nelim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : (if Rlt_bool x 0 then (m + 1)%Z else m) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m.","conclusion":"(if Rlt_bool x 0 then (m + 1)%Z else m) =\ncond_incr (round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l')) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"unfold cond_incr.\nsimpl.\ncase Rlt_bool_spec ; intros Hx' ;  case Zlt_bool_spec ; intros Hm' ; try apply refl_equal.\nelim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le.\nelim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : (if Rlt_bool x 0 then (m + 1)%Z else m) =\n(if round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l') then (m + 1)%Z else m).","conclusion":"(if Rlt_bool x 0 then (m + 1)%Z else m) =\n(if round_ZR (m <? 0)%Z (SpecFloat.loc_Inexact l') then (m + 1)%Z else m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"simpl.\ncase Rlt_bool_spec ; intros Hx' ;  case Zlt_bool_spec ; intros Hm' ; try apply refl_equal.\nelim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le.\nelim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : (if Rlt_bool x 0 then (m + 1)%Z else m) =\n(if (m <? 0)%Z then (m + 1)%Z else m).","conclusion":"(if Rlt_bool x 0 then (m + 1)%Z else m) =\n(if (m <? 0)%Z then (m + 1)%Z else m)","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"case Rlt_bool_spec ; intros Hx' ;  case Zlt_bool_spec ; intros Hm' ; try apply refl_equal.\nelim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le.\nelim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z) : (m + 1)%Z = m.","conclusion":"(m + 1)%Z = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z)","proofString":"elim Rlt_not_le with (1 := Hx').\napply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z)","proofString":"apply Rlt_le.\napply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z) : (0 < x)%R.","conclusion":"(0 < x)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z)","proofString":"apply Rle_lt_trans with (2 := proj1 Hx).\nnow apply IZR_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z) : (0 <= IZR m)%R.","conclusion":"(0 <= IZR m)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (x < 0)%R) (Hm' : (0 <= m)%Z)","proofString":"now apply IZR_le."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z) : m = (m + 1)%Z.","conclusion":"m = (m + 1)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z)","proofString":"elim Rle_not_lt with (1 := Hx').\napply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z) : (x < 0)%R.","conclusion":"(x < 0)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z)","proofString":"apply Rlt_le_trans with (1 := proj2 Hx).\napply IZR_le.\nnow apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z) : (IZR (m + 1) <= 0)%R.","conclusion":"(IZR (m + 1) <= 0)%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z)","proofString":"apply IZR_le.\nnow apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z) : (m + 1 <= 0)%Z.","conclusion":"(m + 1 <= 0)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) (Hx' : (0 <= x)%R) (Hm' : (m < 0)%Z)","proofString":"now apply Zlt_le_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : IZR (Zfloor x) <> x.","conclusion":"IZR (Zfloor x) <> x","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : IZR m <> x.","conclusion":"IZR m <> x","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"now apply Rlt_not_eq."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> Ztrunc x = cond_incr (round_ZR (m <? 0)%Z l) m.","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> Ztrunc x = cond_incr (round_ZR (m <? 0)%Z l) m","hypotheses":"","proofString":"exact inbetween_int_ZR."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) : Ztrunc x = SpecFloat.cond_Zopp (Rlt_bool x 0) m.","conclusion":"Ztrunc x = SpecFloat.cond_Zopp (Rlt_bool x 0) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l)","proofString":"simpl.\nunfold Ztrunc.\ndestruct (Rlt_le_dec x 0) as [Zx|Zx].\nrewrite Rlt_bool_true with (1 := Zx).\nsimpl.\nunfold Zceil.\napply f_equal.\napply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ.\nrewrite Rlt_bool_false with (1 := Zx).\nsimpl.\napply Zfloor_imp.\nrewrite <- Rabs_pos_eq with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) : Ztrunc x = SpecFloat.cond_Zopp (Rlt_bool x 0) m.","conclusion":"Ztrunc x = SpecFloat.cond_Zopp (Rlt_bool x 0) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l)","proofString":"unfold Ztrunc.\ndestruct (Rlt_le_dec x 0) as [Zx|Zx].\nrewrite Rlt_bool_true with (1 := Zx).\nsimpl.\nunfold Zceil.\napply f_equal.\napply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ.\nrewrite Rlt_bool_false with (1 := Zx).\nsimpl.\napply Zfloor_imp.\nrewrite <- Rabs_pos_eq with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) : (if Rlt_bool x 0 then Zceil x else Zfloor x) =\nSpecFloat.cond_Zopp (Rlt_bool x 0) m.","conclusion":"(if Rlt_bool x 0 then Zceil x else Zfloor x) =\nSpecFloat.cond_Zopp (Rlt_bool x 0) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l)","proofString":"destruct (Rlt_le_dec x 0) as [Zx|Zx].\nrewrite Rlt_bool_true with (1 := Zx).\nsimpl.\nunfold Zceil.\napply f_equal.\napply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ.\nrewrite Rlt_bool_false with (1 := Zx).\nsimpl.\napply Zfloor_imp.\nrewrite <- Rabs_pos_eq with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : (if Rlt_bool x 0 then Zceil x else Zfloor x) =\nSpecFloat.cond_Zopp (Rlt_bool x 0) m.","conclusion":"(if Rlt_bool x 0 then Zceil x else Zfloor x) =\nSpecFloat.cond_Zopp (Rlt_bool x 0) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"rewrite Rlt_bool_true with (1 := Zx).\nsimpl.\nunfold Zceil.\napply f_equal.\napply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : Zceil x = SpecFloat.cond_Zopp true m.","conclusion":"Zceil x = SpecFloat.cond_Zopp true m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"simpl.\nunfold Zceil.\napply f_equal.\napply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : Zceil x = (- m)%Z.","conclusion":"Zceil x = (- m)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"unfold Zceil.\napply f_equal.\napply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : (- Zfloor (- x))%Z = (- m)%Z.","conclusion":"(- Zfloor (- x))%Z = (- m)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"apply f_equal.\napply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : Zfloor (- x) = m.","conclusion":"Zfloor (- x) = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"apply Zfloor_imp.\nrewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : (IZR m <= - x < IZR (m + 1))%R.","conclusion":"(IZR m <= - x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"rewrite <- Rabs_left with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : (IZR m <= Rabs x < IZR (m + 1))%R.","conclusion":"(IZR m <= Rabs x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"apply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : (IZR m < IZR (m + 1))%R.","conclusion":"(IZR m < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"apply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R) : (m < m + 1)%Z.","conclusion":"(m < m + 1)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (x < 0)%R)","proofString":"apply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R) : (if Rlt_bool x 0 then Zceil x else Zfloor x) =\nSpecFloat.cond_Zopp (Rlt_bool x 0) m.","conclusion":"(if Rlt_bool x 0 then Zceil x else Zfloor x) =\nSpecFloat.cond_Zopp (Rlt_bool x 0) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"rewrite Rlt_bool_false with (1 := Zx).\nsimpl.\napply Zfloor_imp.\nrewrite <- Rabs_pos_eq with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R) : Zfloor x = SpecFloat.cond_Zopp false m.","conclusion":"Zfloor x = SpecFloat.cond_Zopp false m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"simpl.\napply Zfloor_imp.\nrewrite <- Rabs_pos_eq with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R) : Zfloor x = m.","conclusion":"Zfloor x = m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"apply Zfloor_imp.\nrewrite <- Rabs_pos_eq with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R) : (IZR m <= x < IZR (m + 1))%R.","conclusion":"(IZR m <= x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"rewrite <- Rabs_pos_eq with (1 := Zx).\napply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R) : (IZR m <= Rabs x < IZR (m + 1))%R.","conclusion":"(IZR m <= Rabs x < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"apply inbetween_bounds with (2 := Hl).\napply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R) : (IZR m < IZR (m + 1))%R.","conclusion":"(IZR m < IZR (m + 1))%R","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"apply IZR_lt.\napply Zlt_succ."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R) : (m < m + 1)%Z.","conclusion":"(m < m + 1)%Z","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m (Rabs x) l) (Zx : (0 <= x)%R)","proofString":"apply Zlt_succ."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l -> Ztrunc x = SpecFloat.cond_Zopp (Rlt_bool x 0) m.","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l -> Ztrunc x = SpecFloat.cond_Zopp (Rlt_bool x 0) m","hypotheses":"","proofString":"exact inbetween_int_ZR_sign."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : Znearest choice x =\ncond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"Znearest choice x =\ncond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"unfold Znearest.\nassert (Hm: Zfloor x = m).\napply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx)).\nrewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"assert (Hm: Zfloor x = m).\napply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx)).\nrewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : Zfloor x = m.","conclusion":"Zfloor x = m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"apply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : (IZR m <= x < IZR (m + 1))%R.","conclusion":"(IZR m <= x < IZR (m + 1))%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"exact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then (Zfloor x + 1)%Z else Zfloor x\n| Lt => Zfloor x\n| Gt => (Zfloor x + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then (Zfloor x + 1)%Z else Zfloor x\n| Lt => Zfloor x\n| Gt => (Zfloor x + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match Rcompare (x - IZR m) (/ 2) with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match Rcompare (x - IZR m) (/ 2) with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"replace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match l' with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match l' with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"now case l'."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : l' = Rcompare (x - IZR m) (/ 2).","conclusion":"l' = Rcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : Rcompare x ((IZR m + IZR (m + 1)) / 2) = Rcompare (x - IZR m) (/ 2).","conclusion":"Rcompare x ((IZR m + IZR (m + 1)) / 2) = Rcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : Rcompare x ((IZR m + (IZR m + 1)) / 2) = Rcompare (x - IZR m) (/ 2).","conclusion":"Rcompare x ((IZR m + (IZR m + 1)) / 2) = Rcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : Rcompare (x + - IZR m) ((IZR m + (IZR m + 1)) / 2 + - IZR m) =\nRcompare (x - IZR m) (/ 2).","conclusion":"Rcompare (x + - IZR m) ((IZR m + (IZR m + 1)) / 2 + - IZR m) =\nRcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"apply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : ((IZR m + (IZR m + 1)) / 2 + - IZR m)%R = (/ 2)%R.","conclusion":"((IZR m + (IZR m + 1)) / 2 + - IZR m)%R = (/ 2)%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"field."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : IZR (Zfloor x) <> x.","conclusion":"IZR (Zfloor x) <> x","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : IZR m <> x.","conclusion":"IZR m <> x","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"now apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') : Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (- x) =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m.","conclusion":"Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (- x) =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"assert (Hm: Zfloor (-x) = m).\napply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx)).\nunfold Znearest.\nrewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (- x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') : Zfloor (- x) = m.","conclusion":"Zfloor (- x) = m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"apply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') : (IZR m <= - x < IZR (m + 1))%R.","conclusion":"(IZR m <= - x < IZR (m + 1))%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"exact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (- x) =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m.","conclusion":"Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (- x) =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"unfold Znearest.\nrewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (- x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : match Rcompare (- x - IZR (Zfloor (- x))) (/ 2) with\n| Eq =>\n    if negb (choice (- (Zfloor (- x) + 1))%Z)\n    then Zceil (- x)\n    else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m.","conclusion":"match Rcompare (- x - IZR (Zfloor (- x))) (/ 2) with\n| Eq =>\n    if negb (choice (- (Zfloor (- x) + 1))%Z)\n    then Zceil (- x)\n    else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"rewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (- x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : match Rcompare (- x - IZR (Zfloor (- x))) (/ 2) with\n| Eq =>\n    if negb (choice (- (Zfloor (- x) + 1))%Z)\n    then (Zfloor (- x) + 1)%Z\n    else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => (Zfloor (- x) + 1)%Z\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m.","conclusion":"match Rcompare (- x - IZR (Zfloor (- x))) (/ 2) with\n| Eq =>\n    if negb (choice (- (Zfloor (- x) + 1))%Z)\n    then (Zfloor (- x) + 1)%Z\n    else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => (Zfloor (- x) + 1)%Z\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"rewrite Hm.\nreplace (Rcompare (- x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : match Rcompare (- x - IZR m) (/ 2) with\n| Eq => if negb (choice (- (m + 1))%Z) then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m.","conclusion":"match Rcompare (- x - IZR m) (/ 2) with\n| Eq => if negb (choice (- (m + 1))%Z) then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"replace (Rcompare (- x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : match l' with\n| Eq => if negb (choice (- (m + 1))%Z) then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m.","conclusion":"match l' with\n| Eq => if negb (choice (- (m + 1))%Z) then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend =\ncond_incr (round_N (negb (choice (- (m + 1))%Z)) (SpecFloat.loc_Inexact l'))\n  m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"now case l'."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : l' = Rcompare (- x - IZR m) (/ 2).","conclusion":"l' = Rcompare (- x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"rewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = Rcompare (- x - IZR m) (/ 2).","conclusion":"Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = Rcompare (- x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"rewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : Rcompare (- x) ((IZR m + (IZR m + 1)) / 2) = Rcompare (- x - IZR m) (/ 2).","conclusion":"Rcompare (- x) ((IZR m + (IZR m + 1)) / 2) = Rcompare (- x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"rewrite <- (Rcompare_plus_r (- IZR m) (-x)).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : Rcompare (- x + - IZR m) ((IZR m + (IZR m + 1)) / 2 + - IZR m) =\nRcompare (- x - IZR m) (/ 2).","conclusion":"Rcompare (- x + - IZR m) ((IZR m + (IZR m + 1)) / 2 + - IZR m) =\nRcompare (- x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"apply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : ((IZR m + (IZR m + 1)) / 2 + - IZR m)%R = (/ 2)%R.","conclusion":"((IZR m + (IZR m + 1)) / 2 + - IZR m)%R = (/ 2)%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"field."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : IZR (Zfloor (- x)) <> (- x)%R.","conclusion":"IZR (Zfloor (- x)) <> (- x)%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"rewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m) : IZR m <> (- x)%R.","conclusion":"IZR m <> (- x)%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (x < 0)%R) (l' : comparison) (Hx : (IZR m < - x < IZR (m + 1))%R) (Hl' : Rcompare (- x) ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor (- x) = m)","proofString":"now apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : Znearest choice x =\ncond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"Znearest choice x =\ncond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"assert (Hm: Zfloor x = m).\napply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx)).\nunfold Znearest.\nrewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : Zfloor x = m.","conclusion":"Zfloor x = m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"apply Zfloor_imp.\nexact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') : (IZR m <= x < IZR (m + 1))%R.","conclusion":"(IZR m <= x < IZR (m + 1))%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l')","proofString":"exact (conj (Rlt_le _ _ (proj1 Hx)) (proj2 Hx))."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : Znearest choice x =\ncond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"Znearest choice x =\ncond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"unfold Znearest.\nrewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Zceil_floor_neq.\nrewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield.\nrewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then (Zfloor x + 1)%Z else Zfloor x\n| Lt => Zfloor x\n| Gt => (Zfloor x + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then (Zfloor x + 1)%Z else Zfloor x\n| Lt => Zfloor x\n| Gt => (Zfloor x + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Hm.\nreplace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match Rcompare (x - IZR m) (/ 2) with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match Rcompare (x - IZR m) (/ 2) with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"replace (Rcompare (x - IZR m) (/2)) with l'.\nnow case l'.\nrewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : match l' with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m.","conclusion":"match l' with\n| Eq => if choice m then (m + 1)%Z else m\n| Lt => m\n| Gt => (m + 1)%Z\nend = cond_incr (round_N (choice m) (SpecFloat.loc_Inexact l')) m","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"now case l'."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : l' = Rcompare (x - IZR m) (/ 2).","conclusion":"l' = Rcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite <- Hl'.\nrewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : Rcompare x ((IZR m + IZR (m + 1)) / 2) = Rcompare (x - IZR m) (/ 2).","conclusion":"Rcompare x ((IZR m + IZR (m + 1)) / 2) = Rcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite plus_IZR.\nrewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : Rcompare x ((IZR m + (IZR m + 1)) / 2) = Rcompare (x - IZR m) (/ 2).","conclusion":"Rcompare x ((IZR m + (IZR m + 1)) / 2) = Rcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite <- (Rcompare_plus_r (- IZR m) x).\napply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : Rcompare (x + - IZR m) ((IZR m + (IZR m + 1)) / 2 + - IZR m) =\nRcompare (x - IZR m) (/ 2).","conclusion":"Rcompare (x + - IZR m) ((IZR m + (IZR m + 1)) / 2 + - IZR m) =\nRcompare (x - IZR m) (/ 2)","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"apply f_equal.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : ((IZR m + (IZR m + 1)) / 2 + - IZR m)%R = (/ 2)%R.","conclusion":"((IZR m + (IZR m + 1)) / 2 + - IZR m)%R = (/ 2)%R","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"field."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : IZR (Zfloor x) <> x.","conclusion":"IZR (Zfloor x) <> x","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"rewrite Hm.\nnow apply Rlt_not_eq."},{"statement":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m) : IZR m <> x.","conclusion":"IZR m <> x","hypotheses":"(choice : Z -> bool) (x : R) (m : Z) (l : SpecFloat.location) (Zx : (0 <= x)%R) (l' : comparison) (Hx : (IZR m < x < IZR (m + 1))%R) (Hl' : Rcompare x ((IZR m + IZR (m + 1)) / 2) = l') (Hm : Zfloor x = m)","proofString":"now apply Rlt_not_eq."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : ZnearestE x = cond_incr (round_N (negb (Z.even m)) l) m.","conclusion":"ZnearestE x = cond_incr (round_N (negb (Z.even m)) l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"now apply inbetween_int_N with (choice := fun x => negb (Z.even x))."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l ->\nZnearestE x = cond_incr (round_N (negb (Z.even m)) l) m.","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l ->\nZnearestE x = cond_incr (round_N (negb (Z.even m)) l) m","hypotheses":"","proofString":"exact inbetween_int_NE."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZnearestE x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_N (negb (Z.even m)) l) m).","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZnearestE x =\nSpecFloat.cond_Zopp (Rlt_bool x 0)\n  (cond_incr (round_N (negb (Z.even m)) l) m)","hypotheses":"","proofString":"exact inbetween_int_NE_sign."},{"statement":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l) : ZnearestA x = cond_incr (round_N (0 <=? m)%Z l) m.","conclusion":"ZnearestA x = cond_incr (round_N (0 <=? m)%Z l) m","hypotheses":"(x : R) (m : Z) (l : SpecFloat.location) (Hl : inbetween_int m x l)","proofString":"now apply inbetween_int_N with (choice := fun x => Zle_bool 0 x)."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> ZnearestA x = cond_incr (round_N (0 <=? m)%Z l) m.","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m x l -> ZnearestA x = cond_incr (round_N (0 <=? m)%Z l) m","hypotheses":"","proofString":"exact inbetween_int_NA."},{"statement":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZnearestA x =\nSpecFloat.cond_Zopp (Rlt_bool x 0) (cond_incr (round_N true l) m).","conclusion":"forall (x : R) (m : Z) (l : SpecFloat.location),\ninbetween_int m (Rabs x) l ->\nZnearestA x =\nSpecFloat.cond_Zopp (Rlt_bool x 0) (cond_incr (round_N true l) m)","hypotheses":"","proofString":"exact inbetween_int_NA_sign."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) : truncate_aux (m, e, l) (k1 + k2) =\ntruncate_aux (truncate_aux (m, e, l) k1) k2.","conclusion":"truncate_aux (m, e, l) (k1 + k2) =\ntruncate_aux (truncate_aux (m, e, l) k1) k2","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z)","proofString":"unfold truncate_aux.\ndestruct (inbetween_float_ex beta m e l) as (x,Hx).\nassert (B1 := inbetween_float_new_location _ _ _ _ _ _ Hk1 Hx).\nassert (Hk3: (0 < k1 + k2)%Z).\nchange Z0 with (0 + 0)%Z.\nnow apply Zplus_lt_compat.\nassert (B3 := inbetween_float_new_location _ _ _ _ _ _ Hk3 Hx).\nassert (B2 := inbetween_float_new_location _ _ _ _ _ _ Hk2 B1).\nrewrite Zplus_assoc in B3.\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z)","proofString":"destruct (inbetween_float_ex beta m e l) as (x,Hx).\nassert (B1 := inbetween_float_new_location _ _ _ _ _ _ Hk1 Hx).\nassert (Hk3: (0 < k1 + k2)%Z).\nchange Z0 with (0 + 0)%Z.\nnow apply Zplus_lt_compat.\nassert (B3 := inbetween_float_new_location _ _ _ _ _ _ Hk3 Hx).\nassert (B2 := inbetween_float_new_location _ _ _ _ _ _ Hk2 B1).\nrewrite Zplus_assoc in B3.\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l)","proofString":"assert (B1 := inbetween_float_new_location _ _ _ _ _ _ Hk1 Hx).\nassert (Hk3: (0 < k1 + k2)%Z).\nchange Z0 with (0 + 0)%Z.\nnow apply Zplus_lt_compat.\nassert (B3 := inbetween_float_new_location _ _ _ _ _ _ Hk3 Hx).\nassert (B2 := inbetween_float_new_location _ _ _ _ _ _ Hk2 B1).\nrewrite Zplus_assoc in B3.\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l))","proofString":"assert (Hk3: (0 < k1 + k2)%Z).\nchange Z0 with (0 + 0)%Z.\nnow apply Zplus_lt_compat.\nassert (B3 := inbetween_float_new_location _ _ _ _ _ _ Hk3 Hx).\nassert (B2 := inbetween_float_new_location _ _ _ _ _ _ Hk2 B1).\nrewrite Zplus_assoc in B3.\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) : (0 < k1 + k2)%Z.","conclusion":"(0 < k1 + k2)%Z","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l))","proofString":"change Z0 with (0 + 0)%Z.\nnow apply Zplus_lt_compat."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) : (0 + 0 < k1 + k2)%Z.","conclusion":"(0 + 0 < k1 + k2)%Z","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l))","proofString":"now apply Zplus_lt_compat."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z)","proofString":"assert (B3 := inbetween_float_new_location _ _ _ _ _ _ Hk3 Hx).\nassert (B2 := inbetween_float_new_location _ _ _ _ _ _ Hk2 B1).\nrewrite Zplus_assoc in B3.\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + (k1 + k2)) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + (k1 + k2)) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l))","proofString":"assert (B2 := inbetween_float_new_location _ _ _ _ _ _ Hk2 B1).\nrewrite Zplus_assoc in B3.\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + (k1 + k2)) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)) (B2 : inbetween_float beta (m / beta ^ k1 / beta ^ k2) (e + k1 + k2) x\n  (new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n     (new_location (beta ^ k1) (m mod beta ^ k1) l))) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + (k1 + k2)) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)) (B2 : inbetween_float beta (m / beta ^ k1 / beta ^ k2) (e + k1 + k2) x\n  (new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n     (new_location (beta ^ k1) (m mod beta ^ k1) l)))","proofString":"rewrite Zplus_assoc in B3.\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + k1 + k2) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)) (B2 : inbetween_float beta (m / beta ^ k1 / beta ^ k2) (e + k1 + k2) x\n  (new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n     (new_location (beta ^ k1) (m mod beta ^ k1) l))) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + k1 + k2) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)) (B2 : inbetween_float beta (m / beta ^ k1 / beta ^ k2) (e + k1 + k2) x\n  (new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n     (new_location (beta ^ k1) (m mod beta ^ k1) l)))","proofString":"destruct (inbetween_float_unique _ _ _ _ _ _ _ B2 B3).\nnow rewrite H, H0, Zplus_assoc."},{"statement":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + k1 + k2) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)) (B2 : inbetween_float beta (m / beta ^ k1 / beta ^ k2) (e + k1 + k2) x\n  (new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n     (new_location (beta ^ k1) (m mod beta ^ k1) l))) (H : (m / beta ^ k1 / beta ^ k2)%Z = (m / beta ^ (k1 + k2))%Z) (H0 : new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n  (new_location (beta ^ k1) (m mod beta ^ k1) l) =\nnew_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) : ((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l)).","conclusion":"((m / beta ^ (k1 + k2))%Z, (e + (k1 + k2))%Z,\n new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l) =\n((m / beta ^ k1 / beta ^ k2)%Z, (e + k1 + k2)%Z,\n new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n   (new_location (beta ^ k1) (m mod beta ^ k1) l))","hypotheses":"(m e : Z) (l : SpecFloat.location) (k1 k2 : Z) (Hk1 : (0 < k1)%Z) (Hk2 : (0 < k2)%Z) (x : R) (Hx : inbetween_float beta m e x l) (B1 : inbetween_float beta (m / beta ^ k1) (e + k1) x\n  (new_location (beta ^ k1) (m mod beta ^ k1) l)) (Hk3 : (0 < k1 + k2)%Z) (B3 : inbetween_float beta (m / beta ^ (k1 + k2)) (e + k1 + k2) x\n  (new_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)) (B2 : inbetween_float beta (m / beta ^ k1 / beta ^ k2) (e + k1 + k2) x\n  (new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n     (new_location (beta ^ k1) (m mod beta ^ k1) l))) (H : (m / beta ^ k1 / beta ^ k2)%Z = (m / beta ^ (k1 + k2))%Z) (H0 : new_location (beta ^ k2) ((m / beta ^ k1) mod beta ^ k2)\n  (new_location (beta ^ k1) (m mod beta ^ k1) l) =\nnew_location (beta ^ (k1 + k2)) (m mod beta ^ (k1 + k2)) l)","proofString":"now rewrite H, H0, Zplus_assoc."},{"statement":"(e : Z) (l : SpecFloat.location) : let '(m', _, _) := truncate (0%Z, e, l) in m' = 0%Z.","conclusion":"let '(m', _, _) := truncate (0%Z, e, l) in m' = 0%Z","hypotheses":"(e : Z) (l : SpecFloat.location)","proofString":"unfold truncate.\ncase Zlt_bool.\nsimpl.\napply Zdiv_0_l.\napply refl_equal."},{"statement":"(e : Z) (l : SpecFloat.location) : let\n'(m', _, _) :=\n if (0 <? fexp (Zdigits beta 0 + e) - e)%Z\n then truncate_aux (0%Z, e, l) (fexp (Zdigits beta 0 + e) - e)\n else (0%Z, e, l) in m' = 0%Z.","conclusion":"let\n'(m', _, _) :=\n if (0 <? fexp (Zdigits beta 0 + e) - e)%Z\n then truncate_aux (0%Z, e, l) (fexp (Zdigits beta 0 + e) - e)\n else (0%Z, e, l) in m' = 0%Z","hypotheses":"(e : Z) (l : SpecFloat.location)","proofString":"case Zlt_bool.\nsimpl.\napply Zdiv_0_l.\napply refl_equal."},{"statement":"(e : Z) (l : SpecFloat.location) : let\n'(m', _, _) := truncate_aux (0%Z, e, l) (fexp (Zdigits beta 0 + e) - e) in\n m' = 0%Z.","conclusion":"let\n'(m', _, _) := truncate_aux (0%Z, e, l) (fexp (Zdigits beta 0 + e) - e) in\n m' = 0%Z","hypotheses":"(e : Z) (l : SpecFloat.location)","proofString":"simpl.\napply Zdiv_0_l."},{"statement":"(e : Z) (l : SpecFloat.location) : (0 / beta ^ (fexp e - e))%Z = 0%Z.","conclusion":"(0 / beta ^ (fexp e - e))%Z = 0%Z","hypotheses":"(e : Z) (l : SpecFloat.location)","proofString":"apply Zdiv_0_l."},{"statement":"(e : Z) (l : SpecFloat.location) : 0%Z = 0%Z.","conclusion":"0%Z = 0%Z","hypotheses":"(e : Z) (l : SpecFloat.location)","proofString":"apply refl_equal."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) : (e + (cexp beta fexp x - e))%Z = cexp beta fexp x.","conclusion":"(e + (cexp beta fexp x - e))%Z = cexp beta fexp x","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z)","proofString":"ring."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x) : Zfloor (IZR m * bpow e * bpow (- (e + k))) = (m / beta ^ k)%Z.","conclusion":"Zfloor (IZR m * bpow e * bpow (- (e + k))) = (m / beta ^ k)%Z","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x)","proofString":"rewrite Rmult_assoc, <- bpow_plus.\nring_simplify (e + - (e + k))%Z.\nclear -Hm Hk.\ndestruct k as [|k|k] ; try easy.\nsimpl.\napply Zfloor_div.\nintros H.\ngeneralize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x) : Zfloor (IZR m * bpow (e + - (e + k))) = (m / beta ^ k)%Z.","conclusion":"Zfloor (IZR m * bpow (e + - (e + k))) = (m / beta ^ k)%Z","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x)","proofString":"ring_simplify (e + - (e + k))%Z.\nclear -Hm Hk.\ndestruct k as [|k|k] ; try easy.\nsimpl.\napply Zfloor_div.\nintros H.\ngeneralize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x) : Zfloor (IZR m * bpow (- k)) = (m / beta ^ k)%Z.","conclusion":"Zfloor (IZR m * bpow (- k)) = (m / beta ^ k)%Z","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x)","proofString":"clear -Hm Hk.\ndestruct k as [|k|k] ; try easy.\nsimpl.\napply Zfloor_div.\nintros H.\ngeneralize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : Z) (Hk : (0 < k)%Z) : Zfloor (IZR m * bpow (- k)) = (m / beta ^ k)%Z.","conclusion":"Zfloor (IZR m * bpow (- k)) = (m / beta ^ k)%Z","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : Z) (Hk : (0 < k)%Z)","proofString":"destruct k as [|k|k] ; try easy.\nsimpl.\napply Zfloor_div.\nintros H.\ngeneralize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z) : Zfloor (IZR m * bpow (- Z.pos k)) = (m / beta ^ Z.pos k)%Z.","conclusion":"Zfloor (IZR m * bpow (- Z.pos k)) = (m / beta ^ Z.pos k)%Z","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z)","proofString":"simpl.\napply Zfloor_div.\nintros H.\ngeneralize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z) : Zfloor (IZR m * / IZR (Z.pow_pos beta k)) = (m / Z.pow_pos beta k)%Z.","conclusion":"Zfloor (IZR m * / IZR (Z.pow_pos beta k)) = (m / Z.pow_pos beta k)%Z","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z)","proofString":"apply Zfloor_div.\nintros H.\ngeneralize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z) : Z.pow_pos beta k <> 0%Z.","conclusion":"Z.pow_pos beta k <> 0%Z","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z)","proofString":"intros H.\ngeneralize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z) (H : Z.pow_pos beta k = 0%Z) : False.","conclusion":"False","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z) (H : Z.pow_pos beta k = 0%Z)","proofString":"generalize (Zpower_pos_gt_0 beta k) (Zle_bool_imp_le _ _ (radix_prop beta)).\nlia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z) (H : Z.pow_pos beta k = 0%Z) : ((0 < beta)%Z -> (0 < Z.pow_pos beta k)%Z) -> (2 <= beta)%Z -> False.","conclusion":"((0 < beta)%Z -> (0 < Z.pow_pos beta k)%Z) -> (2 <= beta)%Z -> False","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (k : positive) (Hk : (0 < Z.pos k)%Z) (H : Z.pow_pos beta k = 0%Z)","proofString":"lia."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x) : IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x.","conclusion":"IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x)","proofString":"rewrite scaled_mantissa_generic with (1 := Fx).\nnow rewrite Zfloor_IZR."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x) : IZR (Zfloor (IZR (Ztrunc (scaled_mantissa beta fexp x)))) =\nIZR (Ztrunc (scaled_mantissa beta fexp x)).","conclusion":"IZR (Zfloor (IZR (Ztrunc (scaled_mantissa beta fexp x)))) =\nIZR (Ztrunc (scaled_mantissa beta fexp x))","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (0 < k)%Z) (H : (e + k)%Z = cexp beta fexp x)","proofString":"now rewrite Zfloor_IZR."},{"statement":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (cexp beta fexp x - e <= 0)%Z) : e = cexp beta fexp x.","conclusion":"e = cexp beta fexp x","hypotheses":"(m e : Z) (Hm : m <> 0%Z) (x : R) (Fx : format x) (He : (e <= fexp (Zdigits beta m + e))%Z) (Hc : cexp beta fexp x = fexp (Zdigits beta m + e)) (k : Z) (Hk : (cexp beta fexp x - e <= 0)%Z)","proofString":"lia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x.","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z)","proofString":"unfold truncate.\nrewrite <- cexp_inbetween_float with (1 := Hx) (2 := H1) by now left.\ngeneralize (Zlt_cases 0 (cexp beta fexp x - e)).\ndestruct Zlt_bool ; intros Hk.\nsplit.\nnow apply inbetween_float_new_location.\nring.\napply (conj H1).\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) : let\n'(m', e', l') :=\n if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then truncate_aux (m, e, l) (fexp (Zdigits beta m + e) - e)\n else (m, e, l) in inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x.","conclusion":"let\n'(m', e', l') :=\n if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then truncate_aux (m, e, l) (fexp (Zdigits beta m + e) - e)\n else (m, e, l) in inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z)","proofString":"rewrite <- cexp_inbetween_float with (1 := Hx) (2 := H1) by now left.\ngeneralize (Zlt_cases 0 (cexp beta fexp x - e)).\ndestruct Zlt_bool ; intros Hk.\nsplit.\nnow apply inbetween_float_new_location.\nring.\napply (conj H1).\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) : let\n'(m', e', l') :=\n if (0 <? cexp beta fexp x - e)%Z\n then truncate_aux (m, e, l) (cexp beta fexp x - e)\n else (m, e, l) in inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x.","conclusion":"let\n'(m', e', l') :=\n if (0 <? cexp beta fexp x - e)%Z\n then truncate_aux (m, e, l) (cexp beta fexp x - e)\n else (m, e, l) in inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z)","proofString":"generalize (Zlt_cases 0 (cexp beta fexp x - e)).\ndestruct Zlt_bool ; intros Hk.\nsplit.\nnow apply inbetween_float_new_location.\nring.\napply (conj H1).\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) : (if (0 <? cexp beta fexp x - e)%Z\n then (0 < cexp beta fexp x - e)%Z\n else (0 >= cexp beta fexp x - e)%Z) ->\nlet\n'(m', e', l') :=\n if (0 <? cexp beta fexp x - e)%Z\n then truncate_aux (m, e, l) (cexp beta fexp x - e)\n else (m, e, l) in inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x.","conclusion":"(if (0 <? cexp beta fexp x - e)%Z\n then (0 < cexp beta fexp x - e)%Z\n else (0 >= cexp beta fexp x - e)%Z) ->\nlet\n'(m', e', l') :=\n if (0 <? cexp beta fexp x - e)%Z\n then truncate_aux (m, e, l) (cexp beta fexp x - e)\n else (m, e, l) in inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z)","proofString":"destruct Zlt_bool ; intros Hk.\nsplit.\nnow apply inbetween_float_new_location.\nring.\napply (conj H1).\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 < cexp beta fexp x - e)%Z) : let\n'(m', e', l') := truncate_aux (m, e, l) (cexp beta fexp x - e) in\n inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x.","conclusion":"let\n'(m', e', l') := truncate_aux (m, e, l) (cexp beta fexp x - e) in\n inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 < cexp beta fexp x - e)%Z)","proofString":"split.\nnow apply inbetween_float_new_location.\nring."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 < cexp beta fexp x - e)%Z) : inbetween_float beta (m / beta ^ (cexp beta fexp x - e))\n  (e + (cexp beta fexp x - e)) x\n  (new_location (beta ^ (cexp beta fexp x - e))\n     (m mod beta ^ (cexp beta fexp x - e)) l).","conclusion":"inbetween_float beta (m / beta ^ (cexp beta fexp x - e))\n  (e + (cexp beta fexp x - e)) x\n  (new_location (beta ^ (cexp beta fexp x - e))\n     (m mod beta ^ (cexp beta fexp x - e)) l)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 < cexp beta fexp x - e)%Z)","proofString":"now apply inbetween_float_new_location."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 < cexp beta fexp x - e)%Z) : (e + (cexp beta fexp x - e))%Z = cexp beta fexp x.","conclusion":"(e + (cexp beta fexp x - e))%Z = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 < cexp beta fexp x - e)%Z)","proofString":"ring."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 >= cexp beta fexp x - e)%Z) : inbetween_float beta m e x l /\\ e = cexp beta fexp x.","conclusion":"inbetween_float beta m e x l /\\ e = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 >= cexp beta fexp x - e)%Z)","proofString":"apply (conj H1).\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 >= cexp beta fexp x - e)%Z) : e = cexp beta fexp x.","conclusion":"e = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (Hk : (0 >= cexp beta fexp x - e)%Z)","proofString":"lia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x.","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"apply truncate_correct_partial' with (1 := Hx) (2 := H1).\nrewrite cexp_inbetween_float with (1 := Hx) (2 := H1).\nexact H2.\nnow right."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z) : (e <= cexp beta fexp x)%Z.","conclusion":"(e <= cexp beta fexp x)%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"rewrite cexp_inbetween_float with (1 := Hx) (2 := H1).\nexact H2.\nnow right."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z) : (e <= fexp (Zdigits beta m + e))%Z.","conclusion":"(e <= fexp (Zdigits beta m + e))%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"exact H2."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z) : (e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z.","conclusion":"(e <= cexp beta fexp x)%Z \\/ (e <= fexp (Zdigits beta m + e))%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"now right."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact)","proofString":"destruct (Zle_or_lt e (fexp (Zdigits beta m + e))) as [H3|H3].\ngeneralize (truncate_correct_partial x m e l Hx H1 H3).\ndestruct (truncate (m, e, l)) as [[m' e'] l'].\nintros [H4 H5].\napply (conj H4).\nnow left.\ndestruct H2 as [H2|H2].\ngeneralize (truncate_correct_partial' x m e l Hx H1 H2).\ndestruct (truncate (m, e, l)) as [[m' e'] l'].\nintros [H4 H5].\napply (conj H4).\nnow left.\nrewrite H2 in H1 |- *.\nsimpl.\ngeneralize (Zlt_cases 0 (fexp (Zdigits beta m + e) - e)).\ndestruct Zlt_bool.\nintros H.\napply False_ind.\nlia.\nintros _.\napply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"generalize (truncate_correct_partial x m e l Hx H1 H3).\ndestruct (truncate (m, e, l)) as [[m' e'] l'].\nintros [H4 H5].\napply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) : (let\n '(m', e', l') := truncate (m, e, l) in\n  inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x) ->\nlet\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"(let\n '(m', e', l') := truncate (m, e, l) in\n  inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x) ->\nlet\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z)","proofString":"destruct (truncate (m, e, l)) as [[m' e'] l'].\nintros [H4 H5].\napply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) (m' e' : Z) (l' : SpecFloat.location) : inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x ->\ninbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x ->\ninbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) (m' e' : Z) (l' : SpecFloat.location)","proofString":"intros [H4 H5].\napply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x) : inbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"inbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x)","proofString":"apply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x) : e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x.","conclusion":"e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (e <= fexp (Zdigits beta m + e))%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x)","proofString":"now left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"destruct H2 as [H2|H2].\ngeneralize (truncate_correct_partial' x m e l Hx H1 H2).\ndestruct (truncate (m, e, l)) as [[m' e'] l'].\nintros [H4 H5].\napply (conj H4).\nnow left.\nrewrite H2 in H1 |- *.\nsimpl.\ngeneralize (Zlt_cases 0 (fexp (Zdigits beta m + e) - e)).\ndestruct Zlt_bool.\nintros H.\napply False_ind.\nlia.\nintros _.\napply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"generalize (truncate_correct_partial' x m e l Hx H1 H2).\ndestruct (truncate (m, e, l)) as [[m' e'] l'].\nintros [H4 H5].\napply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : (let\n '(m', e', l') := truncate (m, e, l) in\n  inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x) ->\nlet\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"(let\n '(m', e', l') := truncate (m, e, l) in\n  inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x) ->\nlet\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"destruct (truncate (m, e, l)) as [[m' e'] l'].\nintros [H4 H5].\napply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (m' e' : Z) (l' : SpecFloat.location) : inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x ->\ninbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"inbetween_float beta m' e' x l' /\\ e' = cexp beta fexp x ->\ninbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (m' e' : Z) (l' : SpecFloat.location)","proofString":"intros [H4 H5].\napply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x) : inbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"inbetween_float beta m' e' x l' /\\\n(e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x)","proofString":"apply (conj H4).\nnow left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x) : e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x.","conclusion":"e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (m' e' : Z) (l' : SpecFloat.location) (H4 : inbetween_float beta m' e' x l') (H5 : e' = cexp beta fexp x)","proofString":"now left."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"rewrite H2 in H1 |- *.\nsimpl.\ngeneralize (Zlt_cases 0 (fexp (Zdigits beta m + e) - e)).\ndestruct Zlt_bool.\nintros H.\napply False_ind.\nlia.\nintros _.\napply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : let\n'(m', e', l') := truncate (m, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"simpl.\ngeneralize (Zlt_cases 0 (fexp (Zdigits beta m + e) - e)).\ndestruct Zlt_bool.\nintros H.\napply False_ind.\nlia.\nintros _.\napply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : let\n'(m', e', l') :=\n if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then\n  ((m / beta ^ (fexp (Zdigits beta m + e) - e))%Z,\n   (e + (fexp (Zdigits beta m + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact)\n else (m, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') :=\n if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then\n  ((m / beta ^ (fexp (Zdigits beta m + e) - e))%Z,\n   (e + (fexp (Zdigits beta m + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact)\n else (m, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"generalize (Zlt_cases 0 (fexp (Zdigits beta m + e) - e)).\ndestruct Zlt_bool.\nintros H.\napply False_ind.\nlia.\nintros _.\napply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : (if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then (0 < fexp (Zdigits beta m + e) - e)%Z\n else (0 >= fexp (Zdigits beta m + e) - e)%Z) ->\nlet\n'(m', e', l') :=\n if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then\n  ((m / beta ^ (fexp (Zdigits beta m + e) - e))%Z,\n   (e + (fexp (Zdigits beta m + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact)\n else (m, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"(if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then (0 < fexp (Zdigits beta m + e) - e)%Z\n else (0 >= fexp (Zdigits beta m + e) - e)%Z) ->\nlet\n'(m', e', l') :=\n if (0 <? fexp (Zdigits beta m + e) - e)%Z\n then\n  ((m / beta ^ (fexp (Zdigits beta m + e) - e))%Z,\n   (e + (fexp (Zdigits beta m + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact)\n else (m, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"destruct Zlt_bool.\nintros H.\napply False_ind.\nlia.\nintros _.\napply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : (0 < fexp (Zdigits beta m + e) - e)%Z ->\ninbetween_float beta (m / beta ^ (fexp (Zdigits beta m + e) - e))\n  (e + (fexp (Zdigits beta m + e) - e)) x\n  (new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact) /\\\n((e + (fexp (Zdigits beta m + e) - e))%Z = cexp beta fexp x \\/\n new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n   (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact =\n SpecFloat.loc_Exact /\\ format x).","conclusion":"(0 < fexp (Zdigits beta m + e) - e)%Z ->\ninbetween_float beta (m / beta ^ (fexp (Zdigits beta m + e) - e))\n  (e + (fexp (Zdigits beta m + e) - e)) x\n  (new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact) /\\\n((e + (fexp (Zdigits beta m + e) - e))%Z = cexp beta fexp x \\/\n new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n   (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact =\n SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"intros H.\napply False_ind.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (H : (0 < fexp (Zdigits beta m + e) - e)%Z) : inbetween_float beta (m / beta ^ (fexp (Zdigits beta m + e) - e))\n  (e + (fexp (Zdigits beta m + e) - e)) x\n  (new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact) /\\\n((e + (fexp (Zdigits beta m + e) - e))%Z = cexp beta fexp x \\/\n new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n   (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact =\n SpecFloat.loc_Exact /\\ format x).","conclusion":"inbetween_float beta (m / beta ^ (fexp (Zdigits beta m + e) - e))\n  (e + (fexp (Zdigits beta m + e) - e)) x\n  (new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n     (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact) /\\\n((e + (fexp (Zdigits beta m + e) - e))%Z = cexp beta fexp x \\/\n new_location (beta ^ (fexp (Zdigits beta m + e) - e))\n   (m mod beta ^ (fexp (Zdigits beta m + e) - e)) SpecFloat.loc_Exact =\n SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (H : (0 < fexp (Zdigits beta m + e) - e)%Z)","proofString":"apply False_ind.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (H : (0 < fexp (Zdigits beta m + e) - e)%Z) : False.","conclusion":"False","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) (H : (0 < fexp (Zdigits beta m + e) - e)%Z)","proofString":"lia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : (0 >= fexp (Zdigits beta m + e) - e)%Z ->\ninbetween_float beta m e x SpecFloat.loc_Exact /\\\n(e = cexp beta fexp x \\/\n SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x).","conclusion":"(0 >= fexp (Zdigits beta m + e) - e)%Z ->\ninbetween_float beta m e x SpecFloat.loc_Exact /\\\n(e = cexp beta fexp x \\/\n SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"intros _.\napply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : inbetween_float beta m e x SpecFloat.loc_Exact /\\\n(e = cexp beta fexp x \\/\n SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x).","conclusion":"inbetween_float beta m e x SpecFloat.loc_Exact /\\\n(e = cexp beta fexp x \\/\n SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"apply (conj H1).\nright.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : e = cexp beta fexp x \\/ SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x.","conclusion":"e = cexp beta fexp x \\/ SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"right.\nrepeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x.","conclusion":"SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"repeat split.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z) : format x.","conclusion":"format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 < x)%R) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (H3 : (fexp (Zdigits beta m + e) < e)%Z)","proofString":"inversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nintros Zm.\nunfold cexp.\nrewrite mag_F2R_Zdigits with (1 := Zm).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact)","proofString":"assert (Hm: m = 0%Z).\ncut (m <= 0 < m + 1)%Z.\nlia.\nassert (F2R (Float beta m e) <= x < F2R (Float beta (m + 1) e))%R as Hx'.\napply inbetween_float_bounds with (1 := H1).\nrewrite <- Hx in Hx'.\nsplit.\napply le_0_F2R with (1 := proj1 Hx').\napply gt_0_F2R with (1 := proj2 Hx').\nrewrite Hm, <- Hx in H1 |- *.\nclear -H1.\ndestruct H1 as [_ | l' [H _] _].\nassert (exists e', truncate (Z0, e, loc_Exact) = (Z0, e', loc_Exact)).\nunfold truncate, truncate_aux.\ncase Zlt_bool.\nrewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even.\nnow eexists.\ndestruct H as [e' H].\nrewrite H.\nsplit.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0.\nrewrite F2R_0 in H.\nelim Rlt_irrefl with (1 := H)."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) : m = 0%Z.","conclusion":"m = 0%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact)","proofString":"cut (m <= 0 < m + 1)%Z.\nlia.\nassert (F2R (Float beta m e) <= x < F2R (Float beta (m + 1) e))%R as Hx'.\napply inbetween_float_bounds with (1 := H1).\nrewrite <- Hx in Hx'.\nsplit.\napply le_0_F2R with (1 := proj1 Hx').\napply gt_0_F2R with (1 := proj2 Hx')."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) : (m <= 0 < m + 1)%Z -> m = 0%Z.","conclusion":"(m <= 0 < m + 1)%Z -> m = 0%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact)","proofString":"lia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) : (m <= 0 < m + 1)%Z.","conclusion":"(m <= 0 < m + 1)%Z","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact)","proofString":"assert (F2R (Float beta m e) <= x < F2R (Float beta (m + 1) e))%R as Hx'.\napply inbetween_float_bounds with (1 := H1).\nrewrite <- Hx in Hx'.\nsplit.\napply le_0_F2R with (1 := proj1 Hx').\napply gt_0_F2R with (1 := proj2 Hx')."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (Hm : m = 0%Z) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta m e x l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (Hm : m = 0%Z)","proofString":"rewrite Hm, <- Hx in H1 |- *.\nclear -H1.\ndestruct H1 as [_ | l' [H _] _].\nassert (exists e', truncate (Z0, e, loc_Exact) = (Z0, e', loc_Exact)).\nunfold truncate, truncate_aux.\ncase Zlt_bool.\nrewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even.\nnow eexists.\ndestruct H as [e' H].\nrewrite H.\nsplit.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0.\nrewrite F2R_0 in H.\nelim Rlt_irrefl with (1 := H)."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta 0 e 0 l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (Hm : m = 0%Z) : let\n'(m', e', l') := truncate (0%Z, e, l) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0).","conclusion":"let\n'(m', e', l') := truncate (0%Z, e, l) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : 0%R = x) (H1 : inbetween_float beta 0 e 0 l) (H2 : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact) (Hm : m = 0%Z)","proofString":"clear -H1.\ndestruct H1 as [_ | l' [H _] _].\nassert (exists e', truncate (Z0, e, loc_Exact) = (Z0, e', loc_Exact)).\nunfold truncate, truncate_aux.\ncase Zlt_bool.\nrewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even.\nnow eexists.\ndestruct H as [e' H].\nrewrite H.\nsplit.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0.\nrewrite F2R_0 in H.\nelim Rlt_irrefl with (1 := H)."},{"statement":"(e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta 0 e 0 l) : let\n'(m', e', l') := truncate (0%Z, e, l) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0).","conclusion":"let\n'(m', e', l') := truncate (0%Z, e, l) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0)","hypotheses":"(e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta 0 e 0 l)","proofString":"destruct H1 as [_ | l' [H _] _].\nassert (exists e', truncate (Z0, e, loc_Exact) = (Z0, e', loc_Exact)).\nunfold truncate, truncate_aux.\ncase Zlt_bool.\nrewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even.\nnow eexists.\ndestruct H as [e' H].\nrewrite H.\nsplit.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0.\nrewrite F2R_0 in H.\nelim Rlt_irrefl with (1 := H)."},{"statement":"(e : Z) : let\n'(m', e', l') := truncate (0%Z, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0).","conclusion":"let\n'(m', e', l') := truncate (0%Z, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0)","hypotheses":"(e : Z)","proofString":"assert (exists e', truncate (Z0, e, loc_Exact) = (Z0, e', loc_Exact)).\nunfold truncate, truncate_aux.\ncase Zlt_bool.\nrewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even.\nnow eexists.\ndestruct H as [e' H].\nrewrite H.\nsplit.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0."},{"statement":"(e : Z) : exists e' : Z,\n  truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact).","conclusion":"exists e' : Z,\n  truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)","hypotheses":"(e : Z)","proofString":"unfold truncate, truncate_aux.\ncase Zlt_bool.\nrewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even.\nnow eexists."},{"statement":"(e : Z) : exists e' : Z,\n  (if (0 <? fexp (Zdigits beta 0 + e) - e)%Z\n   then\n    ((0 / beta ^ (fexp (Zdigits beta 0 + e) - e))%Z,\n     (e + (fexp (Zdigits beta 0 + e) - e))%Z,\n     new_location (beta ^ (fexp (Zdigits beta 0 + e) - e))\n       (0 mod beta ^ (fexp (Zdigits beta 0 + e) - e)) SpecFloat.loc_Exact)\n   else (0%Z, e, SpecFloat.loc_Exact)) = (0%Z, e', SpecFloat.loc_Exact).","conclusion":"exists e' : Z,\n  (if (0 <? fexp (Zdigits beta 0 + e) - e)%Z\n   then\n    ((0 / beta ^ (fexp (Zdigits beta 0 + e) - e))%Z,\n     (e + (fexp (Zdigits beta 0 + e) - e))%Z,\n     new_location (beta ^ (fexp (Zdigits beta 0 + e) - e))\n       (0 mod beta ^ (fexp (Zdigits beta 0 + e) - e)) SpecFloat.loc_Exact)\n   else (0%Z, e, SpecFloat.loc_Exact)) = (0%Z, e', SpecFloat.loc_Exact)","hypotheses":"(e : Z)","proofString":"case Zlt_bool.\nrewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even.\nnow eexists."},{"statement":"(e : Z) : exists e' : Z,\n  ((0 / beta ^ (fexp (Zdigits beta 0 + e) - e))%Z,\n   (e + (fexp (Zdigits beta 0 + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta 0 + e) - e))\n     (0 mod beta ^ (fexp (Zdigits beta 0 + e) - e)) SpecFloat.loc_Exact) =\n  (0%Z, e', SpecFloat.loc_Exact).","conclusion":"exists e' : Z,\n  ((0 / beta ^ (fexp (Zdigits beta 0 + e) - e))%Z,\n   (e + (fexp (Zdigits beta 0 + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta 0 + e) - e))\n     (0 mod beta ^ (fexp (Zdigits beta 0 + e) - e)) SpecFloat.loc_Exact) =\n  (0%Z, e', SpecFloat.loc_Exact)","hypotheses":"(e : Z)","proofString":"rewrite Zdiv_0_l, Zmod_0_l.\neexists.\napply f_equal.\nunfold new_location.\nnow case Z.even."},{"statement":"(e : Z) : exists e' : Z,\n  (0%Z, (e + (fexp (Zdigits beta 0 + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta 0 + e) - e)) 0\n     SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact).","conclusion":"exists e' : Z,\n  (0%Z, (e + (fexp (Zdigits beta 0 + e) - e))%Z,\n   new_location (beta ^ (fexp (Zdigits beta 0 + e) - e)) 0\n     SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)","hypotheses":"(e : Z)","proofString":"eexists.\napply f_equal.\nunfold new_location.\nnow case Z.even."},{"statement":"(e : Z) : new_location (beta ^ (fexp (Zdigits beta 0 + e) - e)) 0 SpecFloat.loc_Exact =\nSpecFloat.loc_Exact.","conclusion":"new_location (beta ^ (fexp (Zdigits beta 0 + e) - e)) 0 SpecFloat.loc_Exact =\nSpecFloat.loc_Exact","hypotheses":"(e : Z)","proofString":"unfold new_location.\nnow case Z.even."},{"statement":"(e : Z) : (if Z.even (beta ^ (fexp (Zdigits beta 0 + e) - e))\n then new_location_even (beta ^ (fexp (Zdigits beta 0 + e) - e))\n else new_location_odd (beta ^ (fexp (Zdigits beta 0 + e) - e))) 0%Z\n  SpecFloat.loc_Exact = SpecFloat.loc_Exact.","conclusion":"(if Z.even (beta ^ (fexp (Zdigits beta 0 + e) - e))\n then new_location_even (beta ^ (fexp (Zdigits beta 0 + e) - e))\n else new_location_odd (beta ^ (fexp (Zdigits beta 0 + e) - e))) 0%Z\n  SpecFloat.loc_Exact = SpecFloat.loc_Exact","hypotheses":"(e : Z)","proofString":"now case Z.even."},{"statement":"(e : Z) : exists e' : Z, (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact).","conclusion":"exists e' : Z, (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)","hypotheses":"(e : Z)","proofString":"now eexists."},{"statement":"(e : Z) (H : exists e' : Z,\n  truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)) : let\n'(m', e', l') := truncate (0%Z, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0).","conclusion":"let\n'(m', e', l') := truncate (0%Z, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e' 0 l' /\\\n (e' = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0)","hypotheses":"(e : Z) (H : exists e' : Z,\n  truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact))","proofString":"destruct H as [e' H].\nrewrite H.\nsplit.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0."},{"statement":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)) : let\n'(m', e'0, l') := truncate (0%Z, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e'0 0 l' /\\\n (e'0 = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0).","conclusion":"let\n'(m', e'0, l') := truncate (0%Z, e, SpecFloat.loc_Exact) in\n inbetween_float beta m' e'0 0 l' /\\\n (e'0 = cexp beta fexp 0 \\/ l' = SpecFloat.loc_Exact /\\ format 0)","hypotheses":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact))","proofString":"rewrite H.\nsplit.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0."},{"statement":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)) : inbetween_float beta 0 e' 0 SpecFloat.loc_Exact /\\\n(e' = cexp beta fexp 0 \\/\n SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format 0).","conclusion":"inbetween_float beta 0 e' 0 SpecFloat.loc_Exact /\\\n(e' = cexp beta fexp 0 \\/\n SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format 0)","hypotheses":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact))","proofString":"split.\nconstructor.\napply eq_sym, F2R_0.\nright.\nrepeat split.\napply generic_format_0."},{"statement":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)) : inbetween_float beta 0 e' 0 SpecFloat.loc_Exact.","conclusion":"inbetween_float beta 0 e' 0 SpecFloat.loc_Exact","hypotheses":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact))","proofString":"constructor.\napply eq_sym, F2R_0."},{"statement":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)) : e' = cexp beta fexp 0 \\/\nSpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format 0.","conclusion":"e' = cexp beta fexp 0 \\/\nSpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format 0","hypotheses":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact))","proofString":"right.\nrepeat split.\napply generic_format_0."},{"statement":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)) : SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format 0.","conclusion":"SpecFloat.loc_Exact = SpecFloat.loc_Exact /\\ format 0","hypotheses":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact))","proofString":"repeat split.\napply generic_format_0."},{"statement":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact)) : format 0.","conclusion":"format 0","hypotheses":"(e e' : Z) (H : truncate (0%Z, e, SpecFloat.loc_Exact) = (0%Z, e', SpecFloat.loc_Exact))","proofString":"apply generic_format_0."},{"statement":"(e : Z) (l' : comparison) (H : (0 < 0)%R) : let\n'(m', e', l'0) := truncate (0%Z, e, SpecFloat.loc_Inexact l') in\n inbetween_float beta m' e' 0 l'0 /\\\n (e' = cexp beta fexp 0 \\/ l'0 = SpecFloat.loc_Exact /\\ format 0).","conclusion":"let\n'(m', e', l'0) := truncate (0%Z, e, SpecFloat.loc_Inexact l') in\n inbetween_float beta m' e' 0 l'0 /\\\n (e' = cexp beta fexp 0 \\/ l'0 = SpecFloat.loc_Exact /\\ format 0)","hypotheses":"(e : Z) (l' : comparison) (H : (0 < 0)%R)","proofString":"elim Rlt_irrefl with (1 := H)."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 <= x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact) : let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x).","conclusion":"let\n'(m', e', l') := truncate (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 <= x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact)","proofString":"apply truncate_correct' with (1 := Hx) (2 := H1).\nnow apply cexp_inbetween_float_loc_Exact with (2 := H1)."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 <= x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact) : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hx : (0 <= x)%R) (H1 : inbetween_float beta m e x l) (H2 : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact)","proofString":"now apply cexp_inbetween_float_loc_Exact with (2 := H1)."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hin : inbetween_float beta m (cexp beta fexp x) x l) (He : e = cexp beta fexp x) : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 x0 l0 -> rnd x0 = choice m0 l0.","conclusion":"forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 x0 l0 -> rnd x0 = choice m0 l0","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hin : inbetween_float beta m (cexp beta fexp x) x l) (He : e = cexp beta fexp x)","proofString":"exact inbetween_int_valid."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hin : inbetween_float beta m (cexp beta fexp x) (Rabs x) l) (He : e = cexp beta fexp x) : forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0).","conclusion":"forall (x0 : R) (m0 : Z) (l0 : SpecFloat.location),\ninbetween_int m0 (Rabs x0) l0 ->\nrnd x0 = SpecFloat.cond_Zopp (Rlt_bool x0 0) (choice (Rlt_bool x0 0) m0 l0)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hin : inbetween_float beta m (cexp beta fexp x) (Rabs x) l) (He : e = cexp beta fexp x)","proofString":"exact inbetween_int_valid."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x) \\/ l' = SpecFloat.loc_Exact /\\ format (Rabs x)) : inbetween_float beta m' e' (Rabs x) l'.","conclusion":"inbetween_float beta m' e' (Rabs x) l'","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x) \\/ l' = SpecFloat.loc_Exact /\\ format (Rabs x))","proofString":"exact H1."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x) \\/ l' = SpecFloat.loc_Exact /\\ format (Rabs x)) : e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x.","conclusion":"e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x) \\/ l' = SpecFloat.loc_Exact /\\ format (Rabs x))","proofString":"destruct H2 as [H2|[H2 H3]].\nleft.\nnow rewrite <- cexp_abs.\nright.\napply (conj H2).\nnow apply generic_format_abs_inv."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x)) : e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x.","conclusion":"e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x))","proofString":"left.\nnow rewrite <- cexp_abs."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x)) : e' = cexp beta fexp x.","conclusion":"e' = cexp beta fexp x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : e' = cexp beta fexp (Rabs x))","proofString":"now rewrite <- cexp_abs."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : l' = SpecFloat.loc_Exact) (H3 : format (Rabs x)) : e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x.","conclusion":"e' = cexp beta fexp x \\/ l' = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : l' = SpecFloat.loc_Exact) (H3 : format (Rabs x))","proofString":"right.\napply (conj H2).\nnow apply generic_format_abs_inv."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : l' = SpecFloat.loc_Exact) (H3 : format (Rabs x)) : l' = SpecFloat.loc_Exact /\\ format x.","conclusion":"l' = SpecFloat.loc_Exact /\\ format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : l' = SpecFloat.loc_Exact) (H3 : format (Rabs x))","proofString":"apply (conj H2).\nnow apply generic_format_abs_inv."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : l' = SpecFloat.loc_Exact) (H3 : format (Rabs x)) : format x.","conclusion":"format x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact) (m' e' : Z) (l' : SpecFloat.location) (H1 : inbetween_float beta m' e' (Rabs x) l') (H2 : l' = SpecFloat.loc_Exact) (H3 : format (Rabs x))","proofString":"now apply generic_format_abs_inv."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact) : (e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp x)%Z \\/ l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact)","proofString":"rewrite <- cexp_abs.\napply cexp_inbetween_float_loc_Exact with (2 := Hl) (3 := He).\napply Rabs_pos."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact) : (e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact.","conclusion":"(e <= cexp beta fexp (Rabs x))%Z \\/ l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact)","proofString":"apply cexp_inbetween_float_loc_Exact with (2 := Hl) (3 := He).\napply Rabs_pos."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact) : (0 <= Rabs x)%R.","conclusion":"(0 <= Rabs x)%R","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (Hl : inbetween_float beta m e (Rabs x) l) (He : (e <= fexp (Zdigits beta m + e))%Z \\/ l = SpecFloat.loc_Exact)","proofString":"apply Rabs_pos."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact) : let\n'(m', e', l') := truncate_FIX (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta (FIX_exp emin) x \\/\n  l' = SpecFloat.loc_Exact /\\ generic_format beta (FIX_exp emin) x).","conclusion":"let\n'(m', e', l') := truncate_FIX (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta (FIX_exp emin) x \\/\n  l' = SpecFloat.loc_Exact /\\ generic_format beta (FIX_exp emin) x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact)","proofString":"unfold truncate_FIX.\nset (k := (emin - e)%Z).\nset (p := Zpower beta k).\nunfold cexp, FIX_exp.\ngeneralize (Zlt_cases 0 k).\ncase (Zlt_bool 0 k) ; intros Hk.\nsplit.\nnow apply inbetween_float_new_location.\nclear H2.\nleft.\nunfold k.\nring.\nsplit.\nexact H1.\nunfold k in Hk.\ndestruct H2 as [H2|H2].\nleft.\nlia.\nright.\nsplit.\nexact H2.\nrewrite H2 in H1.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nunfold cexp.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact) : let\n'(m', e', l') :=\n if (0 <? emin - e)%Z\n then\n  ((m / beta ^ (emin - e))%Z, (e + (emin - e))%Z,\n   new_location (beta ^ (emin - e)) (m mod beta ^ (emin - e)) l)\n else (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta (FIX_exp emin) x \\/\n  l' = SpecFloat.loc_Exact /\\ generic_format beta (FIX_exp emin) x).","conclusion":"let\n'(m', e', l') :=\n if (0 <? emin - e)%Z\n then\n  ((m / beta ^ (emin - e))%Z, (e + (emin - e))%Z,\n   new_location (beta ^ (emin - e)) (m mod beta ^ (emin - e)) l)\n else (m, e, l) in\n inbetween_float beta m' e' x l' /\\\n (e' = cexp beta (FIX_exp emin) x \\/\n  l' = SpecFloat.loc_Exact /\\ generic_format beta (FIX_exp emin) x)","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact)","proofString":"set (k := (emin - e)%Z).\nset (p := Zpower beta k).\nunfold cexp, FIX_exp.\ngeneralize (Zlt_cases 0 k).\ncase (Zlt_bool 0 k) ; intros Hk.\nsplit.\nnow apply inbetween_float_new_location.\nclear H2.\nleft.\nunfold k.\nring.\nsplit.\nexact H1.\nunfold k in Hk.\ndestruct H2 as [H2|H2].\nleft.\nlia.\nright.\nsplit.\nexact H2.\nrewrite H2 in H1.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nunfold cexp.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (k : Z) (p : Z) (Hk : (0 < k)%Z) : (e + (emin - e))%Z = emin.","conclusion":"(e + (emin - e))%Z = emin","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (k : Z) (p : Z) (Hk : (0 < k)%Z)","proofString":"ring."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= k)%Z) : inbetween_float beta m e x l.","conclusion":"inbetween_float beta m e x l","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= k)%Z)","proofString":"exact H1."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : e = emin \\/\nl = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x.","conclusion":"e = emin \\/\nl = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z \\/ l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"destruct H2 as [H2|H2].\nleft.\nlia.\nright.\nsplit.\nexact H2.\nrewrite H2 in H1.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nunfold cexp.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : e = emin \\/\nl = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x.","conclusion":"e = emin \\/\nl = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"left.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : e = emin.","conclusion":"e = emin","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : (e <= emin)%Z) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"lia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : e = emin \\/\nl = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x.","conclusion":"e = emin \\/\nl = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"right.\nsplit.\nexact H2.\nrewrite H2 in H1.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nunfold cexp.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : l = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x.","conclusion":"l = SpecFloat.loc_Exact /\\ generic_format beta (fun _ : Z => emin) x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"split.\nexact H2.\nrewrite H2 in H1.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nunfold cexp.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : l = SpecFloat.loc_Exact.","conclusion":"l = SpecFloat.loc_Exact","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"exact H2."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : generic_format beta (fun _ : Z => emin) x.","conclusion":"generic_format beta (fun _ : Z => emin) x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x l) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"rewrite H2 in H1.\ninversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nunfold cexp.\nlia."},{"statement":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z) : generic_format beta (fun _ : Z => emin) x.","conclusion":"generic_format beta (fun _ : Z => emin) x","hypotheses":"(x : R) (m e : Z) (l : SpecFloat.location) (H1 : inbetween_float beta m e x SpecFloat.loc_Exact) (H2 : l = SpecFloat.loc_Exact) (k : Z) (p : Z) (Hk : (0 >= emin - e)%Z)","proofString":"inversion_clear H1.\nrewrite H.\napply generic_format_F2R.\nunfold cexp.\nlia."}]}