{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/SelectLongproof.v","fileSamples":[{"statement":"(le : letenv) (n : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.repr (Int64.unsigned n))) Enil)\n    v /\\ Val.lessdef (Val.loword (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.repr (Int64.unsigned n))) Enil)\n    v /\\ Val.lessdef (Val.loword (Vlong n)) v","hypotheses":"(le : letenv) (n : int64)","proofString":"TrivialExists."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop Olowlong (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.loword x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Olowlong (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.loword x) v","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (n : int) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.unsigned n))) v /\\\n  Val.lessdef (Val.longofintu (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.unsigned n))) v /\\\n  Val.lessdef (Val.longofintu (Vint n)) v","hypotheses":"(le : letenv) (n : int)","proofString":"TrivialExists."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oextend Xuns32 (mk_amount64 Int.zero)) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.longofintu x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oextend Xuns32 (mk_amount64 Int.zero)) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.longofintu x) v","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"TrivialExists.\nsimpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : eval_operation ge sp (Oextend Xuns32 (mk_amount64 Int.zero)) (x :: nil) m =\nSome (Val.longofintu x).","conclusion":"eval_operation ge sp (Oextend Xuns32 (mk_amount64 Int.zero)) (x :: nil) m =\nSome (Val.longofintu x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"simpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : Some (eval_extend Xuns32 x (mk_amount64 Int.zero)) = Some (Val.longofintu x).","conclusion":"Some (eval_extend Xuns32 x (mk_amount64 Int.zero)) = Some (Val.longofintu x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"unfold eval_extend.\nrewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : Some (Val.shll (Val.longofintu x) (Vint (mk_amount64 Int.zero))) =\nSome (Val.longofintu x).","conclusion":"Some (Val.shll (Val.longofintu x) (Vint (mk_amount64 Int.zero))) =\nSome (Val.longofintu x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"rewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : Some (Val.shll (Val.longofintu x) (Vint Int.zero)) = Some (Val.longofintu x).","conclusion":"Some (Val.shll (Val.longofintu x) (Vint Int.zero)) = Some (Val.longofintu x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"destruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) : Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.repr (Int.unsigned i)) Int.zero)\n   else Vundef) = Some (Vlong (Int64.repr (Int.unsigned i))).","conclusion":"Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.repr (Int.unsigned i)) Int.zero)\n   else Vundef) = Some (Vlong (Int64.repr (Int.unsigned i)))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i))","proofString":"rewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) : Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.repr (Int.unsigned i))\n   else Vundef) = Some (Vlong (Int64.repr (Int.unsigned i))).","conclusion":"Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.repr (Int.unsigned i))\n   else Vundef) = Some (Vlong (Int64.repr (Int.unsigned i)))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i))","proofString":"auto."},{"statement":"(le : letenv) (n : int) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v /\\\n  Val.lessdef (Val.longofint (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v /\\\n  Val.lessdef (Val.longofint (Vint n)) v","hypotheses":"(le : letenv) (n : int)","proofString":"TrivialExists."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oextend Xsgn32 (mk_amount64 Int.zero)) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.longofint x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oextend Xsgn32 (mk_amount64 Int.zero)) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.longofint x) v","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"TrivialExists.\nsimpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : eval_operation ge sp (Oextend Xsgn32 (mk_amount64 Int.zero)) (x :: nil) m =\nSome (Val.longofint x).","conclusion":"eval_operation ge sp (Oextend Xsgn32 (mk_amount64 Int.zero)) (x :: nil) m =\nSome (Val.longofint x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"simpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : Some (eval_extend Xsgn32 x (mk_amount64 Int.zero)) = Some (Val.longofint x).","conclusion":"Some (eval_extend Xsgn32 x (mk_amount64 Int.zero)) = Some (Val.longofint x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"unfold eval_extend.\nrewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : Some (Val.shll (Val.longofint x) (Vint (mk_amount64 Int.zero))) =\nSome (Val.longofint x).","conclusion":"Some (Val.shll (Val.longofint x) (Vint (mk_amount64 Int.zero))) =\nSome (Val.longofint x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"rewrite mk_amount64_eq by reflexivity.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : Some (Val.shll (Val.longofint x) (Vint Int.zero)) = Some (Val.longofint x).","conclusion":"Some (Val.shll (Val.longofint x) (Vint Int.zero)) = Some (Val.longofint x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"destruct x; simpl; auto.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) : Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.repr (Int.signed i)) Int.zero)\n   else Vundef) = Some (Vlong (Int64.repr (Int.signed i))).","conclusion":"Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.repr (Int.signed i)) Int.zero)\n   else Vundef) = Some (Vlong (Int64.repr (Int.signed i)))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i))","proofString":"rewrite Int64.shl'_zero.\nauto."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) : Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.repr (Int.signed i))\n   else Vundef) = Some (Vlong (Int64.repr (Int.signed i))).","conclusion":"Some\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.repr (Int.signed i))\n   else Vundef) = Some (Vlong (Int64.repr (Int.signed i)))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i))","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      match addlimm_match a with\n      | addlimm_case1 m0 => longconst (Int64.add n m0)\n      | addlimm_case2 s m0 =>\n          Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n      | addlimm_case3 m0 =>\n          Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n      | addlimm_case4 m0 t => Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)\n      | addlimm_default e0 => Eop (Oaddlimm n) (e0 ::: Enil)\n      end) v /\\ Val.lessdef (Val.addl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      match addlimm_match a with\n      | addlimm_case1 m0 => longconst (Int64.add n m0)\n      | addlimm_case2 s m0 =>\n          Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n      | addlimm_case3 m0 =>\n          Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n      | addlimm_case4 m0 t => Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)\n      | addlimm_default e0 => Eop (Oaddlimm n) (e0 ::: Enil)\n      end) v /\\ Val.lessdef (Val.addl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nsubst n.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.add_zero; auto.\nrewrite Ptrofs.add_zero; auto.\ncase (addlimm_match a); intros; InvEval; subst.\nrewrite Int64.add_commut; TrivialExists.\nTrivialExists.\nsimpl.\nrewrite Ptrofs.add_commut, Genv.shift_symbol_address_64; auto.\neconstructor; split.\nEvalOp.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0); auto.\nrewrite Val.addl_assoc, Int64.add_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero)","proofString":"subst n.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.add_zero; auto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val)","proofString":"intros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.add_zero; auto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.add_zero; auto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.addl x (Vlong Int64.zero)) x.","conclusion":"Val.lessdef (Val.addl x (Vlong Int64.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int64.add_zero; auto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge sp e m le a (Vptr b i)) : Val.lessdef (Vptr b (Ptrofs.add i (Ptrofs.of_int64 Int64.zero))) (Vptr b i).","conclusion":"Val.lessdef (Vptr b (Ptrofs.add i (Ptrofs.of_int64 Int64.zero))) (Vptr b i)","hypotheses":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (H : eval_expr ge sp e m le a (Vptr b i))","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match addlimm_match a with\n    | addlimm_case1 m0 => longconst (Int64.add n m0)\n    | addlimm_case2 s m0 =>\n        Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n    | addlimm_case3 m0 =>\n        Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n    | addlimm_case4 m0 t => Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)\n    | addlimm_default e0 => Eop (Oaddlimm n) (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.addl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match addlimm_match a with\n    | addlimm_case1 m0 => longconst (Int64.add n m0)\n    | addlimm_case2 s m0 =>\n        Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n    | addlimm_case3 m0 =>\n        Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n    | addlimm_case4 m0 t => Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)\n    | addlimm_default e0 => Eop (Oaddlimm n) (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.addl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero)","proofString":"case (addlimm_match a); intros; InvEval; subst.\nrewrite Int64.add_commut; TrivialExists.\nTrivialExists.\nsimpl.\nrewrite Ptrofs.add_commut, Genv.shift_symbol_address_64; auto.\neconstructor; split.\nEvalOp.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0); auto.\nrewrite Val.addl_assoc, Int64.add_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : int64) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add n m0)) v /\\\n  Val.lessdef (Val.addl (Vlong m0) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add n m0)) v /\\\n  Val.lessdef (Val.addl (Vlong m0) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : int64)","proofString":"rewrite Int64.add_commut; TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (s : ident) (m0 : ptrofs) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil) v /\\\n  Val.lessdef (Val.addl (Genv.symbol_address ge s m0) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil) v /\\\n  Val.lessdef (Val.addl (Genv.symbol_address ge s m0) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (s : ident) (m0 : ptrofs)","proofString":"TrivialExists.\nsimpl.\nrewrite Ptrofs.add_commut, Genv.shift_symbol_address_64; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (s : ident) (m0 : ptrofs) : eval_operation ge sp (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) nil\n  m = Some (Val.addl (Genv.symbol_address ge s m0) (Vlong n)).","conclusion":"eval_operation ge sp (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) nil\n  m = Some (Val.addl (Genv.symbol_address ge s m0) (Vlong n))","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (s : ident) (m0 : ptrofs)","proofString":"simpl.\nrewrite Ptrofs.add_commut, Genv.shift_symbol_address_64; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (s : ident) (m0 : ptrofs) : Some (Genv.symbol_address ge s (Ptrofs.add (Ptrofs.of_int64 n) m0)) =\nSome (Val.addl (Genv.symbol_address ge s m0) (Vlong n)).","conclusion":"Some (Genv.symbol_address ge s (Ptrofs.add (Ptrofs.of_int64 n) m0)) =\nSome (Val.addl (Genv.symbol_address ge s m0) (Vlong n))","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (s : ident) (m0 : ptrofs)","proofString":"rewrite Ptrofs.add_commut, Genv.shift_symbol_address_64; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : ptrofs) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil) v /\\\n  Val.lessdef (Val.addl (Val.offset_ptr sp m0) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil) v /\\\n  Val.lessdef (Val.addl (Val.offset_ptr sp m0) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : ptrofs)","proofString":"econstructor; split.\nEvalOp.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0); auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : ptrofs) (b : block) (i : ptrofs) : Val.lessdef (Vptr b (Ptrofs.add (Ptrofs.add i m0) (Ptrofs.of_int64 n)))\n  (Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n) m0))).","conclusion":"Val.lessdef (Vptr b (Ptrofs.add (Ptrofs.add i m0) (Ptrofs.of_int64 n)))\n  (Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n) m0)))","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : ptrofs) (b : block) (i : ptrofs)","proofString":"rewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0); auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : int64) (t : expr) (v1 : val) (H3 : eval_expr ge sp e m le t v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong m0)) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong m0)) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (m0 : int64) (t : expr) (v1 : val) (H3 : eval_expr ge sp e m le t v1)","proofString":"rewrite Val.addl_assoc, Int64.add_commut; TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (e0 : expr) (H0 : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm n) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm n) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (e0 : expr) (H0 : eval_expr ge sp e m le e0 x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (addl a b) v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (addl a b) v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val)","proofString":"unfold addl; case (addl_match a b); intros; InvEval; subst.\nrewrite Val.addl_commut.\napply eval_addlimm; auto.\napply eval_addlimm; auto.\nreplace (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2)))     with (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_permut.\nTrivialExists.\nsimpl.\nrewrite Val.addl_commut, Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut n2).\nauto.\nTrivialExists.\nsimpl.\nrewrite <- (Val.addl_commut v1), <- (Val.addl_commut (Val.addl v1 (Vlong n2))).\nrewrite Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc.\nauto.\nreplace (Val.addl (Val.addl v1 (Vlong n1)) y)     with (Val.addl (Val.addl v1 y) (Vlong n1)).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_commut.\nrewrite <- Val.addl_assoc.\napply eval_addlimm.\nEvalOp.\nrewrite Val.addl_commut.\nTrivialExists.\nTrivialExists.\nrewrite Val.addl_commut.\nTrivialExists.\nTrivialExists.\nrewrite Val.addl_commut.\nTrivialExists.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl (Vlong n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl (Vlong n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.addl_commut.\napply eval_addlimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl y (Vlong n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl y (Vlong n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"apply eval_addlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 t1) v /\\\n  Val.lessdef (Val.addl x (Vlong n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n2 t1) v /\\\n  Val.lessdef (Val.addl x (Vlong n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_addlimm; auto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"replace (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2)))     with (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"apply eval_addlimm.\nEvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl v1 v0).","conclusion":"eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl v1 v0)","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2)) =\nVal.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2)).","conclusion":"Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2)) =\nVal.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"repeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.addl v1 (Val.addl v0 (Val.addl (Vlong n1) (Vlong n2))) =\nVal.addl v1 (Val.addl (Vlong n1) (Val.addl v0 (Vlong n2))).","conclusion":"Val.addl v1 (Val.addl v0 (Val.addl (Vlong n1) (Vlong n2))) =\nVal.addl v1 (Val.addl (Vlong n1) (Val.addl v0 (Vlong n2)))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"decEq.\napply Val.addl_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.addl v0 (Val.addl (Vlong n1) (Vlong n2)) =\nVal.addl (Vlong n1) (Val.addl v0 (Vlong n2)).","conclusion":"Val.addl v0 (Val.addl (Vlong n1) (Vlong n2)) =\nVal.addl (Vlong n1) (Val.addl v0 (Vlong n2))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"apply Val.addl_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oaddl\n       (Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n1) n2)) Enil\n        ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oaddl\n       (Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n1) n2)) Enil\n        ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists.\nsimpl.\nrewrite Val.addl_commut, Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut n2).\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp Oaddl\n  (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2) :: v1 :: nil) m =\nSome (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2)).","conclusion":"eval_operation ge sp Oaddl\n  (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2) :: v1 :: nil) m =\nSome (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"simpl.\nrewrite Val.addl_commut, Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut n2).\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Some (Val.addl (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)) v1) =\nSome (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2)).","conclusion":"Some (Val.addl (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)) v1) =\nSome (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.addl_commut, Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut n2).\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Some (Val.addl v1 (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2))) =\nSome (Val.addl v1 (Val.addl (Vlong n1) (Val.offset_ptr sp n2))).","conclusion":"Some (Val.addl v1 (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2))) =\nSome (Val.addl v1 (Val.addl (Vlong n1) (Val.offset_ptr sp n2)))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"f_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut n2).\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2) =\nVal.addl (Vlong n1) (Val.offset_ptr sp n2).","conclusion":"Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2) =\nVal.addl (Vlong n1) (Val.offset_ptr sp n2)","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"destruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut n2).\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 v1) : Vptr b0 (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2)) =\nVptr b0 (Ptrofs.add (Ptrofs.add i n2) (Ptrofs.of_int64 n1)).","conclusion":"Vptr b0 (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2)) =\nVptr b0 (Ptrofs.add (Ptrofs.add i n2) (Ptrofs.of_int64 n1))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 v1)","proofString":"rewrite Ptrofs.add_assoc, (Ptrofs.add_commut n2).\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 v1) : Vptr b0 (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2)) =\nVptr b0 (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2)).","conclusion":"Vptr b0 (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2)) =\nVptr b0 (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2))","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 v1)","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oaddl\n       (Eop (Oaddrstack (Ptrofs.add n1 (Ptrofs.of_int64 n2))) Enil\n        ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop Oaddl\n       (Eop (Oaddrstack (Ptrofs.add n1 (Ptrofs.of_int64 n2))) Enil\n        ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists.\nsimpl.\nrewrite <- (Val.addl_commut v1), <- (Val.addl_commut (Val.addl v1 (Vlong n2))).\nrewrite Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc.\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : eval_operation ge sp Oaddl\n  (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)) :: v1 :: nil) m =\nSome (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2))).","conclusion":"eval_operation ge sp Oaddl\n  (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)) :: v1 :: nil) m =\nSome (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2)))","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"simpl.\nrewrite <- (Val.addl_commut v1), <- (Val.addl_commut (Val.addl v1 (Vlong n2))).\nrewrite Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc.\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : Some (Val.addl (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2))) v1) =\nSome (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2))).","conclusion":"Some (Val.addl (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2))) v1) =\nSome (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2)))","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite <- (Val.addl_commut v1), <- (Val.addl_commut (Val.addl v1 (Vlong n2))).\nrewrite Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc.\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : Some (Val.addl v1 (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)))) =\nSome (Val.addl (Val.addl v1 (Vlong n2)) (Val.offset_ptr sp n1)).","conclusion":"Some (Val.addl v1 (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)))) =\nSome (Val.addl (Val.addl v1 (Vlong n2)) (Val.offset_ptr sp n1))","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.addl_assoc.\nf_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc.\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : Some (Val.addl v1 (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)))) =\nSome (Val.addl v1 (Val.addl (Vlong n2) (Val.offset_ptr sp n1))).","conclusion":"Some (Val.addl v1 (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)))) =\nSome (Val.addl v1 (Val.addl (Vlong n2) (Val.offset_ptr sp n1)))","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"f_equal; f_equal.\ndestruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc.\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)) =\nVal.addl (Vlong n2) (Val.offset_ptr sp n1).","conclusion":"Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2)) =\nVal.addl (Vlong n2) (Val.offset_ptr sp n1)","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"destruct sp; simpl; auto.\nrewrite Ptrofs.add_assoc.\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 v1) : Vptr b0 (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2))) =\nVptr b0 (Ptrofs.add (Ptrofs.add i n1) (Ptrofs.of_int64 n2)).","conclusion":"Vptr b0 (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2))) =\nVptr b0 (Ptrofs.add (Ptrofs.add i n1) (Ptrofs.of_int64 n2))","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 v1)","proofString":"rewrite Ptrofs.add_assoc.\nauto."},{"statement":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 v1) : Vptr b0 (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2))) =\nVptr b0 (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2))).","conclusion":"Vptr b0 (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2))) =\nVptr b0 (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2)))","hypotheses":"(le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 v1)","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"replace (Val.addl (Val.addl v1 (Vlong n1)) y)     with (Val.addl (Val.addl v1 y) (Vlong n1)).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_commut."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 y) (Vlong n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 y) (Vlong n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"apply eval_addlimm.\nEvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl v1 y).","conclusion":"eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl v1 y)","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.addl (Val.addl v1 y) (Vlong n1) = Val.addl (Val.addl v1 (Vlong n1)) y.","conclusion":"Val.addl (Val.addl v1 y) (Vlong n1) = Val.addl (Val.addl v1 (Vlong n1)) y","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"repeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_commut."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.addl v1 (Val.addl y (Vlong n1)) = Val.addl v1 (Val.addl (Vlong n1) y).","conclusion":"Val.addl v1 (Val.addl y (Vlong n1)) = Val.addl v1 (Val.addl (Vlong n1) y)","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"decEq.\napply Val.addl_commut."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.addl y (Vlong n1) = Val.addl (Vlong n1) y.","conclusion":"Val.addl y (Vlong n1) = Val.addl (Vlong n1) y","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"apply Val.addl_commut."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl x (Val.addl v1 (Vlong n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n2 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl x (Val.addl v1 (Vlong n2))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite <- Val.addl_assoc.\napply eval_addlimm.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl x v1) (Vlong n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n2 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl x v1) (Vlong n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"apply eval_addlimm.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl x v1).","conclusion":"eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl x v1)","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (eval_shiftl s v1 a0) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (eval_shiftl s v1 a0) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.addl_commut.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl y (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl y (eval_shiftl s v1 a0)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (eval_shiftl s v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (x0 : extension) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlext x0 a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (eval_extend x0 v1 a0) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlext x0 a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (eval_extend x0 v1 a0) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (x0 : extension) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.addl_commut.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (x0 : extension) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlext x0 a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl y (eval_extend x0 v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlext x0 a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.addl y (eval_extend x0 v1 a0)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (x0 : extension) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (x0 : extension) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlext x0 a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (eval_extend x0 v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlext x0 a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (eval_extend x0 v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (x0 : extension) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 t3 : expr) (H0 : eval_expr ge sp e m le t3 y) (v1 v0 : val) (H3 : eval_expr ge sp e m le t1 v1) (H4 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omulladd (t3 ::: t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.mull v1 v0) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omulladd (t3 ::: t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.mull v1 v0) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (t1 t2 t3 : expr) (H0 : eval_expr ge sp e m le t3 y) (v1 v0 : val) (H3 : eval_expr ge sp e m le t1 v1) (H4 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Val.addl_commut.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 t3 : expr) (H0 : eval_expr ge sp e m le t3 y) (v1 v0 : val) (H3 : eval_expr ge sp e m le t1 v1) (H4 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omulladd (t3 ::: t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl y (Val.mull v1 v0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omulladd (t3 ::: t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl y (Val.mull v1 v0)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (t1 t2 t3 : expr) (H0 : eval_expr ge sp e m le t3 y) (v1 v0 : val) (H3 : eval_expr ge sp e m le t1 v1) (H4 : eval_expr ge sp e m le t2 v0)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 t3 : expr) (H : eval_expr ge sp e m le t1 x) (v1 v0 : val) (H3 : eval_expr ge sp e m le t2 v1) (H4 : eval_expr ge sp e m le t3 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omulladd (t1 ::: t2 ::: t3 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (Val.mull v1 v0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omulladd (t1 ::: t2 ::: t3 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (Val.mull v1 v0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 t2 t3 : expr) (H : eval_expr ge sp e m le t1 x) (v1 v0 : val) (H3 : eval_expr ge sp e m le t2 v1) (H4 : eval_expr ge sp e m le t3 v0)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oaddl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oaddl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match negl_match a with\n    | negl_case1 n => Eop (Olongconst (Int64.neg n)) Enil\n    | negl_case2 s a0 t1 => Eop (Oneglshift s a0) (t1 ::: Enil)\n    | negl_default e0 => Eop Onegl (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.subl (Vlong Int64.zero) x) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match negl_match a with\n    | negl_case1 n => Eop (Olongconst (Int64.neg n)) Enil\n    | negl_case2 s a0 t1 => Eop (Oneglshift s a0) (t1 ::: Enil)\n    | negl_default e0 => Eop Onegl (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.subl (Vlong Int64.zero) x) v","hypotheses":"(le : letenv) (a : expr) (x : val)","proofString":"case (negl_match a); intros; InvEval; subst.\nTrivialExists.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.neg n)) Enil) v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.neg n)) Enil) v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) (Vlong n)) v","hypotheses":"(le : letenv) (a : expr) (n : int64)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oneglshift s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oneglshift s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) (eval_shiftl s v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop Onegl (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Onegl (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.subl x (Vlong n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.subl x (Vlong n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x)","proofString":"rewrite Val.subl_addl_opp.\napply eval_addlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.addl x (Vlong (Int64.neg n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.addl x (Vlong (Int64.neg n2))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_addlimm; auto."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Val.subl_addl_l.\nrewrite Val.subl_addl_r.\nrewrite Val.addl_assoc.\nsimpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 (Val.addl v0 (Vlong n2))) (Vlong n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 (Val.addl v0 (Vlong n2))) (Vlong n1)) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Val.subl_addl_r.\nrewrite Val.addl_assoc.\nsimpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.addl (Val.subl v1 v0) (Vlong (Int64.neg n2))) (Vlong n1))\n    v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.addl (Val.subl v1 v0) (Vlong (Int64.neg n2))) (Vlong n1))\n    v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Val.addl_assoc.\nsimpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Val.addl (Vlong (Int64.neg n2)) (Vlong n1)))\n    v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Val.addl (Vlong (Int64.neg n2)) (Vlong n1)))\n    v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"simpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Vlong (Int64.add (Int64.neg n2) n1))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Vlong (Int64.add (Int64.neg n2) n1))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Vlong (Int64.add n1 (Int64.neg n2)))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Vlong (Int64.add n1 (Int64.neg n2)))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"rewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 v0) (Vlong (Int64.sub n1 n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 v0) (Vlong (Int64.sub n1 n2))) v","hypotheses":"(le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl (Val.addl v1 (Vlong n1)) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl (Val.addl v1 (Vlong n1)) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.subl_addl_l.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 y) (Vlong n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 y) (Vlong n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl x (Val.addl v1 (Vlong n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl x (Val.addl v1 (Vlong n2))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.subl_addl_r.\napply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl x v1) (Vlong (Int64.neg n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl x v1) (Vlong (Int64.neg n2))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osublshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Osublshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x (eval_shiftl s v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (x0 : extension) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osublext x0 a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x (eval_extend x0 v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Osublext x0 a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x (eval_extend x0 v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (x0 : extension) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 t3 : expr) (H : eval_expr ge sp e m le t1 x) (v1 v0 : val) (H3 : eval_expr ge sp e m le t2 v1) (H4 : eval_expr ge sp e m le t3 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omullsub (t1 ::: t2 ::: t3 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x (Val.mull v1 v0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omullsub (t1 ::: t2 ::: t3 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x (Val.mull v1 v0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 t2 t3 : expr) (H : eval_expr ge sp e m le t1 x) (v1 v0 : val) (H3 : eval_expr ge sp e m le t2 v1) (H4 : eval_expr ge sp e m le t3 v0)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Osubl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Osubl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.subl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if negb (Int.ltu n Int64.iwordsize')\n      then Eop Oshll (a ::: Eop (Ointconst n) Enil ::: Enil)\n      else\n       match shllimm_match a with\n       | shllimm_case1 n1 => Eop (Olongconst (Int64.shl' n1 n)) Enil\n       | shllimm_case2 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then shllimm_base t1 (Int.add a0 n)\n           else shllimm_base a n\n       | shllimm_case3 s t1 =>\n           Eop (Oshllzext s (mk_amount64 n)) (t1 ::: Enil)\n       | shllimm_case4 s t1 =>\n           Eop (Oshllsext s (mk_amount64 n)) (t1 ::: Enil)\n       | shllimm_case5 s a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then Eop (Oshllzext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n           else shllimm_base a n\n       | shllimm_case6 s a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then Eop (Oshllsext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n           else shllimm_base a n\n       | shllimm_case7 x0 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then Eop (Oextend x0 (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n           else shllimm_base a n\n       | shllimm_default e1 => shllimm_base e1 n\n       end) v /\\ Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if negb (Int.ltu n Int64.iwordsize')\n      then Eop Oshll (a ::: Eop (Ointconst n) Enil ::: Enil)\n      else\n       match shllimm_match a with\n       | shllimm_case1 n1 => Eop (Olongconst (Int64.shl' n1 n)) Enil\n       | shllimm_case2 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then shllimm_base t1 (Int.add a0 n)\n           else shllimm_base a n\n       | shllimm_case3 s t1 =>\n           Eop (Oshllzext s (mk_amount64 n)) (t1 ::: Enil)\n       | shllimm_case4 s t1 =>\n           Eop (Oshllsext s (mk_amount64 n)) (t1 ::: Enil)\n       | shllimm_case5 s a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then Eop (Oshllzext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n           else shllimm_base a n\n       | shllimm_case6 s a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then Eop (Oshllsext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n           else shllimm_base a n\n       | shllimm_case7 x0 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then Eop (Oextend x0 (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n           else shllimm_base a n\n       | shllimm_default e1 => shllimm_base e1 n\n       end) v /\\ Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val)","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; [| destruct (Int.ltu n Int64.iwordsize') eqn:L]; simpl.\nintros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero; auto.\ndestruct (shllimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\neconstructor; split.\neapply eval_shllimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split; [|eauto].\napply eval_shllimm_base; auto.\nEvalOp.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq; auto.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq; auto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.zero_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.sign_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by auto.\ndestruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\neconstructor; eauto using eval_shllimm_base.\nintros; TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero)","proofString":"intros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.shl'_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shll x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shll x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int64.shl'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.shl'_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match shllimm_match a with\n    | shllimm_case1 n1 => Eop (Olongconst (Int64.shl' n1 n)) Enil\n    | shllimm_case2 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then shllimm_base t1 (Int.add a0 n)\n        else shllimm_base a n\n    | shllimm_case3 s t1 => Eop (Oshllzext s (mk_amount64 n)) (t1 ::: Enil)\n    | shllimm_case4 s t1 => Eop (Oshllsext s (mk_amount64 n)) (t1 ::: Enil)\n    | shllimm_case5 s a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then Eop (Oshllzext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n        else shllimm_base a n\n    | shllimm_case6 s a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then Eop (Oshllsext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n        else shllimm_base a n\n    | shllimm_case7 x0 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then Eop (Oextend x0 (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n        else shllimm_base a n\n    | shllimm_default e1 => shllimm_base e1 n\n    end v /\\ Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match shllimm_match a with\n    | shllimm_case1 n1 => Eop (Olongconst (Int64.shl' n1 n)) Enil\n    | shllimm_case2 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then shllimm_base t1 (Int.add a0 n)\n        else shllimm_base a n\n    | shllimm_case3 s t1 => Eop (Oshllzext s (mk_amount64 n)) (t1 ::: Enil)\n    | shllimm_case4 s t1 => Eop (Oshllsext s (mk_amount64 n)) (t1 ::: Enil)\n    | shllimm_case5 s a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then Eop (Oshllzext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n        else shllimm_base a n\n    | shllimm_case6 s a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then Eop (Oshllsext s (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n        else shllimm_base a n\n    | shllimm_case7 x0 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then Eop (Oextend x0 (mk_amount64 (Int.add a0 n))) (t1 ::: Enil)\n        else shllimm_base a n\n    | shllimm_default e1 => shllimm_base e1 n\n    end v /\\ Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true)","proofString":"destruct (shllimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\neconstructor; split.\neapply eval_shllimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split; [|eauto].\napply eval_shllimm_base; auto.\nEvalOp.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq; auto.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq; auto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.zero_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.sign_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by auto.\ndestruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\neconstructor; eauto using eval_shllimm_base."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shl' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shll (Vlong n1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shl' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shll (Vlong n1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64)","proofString":"TrivialExists.\nsimpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64) : eval_operation ge sp (Olongconst (Int64.shl' n1 n)) nil m =\nSome (Val.shll (Vlong n1) (Vint n)).","conclusion":"eval_operation ge sp (Olongconst (Int64.shl' n1 n)) nil m =\nSome (Val.shll (Vlong n1) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64)","proofString":"simpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then shllimm_base t1 (Int.add a n)\n     else shllimm_base (Eop (Oshiftl Slsl a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then shllimm_base t1 (Int.add a n)\n     else shllimm_base (Eop (Oshiftl Slsl a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\neconstructor; split.\neapply eval_shllimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split; [|eauto].\napply eval_shllimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (shllimm_base t1 (Int.add a n)) v /\\\n  Val.lessdef (Val.shll (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm_base t1 (Int.add a n)) v /\\\n  Val.lessdef (Val.shll (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"econstructor; split.\neapply eval_shllimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Val.lessdef\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef).","conclusion":"Val.lessdef\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef)","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.shl' i a) n)\n   else Vundef)\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef).","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.shl' i a) n)\n   else Vundef)\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef)","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Val.lessdef (Vlong (Int64.shl' (Int64.shl' i a) n))\n  (Vlong (Int64.shl' i (Int.add a n))).","conclusion":"Val.lessdef (Vlong (Int64.shl' (Int64.shl' i a) n))\n  (Vlong (Int64.shl' i (Int.add a n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : exists v : val,\n  eval_expr ge sp e m le\n    (shllimm_base (Eop (Oshiftl Slsl a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (shllimm_base (Eop (Oshiftl Slsl a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"econstructor; split; [|eauto].\napply eval_shllimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : eval_expr ge sp e m le (shllimm_base (Eop (Oshiftl Slsl a) (t1 ::: Enil)) n)\n  (Val.shll (Val.shll v1 (Vint a)) (Vint n)).","conclusion":"eval_expr ge sp e m le (shllimm_base (Eop (Oshiftl Slsl a) (t1 ::: Enil)) n)\n  (Val.shll (Val.shll v1 (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"apply eval_shllimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : eval_expr ge sp e m le (Eop (Oshiftl Slsl a) (t1 ::: Enil))\n  (Val.shll v1 (Vint a)).","conclusion":"eval_expr ge sp e m le (Eop (Oshiftl Slsl a) (t1 ::: Enil))\n  (Val.shll v1 (Vint a))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshllzext s (mk_amount64 n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.zero_ext_l s v1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshllzext s (mk_amount64 n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.zero_ext_l s v1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount64_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Oshllzext s (mk_amount64 n)) (v1 :: nil) m =\nSome (Val.shll (Val.zero_ext_l s v1) (Vint n)).","conclusion":"eval_operation ge sp (Oshllzext s (mk_amount64 n)) (v1 :: nil) m =\nSome (Val.shll (Val.zero_ext_l s v1) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"simpl.\nrewrite mk_amount64_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some (Val.shll (Val.zero_ext_l s v1) (Vint (mk_amount64 n))) =\nSome (Val.shll (Val.zero_ext_l s v1) (Vint n)).","conclusion":"Some (Val.shll (Val.zero_ext_l s v1) (Vint (mk_amount64 n))) =\nSome (Val.shll (Val.zero_ext_l s v1) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite mk_amount64_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshllsext s (mk_amount64 n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.sign_ext_l s v1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshllsext s (mk_amount64 n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.sign_ext_l s v1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount64_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Oshllsext s (mk_amount64 n)) (v1 :: nil) m =\nSome (Val.shll (Val.sign_ext_l s v1) (Vint n)).","conclusion":"eval_operation ge sp (Oshllsext s (mk_amount64 n)) (v1 :: nil) m =\nSome (Val.shll (Val.sign_ext_l s v1) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"simpl.\nrewrite mk_amount64_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some (Val.shll (Val.sign_ext_l s v1) (Vint (mk_amount64 n))) =\nSome (Val.shll (Val.sign_ext_l s v1) (Vint n)).","conclusion":"Some (Val.shll (Val.sign_ext_l s v1) (Vint (mk_amount64 n))) =\nSome (Val.shll (Val.sign_ext_l s v1) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite mk_amount64_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then Eop (Oshllzext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)\n     else shllimm_base (Eop (Oshllzext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then Eop (Oshllzext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)\n     else shllimm_base (Eop (Oshllzext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.zero_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshllzext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshllzext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.zero_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : eval_operation ge sp (Oshllzext s (mk_amount64 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)).","conclusion":"eval_operation ge sp (Oshllzext s (mk_amount64 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"simpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.zero_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Some (Val.shll (Val.zero_ext_l s v1) (Vint (mk_amount64 (Int.add a n)))) =\nSome (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)).","conclusion":"Some (Val.shll (Val.zero_ext_l s v1) (Vint (mk_amount64 (Int.add a n)))) =\nSome (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite mk_amount64_eq by auto.\ndestruct (Val.zero_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Some (Val.shll (Val.zero_ext_l s v1) (Vint (Int.add a n))) =\nSome (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)).","conclusion":"Some (Val.shll (Val.zero_ext_l s v1) (Vint (Int.add a n))) =\nSome (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"destruct (Val.zero_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64) : Some\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n)).","conclusion":"Some\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64)","proofString":"rewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64) : Some (Vlong (Int64.shl' i (Int.add a n))) =\nSome (Vlong (Int64.shl' (Int64.shl' i a) n)).","conclusion":"Some (Vlong (Int64.shl' i (Int.add a n))) =\nSome (Vlong (Int64.shl' (Int64.shl' i a) n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64)","proofString":"rewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : exists v : val,\n  eval_expr ge sp e m le (shllimm_base (Eop (Oshllzext s a) (t1 ::: Enil)) n)\n    v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm_base (Eop (Oshllzext s a) (t1 ::: Enil)) n)\n    v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.zero_ext_l s v1) (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"econstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then Eop (Oshllsext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)\n     else shllimm_base (Eop (Oshllsext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then Eop (Oshllsext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)\n     else shllimm_base (Eop (Oshllsext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.sign_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshllsext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshllsext s (mk_amount64 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.sign_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : eval_operation ge sp (Oshllsext s (mk_amount64 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)).","conclusion":"eval_operation ge sp (Oshllsext s (mk_amount64 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"simpl.\nrewrite mk_amount64_eq by auto.\ndestruct (Val.sign_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Some (Val.shll (Val.sign_ext_l s v1) (Vint (mk_amount64 (Int.add a n)))) =\nSome (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)).","conclusion":"Some (Val.shll (Val.sign_ext_l s v1) (Vint (mk_amount64 (Int.add a n)))) =\nSome (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite mk_amount64_eq by auto.\ndestruct (Val.sign_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Some (Val.shll (Val.sign_ext_l s v1) (Vint (Int.add a n))) =\nSome (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)).","conclusion":"Some (Val.shll (Val.sign_ext_l s v1) (Vint (Int.add a n))) =\nSome (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"destruct (Val.sign_ext_l s v1); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64) : Some\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n)).","conclusion":"Some\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64)","proofString":"rewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64) : Some (Vlong (Int64.shl' i (Int.add a n))) =\nSome (Vlong (Int64.shl' (Int64.shl' i a) n)).","conclusion":"Some (Vlong (Int64.shl' i (Int.add a n))) =\nSome (Vlong (Int64.shl' (Int64.shl' i a) n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64)","proofString":"rewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : exists v : val,\n  eval_expr ge sp e m le (shllimm_base (Eop (Oshllsext s a) (t1 ::: Enil)) n)\n    v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm_base (Eop (Oshllsext s a) (t1 ::: Enil)) n)\n    v /\\\n  Val.lessdef (Val.shll (Val.shll (Val.sign_ext_l s v1) (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"econstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then Eop (Oextend x0 (mk_amount64 (Int.add a n))) (t1 ::: Enil)\n     else shllimm_base (Eop (Oextend x0 a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (eval_extend x0 v1 a) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then Eop (Oextend x0 (mk_amount64 (Int.add a n))) (t1 ::: Enil)\n     else shllimm_base (Eop (Oextend x0 a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shll (eval_extend x0 v1 a) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\nTrivialExists.\nsimpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by auto.\ndestruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range.\neconstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oextend x0 (mk_amount64 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (eval_extend x0 v1 a) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oextend x0 (mk_amount64 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shll (eval_extend x0 v1 a) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"TrivialExists.\nsimpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by auto.\ndestruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : eval_operation ge sp (Oextend x0 (mk_amount64 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shll (eval_extend x0 v1 a) (Vint n)).","conclusion":"eval_operation ge sp (Oextend x0 (mk_amount64 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shll (eval_extend x0 v1 a) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"simpl.\nunfold eval_extend.\nrewrite mk_amount64_eq by auto.\ndestruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Some (eval_extend x0 v1 (mk_amount64 (Int.add a n))) =\nSome (Val.shll (eval_extend x0 v1 a) (Vint n)).","conclusion":"Some (eval_extend x0 v1 (mk_amount64 (Int.add a n))) =\nSome (Val.shll (eval_extend x0 v1 a) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"unfold eval_extend.\nrewrite mk_amount64_eq by auto.\ndestruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Some\n  (Val.shll\n     match x0 with\n     | Xsgn32 => Val.longofint v1\n     | Xuns32 => Val.longofintu v1\n     end (Vint (mk_amount64 (Int.add a n)))) =\nSome\n  (Val.shll\n     (Val.shll\n        match x0 with\n        | Xsgn32 => Val.longofint v1\n        | Xuns32 => Val.longofintu v1\n        end (Vint a)) (Vint n)).","conclusion":"Some\n  (Val.shll\n     match x0 with\n     | Xsgn32 => Val.longofint v1\n     | Xuns32 => Val.longofintu v1\n     end (Vint (mk_amount64 (Int.add a n)))) =\nSome\n  (Val.shll\n     (Val.shll\n        match x0 with\n        | Xsgn32 => Val.longofint v1\n        | Xuns32 => Val.longofintu v1\n        end (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite mk_amount64_eq by auto.\ndestruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Some\n  (Val.shll\n     match x0 with\n     | Xsgn32 => Val.longofint v1\n     | Xuns32 => Val.longofintu v1\n     end (Vint (Int.add a n))) =\nSome\n  (Val.shll\n     (Val.shll\n        match x0 with\n        | Xsgn32 => Val.longofint v1\n        | Xuns32 => Val.longofintu v1\n        end (Vint a)) (Vint n)).","conclusion":"Some\n  (Val.shll\n     match x0 with\n     | Xsgn32 => Val.longofint v1\n     | Xuns32 => Val.longofintu v1\n     end (Vint (Int.add a n))) =\nSome\n  (Val.shll\n     (Val.shll\n        match x0 with\n        | Xsgn32 => Val.longofint v1\n        | Xuns32 => Val.longofintu v1\n        end (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"destruct (match x0 with Xsgn32 => Val.longofint v1 | Xuns32 => Val.longofintu v1 end); simpl; auto.\nrewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64) : Some\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n)).","conclusion":"Some\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shl' i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shll\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64)","proofString":"rewrite a64_range; simpl; rewrite L, L2.\nrewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64) : Some (Vlong (Int64.shl' i (Int.add a n))) =\nSome (Vlong (Int64.shl' (Int64.shl' i a) n)).","conclusion":"Some (Vlong (Int64.shl' i (Int.add a n))) =\nSome (Vlong (Int64.shl' (Int64.shl' i a) n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) (i : int64)","proofString":"rewrite Int64.shl'_shl'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : exists v : val,\n  eval_expr ge sp e m le (shllimm_base (Eop (Oextend x0 a) (t1 ::: Enil)) n)\n    v /\\ Val.lessdef (Val.shll (eval_extend x0 v1 a) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm_base (Eop (Oextend x0 a) (t1 ::: Enil)) n)\n    v /\\ Val.lessdef (Val.shll (eval_extend x0 v1 a) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (x0 : extension) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"econstructor; split.\neapply eval_shllimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (e1 : expr) (H0 : eval_expr ge sp e m le e1 x) : exists v : val,\n  eval_expr ge sp e m le (shllimm_base e1 n) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm_base e1 n) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (e1 : expr) (H0 : eval_expr ge sp e m le e1 x)","proofString":"econstructor; eauto using eval_shllimm_base."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = false) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop Oshll (a ::: Eop (Ointconst n) Enil ::: Enil))\n    v /\\ Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop Oshll (a ::: Eop (Ointconst n) Enil ::: Enil))\n    v /\\ Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = false)","proofString":"intros; TrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true) : eval_operation ge sp (Oshiftl Slsr (mk_amount64 n)) (x :: nil) m =\nSome (Val.shrlu x (Vint n)).","conclusion":"eval_operation ge sp (Oshiftl Slsr (mk_amount64 n)) (x :: nil) m =\nSome (Val.shrlu x (Vint n))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true)","proofString":"simpl.\nrewrite mk_amount64_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true) : Some (Val.shrlu x (Vint (mk_amount64 n))) = Some (Val.shrlu x (Vint n)).","conclusion":"Some (Val.shrlu x (Vint (mk_amount64 n))) = Some (Val.shrlu x (Vint n))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true)","proofString":"rewrite mk_amount64_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true) : Some (Val.shrlu x (Vint n)) = Some (Val.shrlu x (Vint n)).","conclusion":"Some (Val.shrlu x (Vint n)) = Some (Val.shrlu x (Vint n))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true)","proofString":"auto."},{"statement":"(y z : int) (H : Int.ltu y Int64.iwordsize' = true) (H0 : Int.ltu z Int64.iwordsize' = true) (H1 : Int.unsigned y <= Int.unsigned z) : Int.ltu (Int.sub z y) Int64.iwordsize' = true.","conclusion":"Int.ltu (Int.sub z y) Int64.iwordsize' = true","hypotheses":"(y z : int) (H : Int.ltu y Int64.iwordsize' = true) (H0 : Int.ltu z Int64.iwordsize' = true) (H1 : Int.unsigned y <= Int.unsigned z)","proofString":"unfold Int.ltu; apply zlt_true.\napply Int.ltu_inv in H.\napply Int.ltu_inv in H0.\nchange (Int.unsigned Int64.iwordsize') with Int64.zwordsize in *.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\nassert (Int64.zwordsize < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(y z : int) (H : Int.ltu y Int64.iwordsize' = true) (H0 : Int.ltu z Int64.iwordsize' = true) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int.unsigned Int64.iwordsize'.","conclusion":"Int.unsigned (Int.sub z y) < Int.unsigned Int64.iwordsize'","hypotheses":"(y z : int) (H : Int.ltu y Int64.iwordsize' = true) (H0 : Int.ltu z Int64.iwordsize' = true) (H1 : Int.unsigned y <= Int.unsigned z)","proofString":"apply Int.ltu_inv in H.\napply Int.ltu_inv in H0.\nchange (Int.unsigned Int64.iwordsize') with Int64.zwordsize in *.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\nassert (Int64.zwordsize < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int.unsigned Int64.iwordsize') (H0 : Int.ltu z Int64.iwordsize' = true) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int.unsigned Int64.iwordsize'.","conclusion":"Int.unsigned (Int.sub z y) < Int.unsigned Int64.iwordsize'","hypotheses":"(y z : int) (H : 0 <= Int.unsigned y < Int.unsigned Int64.iwordsize') (H0 : Int.ltu z Int64.iwordsize' = true) (H1 : Int.unsigned y <= Int.unsigned z)","proofString":"apply Int.ltu_inv in H0.\nchange (Int.unsigned Int64.iwordsize') with Int64.zwordsize in *.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\nassert (Int64.zwordsize < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int.unsigned Int64.iwordsize') (H0 : 0 <= Int.unsigned z < Int.unsigned Int64.iwordsize') (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int.unsigned Int64.iwordsize'.","conclusion":"Int.unsigned (Int.sub z y) < Int.unsigned Int64.iwordsize'","hypotheses":"(y z : int) (H : 0 <= Int.unsigned y < Int.unsigned Int64.iwordsize') (H0 : 0 <= Int.unsigned z < Int.unsigned Int64.iwordsize') (H1 : Int.unsigned y <= Int.unsigned z)","proofString":"change (Int.unsigned Int64.iwordsize') with Int64.zwordsize in *.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\nassert (Int64.zwordsize < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int64.zwordsize.","conclusion":"Int.unsigned (Int.sub z y) < Int64.zwordsize","hypotheses":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z)","proofString":"unfold Int.sub; rewrite Int.unsigned_repr.\nlia.\nassert (Int64.zwordsize < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned z - Int.unsigned y < Int64.zwordsize.","conclusion":"Int.unsigned z - Int.unsigned y < Int64.zwordsize","hypotheses":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z)","proofString":"lia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) : 0 <= Int.unsigned z - Int.unsigned y <= Int.max_unsigned.","conclusion":"0 <= Int.unsigned z - Int.unsigned y <= Int.max_unsigned","hypotheses":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z)","proofString":"assert (Int64.zwordsize < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) (H2 : Int64.zwordsize < Int.max_unsigned) : 0 <= Int.unsigned z - Int.unsigned y <= Int.max_unsigned.","conclusion":"0 <= Int.unsigned z - Int.unsigned y <= Int.max_unsigned","hypotheses":"(y z : int) (H : 0 <= Int.unsigned y < Int64.zwordsize) (H0 : 0 <= Int.unsigned z < Int64.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) (H2 : Int64.zwordsize < Int.max_unsigned)","proofString":"lia."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true) : eval_operation ge sp (Oshiftl Sasr (mk_amount64 n)) (x :: nil) m =\nSome (Val.shrl x (Vint n)).","conclusion":"eval_operation ge sp (Oshiftl Sasr (mk_amount64 n)) (x :: nil) m =\nSome (Val.shrl x (Vint n))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true)","proofString":"simpl.\nrewrite mk_amount64_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true) : Some (Val.shrl x (Vint (mk_amount64 n))) = Some (Val.shrl x (Vint n)).","conclusion":"Some (Val.shrl x (Vint (mk_amount64 n))) = Some (Val.shrl x (Vint n))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true)","proofString":"rewrite mk_amount64_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true) : Some (Val.shrl x (Vint n)) = Some (Val.shrl x (Vint n)).","conclusion":"Some (Val.shrl x (Vint n)) = Some (Val.shrl x (Vint n))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int64.iwordsize' = true)","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if negb (Int.ltu n Int64.iwordsize')\n      then Eop Oshrl (a ::: Eop (Ointconst n) Enil ::: Enil)\n      else\n       match shrlimm_match a with\n       | shrlimm_case1 n1 => Eop (Olongconst (Int64.shr' n1 n)) Enil\n       | shrlimm_case2 a0 t1 =>\n           if Int.ltu n a0\n           then\n            Eop\n              (Oshllsext (Int64.zwordsize - Int.unsigned a0)\n                 (mk_amount64 (Int.sub a0 n))) (t1 ::: Enil)\n           else\n            Eop\n              (Osextshrl (mk_amount64 (Int.sub n a0))\n                 (Int64.zwordsize - Int.unsigned n)) \n              (t1 ::: Enil)\n       | shrlimm_case3 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then shrlimm_base t1 (Int.add a0 n)\n           else shrlimm_base a n\n       | shrlimm_case4 s t1 =>\n           if zlt (Int.unsigned n) s && zlt s Int64.zwordsize\n           then\n            Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n))\n              (t1 ::: Enil)\n           else shrlimm_base a n\n       | shrlimm_default e1 => shrlimm_base e1 n\n       end) v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if negb (Int.ltu n Int64.iwordsize')\n      then Eop Oshrl (a ::: Eop (Ointconst n) Enil ::: Enil)\n      else\n       match shrlimm_match a with\n       | shrlimm_case1 n1 => Eop (Olongconst (Int64.shr' n1 n)) Enil\n       | shrlimm_case2 a0 t1 =>\n           if Int.ltu n a0\n           then\n            Eop\n              (Oshllsext (Int64.zwordsize - Int.unsigned a0)\n                 (mk_amount64 (Int.sub a0 n))) (t1 ::: Enil)\n           else\n            Eop\n              (Osextshrl (mk_amount64 (Int.sub n a0))\n                 (Int64.zwordsize - Int.unsigned n)) \n              (t1 ::: Enil)\n       | shrlimm_case3 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int64.iwordsize'\n           then shrlimm_base t1 (Int.add a0 n)\n           else shrlimm_base a n\n       | shrlimm_case4 s t1 =>\n           if zlt (Int.unsigned n) s && zlt s Int64.zwordsize\n           then\n            Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n))\n              (t1 ::: Enil)\n           else shrlimm_base a n\n       | shrlimm_default e1 => shrlimm_base e1 n\n       end) v /\\ Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val)","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; [| destruct (Int.ltu n Int64.iwordsize') eqn:L]; simpl.\nintros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.shr'_zero; auto.\ndestruct (shrlimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu n a) eqn:L2.\nassert (L3: Int.ltu (Int.sub a n) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto.\nassert (L3: Int.ltu (Int.sub n a) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\neconstructor; split.\neapply eval_shrlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shr'_shr'; auto using a64_range.\neconstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp.\ndestruct (zlt (Int.unsigned n) s && zlt s Int64.zwordsize) eqn:E.\nInvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount64_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia.\neconstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp.\neconstructor; eauto using eval_shrlimm_base.\nintros; TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero)","proofString":"intros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.shr'_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.shr'_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shrl x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shrl x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int64.shr'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.shr'_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match shrlimm_match a with\n    | shrlimm_case1 n1 => Eop (Olongconst (Int64.shr' n1 n)) Enil\n    | shrlimm_case2 a0 t1 =>\n        if Int.ltu n a0\n        then\n         Eop\n           (Oshllsext (Int64.zwordsize - Int.unsigned a0)\n              (mk_amount64 (Int.sub a0 n))) (t1 ::: Enil)\n        else\n         Eop\n           (Osextshrl (mk_amount64 (Int.sub n a0))\n              (Int64.zwordsize - Int.unsigned n)) \n           (t1 ::: Enil)\n    | shrlimm_case3 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then shrlimm_base t1 (Int.add a0 n)\n        else shrlimm_base a n\n    | shrlimm_case4 s t1 =>\n        if zlt (Int.unsigned n) s && zlt s Int64.zwordsize\n        then\n         Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)\n        else shrlimm_base a n\n    | shrlimm_default e1 => shrlimm_base e1 n\n    end v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match shrlimm_match a with\n    | shrlimm_case1 n1 => Eop (Olongconst (Int64.shr' n1 n)) Enil\n    | shrlimm_case2 a0 t1 =>\n        if Int.ltu n a0\n        then\n         Eop\n           (Oshllsext (Int64.zwordsize - Int.unsigned a0)\n              (mk_amount64 (Int.sub a0 n))) (t1 ::: Enil)\n        else\n         Eop\n           (Osextshrl (mk_amount64 (Int.sub n a0))\n              (Int64.zwordsize - Int.unsigned n)) \n           (t1 ::: Enil)\n    | shrlimm_case3 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int64.iwordsize'\n        then shrlimm_base t1 (Int.add a0 n)\n        else shrlimm_base a n\n    | shrlimm_case4 s t1 =>\n        if zlt (Int.unsigned n) s && zlt s Int64.zwordsize\n        then\n         Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)\n        else shrlimm_base a n\n    | shrlimm_default e1 => shrlimm_base e1 n\n    end v /\\ Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true)","proofString":"destruct (shrlimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu n a) eqn:L2.\nassert (L3: Int.ltu (Int.sub a n) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto.\nassert (L3: Int.ltu (Int.sub n a) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto.\ndestruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\neconstructor; split.\neapply eval_shrlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shr'_shr'; auto using a64_range.\neconstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp.\ndestruct (zlt (Int.unsigned n) s && zlt s Int64.zwordsize) eqn:E.\nInvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount64_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia.\neconstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp.\neconstructor; eauto using eval_shrlimm_base."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shr' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shrl (Vlong n1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shr' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shrl (Vlong n1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64)","proofString":"TrivialExists.\nsimpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64) : eval_operation ge sp (Olongconst (Int64.shr' n1 n)) nil m =\nSome (Val.shrl (Vlong n1) (Vint n)).","conclusion":"eval_operation ge sp (Olongconst (Int64.shr' n1 n)) nil m =\nSome (Val.shrl (Vlong n1) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (n1 : int64)","proofString":"simpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu n a\n     then\n      Eop\n        (Oshllsext (Int64.zwordsize - Int.unsigned a)\n           (mk_amount64 (Int.sub a n))) (t1 ::: Enil)\n     else\n      Eop\n        (Osextshrl (mk_amount64 (Int.sub n a))\n           (Int64.zwordsize - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu n a\n     then\n      Eop\n        (Oshllsext (Int64.zwordsize - Int.unsigned a)\n           (mk_amount64 (Int.sub a n))) (t1 ::: Enil)\n     else\n      Eop\n        (Osextshrl (mk_amount64 (Int.sub n a))\n           (Int64.zwordsize - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (Int.ltu n a) eqn:L2.\nassert (L3: Int.ltu (Int.sub a n) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto.\nassert (L3: Int.ltu (Int.sub n a) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Oshllsext (Int64.zwordsize - Int.unsigned a)\n          (mk_amount64 (Int.sub a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Oshllsext (Int64.zwordsize - Int.unsigned a)\n          (mk_amount64 (Int.sub a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true)","proofString":"assert (L3: Int.ltu (Int.sub a n) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) : Int.ltu (Int.sub a n) Int64.iwordsize' = true.","conclusion":"Int.ltu (Int.sub a n) Int64.iwordsize' = true","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true)","proofString":"apply sub_shift_amount; auto using a64_range.\napply Int.ltu_inv in L2.\nlia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) : Int.unsigned n <= Int.unsigned a.","conclusion":"Int.unsigned n <= Int.unsigned a","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true)","proofString":"apply Int.ltu_inv in L2.\nlia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : 0 <= Int.unsigned n < Int.unsigned a) : Int.unsigned n <= Int.unsigned a.","conclusion":"Int.unsigned n <= Int.unsigned a","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : 0 <= Int.unsigned n < Int.unsigned a)","proofString":"lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Oshllsext (Int64.zwordsize - Int.unsigned a)\n          (mk_amount64 (Int.sub a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Oshllsext (Int64.zwordsize - Int.unsigned a)\n          (mk_amount64 (Int.sub a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true)","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true) : Val.lessdef\n  (Val.shrl\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (mk_amount64 (Int.sub a n)) Int64.iwordsize'\n   then\n    Vlong\n      (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n         (mk_amount64 (Int.sub a n)))\n   else Vundef).","conclusion":"Val.lessdef\n  (Val.shrl\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (mk_amount64 (Int.sub a n)) Int64.iwordsize'\n   then\n    Vlong\n      (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n         (mk_amount64 (Int.sub a n)))\n   else Vundef)","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true)","proofString":"rewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true) : Val.lessdef (Val.shrl (Vlong (Int64.shl' i a)) (Vint n))\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n))).","conclusion":"Val.lessdef (Val.shrl (Vlong (Int64.shl' i a)) (Vint n))\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true)","proofString":"simpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.shl' i a) n)\n   else Vundef)\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n))).","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.shl' i a) n)\n   else Vundef)\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true)","proofString":"rewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true) : Val.lessdef (Vlong (Int64.shr' (Int64.shl' i a) n))\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n))).","conclusion":"Val.lessdef (Vlong (Int64.shr' (Int64.shl' i a) n))\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true)","proofString":"rewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true) : Val.lessdef\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n)))\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n))).","conclusion":"Val.lessdef\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n)))\n  (Vlong\n     (Int64.shl' (Int64.sign_ext (Int64.zwordsize - Int.unsigned a) i)\n        (Int.sub a n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int64.iwordsize' = true)","proofString":"auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Osextshrl (mk_amount64 (Int.sub n a))\n          (Int64.zwordsize - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Osextshrl (mk_amount64 (Int.sub n a))\n          (Int64.zwordsize - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false)","proofString":"assert (L3: Int.ltu (Int.sub n a) Int64.iwordsize' = true).\napply sub_shift_amount; auto using a64_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) : Int.ltu (Int.sub n a) Int64.iwordsize' = true.","conclusion":"Int.ltu (Int.sub n a) Int64.iwordsize' = true","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false)","proofString":"apply sub_shift_amount; auto using a64_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) : Int.unsigned a <= Int.unsigned n.","conclusion":"Int.unsigned a <= Int.unsigned n","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false)","proofString":"unfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : (if zlt (Int.unsigned n) (Int.unsigned a) then true else false) = false) : Int.unsigned a <= Int.unsigned n.","conclusion":"Int.unsigned a <= Int.unsigned n","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : (if zlt (Int.unsigned n) (Int.unsigned a) then true else false) = false)","proofString":"destruct zlt in L2; discriminate || lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Osextshrl (mk_amount64 (Int.sub n a))\n          (Int64.zwordsize - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Osextshrl (mk_amount64 (Int.sub n a))\n          (Int64.zwordsize - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.shll v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true)","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true) : Val.lessdef\n  (Val.shrl\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))\n  (Val.sign_ext_l (Int64.zwordsize - Int.unsigned n)\n     (if Int.ltu (mk_amount64 (Int.sub n a)) Int64.iwordsize'\n      then Vlong (Int64.shr' i (mk_amount64 (Int.sub n a)))\n      else Vundef)).","conclusion":"Val.lessdef\n  (Val.shrl\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shl' i a) else Vundef)\n     (Vint n))\n  (Val.sign_ext_l (Int64.zwordsize - Int.unsigned n)\n     (if Int.ltu (mk_amount64 (Int.sub n a)) Int64.iwordsize'\n      then Vlong (Int64.shr' i (mk_amount64 (Int.sub n a)))\n      else Vundef))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true)","proofString":"rewrite mk_amount64_eq, L3, a64_range by auto.\nsimpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true) : Val.lessdef (Val.shrl (Vlong (Int64.shl' i a)) (Vint n))\n  (Val.sign_ext_l (Int64.zwordsize - Int.unsigned n)\n     (Vlong (Int64.shr' i (Int.sub n a)))).","conclusion":"Val.lessdef (Val.shrl (Vlong (Int64.shl' i a)) (Vint n))\n  (Val.sign_ext_l (Int64.zwordsize - Int.unsigned n)\n     (Vlong (Int64.shr' i (Int.sub n a))))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true)","proofString":"simpl.\nrewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.shl' i a) n)\n   else Vundef)\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a)))).","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.shl' i a) n)\n   else Vundef)\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a))))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true)","proofString":"rewrite L.\nrewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true) : Val.lessdef (Vlong (Int64.shr' (Int64.shl' i a) n))\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a)))).","conclusion":"Val.lessdef (Vlong (Int64.shr' (Int64.shl' i a) n))\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a))))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true)","proofString":"rewrite Int64.shr'_shl', L2 by auto using a64_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true) : Val.lessdef\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a))))\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a)))).","conclusion":"Val.lessdef\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a))))\n  (Vlong\n     (Int64.sign_ext (Int64.zwordsize - Int.unsigned n)\n        (Int64.shr' i (Int.sub n a))))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int64.iwordsize' = true)","proofString":"auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then shrlimm_base t1 (Int.add a n)\n     else shrlimm_base (Eop (Oshiftl Sasr a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.shrl v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int64.iwordsize'\n     then shrlimm_base t1 (Int.add a n)\n     else shrlimm_base (Eop (Oshiftl Sasr a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.shrl v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (Int.ltu (Int.add a n) Int64.iwordsize') eqn:L2.\neconstructor; split.\neapply eval_shrlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shr'_shr'; auto using a64_range.\neconstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (shrlimm_base t1 (Int.add a n)) v /\\\n  Val.lessdef (Val.shrl (Val.shrl v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrlimm_base t1 (Int.add a n)) v /\\\n  Val.lessdef (Val.shrl (Val.shrl v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"econstructor; split.\neapply eval_shrlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shr'_shr'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Val.lessdef\n  (Val.shrl\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shr' i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shr' i (Int.add a n))\n   else Vundef).","conclusion":"Val.lessdef\n  (Val.shrl\n     (if Int.ltu a Int64.iwordsize' then Vlong (Int64.shr' i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shr' i (Int.add a n))\n   else Vundef)","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite a64_range; simpl.\nrewrite L, L2.\nrewrite Int64.shr'_shr'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.shr' i a) n)\n   else Vundef)\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shr' i (Int.add a n))\n   else Vundef).","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.shr' i a) n)\n   else Vundef)\n  (if Int.ltu (Int.add a n) Int64.iwordsize'\n   then Vlong (Int64.shr' i (Int.add a n))\n   else Vundef)","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite L, L2.\nrewrite Int64.shr'_shr'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true) : Val.lessdef (Vlong (Int64.shr' (Int64.shr' i a) n))\n  (Vlong (Int64.shr' i (Int.add a n))).","conclusion":"Val.lessdef (Vlong (Int64.shr' (Int64.shr' i a) n))\n  (Vlong (Int64.shr' i (Int.add a n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = true)","proofString":"rewrite Int64.shr'_shr'; auto using a64_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : exists v : val,\n  eval_expr ge sp e m le\n    (shrlimm_base (Eop (Oshiftl Sasr a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.shrl v1 (Vint a)) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (shrlimm_base (Eop (Oshiftl Sasr a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.shrl v1 (Vint a)) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"econstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : eval_expr ge sp e m le (shrlimm_base (Eop (Oshiftl Sasr a) (t1 ::: Enil)) n)\n  (Val.shrl (Val.shrl v1 (Vint a)) (Vint n)).","conclusion":"eval_expr ge sp e m le (shrlimm_base (Eop (Oshiftl Sasr a) (t1 ::: Enil)) n)\n  (Val.shrl (Val.shrl v1 (Vint a)) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"apply eval_shrlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false) : eval_expr ge sp e m le (Eop (Oshiftl Sasr a) (t1 ::: Enil))\n  (Val.shrl v1 (Vint a)).","conclusion":"eval_expr ge sp e m le (Eop (Oshiftl Sasr a) (t1 ::: Enil))\n  (Val.shrl v1 (Vint a))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (a : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int64.iwordsize' = false)","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if zlt (Int.unsigned n) s && zlt s Int64.zwordsize\n     then Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)\n     else shrlimm_base (Eop (Osextl s) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if zlt (Int.unsigned n) s && zlt s Int64.zwordsize\n     then Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)\n     else shrlimm_base (Eop (Osextl s) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (zlt (Int.unsigned n) s && zlt s Int64.zwordsize) eqn:E.\nInvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount64_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia.\neconstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = true)","proofString":"InvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount64_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Osextshrl (mk_amount64 n) (s - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s)","proofString":"econstructor; split.\nEvalOp.\nrewrite mk_amount64_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s) : Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n))\n  (Val.sign_ext_l (s - Int.unsigned n) (Val.shrl v1 (Vint n))).","conclusion":"Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n))\n  (Val.sign_ext_l (s - Int.unsigned n) (Val.shrl v1 (Vint n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s)","proofString":"destruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.sign_ext s i) n)\n   else Vundef)\n  (Val.sign_ext_l (s - Int.unsigned n)\n     (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef)).","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.sign_ext s i) n)\n   else Vundef)\n  (Val.sign_ext_l (s - Int.unsigned n)\n     (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s)","proofString":"rewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s) : Val.lessdef (Vlong (Int64.shr' (Int64.sign_ext s i) n))\n  (Vlong (Int64.sign_ext (s - Int.unsigned n) (Int64.shr' i n))).","conclusion":"Val.lessdef (Vlong (Int64.shr' (Int64.sign_ext s i) n))\n  (Vlong (Int64.sign_ext (s - Int.unsigned n) (Int64.shr' i n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s)","proofString":"set (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int64.shr'_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s) (s' : Z) : Val.lessdef (Vlong (Int64.sign_ext s' (Int64.shr' i n)))\n  (Vlong (Int64.sign_ext s' (Int64.shr' i n))).","conclusion":"Val.lessdef (Vlong (Int64.sign_ext s' (Int64.shr' i n)))\n  (Vlong (Int64.sign_ext s' (Int64.shr' i n)))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (H1 : s < Int64.zwordsize) (H0 : Int.unsigned n < s) (s' : Z)","proofString":"auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = false) : exists v : val,\n  eval_expr ge sp e m le (shrlimm_base (Eop (Osextl s) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrlimm_base (Eop (Osextl s) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shrl (Val.sign_ext_l s v1) (Vint n)) v","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = false)","proofString":"econstructor; split; [|eauto].\napply eval_shrlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = false) : eval_expr ge sp e m le (shrlimm_base (Eop (Osextl s) (t1 ::: Enil)) n)\n  (Val.shrl (Val.sign_ext_l s v1) (Vint n)).","conclusion":"eval_expr ge sp e m le (shrlimm_base (Eop (Osextl s) (t1 ::: Enil)) n)\n  (Val.shrl (Val.sign_ext_l s v1) (Vint n))","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = false)","proofString":"apply eval_shrlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = false) : eval_expr ge sp e m le (Eop (Osextl s) (t1 ::: Enil)) (Val.sign_ext_l s v1).","conclusion":"eval_expr ge sp e m le (Eop (Osextl s) (t1 ::: Enil)) (Val.sign_ext_l s v1)","hypotheses":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int64.zwordsize = false)","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (e1 : expr) (H0 : eval_expr ge sp e m le e1 x) : exists v : val,\n  eval_expr ge sp e m le (shrlimm_base e1 n) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrlimm_base e1 n) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = true) (e1 : expr) (H0 : eval_expr ge sp e m le e1 x)","proofString":"econstructor; eauto using eval_shrlimm_base."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = false) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop Oshrl (a ::: Eop (Ointconst n) Enil ::: Enil))\n    v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop Oshrl (a ::: Eop (Ointconst n) Enil ::: Enil))\n    v /\\ Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int64.iwordsize' = false)","proofString":"intros; TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    match Int64.one_bits' n with\n    | nil => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    | i :: nil => shllimm a i\n    | i :: j :: nil =>\n        Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))\n    | i :: j :: _ :: _ => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int64.one_bits' n with\n    | nil => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    | i :: nil => shllimm a i\n    | i :: j :: nil =>\n        Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))\n    | i :: j :: _ :: _ => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"assert (DFL: exists v, eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)) v /\\ Val.lessdef (Val.mull x (Vlong n)) v).\nrewrite Val.mull_commut; TrivialExists.\ngeneralize (Int64.one_bits'_decomp n); generalize (Int64.one_bits'_range n);  destruct (Int64.one_bits' n) as [ | i [ | j []]]; intros P Q.\napply DFL.\nreplace (Val.mull x (Vlong n)) with (Val.shll x (Vint i)).\napply eval_shllimm; auto.\nsimpl in Q.\ndestruct x; auto; simpl.\nrewrite P by auto with coqlib.\nrewrite Q, Int64.add_zero, Int64.shl'_mul.\nauto.\nexploit (eval_shllimm i (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v1 [A1 B1]].\nexploit (eval_shllimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_addl (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto.\napply DFL."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"rewrite Val.mull_commut; TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) : exists v : val,\n  eval_expr ge sp e m le\n    match Int64.one_bits' n with\n    | nil => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    | i :: nil => shllimm a i\n    | i :: j :: nil =>\n        Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))\n    | i :: j :: _ :: _ => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int64.one_bits' n with\n    | nil => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    | i :: nil => shllimm a i\n    | i :: j :: nil =>\n        Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))\n    | i :: j :: _ :: _ => Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil)\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v)","proofString":"generalize (Int64.one_bits'_decomp n); generalize (Int64.one_bits'_range n);  destruct (Int64.one_bits' n) as [ | i [ | j []]]; intros P Q.\napply DFL.\nreplace (Val.mull x (Vlong n)) with (Val.shll x (Vint i)).\napply eval_shllimm; auto.\nsimpl in Q.\ndestruct x; auto; simpl.\nrewrite P by auto with coqlib.\nrewrite Q, Int64.add_zero, Int64.shl'_mul.\nauto.\nexploit (eval_shllimm i (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v1 [A1 B1]].\nexploit (eval_shllimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_addl (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto.\napply DFL."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (P : forall i : int, In i nil -> Int.ltu i Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' nil) : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (P : forall i : int, In i nil -> Int.ltu i Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' nil)","proofString":"apply DFL."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: nil)) : exists v : val,\n  eval_expr ge sp e m le (shllimm a i) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm a i) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: nil))","proofString":"replace (Val.mull x (Vlong n)) with (Val.shll x (Vint i)).\napply eval_shllimm; auto.\nsimpl in Q.\ndestruct x; auto; simpl.\nrewrite P by auto with coqlib.\nrewrite Q, Int64.add_zero, Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: nil)) : exists v : val,\n  eval_expr ge sp e m le (shllimm a i) v /\\\n  Val.lessdef (Val.shll x (Vint i)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm a i) v /\\\n  Val.lessdef (Val.shll x (Vint i)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: nil))","proofString":"apply eval_shllimm; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: nil)) : Val.shll x (Vint i) = Val.mull x (Vlong n).","conclusion":"Val.shll x (Vint i) = Val.mull x (Vlong n)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: nil))","proofString":"simpl in Q.\ndestruct x; auto; simpl.\nrewrite P by auto with coqlib.\nrewrite Q, Int64.add_zero, Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : Val.shll x (Vint i) = Val.mull x (Vlong n).","conclusion":"Val.shll x (Vint i) = Val.mull x (Vlong n)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero)","proofString":"destruct x; auto; simpl.\nrewrite P by auto with coqlib.\nrewrite Q, Int64.add_zero, Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v) (i : int) (P : forall i1 : int, In i1 (i :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : (if Int.ltu i Int64.iwordsize' then Vlong (Int64.shl' i0 i) else Vundef) =\nVlong (Int64.mul i0 n).","conclusion":"(if Int.ltu i Int64.iwordsize' then Vlong (Int64.shl' i0 i) else Vundef) =\nVlong (Int64.mul i0 n)","hypotheses":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v) (i : int) (P : forall i1 : int, In i1 (i :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero)","proofString":"rewrite P by auto with coqlib.\nrewrite Q, Int64.add_zero, Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v) (i : int) (P : forall i1 : int, In i1 (i :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : Vlong (Int64.shl' i0 i) = Vlong (Int64.mul i0 n).","conclusion":"Vlong (Int64.shl' i0 i) = Vlong (Int64.mul i0 n)","hypotheses":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v) (i : int) (P : forall i1 : int, In i1 (i :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero)","proofString":"rewrite Q, Int64.add_zero, Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v) (i : int) (P : forall i1 : int, In i1 (i :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero) : Vlong (Int64.mul i0 (Int64.shl' Int64.one i)) =\nVlong (Int64.mul i0 (Int64.shl' Int64.one i)).","conclusion":"Vlong (Int64.mul i0 (Int64.shl' Int64.one i)) =\nVlong (Int64.mul i0 (Int64.shl' Int64.one i))","hypotheses":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v) (i : int) (P : forall i1 : int, In i1 (i :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.add (Int64.shl' Int64.one i) Int64.zero)","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil))","proofString":"exploit (eval_shllimm i (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v1 [A1 B1]].\nexploit (eval_shllimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_addl (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) : eval_expr ge sp e m (x :: le) (Eletvar 0) x.","conclusion":"eval_expr ge sp e m (x :: le) (Eletvar 0) x","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil))","proofString":"constructor; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) : (exists v : val,\n   eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v /\\\n   Val.lessdef (Val.shll x (Vint i)) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v /\\\n   Val.lessdef (Val.shll x (Vint i)) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil))","proofString":"intros [v1 [A1 B1]].\nexploit (eval_shllimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_addl (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1)","proofString":"exploit (eval_shllimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_addl (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) : eval_expr ge sp e m (x :: le) (Eletvar 0) x.","conclusion":"eval_expr ge sp e m (x :: le) (Eletvar 0) x","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1)","proofString":"constructor; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) : (exists v : val,\n   eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v /\\\n   Val.lessdef (Val.shll x (Vint j)) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v /\\\n   Val.lessdef (Val.shll x (Vint j)) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1)","proofString":"intros [v2 [A2 B2]].\nexploit (eval_addl (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2)","proofString":"exploit (eval_addl (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : exists v0 : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v0 /\\\n  Val.lessdef (Val.mull x (Vlong n)) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le\n    (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v0 /\\\n  Val.lessdef (Val.mull x (Vlong n)) v0","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"exists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : eval_expr ge sp e m le\n  (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet a (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"econstructor; eauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"simpl in Q.\nrewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"rewrite Q, Int64.add_zero.\neapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : Val.lessdef\n  (Val.mull x\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j)))) v.","conclusion":"Val.lessdef\n  (Val.mull x\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j)))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"eapply Val.lessdef_trans; [|eexact B].\neapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : Val.lessdef\n  (Val.mull x\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  (Val.addl v1 v2).","conclusion":"Val.lessdef\n  (Val.mull x\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  (Val.addl v1 v2)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"eapply Val.lessdef_trans; [|eapply Val.addl_lessdef; eauto].\ndestruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : Val.lessdef\n  (Val.mull x\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  (Val.addl (Val.shll x (Vint i)) (Val.shll x (Vint j))).","conclusion":"Val.lessdef\n  (Val.mull x\n     (Vlong (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  (Val.addl (Val.shll x (Vint i)) (Val.shll x (Vint j)))","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull x (Vlong n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"destruct x; simpl; auto; rewrite ! P by auto with coqlib.\nrewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v0) (i j : int) (P : forall i1 : int, In i1 (i :: j :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll (Vlong i0) (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll (Vlong i0) (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : Val.lessdef\n  (Vlong\n     (Int64.mul i0\n        (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  (Val.addl (Vlong (Int64.shl' i0 i)) (Vlong (Int64.shl' i0 j))).","conclusion":"Val.lessdef\n  (Vlong\n     (Int64.mul i0\n        (Int64.add (Int64.shl' Int64.one i) (Int64.shl' Int64.one j))))\n  (Val.addl (Vlong (Int64.shl' i0 i)) (Vlong (Int64.shl' i0 j)))","hypotheses":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v0) (i j : int) (P : forall i1 : int, In i1 (i :: j :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll (Vlong i0) (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll (Vlong i0) (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"rewrite Int64.mul_add_distr_r, <- ! Int64.shl'_mul.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v0) (i j : int) (P : forall i1 : int, In i1 (i :: j :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll (Vlong i0) (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll (Vlong i0) (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v) : Val.lessdef (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j)))\n  (Val.addl (Vlong (Int64.shl' i0 i)) (Vlong (Int64.shl' i0 j))).","conclusion":"Val.lessdef (Vlong (Int64.add (Int64.shl' i0 i) (Int64.shl' i0 j)))\n  (Val.addl (Vlong (Int64.shl' i0 i)) (Vlong (Int64.shl' i0 j)))","hypotheses":"(n : int64) (le : letenv) (a : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i0)) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mull (Vlong i0) (Vlong n)) v0) (i j : int) (P : forall i1 : int, In i1 (i :: j :: nil) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n =\nInt64.add (Int64.shl' Int64.one i)\n  (Int64.add (Int64.shl' Int64.one j) Int64.zero)) (v1 : val) (A1 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shll (Vlong i0) (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (Vlong i0 :: le) (shllimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shll (Vlong i0) (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: le)\n  (addl (shllimm (Eletvar 0) i) (shllimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.addl v1 v2) v)","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j i0 : int) (l : list int) (P : forall i1 : int,\nIn i1 (i :: j :: i0 :: l) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: i0 :: l)) : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (Eop (Olongconst n) Enil ::: a ::: Enil))\n    v /\\ Val.lessdef (Val.mull x (Vlong n)) v) (i j i0 : int) (l : list int) (P : forall i1 : int,\nIn i1 (i :: j :: i0 :: l) -> Int.ltu i1 Int64.iwordsize' = true) (Q : n = Int64.int_of_one_bits' (i :: j :: i0 :: l))","proofString":"apply DFL."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then Eop (Olongconst Int64.zero) Enil\n     else\n      if Int64.eq n Int64.one\n      then a\n      else\n       match mullimm_match a with\n       | mullimm_case1 n2 => Eop (Olongconst (Int64.mul n n2)) Enil\n       | mullimm_case2 n2 t2 => addlimm (Int64.mul n n2) (mullimm_base n t2)\n       | mullimm_default e2 => mullimm_base n e2\n       end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then Eop (Olongconst Int64.zero) Enil\n     else\n      if Int64.eq n Int64.one\n      then a\n      else\n       match mullimm_match a with\n       | mullimm_case1 n2 => Eop (Olongconst (Int64.mul n n2)) Enil\n       | mullimm_case2 n2 t2 => addlimm (Int64.mul n n2) (mullimm_base n t2)\n       | mullimm_default e2 => mullimm_base n e2\n       end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nexists (Vlong Int64.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_zero.\nauto.\npredSpec Int64.eq Int64.eq_spec n Int64.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_one.\nauto.\ncase (mullimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl.\nrewrite Int64.mul_commut; auto.\nrewrite Val.mull_addl_distr_l.\nexploit eval_mullimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addlimm (Int64.mul n n2) le (mullimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto.\napply eval_mullimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero)","proofString":"intros.\nexists (Vlong Int64.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"exists (Vlong Int64.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero).","conclusion":"eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"EvalOp."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mull x (Vlong n)) (Vlong Int64.zero).","conclusion":"Val.lessdef (Val.mull x (Vlong n)) (Vlong Int64.zero)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong (Int64.mul i n)) (Vlong Int64.zero)","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a (Vlong i))","proofString":"subst n.\nrewrite Int64.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.one\n     then a\n     else\n      match mullimm_match a with\n      | mullimm_case1 n2 => Eop (Olongconst (Int64.mul n n2)) Enil\n      | mullimm_case2 n2 t2 => addlimm (Int64.mul n n2) (mullimm_base n t2)\n      | mullimm_default e2 => mullimm_base n e2\n      end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.one\n     then a\n     else\n      match mullimm_match a with\n      | mullimm_case1 n2 => Eop (Olongconst (Int64.mul n n2)) Enil\n      | mullimm_case2 n2 t2 => addlimm (Int64.mul n n2) (mullimm_base n t2)\n      | mullimm_default e2 => mullimm_base n e2\n      end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_one.\nauto.\ncase (mullimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl.\nrewrite Int64.mul_commut; auto.\nrewrite Val.mull_addl_distr_l.\nexploit eval_mullimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addlimm (Int64.mul n n2) le (mullimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto.\napply eval_mullimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.one)","proofString":"intros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_one.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.one) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.one) (H1 : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_one.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.one) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mull x (Vlong n)) x.","conclusion":"Val.lessdef (Val.mull x (Vlong n)) x","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.one) (H1 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int64.mul_one.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : n <> Int64.zero) (H0 : n = Int64.one) (H1 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.mul i n)) (Vlong i)","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : n <> Int64.zero) (H0 : n = Int64.one) (H1 : eval_expr ge sp e m le a (Vlong i))","proofString":"subst n.\nrewrite Int64.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : Int64.one <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : Int64.one <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : Int64.one <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong i) (Vlong i).","conclusion":"Val.lessdef (Vlong i) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : Int64.one <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match mullimm_match a with\n    | mullimm_case1 n2 => Eop (Olongconst (Int64.mul n n2)) Enil\n    | mullimm_case2 n2 t2 => addlimm (Int64.mul n n2) (mullimm_base n t2)\n    | mullimm_default e2 => mullimm_base n e2\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match mullimm_match a with\n    | mullimm_case1 n2 => Eop (Olongconst (Int64.mul n n2)) Enil\n    | mullimm_case2 n2 t2 => addlimm (Int64.mul n n2) (mullimm_base n t2)\n    | mullimm_default e2 => mullimm_base n e2\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.one)","proofString":"case (mullimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl.\nrewrite Int64.mul_commut; auto.\nrewrite Val.mull_addl_distr_l.\nexploit eval_mullimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addlimm (Int64.mul n n2) le (mullimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto.\napply eval_mullimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mull (Vlong n2) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mull (Vlong n2) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64)","proofString":"TrivialExists.\nsimpl.\nrewrite Int64.mul_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) : eval_operation ge sp (Olongconst (Int64.mul n n2)) nil m =\nSome (Val.mull (Vlong n2) (Vlong n)).","conclusion":"eval_operation ge sp (Olongconst (Int64.mul n n2)) nil m =\nSome (Val.mull (Vlong n2) (Vlong n))","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64)","proofString":"simpl.\nrewrite Int64.mul_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) : Some (Vlong (Int64.mul n n2)) = Some (Vlong (Int64.mul n2 n)).","conclusion":"Some (Vlong (Int64.mul n n2)) = Some (Vlong (Int64.mul n2 n))","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64)","proofString":"rewrite Int64.mul_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef (Val.mull (Val.addl v1 (Vlong n2)) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef (Val.mull (Val.addl v1 (Vlong n2)) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.mull_addl_distr_l.\nexploit eval_mullimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addlimm (Int64.mul n n2) le (mullimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"exploit eval_mullimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addlimm (Int64.mul n n2) le (mullimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : (exists v : val,\n   eval_expr ge sp e m le (mullimm_base n t2) v /\\\n   Val.lessdef (Val.mull v1 (Vlong n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (mullimm_base n t2) v /\\\n   Val.lessdef (Val.mull v1 (Vlong n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"intros [v' [A1 B1]].\nexploit (eval_addlimm (Int64.mul n n2) le (mullimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v') : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v')","proofString":"exploit (eval_addlimm (Int64.mul n n2) le (mullimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v') : eval_expr ge sp e m le (mullimm_base n t2) v'.","conclusion":"eval_expr ge sp e m le (mullimm_base n t2) v'","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v')","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v') : (exists v : val,\n   eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n   Val.lessdef (Val.addl v' (Vlong (Int64.mul n n2))) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n   Val.lessdef (Val.addl v' (Vlong (Int64.mul n n2))) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v')","proofString":"intros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v'') (B2 : Val.lessdef (Val.addl v' (Vlong (Int64.mul n n2))) v'') : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef\n    (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v'') (B2 : Val.lessdef (Val.addl v' (Vlong (Int64.mul n n2))) v'')","proofString":"exists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v'') (B2 : Val.lessdef (Val.addl v' (Vlong (Int64.mul n n2))) v'') : Val.lessdef\n  (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v''.","conclusion":"Val.lessdef\n  (Val.addl (Val.mull v1 (Vlong n)) (Val.mull (Vlong n2) (Vlong n))) v''","hypotheses":"(n : int64) (le : letenv) (a : expr) (H : n <> Int64.zero) (H0 : n <> Int64.one) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mullimm_base n t2) v') (B1 : Val.lessdef (Val.mull v1 (Vlong n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v'') (B2 : Val.lessdef (Val.addl v' (Vlong (Int64.mul n n2))) v'')","proofString":"eapply Val.lessdef_trans.\neapply Val.addl_lessdef; eauto.\nrewrite Val.mull_commut; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.one) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (mullimm_base n e2) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm_base n e2) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.one) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x)","proofString":"apply eval_mullimm_base; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull (Vlong n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull (Vlong n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.mull_commut.\napply eval_mullimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull y (Vlong n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull y (Vlong n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"apply eval_mullimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (mullimm n2 t1) v /\\\n  Val.lessdef (Val.mull x (Vlong n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm n2 t1) v /\\\n  Val.lessdef (Val.mull x (Vlong n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_mullimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mull x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Omull (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (n : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.zero_ext sz n)) Enil) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.zero_ext sz n)) Enil) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Vlong n)) v","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (n : int64)","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ozextshrl a0 sz) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shrlu v1 (Vint a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ozextshrl a0 sz) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shrlu v1 (Vint a0))) v","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if zlt (Int.unsigned a0) sz\n     then Eop (Oshllzext (sz - Int.unsigned a0) a0) (t1 ::: Enil)\n     else Eop (Ozextl sz) (Eop (Oshiftl Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shll v1 (Vint a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if zlt (Int.unsigned a0) sz\n     then Eop (Oshllzext (sz - Int.unsigned a0) a0) (t1 ::: Enil)\n     else Eop (Ozextl sz) (Eop (Oshiftl Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shll v1 (Vint a0))) v","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct (zlt (Int.unsigned a0) sz).\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int64.shl'_zero_ext by lia.\nf_equal.\nlia.\nTrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (l : Int.unsigned a0 < sz) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshllzext (sz - Int.unsigned a0) a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shll v1 (Vint a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshllzext (sz - Int.unsigned a0) a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shll v1 (Vint a0))) v","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (l : Int.unsigned a0 < sz)","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite a64_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int64.shl'_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz) : Val.lessdef\n  (Val.zero_ext_l sz\n     (if Int.ltu a0 Int64.iwordsize' then Vlong (Int64.shl' i a0) else Vundef))\n  (if Int.ltu a0 Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0)\n   else Vundef).","conclusion":"Val.lessdef\n  (Val.zero_ext_l sz\n     (if Int.ltu a0 Int64.iwordsize' then Vlong (Int64.shl' i a0) else Vundef))\n  (if Int.ltu a0 Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0)\n   else Vundef)","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz)","proofString":"rewrite a64_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int64.shl'_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz) : Val.lessdef (Vlong (Int64.zero_ext sz (Int64.shl' i a0)))\n  (Vlong (Int64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0)).","conclusion":"Val.lessdef (Vlong (Int64.zero_ext sz (Int64.shl' i a0)))\n  (Vlong (Int64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0))","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz)","proofString":"apply Val.lessdef_same.\nf_equal.\nrewrite Int64.shl'_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz) : Vlong (Int64.zero_ext sz (Int64.shl' i a0)) =\nVlong (Int64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0).","conclusion":"Vlong (Int64.zero_ext sz (Int64.shl' i a0)) =\nVlong (Int64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0)","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz)","proofString":"f_equal.\nrewrite Int64.shl'_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz) : Int64.zero_ext sz (Int64.shl' i a0) =\nInt64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0.","conclusion":"Int64.zero_ext sz (Int64.shl' i a0) =\nInt64.shl' (Int64.zero_ext (sz - Int.unsigned a0) i) a0","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz)","proofString":"rewrite Int64.shl'_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz) : Int64.zero_ext sz (Int64.shl' i a0) =\nInt64.zero_ext (sz - Int.unsigned a0 + Int.unsigned a0) (Int64.shl' i a0).","conclusion":"Int64.zero_ext sz (Int64.shl' i a0) =\nInt64.zero_ext (sz - Int.unsigned a0 + Int.unsigned a0) (Int64.shl' i a0)","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz)","proofString":"f_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz) : sz = sz - Int.unsigned a0 + Int.unsigned a0.","conclusion":"sz = sz - Int.unsigned a0 + Int.unsigned a0","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) (l : Int.unsigned a0 < sz)","proofString":"lia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (g : Int.unsigned a0 >= sz) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ozextl sz) (Eop (Oshiftl Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shll v1 (Vint a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ozextl sz) (Eop (Oshiftl Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz (Val.shll v1 (Vint a0))) v","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount64) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (g : Int.unsigned a0 >= sz)","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (x : val) (e0 : expr) (H0 : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ozextl sz) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Ozextl sz) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext_l sz x) v","hypotheses":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (x : val) (e0 : expr) (H0 : eval_expr ge sp e m le e0 x)","proofString":"TrivialExists."},{"statement":"forall v : val, Val.lessdef (Val.notl (Val.notl v)) v.","conclusion":"forall v : val, Val.lessdef (Val.notl (Val.notl v)) v","hypotheses":"","proofString":"destruct v; auto.\nsimpl; rewrite Int64.not_involutive; auto."},{"statement":"(i : int64) : Val.lessdef (Val.notl (Val.notl (Vlong i))) (Vlong i).","conclusion":"Val.lessdef (Val.notl (Val.notl (Vlong i))) (Vlong i)","hypotheses":"(i : int64)","proofString":"simpl; rewrite Int64.not_involutive; auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) : unary_constructor_sound notl Val.notl.","conclusion":"unary_constructor_sound notl Val.notl","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v)","proofString":"unfold notl; red; intros until x; case (notl_match a); intros; InvEval; subst.\nTrivialExists.\nTrivialExists.\nexists v1; auto.\nexists (eval_shiftl s v1 a0); split; auto.\nEvalOp.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int64.not_and_or_not, Int64.not_involutive, Int64.or_commut.\nauto.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int64.not_or_and_not, Int64.not_involutive, Int64.and_commut.\nauto.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nunfold Int64.not; rewrite ! Int64.xor_assoc.\nauto.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nunfold Int64.not; rewrite ! Int64.xor_assoc, Int64.xor_idem, Int64.xor_zero.\nauto.\nTrivialExists."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (n : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.not n)) Enil) v /\\\n  Val.lessdef (Val.notl (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.not n)) Enil) v /\\\n  Val.lessdef (Val.notl (Vlong n)) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (n : int64)","proofString":"TrivialExists."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Onotlshift s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Onotlshift s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (eval_shiftl s v1 a0)) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"TrivialExists."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le t1 v /\\ Val.lessdef (Val.notl (Val.notl v1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le t1 v /\\ Val.lessdef (Val.notl (Val.notl v1)) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"exists v1; auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.notl (eval_shiftl s v1 a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.notl (eval_shiftl s v1 a0))) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"exists (eval_shiftl s v1 a0); split; auto.\nEvalOp."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le (Eop (Oshiftl s a0) (t1 ::: Enil))\n  (eval_shiftl s v1 a0).","conclusion":"eval_expr ge sp e m le (Eop (Oshiftl s a0) (t1 ::: Enil))\n  (eval_shiftl s v1 a0)","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount64) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1)","proofString":"EvalOp."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Oornl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.andl v1 (Val.notl v0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oornl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.andl v1 (Val.notl v0))) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int64.not_and_or_not, Int64.not_involutive, Int64.or_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.not (Int64.and i (Int64.not i0))))\n  (Vlong (Int64.or i0 (Int64.not i))).","conclusion":"Val.lessdef (Vlong (Int64.not (Int64.and i (Int64.not i0))))\n  (Vlong (Int64.or i0 (Int64.not i)))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"rewrite Int64.not_and_or_not, Int64.not_involutive, Int64.or_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.or i0 (Int64.not i)))\n  (Vlong (Int64.or i0 (Int64.not i))).","conclusion":"Val.lessdef (Vlong (Int64.or i0 (Int64.not i)))\n  (Vlong (Int64.or i0 (Int64.not i)))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Obicl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.orl v1 (Val.notl v0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obicl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.orl v1 (Val.notl v0))) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int64.not_or_and_not, Int64.not_involutive, Int64.and_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.not (Int64.or i (Int64.not i0))))\n  (Vlong (Int64.and i0 (Int64.not i))).","conclusion":"Val.lessdef (Vlong (Int64.not (Int64.or i (Int64.not i0))))\n  (Vlong (Int64.and i0 (Int64.not i)))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"rewrite Int64.not_or_and_not, Int64.not_involutive, Int64.and_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.and i0 (Int64.not i)))\n  (Vlong (Int64.and i0 (Int64.not i))).","conclusion":"Val.lessdef (Vlong (Int64.and i0 (Int64.not i)))\n  (Vlong (Int64.and i0 (Int64.not i)))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Oeqvl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.xorl v1 v0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oeqvl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.xorl v1 v0)) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nunfold Int64.not; rewrite ! Int64.xor_assoc.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.not (Int64.xor i i0)))\n  (Vlong (Int64.xor i (Int64.not i0))).","conclusion":"Val.lessdef (Vlong (Int64.not (Int64.xor i i0)))\n  (Vlong (Int64.xor i (Int64.not i0)))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"unfold Int64.not; rewrite ! Int64.xor_assoc.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.xor i (Int64.xor i0 Int64.mone)))\n  (Vlong (Int64.xor i (Int64.xor i0 Int64.mone))).","conclusion":"Val.lessdef (Vlong (Int64.xor i (Int64.xor i0 Int64.mone)))\n  (Vlong (Int64.xor i (Int64.xor i0 Int64.mone)))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Oxorl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.xorl v1 (Val.notl v0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oxorl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.notl (Val.xorl v1 (Val.notl v0))) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nunfold Int64.not; rewrite ! Int64.xor_assoc, Int64.xor_idem, Int64.xor_zero.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.not (Int64.xor i (Int64.not i0))))\n  (Vlong (Int64.xor i i0)).","conclusion":"Val.lessdef (Vlong (Int64.not (Int64.xor i (Int64.not i0))))\n  (Vlong (Int64.xor i i0))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"unfold Int64.not; rewrite ! Int64.xor_assoc, Int64.xor_idem, Int64.xor_zero.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0)) : Val.lessdef (Vlong (Int64.xor i i0)) (Vlong (Int64.xor i i0)).","conclusion":"Val.lessdef (Vlong (Int64.xor i i0)) (Vlong (Int64.xor i i0))","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int64) (H2 : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le t2 (Vlong i0))","proofString":"auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop Onotl (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.notl x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Onotl (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.notl x) v","hypotheses":"(INV : forall v : val, Val.lessdef (Val.notl (Val.notl v)) v) (le : letenv) (a : expr) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (andlimm_base n a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andlimm_base n a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"unfold andlimm_base.\npredSpec Int64.eq Int64.eq_spec n Int64.zero.\nexists (Vlong Int64.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.and_zero.\nauto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.and_mone; auto.\ndestruct (Z_is_power2m1 (Int64.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int64.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_andl by auto.\napply eval_zero_ext_l; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then Eop (Olongconst Int64.zero) Enil\n     else\n      if Int64.eq n Int64.mone\n      then a\n      else\n       match Z_is_power2m1 (Int64.unsigned n) with\n       | Some s => zero_ext_l s a\n       | None => Eop (Oandlimm n) (a ::: Enil)\n       end) v /\\ Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then Eop (Olongconst Int64.zero) Enil\n     else\n      if Int64.eq n Int64.mone\n      then a\n      else\n       match Z_is_power2m1 (Int64.unsigned n) with\n       | Some s => zero_ext_l s a\n       | None => Eop (Oandlimm n) (a ::: Enil)\n       end) v /\\ Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nexists (Vlong Int64.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.and_zero.\nauto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.and_mone; auto.\ndestruct (Z_is_power2m1 (Int64.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int64.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_andl by auto.\napply eval_zero_ext_l; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"exists (Vlong Int64.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.and_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero).","conclusion":"eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"EvalOp."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : Val.lessdef (Val.andl x (Vlong n)) (Vlong Int64.zero).","conclusion":"Val.lessdef (Val.andl x (Vlong n)) (Vlong Int64.zero)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int64.and_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero) : Val.lessdef (Vlong (Int64.and i n)) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong (Int64.and i n)) (Vlong Int64.zero)","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero)","proofString":"subst n.\nrewrite Int64.and_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.and i Int64.zero)) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong (Int64.and i Int64.zero)) (Vlong Int64.zero)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.and_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone\n     then a\n     else\n      match Z_is_power2m1 (Int64.unsigned n) with\n      | Some s => zero_ext_l s a\n      | None => Eop (Oandlimm n) (a ::: Enil)\n      end) v /\\ Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone\n     then a\n     else\n      match Z_is_power2m1 (Int64.unsigned n) with\n      | Some s => zero_ext_l s a\n      | None => Eop (Oandlimm n) (a ::: Enil)\n      end) v /\\ Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.and_mone; auto.\ndestruct (Z_is_power2m1 (Int64.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int64.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_andl by auto.\napply eval_zero_ext_l; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone)","proofString":"exists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.and_mone; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone) : Val.lessdef (Val.andl x (Vlong n)) x.","conclusion":"Val.lessdef (Val.andl x (Vlong n)) x","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone)","proofString":"subst.\ndestruct x; simpl; auto.\nrewrite Int64.and_mone; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Val.andl x (Vlong Int64.mone)) x.","conclusion":"Val.lessdef (Val.andl x (Vlong Int64.mone)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero)","proofString":"destruct x; simpl; auto.\nrewrite Int64.and_mone; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Vlong (Int64.and i Int64.mone)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.and i Int64.mone)) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.mone <> Int64.zero)","proofString":"rewrite Int64.and_mone; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le\n    match Z_is_power2m1 (Int64.unsigned n) with\n    | Some s => zero_ext_l s a\n    | None => Eop (Oandlimm n) (a ::: Enil)\n    end v /\\ Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Z_is_power2m1 (Int64.unsigned n) with\n    | Some s => zero_ext_l s a\n    | None => Eop (Oandlimm n) (a ::: Enil)\n    end v /\\ Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone)","proofString":"destruct (Z_is_power2m1 (Int64.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int64.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_andl by auto.\napply eval_zero_ext_l; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (s : Z) (P : Z_is_power2m1 (Int64.unsigned n) = Some s) : exists v : val,\n  eval_expr ge sp e m le (zero_ext_l s a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (zero_ext_l s a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (s : Z) (P : Z_is_power2m1 (Int64.unsigned n) = Some s)","proofString":"assert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int64.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_andl by auto.\napply eval_zero_ext_l; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (s : Z) (P : Z_is_power2m1 (Int64.unsigned n) = Some s) (H2 : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le (zero_ext_l s a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (zero_ext_l s a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (s : Z) (P : Z_is_power2m1 (Int64.unsigned n) = Some s) (H2 : 0 <= s)","proofString":"rewrite <- (Int64.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_andl by auto.\napply eval_zero_ext_l; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (s : Z) (P : Z_is_power2m1 (Int64.unsigned n) = Some s) (H2 : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le (zero_ext_l s a) v /\\\n  Val.lessdef (Val.zero_ext_l s x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (zero_ext_l s a) v /\\\n  Val.lessdef (Val.zero_ext_l s x) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (s : Z) (P : Z_is_power2m1 (Int64.unsigned n) = Some s) (H2 : 0 <= s)","proofString":"apply eval_zero_ext_l; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (P : Z_is_power2m1 (Int64.unsigned n) = None) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oandlimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oandlimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (P : Z_is_power2m1 (Int64.unsigned n) = None)","proofString":"TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (andlimm n a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (andlimm n a) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"unfold andlimm.\ncase (andlimm_match a); intros; InvEval; subst.\nrewrite Int64.and_commut; TrivialExists.\nrewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto.\ndestruct (zle 0 s).\nreplace (Val.zero_ext_l s v1) with (Val.andl v1 (Vlong (Int64.repr (two_p s - 1)))).\nrewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto.\ndestruct v1; simpl; auto.\nrewrite Int64.zero_ext_and by auto.\nauto.\napply eval_andlimm_base.\nEvalOp.\napply eval_andlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match andlimm_match a with\n    | andlimm_case1 n2 => Eop (Olongconst (Int64.and n n2)) Enil\n    | andlimm_case2 n2 t2 => andlimm_base (Int64.and n n2) t2\n    | andlimm_case3 s t2 =>\n        if zle 0 s\n        then andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2\n        else andlimm_base n a\n    | andlimm_default e2 => andlimm_base n e2\n    end v /\\ Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match andlimm_match a with\n    | andlimm_case1 n2 => Eop (Olongconst (Int64.and n n2)) Enil\n    | andlimm_case2 n2 t2 => andlimm_base (Int64.and n n2) t2\n    | andlimm_case3 s t2 =>\n        if zle 0 s\n        then andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2\n        else andlimm_base n a\n    | andlimm_default e2 => andlimm_base n e2\n    end v /\\ Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"case (andlimm_match a); intros; InvEval; subst.\nrewrite Int64.and_commut; TrivialExists.\nrewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto.\ndestruct (zle 0 s).\nreplace (Val.zero_ext_l s v1) with (Val.andl v1 (Vlong (Int64.repr (two_p s - 1)))).\nrewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto.\ndestruct v1; simpl; auto.\nrewrite Int64.zero_ext_and by auto.\nauto.\napply eval_andlimm_base.\nEvalOp.\napply eval_andlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.and n n2)) Enil) v /\\\n  Val.lessdef (Val.andl (Vlong n2) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.and n n2)) Enil) v /\\\n  Val.lessdef (Val.andl (Vlong n2) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (n2 : int64)","proofString":"rewrite Int64.and_commut; TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (andlimm_base (Int64.and n n2) t2) v /\\\n  Val.lessdef (Val.andl (Val.andl v1 (Vlong n2)) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andlimm_base (Int64.and n n2) t2) v /\\\n  Val.lessdef (Val.andl (Val.andl v1 (Vlong n2)) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (andlimm_base (Int64.and n2 n) t2) v /\\\n  Val.lessdef (Val.andl v1 (Val.andl (Vlong n2) (Vlong n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andlimm_base (Int64.and n2 n) t2) v /\\\n  Val.lessdef (Val.andl v1 (Val.andl (Vlong n2) (Vlong n))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"apply eval_andlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if zle 0 s\n     then andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2\n     else andlimm_base n (Eop (Ozextl s) (t2 ::: Enil))) v /\\\n  Val.lessdef (Val.andl (Val.zero_ext_l s v1) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if zle 0 s\n     then andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2\n     else andlimm_base n (Eop (Ozextl s) (t2 ::: Enil))) v /\\\n  Val.lessdef (Val.andl (Val.zero_ext_l s v1) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"destruct (zle 0 s).\nreplace (Val.zero_ext_l s v1) with (Val.andl v1 (Vlong (Int64.repr (two_p s - 1)))).\nrewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto.\ndestruct v1; simpl; auto.\nrewrite Int64.zero_ext_and by auto.\nauto.\napply eval_andlimm_base.\nEvalOp."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le\n    (andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2) v /\\\n  Val.lessdef (Val.andl (Val.zero_ext_l s v1) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2) v /\\\n  Val.lessdef (Val.andl (Val.zero_ext_l s v1) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s)","proofString":"replace (Val.zero_ext_l s v1) with (Val.andl v1 (Vlong (Int64.repr (two_p s - 1)))).\nrewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto.\ndestruct v1; simpl; auto.\nrewrite Int64.zero_ext_and by auto.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le\n    (andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2) v /\\\n  Val.lessdef\n    (Val.andl (Val.andl v1 (Vlong (Int64.repr (two_p s - 1)))) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (andlimm_base (Int64.and n (Int64.repr (two_p s - 1))) t2) v /\\\n  Val.lessdef\n    (Val.andl (Val.andl v1 (Vlong (Int64.repr (two_p s - 1)))) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s)","proofString":"rewrite Val.andl_assoc, Int64.and_commut.\napply eval_andlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le\n    (andlimm_base (Int64.and (Int64.repr (two_p s - 1)) n) t2) v /\\\n  Val.lessdef\n    (Val.andl v1 (Val.andl (Vlong (Int64.repr (two_p s - 1))) (Vlong n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (andlimm_base (Int64.and (Int64.repr (two_p s - 1)) n) t2) v /\\\n  Val.lessdef\n    (Val.andl v1 (Val.andl (Vlong (Int64.repr (two_p s - 1))) (Vlong n))) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s)","proofString":"apply eval_andlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s) : Val.andl v1 (Vlong (Int64.repr (two_p s - 1))) = Val.zero_ext_l s v1.","conclusion":"Val.andl v1 (Vlong (Int64.repr (two_p s - 1))) = Val.zero_ext_l s v1","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s)","proofString":"destruct v1; simpl; auto.\nrewrite Int64.zero_ext_and by auto.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (i : int64) (H2 : eval_expr ge sp e m le t2 (Vlong i)) (l : 0 <= s) : Vlong (Int64.and i (Int64.repr (two_p s - 1))) = Vlong (Int64.zero_ext s i).","conclusion":"Vlong (Int64.and i (Int64.repr (two_p s - 1))) = Vlong (Int64.zero_ext s i)","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (i : int64) (H2 : eval_expr ge sp e m le t2 (Vlong i)) (l : 0 <= s)","proofString":"rewrite Int64.zero_ext_and by auto.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (i : int64) (H2 : eval_expr ge sp e m le t2 (Vlong i)) (l : 0 <= s) : Vlong (Int64.and i (Int64.repr (two_p s - 1))) =\nVlong (Int64.and i (Int64.repr (two_p s - 1))).","conclusion":"Vlong (Int64.and i (Int64.repr (two_p s - 1))) =\nVlong (Int64.and i (Int64.repr (two_p s - 1)))","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (i : int64) (H2 : eval_expr ge sp e m le t2 (Vlong i)) (l : 0 <= s)","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (g : 0 > s) : exists v : val,\n  eval_expr ge sp e m le (andlimm_base n (Eop (Ozextl s) (t2 ::: Enil))) v /\\\n  Val.lessdef (Val.andl (Val.zero_ext_l s v1) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andlimm_base n (Eop (Ozextl s) (t2 ::: Enil))) v /\\\n  Val.lessdef (Val.andl (Val.zero_ext_l s v1) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (g : 0 > s)","proofString":"apply eval_andlimm_base.\nEvalOp."},{"statement":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (g : 0 > s) : eval_expr ge sp e m le (Eop (Ozextl s) (t2 ::: Enil)) (Val.zero_ext_l s v1).","conclusion":"eval_expr ge sp e m le (Eop (Ozextl s) (t2 ::: Enil)) (Val.zero_ext_l s v1)","hypotheses":"(n : int64) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (g : 0 > s)","proofString":"EvalOp."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (andlimm_base n e2) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andlimm_base n e2) v /\\\n  Val.lessdef (Val.andl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x)","proofString":"apply eval_andlimm_base; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl (Vlong n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl (Vlong n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.andl_commut; apply eval_andlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\\n  Val.lessdef (Val.andl x (Vlong n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\\n  Val.lessdef (Val.andl x (Vlong n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_andlimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Obicl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.andl (Val.notl v1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obicl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.andl (Val.notl v1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.andl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Obicl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (Val.notl v1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Obicl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (Val.notl v1)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Obiclshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.andl (Val.notl (eval_shiftl s v1 a0)) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Obiclshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.andl (Val.notl (eval_shiftl s v1 a0)) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.andl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Obiclshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (Val.notl (eval_shiftl s v1 a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Obiclshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (Val.notl (eval_shiftl s v1 a0))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oandlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.andl (eval_shiftl s v1 a0) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oandlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.andl (eval_shiftl s v1 a0) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.andl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oandlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oandlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x (eval_shiftl s v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oandl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oandl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.andl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (orlimm n a) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (orlimm n a) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"unfold orlimm.\npredSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\nintros.\nexists (Vlong Int64.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.or_mone.\nauto.\ndestruct (orlimm_match a); intros; InvEval; subst.\nrewrite Int64.or_commut; TrivialExists.\nrewrite Val.orl_assoc, Int64.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      if Int64.eq n Int64.mone\n      then Eop (Olongconst Int64.mone) Enil\n      else\n       match orlimm_match a with\n       | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n       | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n       | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      if Int64.eq n Int64.mone\n      then Eop (Olongconst Int64.mone) Enil\n      else\n       match orlimm_match a with\n       | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n       | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n       | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\nintros.\nexists (Vlong Int64.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.or_mone.\nauto.\ndestruct (orlimm_match a); intros; InvEval; subst.\nrewrite Int64.or_commut; TrivialExists.\nrewrite Val.orl_assoc, Int64.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero)","proofString":"intros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n = Int64.zero) (H0 : eval_expr ge sp e m le a x)","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong Int64.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong Int64.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.orl x (Vlong Int64.zero)) x.","conclusion":"Val.lessdef (Val.orl x (Vlong Int64.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.or i Int64.zero)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.or i Int64.zero)) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone\n     then Eop (Olongconst Int64.mone) Enil\n     else\n      match orlimm_match a with\n      | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n      | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n      | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone\n     then Eop (Olongconst Int64.mone) Enil\n     else\n      match orlimm_match a with\n      | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n      | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n      | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone.\nintros.\nexists (Vlong Int64.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.or_mone.\nauto.\ndestruct (orlimm_match a); intros; InvEval; subst.\nrewrite Int64.or_commut; TrivialExists.\nrewrite Val.orl_assoc, Int64.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone)","proofString":"intros.\nexists (Vlong Int64.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.or_mone.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a x)","proofString":"exists (Vlong Int64.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.or_mone.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) (Vlong Int64.mone).","conclusion":"eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) (Vlong Int64.mone)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a x)","proofString":"EvalOp."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.orl x (Vlong n)) (Vlong Int64.mone).","conclusion":"Val.lessdef (Val.orl x (Vlong n)) (Vlong Int64.mone)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int64.or_mone.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.or i n)) (Vlong Int64.mone).","conclusion":"Val.lessdef (Vlong (Int64.or i n)) (Vlong Int64.mone)","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : n <> Int64.zero) (H0 : n = Int64.mone) (H1 : eval_expr ge sp e m le a (Vlong i))","proofString":"subst n.\nrewrite Int64.or_mone.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : Int64.mone <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.or i Int64.mone)) (Vlong Int64.mone).","conclusion":"Val.lessdef (Vlong (Int64.or i Int64.mone)) (Vlong Int64.mone)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : Int64.mone <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.or_mone.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : Int64.mone <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong Int64.mone) (Vlong Int64.mone).","conclusion":"Val.lessdef (Vlong Int64.mone) (Vlong Int64.mone)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : Int64.mone <> Int64.zero) (H1 : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orlimm_match a with\n    | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n    | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n    | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orlimm_match a with\n    | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n    | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n    | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.mone)","proofString":"destruct (orlimm_match a); intros; InvEval; subst.\nrewrite Int64.or_commut; TrivialExists.\nrewrite Val.orl_assoc, Int64.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (H : n <> Int64.zero) (H0 : n <> Int64.mone) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.or n n2)) Enil) v /\\\n  Val.lessdef (Val.orl (Vlong n2) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.or n n2)) Enil) v /\\\n  Val.lessdef (Val.orl (Vlong n2) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (H : n <> Int64.zero) (H0 : n <> Int64.mone) (n2 : int64)","proofString":"rewrite Int64.or_commut; TrivialExists."},{"statement":"(n : int64) (le : letenv) (H : n <> Int64.zero) (H0 : n <> Int64.mone) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (H : n <> Int64.zero) (H0 : n <> Int64.mone) (n2 : int64) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.orl_assoc, Int64.or_commut; TrivialExists."},{"statement":"(n : int64) (le : letenv) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.mone) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (x : val) (H : n <> Int64.zero) (H0 : n <> Int64.mone) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl (Vlong n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl (Vlong n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.orl_commut.\napply eval_orlimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl y (Vlong n1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl y (Vlong n1)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"apply eval_orlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (orlimm n2 t1) v /\\\n  Val.lessdef (Val.orl x (Vlong n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (orlimm n2 t1) v /\\\n  Val.lessdef (Val.orl x (Vlong n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_orlimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oornl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.notl v1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oornl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.notl v1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.orl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oornl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Val.notl v1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oornl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Val.notl v1)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oornlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.notl (eval_shiftl s v1 a0)) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oornlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.notl (eval_shiftl s v1 a0)) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.orl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oornlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Val.notl (eval_shiftl s v1 a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oornlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Val.notl (eval_shiftl s v1 a0))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq (Int.add a1 a2) Int64.iwordsize' && same_expr_pure t1 t2\n     then Eop (Oshiftl Sror a2) (t2 ::: Enil)\n     else\n      Eop (Oorlshift Slsr a2)\n        (Eop (Oshiftl Slsl a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq (Int.add a1 a2) Int64.iwordsize' && same_expr_pure t1 t2\n     then Eop (Oshiftl Sror a2) (t2 ::: Enil)\n     else\n      Eop (Oorlshift Slsr a2)\n        (Eop (Oshiftl Slsl a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"destruct (Int.eq (Int.add a1 a2) Int64.iwordsize' && same_expr_pure t1 t2) eqn:?.\nInvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a1 a2) Int64.iwordsize' && same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a1 a2) Int64.iwordsize' && same_expr_pure t1 t2 = true)","proofString":"InvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.eq (Int.add a1 a2) Int64.iwordsize' = true) (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.eq (Int.add a1 a2) Int64.iwordsize' = true) (H0 : same_expr_pure t1 t2 = true)","proofString":"apply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true)","proofString":"exploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) : t1 = t2 /\\ v1 = v0 ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"t1 = t2 /\\ v1 = v0 ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true)","proofString":"intros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) (EQ1 : t1 = t2) (EQ2 : v1 = v0) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) (EQ1 : t1 = t2) (EQ2 : v1 = v0)","proofString":"subst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (v0 : val) (H2 H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v0 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v0 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (v0 : val) (H2 H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"econstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : Val.lessdef\n  (Val.orl\n     (if Int.ltu a1 Int64.iwordsize' then Vlong (Int64.shl' i a1) else Vundef)\n     (if Int.ltu a2 Int64.iwordsize'\n      then Vlong (Int64.shru' i a2)\n      else Vundef)) (Vlong (Int64.ror i (Int64.repr (Int.unsigned a2)))).","conclusion":"Val.lessdef\n  (Val.orl\n     (if Int.ltu a1 Int64.iwordsize' then Vlong (Int64.shl' i a1) else Vundef)\n     (if Int.ltu a2 Int64.iwordsize'\n      then Vlong (Int64.shru' i a2)\n      else Vundef)) (Vlong (Int64.ror i (Int64.repr (Int.unsigned a2))))","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"rewrite ! a64_range.\nsimpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Val.orl (Vlong (Int64.shl' i a1)) (Vlong (Int64.shru' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a2)))).","conclusion":"Val.lessdef (Val.orl (Vlong (Int64.shl' i a1)) (Vlong (Int64.shru' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a2))))","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"simpl.\nrewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Vlong (Int64.or (Int64.shl' i a1) (Int64.shru' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a2)))).","conclusion":"Val.lessdef (Vlong (Int64.or (Int64.shl' i a1) (Int64.shru' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a2))))","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a1 a2 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"rewrite <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a1 a2) Int64.iwordsize' && same_expr_pure t1 t2 = false) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oorlshift Slsr a2)\n       (Eop (Oshiftl Slsl a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oorlshift Slsr a2)\n       (Eop (Oshiftl Slsl a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shll v1 (Vint a1)) (Val.shrlu v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a1 a2) Int64.iwordsize' && same_expr_pure t1 t2 = false)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq (Int.add a2 a1) Int64.iwordsize' && same_expr_pure t1 t2\n     then Eop (Oshiftl Sror a1) (t1 ::: Enil)\n     else\n      Eop (Oorlshift Slsl a2)\n        (Eop (Oshiftl Slsr a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq (Int.add a2 a1) Int64.iwordsize' && same_expr_pure t1 t2\n     then Eop (Oshiftl Sror a1) (t1 ::: Enil)\n     else\n      Eop (Oorlshift Slsl a2)\n        (Eop (Oshiftl Slsr a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0)","proofString":"destruct (Int.eq (Int.add a2 a1) Int64.iwordsize' && same_expr_pure t1 t2) eqn:?.\nInvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a2 a1) Int64.iwordsize' && same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a2 a1) Int64.iwordsize' && same_expr_pure t1 t2 = true)","proofString":"InvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.eq (Int.add a2 a1) Int64.iwordsize' = true) (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.eq (Int.add a2 a1) Int64.iwordsize' = true) (H0 : same_expr_pure t1 t2 = true)","proofString":"apply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true)","proofString":"exploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) : t1 = t2 /\\ v1 = v0 ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"t1 = t2 /\\ v1 = v0 ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true)","proofString":"intros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) (EQ1 : t1 = t2) (EQ2 : v1 = v0) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t1 t2 = true) (EQ1 : t1 = t2) (EQ2 : v1 = v0)","proofString":"subst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (v0 : val) (H2 H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v0 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshiftl Sror a1) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v0 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (v0 : val) (H2 H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"econstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : Val.lessdef\n  (Val.orl\n     (if Int.ltu a1 Int64.iwordsize'\n      then Vlong (Int64.shru' i a1)\n      else Vundef)\n     (if Int.ltu a2 Int64.iwordsize' then Vlong (Int64.shl' i a2) else Vundef))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a1)))).","conclusion":"Val.lessdef\n  (Val.orl\n     (if Int.ltu a1 Int64.iwordsize'\n      then Vlong (Int64.shru' i a1)\n      else Vundef)\n     (if Int.ltu a2 Int64.iwordsize' then Vlong (Int64.shl' i a2) else Vundef))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a1))))","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"rewrite ! a64_range.\nsimpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Val.orl (Vlong (Int64.shru' i a1)) (Vlong (Int64.shl' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a1)))).","conclusion":"Val.lessdef (Val.orl (Vlong (Int64.shru' i a1)) (Vlong (Int64.shl' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a1))))","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"simpl.\nrewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Vlong (Int64.or (Int64.shru' i a1) (Int64.shl' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a1)))).","conclusion":"Val.lessdef (Vlong (Int64.or (Int64.shru' i a1) (Int64.shl' i a2)))\n  (Vlong (Int64.ror i (Int64.repr (Int.unsigned a1))))","hypotheses":"(le : letenv) (a b : expr) (a1 a2 : amount64) (t2 : expr) (i : int64) (H2 H3 : eval_expr ge sp e m le t2 (Vlong i)) (H : Int.add a2 a1 = Int64.iwordsize') (H0 : same_expr_pure t2 t2 = true)","proofString":"rewrite Int64.or_commut, <- Int64.or_ror'; auto using a64_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a2 a1) Int64.iwordsize' && same_expr_pure t1 t2 = false) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oorlshift Slsl a2)\n       (Eop (Oshiftl Slsr a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oorlshift Slsl a2)\n       (Eop (Oshiftl Slsr a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.shrlu v1 (Vint a1)) (Val.shll v0 (Vint a2))) v","hypotheses":"(le : letenv) (a b : expr) (a1 : amount64) (t1 : expr) (a2 : amount64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a2 a1) Int64.iwordsize' && same_expr_pure t1 t2 = false)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (eval_shiftl s v1 a0) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (eval_shiftl s v1 a0) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.orl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (eval_shiftl s v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oorl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (xorlimm_base n a) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorlimm_base n a) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"unfold xorlimm_base.\npredSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nexists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.xor_zero.\nauto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\nsubst n.\nchange (Val.xorl x (Vlong Int64.mone)) with (Val.notl x).\napply eval_notl; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      if Int64.eq n Int64.mone then notl a else Eop (Oxorlimm n) (a ::: Enil))\n    v /\\ Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      if Int64.eq n Int64.mone then notl a else Eop (Oxorlimm n) (a ::: Enil))\n    v /\\ Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nexists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.xor_zero.\nauto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\nsubst n.\nchange (Val.xorl x (Vlong Int64.mone)) with (Val.notl x).\napply eval_notl; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"intros.\nexists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.xor_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"exists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int64.xor_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : eval_expr ge sp e m le a x.","conclusion":"eval_expr ge sp e m le a x","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : Val.lessdef (Val.xorl x (Vlong n)) x.","conclusion":"Val.lessdef (Val.xorl x (Vlong n)) x","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int64.xor_zero.\nauto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero) : Val.lessdef (Vlong (Int64.xor i n)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.xor i n)) (Vlong i)","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n = Int64.zero)","proofString":"subst n.\nrewrite Int64.xor_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.xor i Int64.zero)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.xor i Int64.zero)) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.xor_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong i) (Vlong i).","conclusion":"Val.lessdef (Vlong i) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone then notl a else Eop (Oxorlimm n) (a ::: Enil))\n    v /\\ Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone then notl a else Eop (Oxorlimm n) (a ::: Enil))\n    v /\\ Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone.\nsubst n.\nchange (Val.xorl x (Vlong Int64.mone)) with (Val.notl x).\napply eval_notl; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\ Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\ Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone)","proofString":"subst n.\nchange (Val.xorl x (Vlong Int64.mone)) with (Val.notl x).\napply eval_notl; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\\n  Val.lessdef (Val.xorl x (Vlong Int64.mone)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\\n  Val.lessdef (Val.xorl x (Vlong Int64.mone)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero)","proofString":"change (Val.xorl x (Vlong Int64.mone)) with (Val.notl x).\napply eval_notl; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\ Val.lessdef (Val.notl x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\ Val.lessdef (Val.notl x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero)","proofString":"apply eval_notl; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorlimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorlimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone)","proofString":"TrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (xorlimm n a) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (xorlimm n a) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"unfold xorlimm.\ndestruct (xorlimm_match a); intros; InvEval; subst.\nrewrite Int64.xor_commut; TrivialExists.\nrewrite Val.xorl_assoc; simpl.\nrewrite (Int64.xor_commut n2).\napply eval_xorlimm_base; auto.\napply eval_xorlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match xorlimm_match a with\n    | xorlimm_case1 n2 => Eop (Olongconst (Int64.xor n n2)) Enil\n    | xorlimm_case2 n2 t2 => xorlimm_base (Int64.xor n n2) t2\n    | xorlimm_default e2 => xorlimm_base n e2\n    end v /\\ Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match xorlimm_match a with\n    | xorlimm_case1 n2 => Eop (Olongconst (Int64.xor n n2)) Enil\n    | xorlimm_case2 n2 t2 => xorlimm_base (Int64.xor n n2) t2\n    | xorlimm_default e2 => xorlimm_base n e2\n    end v /\\ Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val)","proofString":"destruct (xorlimm_match a); intros; InvEval; subst.\nrewrite Int64.xor_commut; TrivialExists.\nrewrite Val.xorl_assoc; simpl.\nrewrite (Int64.xor_commut n2).\napply eval_xorlimm_base; auto.\napply eval_xorlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.xor n n2)) Enil) v /\\\n  Val.lessdef (Val.xorl (Vlong n2) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.xor n n2)) Enil) v /\\\n  Val.lessdef (Val.xorl (Vlong n2) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (n2 : int64)","proofString":"rewrite Int64.xor_commut; TrivialExists."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (xorlimm_base (Int64.xor n n2) t2) v /\\\n  Val.lessdef (Val.xorl (Val.xorl v1 (Vlong n2)) (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorlimm_base (Int64.xor n n2) t2) v /\\\n  Val.lessdef (Val.xorl (Val.xorl v1 (Vlong n2)) (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite Val.xorl_assoc; simpl.\nrewrite (Int64.xor_commut n2).\napply eval_xorlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (xorlimm_base (Int64.xor n n2) t2) v /\\\n  Val.lessdef (Val.xorl v1 (Vlong (Int64.xor n2 n))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorlimm_base (Int64.xor n n2) t2) v /\\\n  Val.lessdef (Val.xorl v1 (Vlong (Int64.xor n2 n))) v","hypotheses":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"rewrite (Int64.xor_commut n2).\napply eval_xorlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (xorlimm_base (Int64.xor n n2) t2) v /\\\n  Val.lessdef (Val.xorl v1 (Vlong (Int64.xor n n2))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorlimm_base (Int64.xor n n2) t2) v /\\\n  Val.lessdef (Val.xorl v1 (Vlong (Int64.xor n n2))) v","hypotheses":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1)","proofString":"apply eval_xorlimm_base; auto."},{"statement":"(n : int64) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (xorlimm_base n e2) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorlimm_base n e2) v /\\\n  Val.lessdef (Val.xorl x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x)","proofString":"apply eval_xorlimm_base; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl (Vlong n1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl (Vlong n1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y)","proofString":"rewrite Val.xorl_commut; apply eval_xorlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\\n  Val.lessdef (Val.xorl x (Vlong n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\\n  Val.lessdef (Val.xorl x (Vlong n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x)","proofString":"apply eval_xorlimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oeqvl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl (Val.notl v1) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oeqvl (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl (Val.notl v1) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.xorl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oeqvl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (Val.notl v1)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oeqvl (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (Val.notl v1)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oeqvlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl (Val.notl (eval_shiftl s v1 a0)) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oeqvlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl (Val.notl (eval_shiftl s v1 a0)) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.xorl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oeqvlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (Val.notl (eval_shiftl s v1 a0))) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oeqvlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (Val.notl (eval_shiftl s v1 a0))) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl (eval_shiftl s v1 a0) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorlshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl (eval_shiftl s v1 a0) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.xorl_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (eval_shiftl s v1 a0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorlshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x (eval_shiftl s v1 a0)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oxorl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oxorl (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.xorl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z)","proofString":"exploit Val.modls_divls; eauto.\nintros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) : (exists v : val, Val.divls x y = Some v /\\ z = Val.subl x (Val.mull v y)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","conclusion":"(exists v : val, Val.divls x y = Some v /\\ z = Val.subl x (Val.mull v y)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z)","proofString":"intros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (q : val) (A : Val.divls x y = Some q) (B : z = Val.subl x (Val.mull q y)) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) (q : val) (A : Val.divls x y = Some q) (B : z = Val.subl x (Val.mull q y))","proofString":"subst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modls x y = Some (Val.subl x (Val.mull q y))) (A : Val.divls x y = Some q) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (Val.subl x (Val.mull q y)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (Val.subl x (Val.mull q y)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modls x y = Some (Val.subl x (Val.mull q y))) (A : Val.divls x y = Some q)","proofString":"TrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modls x y = Some (Val.subl x (Val.mull q y))) (A : Val.divls x y = Some q) : eval_expr ge sp e m le\n  (Elet a\n     (Elet (lift b)\n        (Eop Omullsub\n           (Eletvar 1\n            ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                ::: Eletvar 0 ::: Enil)))) (Val.subl x (Val.mull q y)).","conclusion":"eval_expr ge sp e m le\n  (Elet a\n     (Elet (lift b)\n        (Eop Omullsub\n           (Eletvar 1\n            ::: Eop Odivl (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                ::: Eletvar 0 ::: Enil)))) (Val.subl x (Val.mull q y))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modls x y = Some (Val.subl x (Val.mull q y))) (A : Val.divls x y = Some q)","proofString":"repeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modls x y = Some (Val.subl x (Val.mull q y))) (A : Val.divls x y = Some q) : eval_operation ge sp Odivl (x :: y :: nil) m = Some q.","conclusion":"eval_operation ge sp Odivl (x :: y :: nil) m = Some q","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modls x y = Some (Val.subl x (Val.mull q y))) (A : Val.divls x y = Some q)","proofString":"exact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z)","proofString":"exploit Val.modlu_divlu; eauto.\nintros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) : (exists v : val, Val.divlu x y = Some v /\\ z = Val.subl x (Val.mull v y)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","conclusion":"(exists v : val, Val.divlu x y = Some v /\\ z = Val.subl x (Val.mull v y)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z)","proofString":"intros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (q : val) (A : Val.divlu x y = Some q) (B : z = Val.subl x (Val.mull q y)) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) (q : val) (A : Val.divlu x y = Some q) (B : z = Val.subl x (Val.mull q y))","proofString":"subst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull q y))) (A : Val.divlu x y = Some q) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (Val.subl x (Val.mull q y)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omullsub\n             (Eletvar 1\n              ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (Val.subl x (Val.mull q y)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull q y))) (A : Val.divlu x y = Some q)","proofString":"TrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull q y))) (A : Val.divlu x y = Some q) : eval_expr ge sp e m le\n  (Elet a\n     (Elet (lift b)\n        (Eop Omullsub\n           (Eletvar 1\n            ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                ::: Eletvar 0 ::: Enil)))) (Val.subl x (Val.mull q y)).","conclusion":"eval_expr ge sp e m le\n  (Elet a\n     (Elet (lift b)\n        (Eop Omullsub\n           (Eletvar 1\n            ::: Eop Odivlu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                ::: Eletvar 0 ::: Enil)))) (Val.subl x (Val.mull q y))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull q y))) (A : Val.divlu x y = Some q)","proofString":"repeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull q y))) (A : Val.divlu x y = Some q) : eval_operation ge sp Odivlu (x :: y :: nil) m = Some q.","conclusion":"eval_operation ge sp Odivlu (x :: y :: nil) m = Some q","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modlu x y = Some (Val.subl x (Val.mull q y))) (A : Val.divlu x y = Some q)","proofString":"exact A."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z)","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 63)) with true in H0; inv H0.\nrewrite Int64.shrx'_zero.\nauto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (H1 : n = Int.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (H1 : n = Int.zero)","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 63)) with true in H0; inv H0.\nrewrite Int64.shrx'_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint Int.zero) = Some z) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint Int.zero) = Some z)","proofString":"exists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 63)) with true in H0; inv H0.\nrewrite Int64.shrx'_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint Int.zero) = Some z) : Val.lessdef z x.","conclusion":"Val.lessdef z x","hypotheses":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint Int.zero) = Some z)","proofString":"destruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 63)) with true in H0; inv H0.\nrewrite Int64.shrx'_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : (if Int.ltu Int.zero (Int.repr 63)\n then Some (Vlong (Int64.shrx' i Int.zero))\n else None) = Some z) : Val.lessdef z (Vlong i).","conclusion":"Val.lessdef z (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (z : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : (if Int.ltu Int.zero (Int.repr 63)\n then Some (Vlong (Int64.shrx' i Int.zero))\n else None) = Some z)","proofString":"change (Int.ltu Int.zero (Int.repr 63)) with true in H0; inv H0.\nrewrite Int64.shrx'_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shrx' i Int.zero)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.shrx' i Int.zero)) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.shrx'_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong i) (Vlong i).","conclusion":"Val.lessdef (Vlong i) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (H1 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (H1 : n <> Int.zero)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shllimm a n2) v /\\ Val.lessdef (Val.shll x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm a n2) v /\\ Val.lessdef (Val.shll x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y)","proofString":"InvEval.\napply eval_shllimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shllimm a n2) v /\\\n  Val.lessdef (Val.shll x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm a n2) v /\\\n  Val.lessdef (Val.shll x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shllimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshll (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shll x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oshll (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shll x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shrlimm a n2) v /\\ Val.lessdef (Val.shrl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrlimm a n2) v /\\ Val.lessdef (Val.shrl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y)","proofString":"InvEval.\napply eval_shrlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shrlimm a n2) v /\\\n  Val.lessdef (Val.shrl x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrlimm a n2) v /\\\n  Val.lessdef (Val.shrl x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shrlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshrl (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oshrl (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shrluimm a n2) v /\\ Val.lessdef (Val.shrlu x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrluimm a n2) v /\\ Val.lessdef (Val.shrlu x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y)","proofString":"InvEval.\napply eval_shrluimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shrluimm a n2) v /\\\n  Val.lessdef (Val.shrlu x (Vint n2)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrluimm a n2) v /\\\n  Val.lessdef (Val.shrlu x (Vint n2)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shrluimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshrlu (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Oshrlu (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y)","proofString":"TrivialExists."},{"statement":"(ov : option bool) (w : val) (H : option_map Val.of_bool ov = Some w) : Val.of_optbool ov = w.","conclusion":"Val.of_optbool ov = w","hypotheses":"(ov : option bool) (w : val) (H : option_map Val.of_bool ov = Some w)","proofString":"destruct ov; inv H; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : sem c x (Vlong n2) = Some v) (H0 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Ocmp (default c n2)) (a ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (default c n2)) (a ::: Enil)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : sem c x (Vlong n2) = Some v) (H0 : eval_expr ge sp e m le a x)","proofString":"EvalOp.\nsimpl.\nrewrite sem_default in H.\napply option_map_of_bool_inv in H.\ncongruence."},{"statement":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : sem c x (Vlong n2) = Some v) (H0 : eval_expr ge sp e m le a x) : eval_operation ge sp (Ocmp (default c n2)) (x :: nil) m = Some v.","conclusion":"eval_operation ge sp (Ocmp (default c n2)) (x :: nil) m = Some v","hypotheses":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : sem c x (Vlong n2) = Some v) (H0 : eval_expr ge sp e m le a x)","proofString":"simpl.\nrewrite sem_default in H.\napply option_map_of_bool_inv in H.\ncongruence."},{"statement":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : sem c x (Vlong n2) = Some v) (H0 : eval_expr ge sp e m le a x) : Some (Val.of_optbool (eval_condition (default c n2) (x :: nil) m)) = Some v.","conclusion":"Some (Val.of_optbool (eval_condition (default c n2) (x :: nil) m)) = Some v","hypotheses":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : sem c x (Vlong n2) = Some v) (H0 : eval_expr ge sp e m le a x)","proofString":"rewrite sem_default in H.\napply option_map_of_bool_inv in H.\ncongruence."},{"statement":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : option_map Val.of_bool (eval_condition (default c n2) (x :: nil) m) = Some v) (H0 : eval_expr ge sp e m le a x) : Some (Val.of_optbool (eval_condition (default c n2) (x :: nil) m)) = Some v.","conclusion":"Some (Val.of_optbool (eval_condition (default c n2) (x :: nil) m)) = Some v","hypotheses":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : option_map Val.of_bool (eval_condition (default c n2) (x :: nil) m) = Some v) (H0 : eval_expr ge sp e m le a x)","proofString":"apply option_map_of_bool_inv in H.\ncongruence."},{"statement":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : Val.of_optbool (eval_condition (default c n2) (x :: nil) m) = v) (H0 : eval_expr ge sp e m le a x) : Some (Val.of_optbool (eval_condition (default c n2) (x :: nil) m)) = Some v.","conclusion":"Some (Val.of_optbool (eval_condition (default c n2) (x :: nil) m)) = Some v","hypotheses":"(le : letenv) (a : expr) (x : val) (c : comparison) (n2 : int64) (v : val) (H : Val.of_optbool (eval_condition (default c n2) (x :: nil) m) = v) (H0 : eval_expr ge sp e m le a x)","proofString":"congruence."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (c0 : comparison) (n1 : int64) (v : val) (H0 : sem c0 (Vlong n1) (Vlong n2) = Some v) : eval_expr ge sp e m le\n  (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v.","conclusion":"eval_expr ge sp e m le\n  (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (c0 : comparison) (n1 : int64) (v : val) (H0 : sem c0 (Vlong n1) (Vlong n2) = Some v)","proofString":"rewrite sem_int in H0; inv H0.\nEvalOp.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (c0 : comparison) (n1 : int64) : eval_expr ge sp e m le\n  (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil)\n  (Val.of_bool (intsem c0 n1 n2)).","conclusion":"eval_expr ge sp e m le\n  (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil)\n  (Val.of_bool (intsem c0 n1 n2))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (c0 : comparison) (n1 : int64)","proofString":"EvalOp.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (c0 : comparison) (n1 : int64) : eval_operation ge sp\n  (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) nil m =\nSome (Val.of_bool (intsem c0 n1 n2)).","conclusion":"eval_operation ge sp\n  (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) nil m =\nSome (Val.of_bool (intsem c0 n1 n2))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (c0 : comparison) (n1 : int64)","proofString":"destruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le\n  (if Int64.eq n2 Int64.zero\n   then Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil)\n   else\n    Eop (Ocmp (default Ceq n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v.","conclusion":"eval_expr ge sp e m le\n  (if Int64.eq n2 Int64.zero\n   then Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil)\n   else\n    Eop (Ocmp (default Ceq n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"predSpec Int64.eq Int64.eq_spec n2 Int64.zero.\nsubst n2.\ndestruct v1; simpl in H0; rewrite ? sem_undef, ? sem_eq in H0; inv H0.\nEvalOp.\neapply eval_complimm_default; eauto.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 = Int64.zero) : eval_expr ge sp e m le (Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 = Int64.zero)","proofString":"subst n2.\ndestruct v1; simpl in H0; rewrite ? sem_undef, ? sem_eq in H0; inv H0.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong Int64.zero) = Some v) (H3 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le (Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong Int64.zero) = Some v) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct v1; simpl in H0; rewrite ? sem_undef, ? sem_eq in H0; inv H0.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) : eval_expr ge sp e m le (Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil))\n  (Val.of_bool (Int64.eq (Int64.and i m0) Int64.zero)).","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Cmasklzero m0)) (t1 ::: Enil))\n  (Val.of_bool (Int64.eq (Int64.and i m0) Int64.zero))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i))","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero) : eval_expr ge sp e m le\n  (Eop (Ocmp (default Ceq n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v.","conclusion":"eval_expr ge sp e m le\n  (Eop (Ocmp (default Ceq n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero)","proofString":"eapply eval_complimm_default; eauto.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero) : eval_expr ge sp e m le (Eop (Oandlimm m0) (t1 ::: Enil))\n  (Val.andl v1 (Vlong m0)).","conclusion":"eval_expr ge sp e m le (Eop (Oandlimm m0) (t1 ::: Enil))\n  (Val.andl v1 (Vlong m0))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Ceq (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero)","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le\n  (if Int64.eq n2 Int64.zero\n   then Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil)\n   else\n    Eop (Ocmp (default Cne n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v.","conclusion":"eval_expr ge sp e m le\n  (if Int64.eq n2 Int64.zero\n   then Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil)\n   else\n    Eop (Ocmp (default Cne n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"predSpec Int64.eq Int64.eq_spec n2 Int64.zero.\nsubst n2.\ndestruct v1; simpl in H0; rewrite ? sem_undef, ? sem_ne in H0; inv H0.\nEvalOp.\neapply eval_complimm_default; eauto.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 = Int64.zero) : eval_expr ge sp e m le (Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 = Int64.zero)","proofString":"subst n2.\ndestruct v1; simpl in H0; rewrite ? sem_undef, ? sem_ne in H0; inv H0.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong Int64.zero) = Some v) (H3 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le (Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong Int64.zero) = Some v) (H3 : eval_expr ge sp e m le t1 v1)","proofString":"destruct v1; simpl in H0; rewrite ? sem_undef, ? sem_ne in H0; inv H0.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i)) : eval_expr ge sp e m le (Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil))\n  (Val.of_bool (negb (Int64.eq (Int64.and i m0) Int64.zero))).","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Cmasklnotzero m0)) (t1 ::: Enil))\n  (Val.of_bool (negb (Int64.eq (Int64.and i m0) Int64.zero)))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (m0 : int64) (t1 : expr) (i : int64) (H3 : eval_expr ge sp e m le t1 (Vlong i))","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero) : eval_expr ge sp e m le\n  (Eop (Ocmp (default Cne n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v.","conclusion":"eval_expr ge sp e m le\n  (Eop (Ocmp (default Cne n2)) (Eop (Oandlimm m0) (t1 ::: Enil) ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero)","proofString":"eapply eval_complimm_default; eauto.\nEvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero) : eval_expr ge sp e m le (Eop (Oandlimm m0) (t1 ::: Enil))\n  (Val.andl v1 (Vlong m0)).","conclusion":"eval_expr ge sp e m le (Eop (Oandlimm m0) (t1 ::: Enil))\n  (Val.andl v1 (Vlong m0))","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int64) (t1 : expr) (v v1 : val) (H0 : sem Cne (Val.andl v1 (Vlong m0)) (Vlong n2) = Some v) (H3 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int64.zero)","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (x : val) (c0 : comparison) (e1 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : sem c0 x (Vlong n2) = Some v) : eval_expr ge sp e m le (Eop (Ocmp (default c0 n2)) (e1 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (default c0 n2)) (e1 ::: Enil)) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (x : val) (c0 : comparison) (e1 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : sem c0 x (Vlong n2) = Some v)","proofString":"eapply eval_complimm_default; eauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (x v : val) (H : eval_expr ge sp e m le a x) (H0 : sem c (Vlong n2) x = Some v) : eval_expr ge sp e m le (complimm default intsem (swap_comparison c) a n2) v.","conclusion":"eval_expr ge sp e m le (complimm default intsem (swap_comparison c) a n2) v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (x v : val) (H : eval_expr ge sp e m le a x) (H0 : sem c (Vlong n2) x = Some v)","proofString":"eapply eval_complimm; eauto.\nrewrite sem_swap; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (x v : val) (H : eval_expr ge sp e m le a x) (H0 : sem c (Vlong n2) x = Some v) : sem (swap_comparison c) x (Vlong n2) = Some v.","conclusion":"sem (swap_comparison c) x (Vlong n2) = Some v","hypotheses":"(le : letenv) (c : comparison) (a : expr) (n2 : int64) (x v : val) (H : eval_expr ge sp e m le a x) (H0 : sem c (Vlong n2) x = Some v)","proofString":"rewrite sem_swap; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmpl c (Vlong n1) y = Some v) : eval_expr ge sp e m le\n  (complimm Ccomplimm Int64.cmp (swap_comparison c) t2 n1) v.","conclusion":"eval_expr ge sp e m le\n  (complimm Ccomplimm Int64.cmp (swap_comparison c) t2 n1) v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmpl c (Vlong n1) y = Some v)","proofString":"apply eval_complimm_swap with (sem := Val.cmpl) (x := y); auto.\nintros; unfold Val.cmpl; rewrite Val.swap_cmpl_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmpl c (Vlong n1) y = Some v) : forall (c0 : comparison) (x y0 : val),\nVal.cmpl (swap_comparison c0) x y0 = Val.cmpl c0 y0 x.","conclusion":"forall (c0 : comparison) (x y0 : val),\nVal.cmpl (swap_comparison c0) x y0 = Val.cmpl c0 y0 x","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmpl c (Vlong n1) y = Some v)","proofString":"intros; unfold Val.cmpl; rewrite Val.swap_cmpl_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (v : val) (H : eval_expr ge sp e m le t1 x) (H1 : Val.cmpl c x (Vlong n2) = Some v) : eval_expr ge sp e m le (complimm Ccomplimm Int64.cmp c t1 n2) v.","conclusion":"eval_expr ge sp e m le (complimm Ccomplimm Int64.cmp c t1 n2) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (v : val) (H : eval_expr ge sp e m le t1 x) (H1 : Val.cmpl c x (Vlong n2) = Some v)","proofString":"apply eval_complimm with (sem := Val.cmpl) (x := x); auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le\n  (Eop (Ocmp (Ccomplshift (swap_comparison c) s a0)) (t2 ::: t1 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le\n  (Eop (Ocmp (Ccomplshift (swap_comparison c) s a0)) (t2 ::: t1 ::: Enil)) v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"EvalOp.\nsimpl.\nrewrite Val.swap_cmpl_bool.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Ocmp (Ccomplshift (swap_comparison c) s a0))\n  (y :: v1 :: nil) m = Some v.","conclusion":"eval_operation ge sp (Ocmp (Ccomplshift (swap_comparison c) s a0))\n  (y :: v1 :: nil) m = Some v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"simpl.\nrewrite Val.swap_cmpl_bool.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : Some\n  (Val.of_optbool (Val.cmpl_bool (swap_comparison c) y (eval_shiftl s v1 a0))) =\nSome v.","conclusion":"Some\n  (Val.of_optbool (Val.cmpl_bool (swap_comparison c) y (eval_shiftl s v1 a0))) =\nSome v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.swap_cmpl_bool.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : Some (Val.of_optbool (Val.cmpl_bool c (eval_shiftl s v1 a0) y)) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmpl_bool c (eval_shiftl s v1 a0) y)) = Some v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmpl c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"apply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.of_optbool (Val.cmpl_bool c (eval_shiftl s v1 a0) y) = v) (H4 : eval_expr ge sp e m le t1 v1) : Some (Val.of_optbool (Val.cmpl_bool c (eval_shiftl s v1 a0) y)) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmpl_bool c (eval_shiftl s v1 a0) y)) = Some v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.of_optbool (Val.cmpl_bool c (eval_shiftl s v1 a0) y) = v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"congruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmpl c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1) : eval_expr ge sp e m le (Eop (Ocmp (Ccomplshift c s a0)) (t1 ::: t2 ::: Enil))\n  v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Ccomplshift c s a0)) (t1 ::: t2 ::: Enil))\n  v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmpl c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"EvalOp.\nsimpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmpl c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1) : eval_operation ge sp (Ocmp (Ccomplshift c s a0)) (x :: v1 :: nil) m = Some v.","conclusion":"eval_operation ge sp (Ocmp (Ccomplshift c s a0)) (x :: v1 :: nil) m = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmpl c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"simpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmpl c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.of_optbool (Val.cmpl_bool c x (eval_shiftl s v1 a0))) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmpl_bool c x (eval_shiftl s v1 a0))) = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmpl c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"apply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.of_optbool (Val.cmpl_bool c x (eval_shiftl s v1 a0)) = v) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.of_optbool (Val.cmpl_bool c x (eval_shiftl s v1 a0))) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmpl_bool c x (eval_shiftl s v1 a0))) = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.of_optbool (Val.cmpl_bool c x (eval_shiftl s v1 a0)) = v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"congruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmpl c x y = Some v) : eval_expr ge sp e m le (Eop (Ocmp (Ccompl c)) (e1 ::: e2 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Ccompl c)) (e1 ::: e2 ::: Enil)) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmpl c x y = Some v)","proofString":"EvalOp.\nsimpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmpl c x y = Some v) : eval_operation ge sp (Ocmp (Ccompl c)) (x :: y :: nil) m = Some v.","conclusion":"eval_operation ge sp (Ocmp (Ccompl c)) (x :: y :: nil) m = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmpl c x y = Some v)","proofString":"simpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmpl c x y = Some v) : Some (Val.of_optbool (Val.cmpl_bool c x y)) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmpl_bool c x y)) = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmpl c x y = Some v)","proofString":"apply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.of_optbool (Val.cmpl_bool c x y) = v) : Some (Val.of_optbool (Val.cmpl_bool c x y)) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmpl_bool c x y)) = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.of_optbool (Val.cmpl_bool c x y) = v)","proofString":"congruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c (Vlong n1) y = Some v) : eval_expr ge sp e m le\n  (complimm Ccompluimm Int64.cmpu (swap_comparison c) t2 n1) v.","conclusion":"eval_expr ge sp e m le\n  (complimm Ccompluimm Int64.cmpu (swap_comparison c) t2 n1) v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c (Vlong n1) y = Some v)","proofString":"apply eval_complimm_swap with (sem := Val.cmplu (Mem.valid_pointer m)) (x := y); auto.\nintros; unfold Val.cmplu; rewrite Val.swap_cmplu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c (Vlong n1) y = Some v) : forall (c0 : comparison) (x y0 : val),\nVal.cmplu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmplu (Mem.valid_pointer m) c0 y0 x.","conclusion":"forall (c0 : comparison) (x y0 : val),\nVal.cmplu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmplu (Mem.valid_pointer m) c0 y0 x","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c (Vlong n1) y = Some v)","proofString":"intros; unfold Val.cmplu; rewrite Val.swap_cmplu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (v : val) (H : eval_expr ge sp e m le t1 x) (H1 : Val.cmplu (Mem.valid_pointer m) c x (Vlong n2) = Some v) : eval_expr ge sp e m le (complimm Ccompluimm Int64.cmpu c t1 n2) v.","conclusion":"eval_expr ge sp e m le (complimm Ccompluimm Int64.cmpu c t1 n2) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (v : val) (H : eval_expr ge sp e m le t1 x) (H1 : Val.cmplu (Mem.valid_pointer m) c x (Vlong n2) = Some v)","proofString":"apply eval_complimm with (sem := Val.cmplu (Mem.valid_pointer m)) (x := x); auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le\n  (Eop (Ocmp (Ccomplushift (swap_comparison c) s a0)) (t2 ::: t1 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le\n  (Eop (Ocmp (Ccomplushift (swap_comparison c) s a0)) (t2 ::: t1 ::: Enil)) v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"EvalOp.\nsimpl.\nrewrite Val.swap_cmplu_bool.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Ocmp (Ccomplushift (swap_comparison c) s a0))\n  (y :: v1 :: nil) m = Some v.","conclusion":"eval_operation ge sp (Ocmp (Ccomplushift (swap_comparison c) s a0))\n  (y :: v1 :: nil) m = Some v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"simpl.\nrewrite Val.swap_cmplu_bool.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) (swap_comparison c) y\n        (eval_shiftl s v1 a0))) = Some v.","conclusion":"Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) (swap_comparison c) y\n        (eval_shiftl s v1 a0))) = Some v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"rewrite Val.swap_cmplu_bool.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1) : Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y)) =\nSome v.","conclusion":"Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y)) =\nSome v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y = Some v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"apply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.of_optbool\n  (Val.cmplu_bool (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y) = v) (H4 : eval_expr ge sp e m le t1 v1) : Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y)) =\nSome v.","conclusion":"Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y)) =\nSome v","hypotheses":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount64) (t1 t2 : expr) (v : val) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H1 : Val.of_optbool\n  (Val.cmplu_bool (Mem.valid_pointer m) c (eval_shiftl s v1 a0) y) = v) (H4 : eval_expr ge sp e m le t1 v1)","proofString":"congruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1) : eval_expr ge sp e m le\n  (Eop (Ocmp (Ccomplushift c s a0)) (t1 ::: t2 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le\n  (Eop (Ocmp (Ccomplushift c s a0)) (t1 ::: t2 ::: Enil)) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"EvalOp.\nsimpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1) : eval_operation ge sp (Ocmp (Ccomplushift c s a0)) (x :: v1 :: nil) m = Some v.","conclusion":"eval_operation ge sp (Ocmp (Ccomplushift c s a0)) (x :: v1 :: nil) m = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"simpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1) : Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c x (eval_shiftl s v1 a0))) =\nSome v.","conclusion":"Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c x (eval_shiftl s v1 a0))) =\nSome v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.cmplu (Mem.valid_pointer m) c x (eval_shiftl s v1 a0) = Some v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"apply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.of_optbool\n  (Val.cmplu_bool (Mem.valid_pointer m) c x (eval_shiftl s v1 a0)) = v) (H4 : eval_expr ge sp e m le t2 v1) : Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c x (eval_shiftl s v1 a0))) =\nSome v.","conclusion":"Some\n  (Val.of_optbool\n     (Val.cmplu_bool (Mem.valid_pointer m) c x (eval_shiftl s v1 a0))) =\nSome v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount64) (t2 : expr) (v : val) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H1 : Val.of_optbool\n  (Val.cmplu_bool (Mem.valid_pointer m) c x (eval_shiftl s v1 a0)) = v) (H4 : eval_expr ge sp e m le t2 v1)","proofString":"congruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v) : eval_expr ge sp e m le (Eop (Ocmp (Ccomplu c)) (e1 ::: e2 ::: Enil)) v.","conclusion":"eval_expr ge sp e m le (Eop (Ocmp (Ccomplu c)) (e1 ::: e2 ::: Enil)) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v)","proofString":"EvalOp.\nsimpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v) : eval_operation ge sp (Ocmp (Ccomplu c)) (x :: y :: nil) m = Some v.","conclusion":"eval_operation ge sp (Ocmp (Ccomplu c)) (x :: y :: nil) m = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v)","proofString":"simpl.\napply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v) : Some (Val.of_optbool (Val.cmplu_bool (Mem.valid_pointer m) c x y)) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmplu_bool (Mem.valid_pointer m) c x y)) = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v)","proofString":"apply option_map_of_bool_inv in H1.\ncongruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.of_optbool (Val.cmplu_bool (Mem.valid_pointer m) c x y) = v) : Some (Val.of_optbool (Val.cmplu_bool (Mem.valid_pointer m) c x y)) = Some v.","conclusion":"Some (Val.of_optbool (Val.cmplu_bool (Mem.valid_pointer m) c x y)) = Some v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (v : val) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) (H1 : Val.of_optbool (Val.cmplu_bool (Mem.valid_pointer m) c x y) = v)","proofString":"congruence."}]}