[{"statement":"Lemma trav_label_countable: countable (@set_full trav_label).","proof":"apply countable_prod.\n2: now apply actid_countable.\napply countable_subset with    (s':=eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ (fun ta => exists tid, ta = ta_propagate tid)).\n2: {\nunfolder.\nins.\ndestruct x; eauto.\n}\napply countable_union.\n{\napply finite_countable.\nexists [ta_cover; ta_issue; ta_reserve].\nclear; basic_solver.\n}\npose pos_countable as AA.\ndestruct AA as [AA|AA].\n{\nexfalso.\napply AA.\nrepeat constructor.\n}\ndesf.\nright.\nexists (fun n => ta_propagate (nu n)).\ndestruct AA; desf.\n{\nleft.\nsplits; ins.\n{\nnow exists (nu i).\n}\n{\ninv EQ.\nnow apply INJ.\n}\ndesf; eauto.\ndestruct (SUR tid) as [y].\n{\nclear; basic_solver.\n}\nnow exists y; subst.\n}\nright.\nexists n.\nsplits; ins.\n{\nnow exists (nu i).\n}\n{\ninv EQ.\nnow apply INJ.\n}\ndesf; eauto.\ndestruct (SUR tid) as [y [HH DD]].\n{\nclear; basic_solver.\n}\nexists y.\nnow splits; auto; subst.\n"},{"statement":"Lemma event_surj y : exists x, y = event x.","proof":"ins.\nexists (mkTL ta_cover y); ins.\n"},{"statement":"Lemma event_cover_finite_inj y :\n  set_finite (fun x => y = event x /\\ (action ↓₁ eq ta_cover) x).","proof":"ins.\nexists [mkTL ta_cover y].\nins.\ndesf.\nred in IN0.\ndestruct x as [[]]; ins; auto.\n"},{"statement":"Lemma event_issue_finite_inj y :\n  set_finite (fun x => y = event x /\\ (action ↓₁ eq ta_issue) x).","proof":"ins.\nexists [mkTL ta_issue y].\nins.\ndesf.\nred in IN0.\ndestruct x as [[]]; ins; auto.\n"},{"statement":"Lemma event_collect_eq a e:\n  event ↑₁ eq (mkTL a e) ≡₁ eq e.","proof":"basic_solver.\n"},{"statement":"Lemma dom_rel_collect_event (b : trav_action) A B r\n      (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) :\n  dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B.","proof":"unfolder.\nins.\ndesf.\nexists (mkTL b x); ins.\nsplit; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto.\n"},{"statement":"Lemma dom_rel_collect_event2 (b : trav_action) A B r\n      (UU : B ⊆₁ action ↓₁ eq b):\n  dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B <->\n    dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B.","proof":"split; [by apply dom_rel_collect_event| ].\nins.\nunfolder.\nins.\ndesf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\n{\neexists.\napply seq_eqv_r.\nsplit; vauto.\n}\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto.\n"},{"statement":"Lemma dom_rel_tls_helper T (a1 a2: trav_action) (r: relation actid)\n      (DOM: dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n                    ⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)):\n  dom_rel (⦗action ↓₁ eq a1⦘ ⨾ event ↓ r ⨾ ⦗action ↓₁ eq a2⦘ ⨾ ⦗T⦘) ⊆₁ T.","proof":"rewrite <- id_inter.\ntransitivity (T ∩₁ action ↓₁ eq a1); [| basic_solver].\napply dom_rel_collect_event2; [basic_solver| ].\ngeneralize DOM.\nbasic_solver 10.\n"},{"statement":"Lemma set_pair_cancel_action a B:\n    event ↑₁ (eq a <*> B) ≡₁ B.","proof":"rewrite set_pair_alt.\nsplit; try basic_solver.\nintros b Bb.\nexists (mkTL a b).\nvauto.\n"},{"statement":"Lemma set_pair_exact a e:\n  eq a <*> eq e ≡₁ eq (mkTL a e).","proof":"unfold set_pair.\nsplit; try basic_solver.\nintros [? ?] [-> ->].\nauto.\n"},{"statement":"Lemma iord_no_reserve G sc:\n  iord G sc ≡ restr_rel (set_compl (action ↓₁ eq ta_reserve)) (iord G sc).","proof":"rewrite restr_relE.\nsplit; [| basic_solver].\napply dom_helper_3.\nunfold iord.\niord_dom_unfolder; ins; subst; vauto.\n"},{"statement":"Lemma iord_alt :\n    iord ≡ restr_rel (event ↓₁ (E \\₁ is_init)) iord_simpl.","proof":"unfold iord, iord_simpl.\nbasic_solver 10.\n"},{"statement":"Lemma iord_simpl_irreflexive WF COMP WFSC CONS : irreflexive iord_simpl.","proof":"unfold iord_simpl.\niord_simpl_dom_unfolder.\n{\neapply sb_sc_acyclic; eauto.\napply CONS.\n}\neapply ar_rf_ppo_loc_acyclic; eauto.\n"},{"statement":"Lemma iord_irreflexive WF COMP WFSC CONS : irreflexive iord.","proof":"apply irreflexive_restr.\nauto using iord_simpl_irreflexive.\n"},{"statement":"Lemma AR_trans : transitive AR.","proof":"unfold \"AR\".\nrewrite <- restr_relE.\napply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct.\n"},{"statement":"Lemma AR_irr WF COMP CONS : irreflexive AR.","proof":"unfold \"AR\".\nrewrite <- restr_relE.\napply irreflexive_restr.\napply map_rel_irr.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto.\n"},{"statement":"Lemma AR_acyc WF COMP CONS : acyclic AR.","proof":"apply trans_irr_acyclic; auto with lbase.\n"},{"statement":"Lemma SBRF : SB ⨾ RF ⊆ ∅₂.","proof":"iord_dom_solver.\n"},{"statement":"Lemma SBAR : SB ⨾ AR ⊆ ∅₂.","proof":"iord_dom_solver.\n"},{"statement":"Lemma RFAR : RF ⨾ AR ⊆ ∅₂.","proof":"iord_dom_solver.\n"},{"statement":"Lemma RFRF : RF ⨾ RF ⊆ ∅₂.","proof":"iord_dom_solver.\n"},{"statement":"Lemma RF_trans : transitive RF.","proof":"iord_dom_solver.\n"},{"statement":"Lemma RF_irr : irreflexive RF.","proof":"iord_dom_solver.\n"},{"statement":"Lemma eSB_in_sb_sc_ct : event ↑ SB ⊆ (sb ∪ sc)⁺.","proof":"unfold \"SB\".\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma SB_acyclic WF WFSC CONS : acyclic SB.","proof":"eapply collect_rel_acyclic with (f:=event).\nrewrite eSB_in_sb_sc_ct.\nred.\nrewrite ct_of_ct.\napply sb_sc_acyclic; auto.\napply CONS.\n"},{"statement":"Lemma SB_trans : transitive SB.","proof":"unfold \"SB\".\nrewrite <- restr_relE.\napply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\nnow rewrite ct_ct.\n"},{"statement":"Lemma SB_irr WF WFSC CONS : irreflexive SB.","proof":"arewrite (SB ⊆ SB⁺).\nnow apply SB_acyclic.\n"},{"statement":"Lemma FWBOBFWBOB : FWBOB ⨾ FWBOB ⊆ ∅₂.","proof":"iord_dom_solver.\n"},{"statement":"Lemma FWBOB_trans : transitive FWBOB.","proof":"apply transitiveI.\nrewrite FWBOBFWBOB.\nclear; basic_solver 1.\n"},{"statement":"Lemma FWBOB_irr : irreflexive FWBOB.","proof":"iord_dom_solver.\n"},{"statement":"Lemma IPROP_trans : transitive IPROP.","proof":"apply transitiveI.\niord_dom_solver.\n"},{"statement":"Lemma IPROP_irr : irreflexive IPROP.","proof":"iord_dom_solver.\n"},{"statement":"Lemma PROP_trans : transitive PROP.","proof":"apply transitiveI.\niord_dom_solver.\n"},{"statement":"Lemma PROP_irr : irreflexive PROP.","proof":"iord_dom_solver.\n"},{"statement":"Lemma SBRF_acyc WF WFSC CONS : acyclic (SB ∪ RF).","proof":"apply acyclic_utt; splits; auto with lbase.\nrewrite SBRF.\napply false_acyclic.\n"},{"statement":"Lemma RFSB_trans : transitive (RF ⨾ SB).","proof":"apply transitiveI.\nrewrite !seqA.\nsin_rewrite SBRF.\nclear.\nbasic_solver 1.\n"},{"statement":"Lemma FWBOBSB : FWBOB ⨾ SB ⊆ ∅₂.","proof":"iord_dom_solver.\n"},{"statement":"Lemma ERF : event ↑ RF ⊆ rf^?.","proof":"unfold \"RF\".\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma EFWBOB : event ↑ FWBOB ⊆ fwbob.","proof":"unfold \"FWBOB\".\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma EAR : event ↑ AR ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proof":"unfold \"AR\".\nclear.\nbasic_solver 10.\n"},{"statement":"Lemma RFSBFWBOBINAR WF WFSC CONS : RF ⨾ SB^? ⨾ FWBOB ⊆ AR.","proof":"iord_parts_unfolder.\nrewrite !seqA.\nhahn_frame.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn.\n"},{"statement":"Lemma RFSBFINAR WF WFSC CONS : event ↑ (RF^? ⨾ SB^? ⨾ FWBOB) ⊆ ar⁺.","proof":"rewrite !collect_rel_seqi, !collect_rel_cr.\nrewrite ERF, eSB_in_sb_sc_ct, EFWBOB.\nrewrite cr_of_cr.\nrewrite cr_of_ct.\napply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS.\n"},{"statement":"Lemma FWBOB_SBRF_acyc WF WFSC COMP CONS : acyclic (FWBOB ⨾ (SB ∪ RF)⁺).","proof":"rewrite acyclic_seqC.\nrewrite path_ut2; auto with lbase.\nrewrite ct_of_trans; auto with lbase.\nrepeat (rewrite rt_of_trans; auto with lbase).\narewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\n{\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\n}\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto.\n"},{"statement":"Lemma SBRFFWBOB_acyc WF WFSC COMP CONS : acyclic (SB ∪ RF ∪ FWBOB).","proof":"apply acyclic_ut; splits; auto with lbase.\n"},{"statement":"Lemma iord_acyclic WF WFSC COMP CONS : acyclic iord.","proof":"assert (transitive sb) as SBTRANS.\n{\napply sb_trans.\n}\nred.\nunfold \"iord\".\napply acyclic_restr.\napply acyclic_ut; splits; auto with lbase.\n2: {\nrewrite ct_begin.\narewrite (PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⊆ ∅₂).\n{\niord_dom_solver.\n}\nrewrite seq_false_l.\napply false_acyclic.\n}\napply acyclic_ut; splits; auto with lbase.\n2: {\nrewrite ct_begin.\narewrite (IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⊆ ∅₂).\n{\niord_dom_solver.\n}\nrewrite seq_false_l.\napply false_acyclic.\n}\napply acyclic_ut; splits; auto with lbase.\nrewrite acyclic_seqC.\nrewrite unionA, unionC.\narewrite (FWBOB ⊆ SB^? ⨾ FWBOB).\n{\nclear.\nbasic_solver 10.\n}\nrewrite path_absorb.\n2: {\nleft.\nrewrite seq_union_r.\nrewrite SBRF, union_false_l.\nunionR right.\nhahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase.\n}\narewrite (SB⁺ ⊆ SB).\n{\napply ct_of_trans; auto with lbase.\n}\nrewrite !seq_union_l, !seqA.\nrewrite !SBAR.\nrewrite seq_false_r, !union_false_r.\nrewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\n{\napply ct_of_trans; auto with lbase.\n}\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\n{\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\n}\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto.\n"},{"statement":"Lemma SB_fsupp WF WFSC CONS\n        (FSUPPSC : fsupp sc)\n    : fsupp (restr_rel (event ↓₁ (E \\₁ is_init)) SB).","proof":"assert (FSUPPSB : fsupp (<|set_compl is_init|> ⨾ sb)).\n{\nnow apply fsupp_sb.\n}\nunfold \"SB\".\nrewrite inclusion_t_rt.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\n{\nclear; basic_solver.\n}\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\n{\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\n}\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\n{\nnow apply fsupp_eqv.\n}\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\n{\napply fsupp_seq; auto.\n}\nrepeat apply fsupp_union; auto.\n{\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\n}\n{\nrewrite <- !seqA.\napply fsupp_seq; auto.\n}\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto).\n"},{"statement":"Lemma RF_fsupp (FSUPPRF : fsupp rf) :\n    fsupp RF.","proof":"unfold \"RF\".\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite seq_id_r.\napply fsupp_seq_l_map_rel; auto with lbase.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr.\n"},{"statement":"Lemma AR_fsupp WF WFSC MF CONS COMP\n        (IMM_FAIR: imm_s_fair G sc):\n    fsupp (⦗event ↓₁ (set_compl is_init)⦘ ⨾ AR).","proof":"unfold \"AR\".\nseq_rewrite seq_eqvC.\nrewrite seqA.\nrewrite <- seqA with (r2 := event ↓ _).\nrewrite map_rel_eqv with (f := event), map_rel_seq.\narewrite_id ⦗action ↓₁ eq ta_issue⦘ at 2.\nrewrite seq_id_r.\napply fsupp_seq_l_map_rel; auto with lbase.\neapply fsupp_mori.\n2: {\neapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto.\n}\nred.\nbasic_solver 10.\n"},{"statement":"Lemma FWBOB_fsupp WF : fsupp (restr_rel (event ↓₁ (E \\₁ is_init)) FWBOB).","proof":"assert (FSUPPSB : fsupp (<|set_compl is_init|> ⨾ sb)).\n{\nnow apply fsupp_sb.\n}\nunfold \"FWBOB\".\narewrite_id ⦗action ↓₁ eq ta_issue⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver.\n"},{"statement":"Lemma IPROP_fsupp : fsupp IPROP.","proof":"unfold \"IPROP\".\nrewrite <- seqA.\napply fsupp_seq; auto using fsupp_eqv.\napply fsupp_seq_l_map_rel; auto with lbase.\nrepeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto.\n"},{"statement":"Lemma PROP_fsupp WF MF CONS COMP (IMM_FAIR: imm_s_fair G sc)\n        (TB: fin_threads G):\n    fsupp (⦗event ↓₁ (set_compl is_init)⦘ ⨾ PROP).","proof":"assert (FSUPPSBCR : fsupp (⦗set_compl is_init⦘ ⨾ sb^?)).\n{\nrewrite crE, seq_union_r.\napply fsupp_union; auto using fsupp_seq, fsupp_eqv, fsupp_sb.\n}\nassert (fsupp (⦗set_compl is_init⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) as FSUPPAR.\n{\nrewrite rtE, seq_union_r.\napply fsupp_union; auto using fsupp_seq, fsupp_eqv.\neapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto.\n}\nassert (FSUPSC : fsupp sc).\n{\neapply imm_s_fair_fsupp_sc; eauto.\napply CONS.\n}\nassert (SCPLOC : sc_per_loc G).\n{\napply coherence_sc_per_loc.\napply CONS.\n}\nunfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗W⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\nrewrite !seq_id_r.\nrewrite <- !seqA.\nrewrite seq_eqvC, !seqA.\nrewrite map_rel_eqv with (f := event), map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite <- !seqA.\napply fsupp_seq.\n2: {\napply fsupp_cr.\napply MF.\n}\nrewrite no_fr_to_init; auto.\nrewrite crE, !seq_union_r, !seq_union_l, !seq_id_r.\napply fsupp_union.\n{\neapply fsupp_furr; eauto.\n}\nrewrite <- !seqA, seqA.\napply fsupp_seq.\n2: {\neapply fsupp_furr; eauto.\n}\neapply fsupp_mori with (x:=fr).\n{\nred.\nclear.\nbasic_solver.\n}\napply MF.\n"},{"statement":"Lemma iord_fsupp WF WFSC MF CONS COMP\n        (IMM_FAIR: imm_s_fair G sc)\n        (TB: fin_threads G):\n    fsupp (⦗event ↓₁ (set_compl is_init)⦘ ⨾ iord).","proof":"assert (FSUPPRF : fsupp rf).\n{\nnow apply fsupp_rf.\n}\nassert (FSUPPSC : fsupp sc).\n{\neapply imm_s_fair_fsupp_sc; eauto.\n}\nunfold \"iord\".\nrewrite !restr_union, !seq_union_r.\nrepeat (apply fsupp_union).\n6: {\neapply fsupp_mori; [| eapply PROP_fsupp]; eauto.\nred.\nbasic_solver.\n}\n4: {\neapply fsupp_mori; [| apply AR_fsupp]; auto.\nred.\nbasic_solver.\n}\nall: apply fsupp_seq; [by apply fsupp_eqv| ].\n1, 3: by auto using SB_fsupp, FWBOB_fsupp.\nall: apply fsupp_restr; auto using RF_fsupp, IPROP_fsupp.\n"},{"statement":"Lemma no_RF_to_init_weak WF:\n    ⦗event ↓₁ set_compl is_init⦘ ⨾ RF ≡ ⦗event ↓₁ set_compl is_init⦘ ⨾ RF ⨾ ⦗event ↓₁ set_compl is_init⦘.","proof":"split; [| basic_solver].\nrewrite <- seqA.\napply domb_helper.\nunfold \"RF\".\nrewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\n{\nunfolder.\nins.\ndesc.\ncongruence.\n}\nrewrite no_rf_to_init; auto.\nbasic_solver.\n"},{"statement":"Lemma no_AR_to_init WF CONS:\n    AR ≡ AR ⨾ ⦗event ↓₁ set_compl is_init⦘.","proof":"split; [| basic_solver].\napply domb_helper.\nforward eapply no_ar_rf_ppo_loc_to_init as AR'_NI; eauto.\napply seq_eqv_compl in AR'_NI.\nunfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver.\n"},{"statement":"Lemma no_PROP_to_init WF CONS :\n     ⦗event ↓₁ set_compl is_init⦘ ⨾ PROP ≡\n     ⦗event ↓₁ set_compl is_init⦘ ⨾ PROP ⨾ ⦗event ↓₁ set_compl is_init⦘.","proof":"split; [| basic_solver].\nrewrite <- !seqA.\napply domb_helper.\nunfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\n{\napply coherence_sc_per_loc, CONS.\n}\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10.\n"},{"statement":"Lemma seq_eqv_l_trans {A: Type} (r: relation A) (s: A -> Prop)\n        (TRANS: transitive r):\n    transitive (⦗s⦘ ⨾ r).","proof":"red.\nintros ? ? ? ?%seq_eqv_l ?%seq_eqv_l.\ndesc.\napply seq_eqv_l.\nsplit; auto.\neapply TRANS; eauto.\n"},{"statement":"Lemma iord_ct_fsupp WF WFSC COMP MF CONS\n        (FAIR: mem_fair G)\n        (IMM_FAIR: imm_s_fair G sc)\n        (TB: fin_threads G):\n    fsupp (⦗event ↓₁ (set_compl is_init)⦘ ⨾ iord⁺).","proof":"forward eapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc as FS_AR_RFPPOL; eauto.\nassert (transitive sb) as SBTRANS.\n{\napply sb_trans.\n}\nassert (FSUPPSB : fsupp (<|set_compl is_init|> ⨾ sb)).\n{\nnow apply fsupp_sb.\n}\nassert (FSUPPRF : fsupp rf).\n{\nnow apply fsupp_rf.\n}\nassert (FSUPPSC : fsupp sc).\n{\neapply imm_s_fair_fsupp_sc; eauto.\n}\nunfold \"iord\".\nrewrite !restr_union.\nremember      (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))                 SB) as rSB.\nremember      (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))                 FWBOB) as rFWBOB.\nrewrite !inclusion_restr.\nassert (transitive rFWBOB) as TRFWBOB.\n{\nsubst rFWBOB.\napply transitive_restr.\nauto with lbase.\n}\nassert (rSB ∪ RF ⊆ RF^? ⨾ rSB^?) as SBRFT.\n{\nrewrite crE.\nclear; basic_solver 10.\n}\nassert (fsupp rSB) as FSUPPRSB.\n{\nsubst rSB; auto with lbase.\n}\nassert (fsupp rSB^?) as FSUPPRSBCR.\n{\nnow apply fsupp_cr.\n}\nassert (fsupp rFWBOB) as FSUPPRFWBOB.\n{\nsubst rFWBOB; auto with lbase.\n}\nassert (transitive rSB) as TRSB.\n{\nsubst rSB.\napply transitive_restr.\nauto with lbase.\n}\nassert (rSB ⨾ RF ⊆ ∅₂) as RSBRF.\n{\narewrite (rSB ⊆ SB); auto with lbase.\nsubst rSB.\napply inclusion_restr.\n}\nassert (fsupp (rSB ∪ RF)＊) as SRA.\n{\nrewrite SBRFT.\nrewrite rt_of_trans; auto.\n{\napply fsupp_cr.\napply fsupp_seq; auto.\nall: apply fsupp_cr; auto with lbase.\n}\napply transitiveI.\nrewrite !seqA.\nrewrite !crE, !seq_union_l, !seq_union_r.\nrewrite !seq_id_l,  !seq_id_r.\nsin_rewrite !RFRF.\nsin_rewrite !rewrite_trans; auto with lbase.\nsin_rewrite !RSBRF.\nunionL; eauto with hahn.\nall: clear; basic_solver 1.\n}\nassert (rFWBOB ⨾ rSB ⊆ ∅₂) as RFWBOBSB.\n{\nsubst rFWBOB rSB.\nrewrite !inclusion_restr.\nauto with lbase.\n}\nassert (transitive (RF ⨾ rSB)) as TRFRSB.\n{\napply transitiveI.\nrewrite !seqA.\nsin_rewrite RSBRF.\nclear; basic_solver 1.\n}\nassert (rSB^? ⨾ RF ⊆ RF) as RSBCRRF.\n{\nrewrite crE, !seq_union_l, seq_id_l.\nrewrite RSBRF.\nnow rewrite union_false_r.\n}\nassert (transitive (RF^? ⨾ rSB^?)) as TRFSBCR.\n{\napply transitiveI.\nrewrite !seqA.\nrewrite crE, !seq_union_l, !seq_union_r, !seq_id_l.\narewrite (rSB^? ⨾ rSB^? ⊆ rSB^?).\n{\napply transitiveI.\nnow apply transitive_cr.\n}\nsin_rewrite !RSBCRRF.\nsin_rewrite !RFRF.\nunionL; eauto with hahn.\nclear; basic_solver 1.\n}\nassert (rFWBOB ⨾ (rSB ∪ RF)⁺ ⊆ rFWBOB ⨾ RF ⨾ rSB^?) as FWBOBSBRF.\n{\nrewrite ct_begin.\nrewrite path_ut; auto with lbase.\narewrite (rFWBOB ⨾ (rSB ∪ RF) ⊆ rFWBOB ⨾ RF).\n{\nrewrite seq_union_r.\nrewrite RFWBOBSB.\nunionL; eauto with hahn.\nclear; basic_solver 1.\n}\nrewrite ct_of_trans; auto with lbase.\nrewrite !rt_of_trans; auto with lbase.\nrewrite !crE, !seq_union_r, !seq_union_l, !seq_union_r, !seq_id_r, !seq_id_l.\nsin_rewrite !RSBRF.\nsin_rewrite !RFRF.\nrewrite !seq_false_l, !seq_false_r.\nrewrite !union_false_l, !union_false_r.\nrewrite !seqA.\nsin_rewrite !RFRF.\nrewrite !seq_false_l, !seq_false_r.\nsin_rewrite !RSBRF.\nrewrite !seq_false_l, !seq_false_r.\nnow rewrite !union_false_r.\n}\nassert (fsupp (⦗event ↓₁ set_compl is_init⦘ ⨾ AR^?)) as FARCR.\n{\nrewrite crE, seq_union_r.\napply fsupp_union; [rewrite <- id_inter; by apply fsupp_eqv| ].\nauto with lbase.\n}\nassert (rSB ⊆ SB) as RSBIN.\n{\nsubst rSB.\napply inclusion_restr.\n}\nassert (rFWBOB ⊆ FWBOB) as RFWBOBIN.\n{\nsubst rFWBOB.\napply inclusion_restr.\n}\nassert (rFWBOB ⊆ rFWBOB ⨾ ⦗event ↓₁ set_compl is_init⦘) as FWB_NI.\n{\nsubst rFWBOB.\nbasic_solver.\n}\nassert (fsupp (⦗event ↓₁ set_compl is_init⦘ ⨾ (rSB ∪ RF ∪ rFWBOB))⁺) as FSRFW.\n{\nrewrite !seq_union_r.\nrewrite inclusion_seq_eqv_l with (r := RF), inclusion_seq_eqv_l with (r := rFWBOB).\napply fsupp_rt_ct.\nrewrite path_ut; auto.\nrepeat apply fsupp_seq.\n3: now apply fsupp_cr.\n{\neapply fsupp_mori; [| by apply SRA].\nred.\napply clos_refl_trans_mori.\nbasic_solver.\n}\nrewrite inclusion_seq_eqv_l.\nrewrite FWBOBSBRF.\napply fsupp_ct_rt.\nrewrite ct_rotl, !seqA.\nrewrite rtE.\nrepeat case_union _ _.\napply fsupp_union.\n{\nrepeat (apply fsupp_seq; auto with lbase).\napply fsupp_eqv.\n}\nrewrite FWB_NI, seqA at 1.\nrewrite <- seqA with (r1 := ⦗_⦘).\nrewrite clos_trans_domb_l; [| rewrite FWB_NI; basic_solver].\nrepeat (apply fsupp_seq; auto with lbase).\nrewrite RSBIN, RFWBOBIN.\nrewrite RFSBFWBOBINAR; auto.\neapply fsupp_mori; [| by apply FARCR].\nred.\nrewrite ct_of_trans; [basic_solver| ].\nrewrite <- restr_relE.\napply transitive_restr, AR_trans.\n}\nassert (RF ⨾ rSB^? ⨾ rFWBOB ⊆ AR) as RRFSBFWBOBINAR.\n{\nrewrite RSBIN, RFWBOBIN; auto with lbase.\n}\nassert (PROP ⨾ (rSB ∪ RF ∪ rFWBOB ∪ AR ∪ IPROP) ⊆ ∅₂) as PROPIORDSTEP.\n{\nsubst.\nclear.\niord_dom_solver.\n}\nassert (PROP ⨾ (rSB ∪ RF ∪ rFWBOB ∪ AR ∪ IPROP)⁺ ⊆ ∅₂) as PROPIORD.\n{\nrewrite ct_begin.\nsin_rewrite PROPIORDSTEP.\nclear; basic_solver 1.\n}\nrewrite clos_trans_domb_l_strong.\n2: {\nsubst rSB rFWBOB.\nunfold \"IPROP\".\nrewrite !seq_union_r.\nrepeat apply union_domb; try (clear; basic_solver).\n{\nrewrite no_RF_to_init_weak; auto.\nbasic_solver.\n}\n{\nrewrite no_AR_to_init; auto.\nbasic_solver.\n}\n{\niord_dom_solver.\n}\nrewrite no_PROP_to_init; auto.\nclear.\nbasic_solver.\n}\napply fsupp_rt_ct.\nrewrite <- seqA.\nrewrite inclusion_seq_eqv_r.\nrepeat case_union _ _ .\nrewrite path_ut; auto with lbase.\n2: {\napply seq_eqv_l_trans; auto with lbase.\n}\nrewrite <- !seq_union_r.\nrepeat apply fsupp_seq.\n3: {\neapply fsupp_cr, PROP_fsupp; eauto.\n}\n2: {\nrewrite inclusion_eqv_rel_true, !seq_id_l.\nrewrite PROPIORD.\nrewrite empty_rt.\nauto using fsupp_eqv.\n}\nassert (IPROP ⨾ (rSB ∪ RF ∪ rFWBOB ∪ AR) ⊆ ∅₂) as IPROPIORDSTEP.\n{\nsubst.\nclear.\niord_dom_solver.\n}\nassert (IPROP ⨾ (rSB ∪ RF ∪ rFWBOB ∪ AR)⁺ ⊆ ∅₂) as IPROPIORD.\n{\nrewrite ct_begin.\nsin_rewrite IPROPIORDSTEP.\nclear; basic_solver 1.\n}\nrewrite seq_union_r.\nrewrite path_ut; auto with lbase.\n2: {\napply seq_eqv_l_trans; auto with lbase.\n}\nrewrite <- !seqA.\napply fsupp_seq.\n2: now auto using fsupp_cr, fsupp_seq, fsupp_eqv with lbase.\napply fsupp_seq.\n2: {\nrewrite inclusion_eqv_rel_true, !seq_id_l.\nrewrite IPROPIORD.\nrewrite empty_rt.\nauto using fsupp_eqv.\n}\nrewrite rtE, seq_union_r.\napply fsupp_union; eauto using fsupp_seq, fsupp_eqv.\napply fsupp_rt_ct.\nrewrite path_ut; auto with lbase.\n2: {\napply seq_eqv_l_trans; auto with lbase.\n}\nrepeat apply fsupp_seq.\n3: now apply fsupp_cr; auto with lbase.\n{\nnow apply fsupp_ct_rt.\n}\napply fsupp_ct_rt.\nrewrite ct_rotl.\nrepeat (apply fsupp_seq; auto with lbase).\nrewrite ct_end, !seqA.\nrewrite inclusion_seq_eqv_l with (r := AR).\narewrite ((rSB ∪ RF ∪ rFWBOB) ⨾ AR ⊆ rFWBOB ⨾ AR).\n{\nrewrite !seq_union_l.\nrewrite RSBIN, SBAR, RFAR.\nnow rewrite !union_false_l.\n}\nrepeat case_union _ _.\nremember (event ↓₁ set_compl is_init) as ENI.\nrewrite path_ut; auto.\n2: {\napply seq_eqv_l_trans; auto with lbase.\n}\nrewrite !seqA.\nrewrite <- seqA with (r3 := AR).\nsin_rewrite rewrite_trans_seq_cr_l; auto.\n2: {\napply seq_eqv_l_trans; auto with lbase.\n}\nrewrite inclusion_seq_eqv_l with (r := rSB) at 2.\nrewrite inclusion_seq_eqv_l with (r := RF) at 2.\nrewrite <- seqA with (r2 := rFWBOB).\nrewrite !inclusion_seq_eqv_l with (r := rFWBOB).\nrewrite FWBOBSBRF.\narewrite ((rFWBOB ⨾ RF ⨾ rSB^?)＊ ⨾ rFWBOB ⨾ AR ⊆ rFWBOB ⨾ AR).\n{\nrewrite rtE with (r:=rFWBOB ⨾ RF ⨾ rSB^?).\nrewrite seq_union_l, seq_id_l.\nunionL; eauto with hahn.\nrewrite ct_rotl, !seqA.\nsin_rewrite !RRFSBFWBOBINAR.\nhahn_frame_l.\nseq_rewrite <- ct_end.\nrewrite ct_unit.\napply ct_of_trans; auto with lbase.\n}\neapply fsupp_mori.\n{\nred.\napply clos_refl_trans_mori.\napply doma_rewrite with (d := ENI).\nrewrite rtE.\nrepeat case_union _ _.\napply union_doma.\n{\nsubst rFWBOB.\nbasic_solver.\n}\nrewrite ct_begin.\nbasic_solver.\n}\nrewrite (@inclusion_seq_eqv_l _ rSB).\nrewrite (@inclusion_seq_eqv_l _ RF).\narewrite ((rSB ∪ RF)＊ ⨾ rFWBOB ⊆ RF^? ⨾ rSB^? ⨾ rFWBOB).\n{\nrewrite SBRFT.\nrewrite rt_of_trans; auto.\nrewrite cr_seq, !seqA.\nunionL; eauto with hahn.\nclear.\nbasic_solver 10.\n}\nrewrite crE, !seq_union_l, seq_id_l.\nsin_rewrite RRFSBFWBOBINAR.\nrewrite rewrite_trans; auto with lbase.\nrewrite rt_of_trans.\n{\ncase_union _ _.\nsubst ENI.\napply fsupp_cr, fsupp_union; auto with lbase.\nrewrite FWB_NI.\nrewrite seqA.\nrewrite <- seqA with (r2 := rSB^?).\nrepeat (apply fsupp_seq; auto with lbase).\napply fsupp_eqv.\n}\napply seq_eqv_l_trans.\nassert (AR ⨾ rFWBOB ⊆ ∅₂) as ARFWBOB.\n{\nsubst.\nunfold \"AR\", \"FWBOB\".\niord_dom_solver.\n}\nassert (AR ⨾ rSB ⊆ ∅₂) as ARSB.\n{\nsubst.\nunfold \"AR\", \"SB\".\niord_dom_solver.\n}\nassert (AR ⨾ rSB^? ⨾ rFWBOB ⊆ ∅₂) as ARSBFW.\n{\nrewrite crE, !seq_union_l, !seq_union_r, !seq_id_l.\nrewrite ARFWBOB.\nsin_rewrite ARSB.\nclear; basic_solver 1.\n}\napply transitiveI.\nrewrite !seq_union_r, !seq_union_l, !seqA.\nunionL.\n{\nsin_rewrite ARSBFW.\nclear; basic_solver 1.\n}\n{\nsin_rewrite ARSBFW.\nclear; basic_solver 1.\n}\nall: rewrite rewrite_trans; eauto with hahn lbase.\n"},{"statement":"Lemma PROP_to_ninit (WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) :\n  PROP ≡ PROP ⨾ ⦗event ↓₁ set_compl is_init⦘.","proof":"split; [| basic_solver].\napply domb_helper.\nunfold PROP.\nrewrite furr_to_ninit; auto.\nrelsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\n{\nrewrite no_co_to_init; auto.\nbasic_solver 10.\n}\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto.\n"},{"statement":"Lemma PROP_E_end (WF : Wf G) (WFsc : wf_sc G sc) :\n  PROP ⨾ ⦗event ↓₁ acts_set G⦘ ≡ ⦗event ↓₁ acts_set G⦘ ⨾ PROP ⨾ ⦗event ↓₁ acts_set G⦘.","proof":"split; [| basic_solver].\napply doma_helper.\nunfold PROP.\nrewrite furr_E_ENI_cr, !crE; auto.\nrewrite wf_coE; eauto.\nrewrite wf_frE; eauto.\nrewrite !seq_union_l, !seq_union_r.\nrewrite !map_rel_union.\nrewrite !inter_union_l.\nrepeat case_union _ _.\nrepeat apply union_doma.\n{\nunfold is_ta_propagate_to_G; unfolder; ins; desf; subst;    destruct x, y; ins; subst; ins.\n}\nall: basic_solver 10.\n"},{"statement":"Lemma iord_simpl_E_E (WF : Wf G) (WFsc : wf_sc G sc) :\n  iord_simpl ⊆ event ↓ (E × E)^?.","proof":"unfold iord_simpl.\nunfold SB, RF, FWBOB, AR, IPROP, PROP.\nrewrite ppo_in_sb, fwbob_in_sb; auto.\nrepeat rewrite inclusion_seq_eqv_l with (dom := action ↓₁ eq _).\nrepeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\n{\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\n}\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10.\n"}]