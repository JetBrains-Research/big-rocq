{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/CSEdomain.v","fileSamples":[{"statement":"(valu : valuation) (ge : genv) (sp : val) (m : mem) (rh : rhs) (v : val) (rh' : rhs) (H : rhs_eval_to valu ge sp m rh v) (H0 : rhs_compat rh rh') : rhs_eval_to valu ge sp m rh' v.","proofString":"inv H; inv H0; econstructor; eauto."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) : wf_numbering empty_numbering.","proofString":"split; simpl; intros.\ncontradiction.\nrewrite PTree.gempty in H; discriminate.\ncontradiction."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (e : equation) (H : False) : wf_equation 1%positive e.","proofString":"contradiction."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : positive) (v : valnum) (H : (PTree.empty valnum) ! r = Some v) : Plt v 1.","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : reg) (v : positive) (H : False) : (PTree.empty valnum) ! r = Some v.","proofString":"contradiction."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (eq : equation) (H : False) : equation_holds valu ge sp m eq.","proofString":"contradiction."},{"statement":"(valu : valuation) (ge : genv) (sp : val) (rs : regset) (m : mem) (r : positive) (v : valnum) (H : (PTree.empty valnum) ! r = Some v) : rs # r = valu v.","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(valu : valnum -> val) (c : comparison) (x y : valnum) (res res' : bool) (H : (if eq_valnum x y\n then Some match c with\n           | Cne | Clt | Cgt => false\n           | _ => true\n           end\n else None) = Some res') (H0 : Val.cmp_bool c (valu x) (valu y) = Some res) : res = res'.","proofString":"destruct (eq_valnum x y); inv H.\ndestruct (valu y); simpl in H0; inv H0.\ndestruct c; simpl; unfold Int.lt; rewrite ? Int.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (c : comparison) (y : valnum) (res : bool) (H0 : Val.cmp_bool c (valu y) (valu y) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct (valu y); simpl in H0; inv H0.\ndestruct c; simpl; unfold Int.lt; rewrite ? Int.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (c : comparison) (y : valnum) (i : int) : Int.cmp c i i = match c with\n                | Cne | Clt | Cgt => false\n                | _ => true\n                end.","proofString":"destruct c; simpl; unfold Int.lt; rewrite ? Int.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (x y : valnum) (res res' : bool) (H : (if eq_valnum x y\n then Some match c with\n           | Cne | Clt | Cgt => false\n           | _ => true\n           end\n else None) = Some res') (H0 : match valu x with\n| Vint n1 =>\n    match valu y with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n           || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match valu y with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n           || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n            || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n           Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n          then Val.cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some res) : res = res'.","proofString":"destruct (eq_valnum x y); inv H.\ndestruct (valu y).\ndiscriminate.\ninv H0.\ndestruct c; simpl; unfold Int.ltu; rewrite ? Int.eq_true, ? zlt_false by lia; auto.\ndiscriminate.\ndiscriminate.\ndiscriminate.\ndestruct Archi.ptr64; try discriminate.\nrewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (H0 : match valu y with\n| Vint n1 =>\n    match valu y with\n    | Vint n2 => Some (Int.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n1 Int.zero &&\n          (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n           || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match valu y with\n    | Vint n2 =>\n        if Archi.ptr64\n        then None\n        else\n         if\n          Int.eq n2 Int.zero &&\n          (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n           || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n            || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n           Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n          then Val.cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct (valu y).\ndiscriminate.\ninv H0.\ndestruct c; simpl; unfold Int.ltu; rewrite ? Int.eq_true, ? zlt_false by lia; auto.\ndiscriminate.\ndiscriminate.\ndiscriminate.\ndestruct Archi.ptr64; try discriminate.\nrewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (i : int) (H0 : Some (Int.cmpu c i i) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"inv H0.\ndestruct c; simpl; unfold Int.ltu; rewrite ? Int.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (i : int) : Int.cmpu c i i = match c with\n                 | Cne | Clt | Cgt => false\n                 | _ => true\n                 end.","proofString":"destruct c; simpl; unfold Int.ltu; rewrite ? Int.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (i : int64) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (f : Floats.float) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (f : Floats.float32) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (b : block) (i : ptrofs) (H0 : (if Archi.ptr64\n then None\n else\n  if eq_block b b\n  then\n   if\n    (Mem.valid_pointer m b (Ptrofs.unsigned i)\n     || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) &&\n    (Mem.valid_pointer m b (Ptrofs.unsigned i)\n     || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n   then Some (Ptrofs.cmpu c i i)\n   else None\n  else\n   if\n    Mem.valid_pointer m b (Ptrofs.unsigned i) &&\n    Mem.valid_pointer m b (Ptrofs.unsigned i)\n   then Val.cmp_different_blocks c\n   else None) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct Archi.ptr64; try discriminate.\nrewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (b : block) (i : ptrofs) (H0 : (if eq_block b b\n then\n  if\n   (Mem.valid_pointer m b (Ptrofs.unsigned i)\n    || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) &&\n   (Mem.valid_pointer m b (Ptrofs.unsigned i)\n    || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n  then Some (Ptrofs.cmpu c i i)\n  else None\n else\n  if\n   Mem.valid_pointer m b (Ptrofs.unsigned i) &&\n   Mem.valid_pointer m b (Ptrofs.unsigned i)\n  then Val.cmp_different_blocks c\n  else None) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"rewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (b : block) (i : ptrofs) (H0 : (if\n  (Mem.valid_pointer m b (Ptrofs.unsigned i)\n   || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) &&\n  (Mem.valid_pointer m b (Ptrofs.unsigned i)\n   || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n then Some (Ptrofs.cmpu c i i)\n else None) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (b : block) (i : ptrofs) : Ptrofs.cmpu c i i = match c with\n                    | Cne | Clt | Cgt => false\n                    | _ => true\n                    end.","proofString":"destruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (c : comparison) (x y : valnum) (res res' : bool) (H : (if eq_valnum x y\n then Some match c with\n           | Cne | Clt | Cgt => false\n           | _ => true\n           end\n else None) = Some res') (H0 : Val.cmpl_bool c (valu x) (valu y) = Some res) : res = res'.","proofString":"destruct (eq_valnum x y); inv H.\ndestruct (valu y); simpl in H0; inv H0.\ndestruct c; simpl; unfold Int64.lt; rewrite ? Int64.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (c : comparison) (y : valnum) (res : bool) (H0 : Val.cmpl_bool c (valu y) (valu y) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct (valu y); simpl in H0; inv H0.\ndestruct c; simpl; unfold Int64.lt; rewrite ? Int64.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (c : comparison) (y : valnum) (i : int64) : Int64.cmp c i i = match c with\n                  | Cne | Clt | Cgt => false\n                  | _ => true\n                  end.","proofString":"destruct c; simpl; unfold Int64.lt; rewrite ? Int64.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (x y : valnum) (res res' : bool) (H : (if eq_valnum x y\n then Some match c with\n           | Cne | Clt | Cgt => false\n           | _ => true\n           end\n else None) = Some res') (H0 : match valu x with\n| Vlong n1 =>\n    match valu y with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n           || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match valu y with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n           || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n            || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n           Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n          then Val.cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some res) : res = res'.","proofString":"destruct (eq_valnum x y); inv H.\ndestruct (valu y).\ndiscriminate.\ndiscriminate.\ninv H0.\ndestruct c; simpl; unfold Int64.ltu; rewrite ? Int64.eq_true, ? zlt_false by lia; auto.\ndiscriminate.\ndiscriminate.\ndestruct (negb Archi.ptr64); try discriminate.\nrewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (H0 : match valu y with\n| Vlong n1 =>\n    match valu y with\n    | Vlong n2 => Some (Int64.cmpu c n1 n2)\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n1 Int64.zero &&\n          (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n           || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | _ => None\n    end\n| Vptr b1 ofs1 =>\n    match valu y with\n    | Vlong n2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if\n          Int64.eq n2 Int64.zero &&\n          (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n           || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n         then Val.cmp_different_blocks c\n         else None\n    | Vptr b2 ofs2 =>\n        if negb Archi.ptr64\n        then None\n        else\n         if eq_block b1 b2\n         then\n          if\n           (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n            || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n           (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n          then Some (Ptrofs.cmpu c ofs1 ofs2)\n          else None\n         else\n          if\n           Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n           Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n          then Val.cmp_different_blocks c\n          else None\n    | _ => None\n    end\n| _ => None\nend = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct (valu y).\ndiscriminate.\ndiscriminate.\ninv H0.\ndestruct c; simpl; unfold Int64.ltu; rewrite ? Int64.eq_true, ? zlt_false by lia; auto.\ndiscriminate.\ndiscriminate.\ndestruct (negb Archi.ptr64); try discriminate.\nrewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (i : int) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (i : int64) (H0 : Some (Int64.cmpu c i i) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"inv H0.\ndestruct c; simpl; unfold Int64.ltu; rewrite ? Int64.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (i : int64) : Int64.cmpu c i i = match c with\n                   | Cne | Clt | Cgt => false\n                   | _ => true\n                   end.","proofString":"destruct c; simpl; unfold Int64.ltu; rewrite ? Int64.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (f : Floats.float) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (f : Floats.float32) (H0 : None = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"discriminate."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (b : block) (i : ptrofs) (H0 : (if negb Archi.ptr64\n then None\n else\n  if eq_block b b\n  then\n   if\n    (Mem.valid_pointer m b (Ptrofs.unsigned i)\n     || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) &&\n    (Mem.valid_pointer m b (Ptrofs.unsigned i)\n     || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n   then Some (Ptrofs.cmpu c i i)\n   else None\n  else\n   if\n    Mem.valid_pointer m b (Ptrofs.unsigned i) &&\n    Mem.valid_pointer m b (Ptrofs.unsigned i)\n   then Val.cmp_different_blocks c\n   else None) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct (negb Archi.ptr64); try discriminate.\nrewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (b : block) (i : ptrofs) (H0 : (if eq_block b b\n then\n  if\n   (Mem.valid_pointer m b (Ptrofs.unsigned i)\n    || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) &&\n   (Mem.valid_pointer m b (Ptrofs.unsigned i)\n    || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n  then Some (Ptrofs.cmpu c i i)\n  else None\n else\n  if\n   Mem.valid_pointer m b (Ptrofs.unsigned i) &&\n   Mem.valid_pointer m b (Ptrofs.unsigned i)\n  then Val.cmp_different_blocks c\n  else None) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"rewrite dec_eq_true in H0.\ndestruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (res : bool) (b : block) (i : ptrofs) (H0 : (if\n  (Mem.valid_pointer m b (Ptrofs.unsigned i)\n   || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) &&\n  (Mem.valid_pointer m b (Ptrofs.unsigned i)\n   || Mem.valid_pointer m b (Ptrofs.unsigned i - 1))\n then Some (Ptrofs.cmpu c i i)\n else None) = Some res) : res = match c with\n      | Cne | Clt | Cgt => false\n      | _ => true\n      end.","proofString":"destruct andb in H0; inv H0.\ndestruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."},{"statement":"(valu : valnum -> val) (m : mem) (c : comparison) (y : valnum) (b : block) (i : ptrofs) : Ptrofs.cmpu c i i = match c with\n                    | Cne | Clt | Cgt => false\n                    | _ => true\n                    end.","proofString":"destruct c; simpl; unfold Ptrofs.ltu; rewrite ? Ptrofs.eq_true, ? zlt_false by lia; auto."}]}