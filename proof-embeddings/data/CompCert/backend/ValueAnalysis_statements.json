{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/ValueAnalysis.v","fileSamples":[{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) : exists (ae : aenv) (am : amem),\n  (analyze rm f) # (fn_entrypoint f) = VA.State ae am /\\\n  ematch bc (init_regs vl (fn_params f)) ae /\\ mmatch bc m am.","proofString":"unfold analyze.\nset (lu := Liveness.last_uses f).\nset (entry := VA.State (einit_regs f.(fn_params) f.(fn_sig).(sig_args)) mfunction_entry).\ndestruct (DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)                        (fn_entrypoint f) entry) as [res|] eqn:FIX.\nassert (A: VA.ge res!!(fn_entrypoint f) entry) by (eapply DS.fixpoint_entry; eauto).\ndestruct (res!!(fn_entrypoint f)) as [ | ae am ]; simpl in A.\ncontradiction.\ndestruct A as [A1 A2].\nexists ae, am.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\napply ematch_init; auto.\nauto.\nexists AE.top, mtop.\nsplit.\napply PMap.gi.\nsplit.\napply ematch_ge with (einit_regs (fn_params f) f.(fn_sig).(sig_args)).\napply ematch_init; auto.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) : exists (ae : aenv) (am : amem),\n  match\n    DS.fixpoint (fn_code f) successors_instr (transfer' f (last_uses f) rm)\n      (fn_entrypoint f)\n      (VA.State (einit_regs (fn_params f) (sig_args (fn_sig f)))\n         mfunction_entry)\n  with\n  | Some res => res\n  | None => PMap.init (VA.State AE.top mtop)\n  end # (fn_entrypoint f) = VA.State ae am /\\\n  ematch bc (init_regs vl (fn_params f)) ae /\\ mmatch bc m am.","proofString":"set (lu := Liveness.last_uses f).\nset (entry := VA.State (einit_regs f.(fn_params) f.(fn_sig).(sig_args)) mfunction_entry).\ndestruct (DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)                        (fn_entrypoint f) entry) as [res|] eqn:FIX.\nassert (A: VA.ge res!!(fn_entrypoint f) entry) by (eapply DS.fixpoint_entry; eauto).\ndestruct (res!!(fn_entrypoint f)) as [ | ae am ]; simpl in A.\ncontradiction.\ndestruct A as [A1 A2].\nexists ae, am.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\napply ematch_init; auto.\nauto.\nexists AE.top, mtop.\nsplit.\napply PMap.gi.\nsplit.\napply ematch_ge with (einit_regs (fn_params f) f.(fn_sig).(sig_args)).\napply ematch_init; auto.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) : exists (ae : aenv) (am : amem),\n  match\n    DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n      (fn_entrypoint f)\n      (VA.State (einit_regs (fn_params f) (sig_args (fn_sig f)))\n         mfunction_entry)\n  with\n  | Some res => res\n  | None => PMap.init (VA.State AE.top mtop)\n  end # (fn_entrypoint f) = VA.State ae am /\\\n  ematch bc (init_regs vl (fn_params f)) ae /\\ mmatch bc m am.","proofString":"set (entry := VA.State (einit_regs f.(fn_params) f.(fn_sig).(sig_args)) mfunction_entry).\ndestruct (DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)                        (fn_entrypoint f) entry) as [res|] eqn:FIX.\nassert (A: VA.ge res!!(fn_entrypoint f) entry) by (eapply DS.fixpoint_entry; eauto).\ndestruct (res!!(fn_entrypoint f)) as [ | ae am ]; simpl in A.\ncontradiction.\ndestruct A as [A1 A2].\nexists ae, am.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\napply ematch_init; auto.\nauto.\nexists AE.top, mtop.\nsplit.\napply PMap.gi.\nsplit.\napply ematch_ge with (einit_regs (fn_params f) f.(fn_sig).(sig_args)).\napply ematch_init; auto.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (A : False) : exists (ae : aenv) (am : amem),\n  VA.Bot = VA.State ae am /\\\n  ematch bc (init_regs vl (fn_params f)) ae /\\ mmatch bc m am.","proofString":"contradiction."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f))) /\\\n(forall (bc0 : block_classification) (m0 : mem),\n mmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am)) : exists (ae0 : aenv) (am0 : amem),\n  VA.State ae am = VA.State ae0 am0 /\\\n  ematch bc (init_regs vl (fn_params f)) ae0 /\\ mmatch bc m am0.","proofString":"destruct A as [A1 A2].\nexists ae, am.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\napply ematch_init; auto.\nauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A1 : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f)))) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am) : exists (ae0 : aenv) (am0 : amem),\n  VA.State ae am = VA.State ae0 am0 /\\\n  ematch bc (init_regs vl (fn_params f)) ae0 /\\ mmatch bc m am0.","proofString":"exists ae, am.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\napply ematch_init; auto.\nauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A1 : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f)))) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am) : VA.State ae am = VA.State ae am /\\\nematch bc (init_regs vl (fn_params f)) ae /\\ mmatch bc m am.","proofString":"split.\nauto.\nsplit.\neapply ematch_ge; eauto.\napply ematch_init; auto.\nauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A1 : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f)))) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am) : VA.State ae am = VA.State ae am.","proofString":"auto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A1 : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f)))) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am) : ematch bc (init_regs vl (fn_params f)) ae /\\ mmatch bc m am.","proofString":"split.\neapply ematch_ge; eauto.\napply ematch_init; auto.\nauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A1 : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f)))) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am) : ematch bc (init_regs vl (fn_params f)) ae.","proofString":"eapply ematch_ge; eauto.\napply ematch_init; auto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A1 : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f)))) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am) : ematch bc (init_regs vl (fn_params f))\n  (einit_regs (fn_params f) (sig_args (fn_sig f))).","proofString":"apply ematch_init; auto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (ae : aenv) (am : amem) (A1 : AE.ge ae (einit_regs (fn_params f) (sig_args (fn_sig f)))) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mfunction_entry -> mmatch bc0 m0 am) : mmatch bc m am.","proofString":"auto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : exists (ae : aenv) (am : amem),\n  (PMap.init (VA.State AE.top mtop)) # (fn_entrypoint f) = VA.State ae am /\\\n  ematch bc (init_regs vl (fn_params f)) ae /\\ mmatch bc m am.","proofString":"exists AE.top, mtop.\nsplit.\napply PMap.gi.\nsplit.\napply ematch_ge with (einit_regs (fn_params f) f.(fn_sig).(sig_args)).\napply ematch_init; auto.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : (PMap.init (VA.State AE.top mtop)) # (fn_entrypoint f) = VA.State AE.top mtop /\\\nematch bc (init_regs vl (fn_params f)) AE.top /\\ mmatch bc m mtop.","proofString":"split.\napply PMap.gi.\nsplit.\napply ematch_ge with (einit_regs (fn_params f) f.(fn_sig).(sig_args)).\napply ematch_init; auto.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : (PMap.init (VA.State AE.top mtop)) # (fn_entrypoint f) = VA.State AE.top mtop.","proofString":"apply PMap.gi."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : ematch bc (init_regs vl (fn_params f)) AE.top /\\ mmatch bc m mtop.","proofString":"split.\napply ematch_ge with (einit_regs (fn_params f) f.(fn_sig).(sig_args)).\napply ematch_init; auto.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : ematch bc (init_regs vl (fn_params f)) AE.top.","proofString":"apply ematch_ge with (einit_regs (fn_params f) f.(fn_sig).(sig_args)).\napply ematch_init; auto.\napply AE.ge_top."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : ematch bc (init_regs vl (fn_params f))\n  (einit_regs (fn_params f) (sig_args (fn_sig f))).","proofString":"apply ematch_init; auto."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : AE.ge AE.top (einit_regs (fn_params f) (sig_args (fn_sig f))).","proofString":"apply AE.ge_top."},{"statement":"(rm : romem) (f : function) (vl : list val) (m : mem) (bc : block_classification) (H : forall v : val, In v vl -> vmatch bc v (Ifptr Nonstack)) (H0 : Val.has_argtype_list vl (sig_args (fn_sig f))) (H1 : mmatch bc m mfunction_entry) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) : mmatch bc m mtop.","proofString":"eapply mmatch_top'; eauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (H : match\n  DS.fixpoint (fn_code f) successors_instr (transfer' f (last_uses f) rm)\n    (fn_entrypoint f)\n    (VA.State (einit_regs (fn_params f) (sig_args (fn_sig f)))\n       mfunction_entry)\nwith\n| Some res => res\n| None => PMap.init (VA.State AE.top mtop)\nend # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge\n  match\n    DS.fixpoint (fn_code f) successors_instr (transfer' f (last_uses f) rm)\n      (fn_entrypoint f)\n      (VA.State (einit_regs (fn_params f) (sig_args (fn_sig f)))\n         mfunction_entry)\n  with\n  | Some res => res\n  | None => PMap.init (VA.State AE.top mtop)\n  end # s (transfer f rm n ae am).","proofString":"set (lu := Liveness.last_uses f) in *.\nset (entry := VA.State (einit_regs f.(fn_params) f.(fn_sig).(sig_args)) mfunction_entry) in *.\ndestruct (DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)                        (fn_entrypoint f) entry) as [res|] eqn:FIX.\nassert (A: VA.ge res!!s (transfer' f lu rm n res#n)).\neapply DS.fixpoint_solution; eauto with coqlib.\nintros.\nunfold transfer'.\nsimpl.\nauto.\nrewrite H in A.\nunfold transfer' in A.\nrewrite H2 in A.\nrewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto.\nrewrite H2.\nrewrite PMap.gi.\nsplit; intros.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (H : match\n  DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n    (fn_entrypoint f)\n    (VA.State (einit_regs (fn_params f) (sig_args (fn_sig f)))\n       mfunction_entry)\nwith\n| Some res => res\n| None => PMap.init (VA.State AE.top mtop)\nend # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge\n  match\n    DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n      (fn_entrypoint f)\n      (VA.State (einit_regs (fn_params f) (sig_args (fn_sig f)))\n         mfunction_entry)\n  with\n  | Some res => res\n  | None => PMap.init (VA.State AE.top mtop)\n  end # s (transfer f rm n ae am).","proofString":"set (entry := VA.State (einit_regs f.(fn_params) f.(fn_sig).(sig_args)) mfunction_entry) in *.\ndestruct (DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)                        (fn_entrypoint f) entry) as [res|] eqn:FIX.\nassert (A: VA.ge res!!s (transfer' f lu rm n res#n)).\neapply DS.fixpoint_solution; eauto with coqlib.\nintros.\nunfold transfer'.\nsimpl.\nauto.\nrewrite H in A.\nunfold transfer' in A.\nrewrite H2 in A.\nrewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto.\nrewrite H2.\nrewrite PMap.gi.\nsplit; intros.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (H : match\n  DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n    (fn_entrypoint f) entry\nwith\n| Some res => res\n| None => PMap.init (VA.State AE.top mtop)\nend # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge\n  match\n    DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n      (fn_entrypoint f) entry\n  with\n  | Some res => res\n  | None => PMap.init (VA.State AE.top mtop)\n  end # s (transfer f rm n ae am).","proofString":"destruct (DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)                        (fn_entrypoint f) entry) as [res|] eqn:FIX.\nassert (A: VA.ge res!!s (transfer' f lu rm n res#n)).\neapply DS.fixpoint_solution; eauto with coqlib.\nintros.\nunfold transfer'.\nsimpl.\nauto.\nrewrite H in A.\nunfold transfer' in A.\nrewrite H2 in A.\nrewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto.\nrewrite H2.\nrewrite PMap.gi.\nsplit; intros.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge res # s (transfer f rm n ae am).","proofString":"assert (A: VA.ge res!!s (transfer' f lu rm n res#n)).\neapply DS.fixpoint_solution; eauto with coqlib.\nintros.\nunfold transfer'.\nsimpl.\nauto.\nrewrite H in A.\nunfold transfer' in A.\nrewrite H2 in A.\nrewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge res # s (transfer' f lu rm n res # n).","proofString":"eapply DS.fixpoint_solution; eauto with coqlib.\nintros.\nunfold transfer'.\nsimpl.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : forall n0 : positive, DS.L.eq (transfer' f lu rm n0 DS.L.bot) DS.L.bot.","proofString":"intros.\nunfold transfer'.\nsimpl.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (n0 : positive) : DS.L.eq (transfer' f lu rm n0 DS.L.bot) DS.L.bot.","proofString":"unfold transfer'.\nsimpl.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (n0 : positive) : DS.L.eq\n  match DS.L.bot with\n  | VA.Bot => VA.Bot\n  | VA.State ae0 am0 =>\n      match transfer f rm n0 ae0 am0 with\n      | VA.Bot => VA.Bot\n      | VA.State ae'0 am'0 =>\n          VA.State\n            match lu ! n0 with\n            | Some regs => eforget regs ae'0\n            | None => ae'0\n            end am'0\n      end\n  end DS.L.bot.","proofString":"simpl.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (n0 : positive) : True.","proofString":"auto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (A : VA.ge res # s (transfer' f lu rm n res # n)) : VA.ge res # s (transfer f rm n ae am).","proofString":"rewrite H in A.\nunfold transfer' in A.\nrewrite H2 in A.\nrewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (A : VA.ge res # s (transfer' f lu rm n (VA.State ae am))) : VA.ge res # s (transfer f rm n ae am).","proofString":"unfold transfer' in A.\nrewrite H2 in A.\nrewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (A : VA.ge res # s\n  match transfer f rm n ae am with\n  | VA.Bot => VA.Bot\n  | VA.State ae'0 am'0 =>\n      VA.State\n        match lu ! n with\n        | Some regs => eforget regs ae'0\n        | None => ae'0\n        end am'0\n  end) : VA.ge res # s (transfer f rm n ae am).","proofString":"rewrite H2 in A.\nrewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (A : VA.ge res # s\n  (VA.State\n     match lu ! n with\n     | Some regs => eforget regs ae'\n     | None => ae'\n     end am')) : VA.ge res # s (transfer f rm n ae am).","proofString":"rewrite H2.\ndestruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (A : VA.ge res # s\n  (VA.State\n     match lu ! n with\n     | Some regs => eforget regs ae'\n     | None => ae'\n     end am')) : VA.ge res # s (VA.State ae' am').","proofString":"destruct lu!n.\neapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge.\nauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (l : list reg) (A : VA.ge res # s (VA.State (eforget l ae') am')) : VA.ge res # s (VA.State ae' am').","proofString":"eapply VA.ge_trans.\neauto.\nsplit; auto.\napply eforget_ge."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (l : list reg) (A : VA.ge res # s (VA.State (eforget l ae') am')) : AE.ge (eforget l ae') ae'.","proofString":"apply eforget_ge."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (res : PMap.t DS.L.t) (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = Some res) (H : res # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (A : VA.ge res # s (VA.State ae' am')) : VA.ge res # s (VA.State ae' am').","proofString":"auto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) (H : (PMap.init (VA.State AE.top mtop)) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge (PMap.init (VA.State AE.top mtop)) # s (transfer f rm n ae am).","proofString":"rewrite H2.\nrewrite PMap.gi.\nsplit; intros.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) (H : (PMap.init (VA.State AE.top mtop)) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge (PMap.init (VA.State AE.top mtop)) # s (VA.State ae' am').","proofString":"rewrite PMap.gi.\nsplit; intros.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) (H : (PMap.init (VA.State AE.top mtop)) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : VA.ge (VA.State AE.top mtop) (VA.State ae' am').","proofString":"split; intros.\napply AE.ge_top.\neapply mmatch_top'; eauto."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) (H : (PMap.init (VA.State AE.top mtop)) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') : AE.ge AE.top ae'.","proofString":"apply AE.ge_top."},{"statement":"(f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (rm : romem) (ae' : aenv) (am' : amem) (lu : PTree.t (list reg)) (entry : VA.t') (FIX : DS.fixpoint (fn_code f) successors_instr (transfer' f lu rm)\n  (fn_entrypoint f) entry = None) (H : (PMap.init (VA.State AE.top mtop)) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (bc : block_classification) (m : mem) (H3 : mmatch bc m am') : mmatch bc m mtop.","proofString":"eapply mmatch_top'; eauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') : exists (ae'' : aenv) (am'' : amem),\n  (analyze rm f) # s = VA.State ae'' am'' /\\\n  ematch bc e ae'' /\\ mmatch bc m am''.","proofString":"exploit analyze_successor; eauto.\nrewrite H2.\ndestruct (analyze rm f)#s as [ | ae'' am'']; simpl; try tauto.\nintros [A B].\nexists ae'', am''.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\neauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') : VA.ge (analyze rm f) # s (transfer f rm n ae am) ->\nexists (ae'' : aenv) (am'' : amem),\n  (analyze rm f) # s = VA.State ae'' am'' /\\\n  ematch bc e ae'' /\\ mmatch bc m am''.","proofString":"rewrite H2.\ndestruct (analyze rm f)#s as [ | ae'' am'']; simpl; try tauto.\nintros [A B].\nexists ae'', am''.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\neauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') : VA.ge (analyze rm f) # s (VA.State ae' am') ->\nexists (ae'' : aenv) (am'' : amem),\n  (analyze rm f) # s = VA.State ae'' am'' /\\\n  ematch bc e ae'' /\\ mmatch bc m am''.","proofString":"destruct (analyze rm f)#s as [ | ae'' am'']; simpl; try tauto.\nintros [A B].\nexists ae'', am''.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\neauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') (ae'' : aenv) (am'' : amem) : AE.ge ae'' ae' /\\\n(forall (bc0 : block_classification) (m0 : mem),\n mmatch bc0 m0 am' -> mmatch bc0 m0 am'') ->\nexists (ae''0 : aenv) (am''0 : amem),\n  VA.State ae'' am'' = VA.State ae''0 am''0 /\\\n  ematch bc e ae''0 /\\ mmatch bc m am''0.","proofString":"intros [A B].\nexists ae'', am''.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\neauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') (ae'' : aenv) (am'' : amem) (A : AE.ge ae'' ae') (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am' -> mmatch bc0 m0 am'') : exists (ae''0 : aenv) (am''0 : amem),\n  VA.State ae'' am'' = VA.State ae''0 am''0 /\\\n  ematch bc e ae''0 /\\ mmatch bc m am''0.","proofString":"exists ae'', am''.\nsplit.\nauto.\nsplit.\neapply ematch_ge; eauto.\neauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') (ae'' : aenv) (am'' : amem) (A : AE.ge ae'' ae') (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am' -> mmatch bc0 m0 am'') : VA.State ae'' am'' = VA.State ae'' am'' /\\\nematch bc e ae'' /\\ mmatch bc m am''.","proofString":"split.\nauto.\nsplit.\neapply ematch_ge; eauto.\neauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') (ae'' : aenv) (am'' : amem) (A : AE.ge ae'' ae') (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am' -> mmatch bc0 m0 am'') : VA.State ae'' am'' = VA.State ae'' am''.","proofString":"auto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') (ae'' : aenv) (am'' : amem) (A : AE.ge ae'' ae') (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am' -> mmatch bc0 m0 am'') : ematch bc e ae'' /\\ mmatch bc m am''.","proofString":"split.\neapply ematch_ge; eauto.\neauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') (ae'' : aenv) (am'' : amem) (A : AE.ge ae'' ae') (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am' -> mmatch bc0 m0 am'') : ematch bc e ae''.","proofString":"eapply ematch_ge; eauto."},{"statement":"(e : regset) (m : mem) (rm : romem) (f : function) (n : positive) (ae : aenv) (am : amem) (instr : instruction) (s : node) (ae' : aenv) (am' : amem) (bc : block_classification) (H : (analyze rm f) # n = VA.State ae am) (H0 : (fn_code f) ! n = Some instr) (H1 : In s (successors_instr instr)) (H2 : transfer f rm n ae am = VA.State ae' am') (H3 : ematch bc e ae') (H4 : mmatch bc m am') (ae'' : aenv) (am'' : amem) (A : AE.ge ae'' ae') (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am' -> mmatch bc0 m0 am'') : mmatch bc m am''.","proofString":"eauto."},{"statement":"(bc : block_classification) (e : regset) (ae : aenv) (r : positive) (H : ematch bc e ae) : vmatch bc e # r (areg ae r).","proofString":"apply H."},{"statement":"(bc : block_classification) (e : regset) (ae : aenv) (H : ematch bc e ae) : list_forall2 (vmatch bc) nil nil.","proofString":"constructor."},{"statement":"(bc : block_classification) (e : regset) (ae : aenv) (a : positive) (rl : list positive) (IHrl : ematch bc e ae -> list_forall2 (vmatch bc) e ## rl (aregs ae rl)) (H : ematch bc e ae) : list_forall2 (vmatch bc) (e # a :: e ## rl) (areg ae a :: aregs ae rl).","proofString":"constructor; [apply areg_sound|]; auto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) : forall (a : builtin_arg positive) (v : val),\neval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a v ->\nvmatch bc v (abuiltin_arg ae am rm a).","proofString":"induction 1; simpl; eauto with va.\neapply loadv_sound; eauto.\nsimpl.\nrewrite Ptrofs.add_zero_l.\nauto with va.\nsimpl.\nrewrite Ptrofs.add_zero_l.\nauto with va.\neapply loadv_sound; eauto.\napply symbol_address_sound; auto.\napply symbol_address_sound; auto.\ndestruct Archi.ptr64; auto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : vmatch bc v (loadv chunk rm am (Ptr (Stk ofs))).","proofString":"eapply loadv_sound; eauto.\nsimpl.\nrewrite Ptrofs.add_zero_l.\nauto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : vmatch bc (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) (Ptr (Stk ofs)).","proofString":"simpl.\nrewrite Ptrofs.add_zero_l.\nauto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : vmatch bc (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) (Ptr (Stk ofs)).","proofString":"rewrite Ptrofs.add_zero_l.\nauto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) : vmatch bc (Vptr sp ofs) (Ptr (Stk ofs)).","proofString":"auto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (ofs : ptrofs) : vmatch bc (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) (Ptr (Stk ofs)).","proofString":"simpl.\nrewrite Ptrofs.add_zero_l.\nauto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (ofs : ptrofs) : vmatch bc (Vptr sp (Ptrofs.add Ptrofs.zero ofs)) (Ptr (Stk ofs)).","proofString":"rewrite Ptrofs.add_zero_l.\nauto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (ofs : ptrofs) : vmatch bc (Vptr sp ofs) (Ptr (Stk ofs)).","proofString":"auto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : vmatch bc v (loadv chunk rm am (Ptr (Gl id ofs))).","proofString":"eapply loadv_sound; eauto.\napply symbol_address_sound; auto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) : vmatch bc (Senv.symbol_address ge id ofs) (Ptr (Gl id ofs)).","proofString":"apply symbol_address_sound; auto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (id : ident) (ofs : ptrofs) : vmatch bc (Senv.symbol_address ge id ofs) (Ptr (Gl id ofs)).","proofString":"apply symbol_address_sound; auto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (IHeval_builtin_arg1 : vmatch bc v1 (abuiltin_arg ae am rm a1)) (IHeval_builtin_arg2 : vmatch bc v2 (abuiltin_arg ae am rm a2)) : vmatch bc (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)\n  (if Archi.ptr64\n   then addl (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a2)\n   else add (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a2)).","proofString":"destruct Archi.ptr64; auto with va."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) : forall (al : list (builtin_arg positive)) (vl : list val),\neval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl ->\nlist_forall2 (vmatch bc) vl (map (abuiltin_arg ae am rm) al).","proofString":"induction 1; simpl.\nconstructor.\nconstructor; auto.\neapply abuiltin_arg_sound; eauto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) : list_forall2 (vmatch bc) nil nil.","proofString":"constructor."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : list_forall2 (vmatch bc) bl (map (abuiltin_arg ae am rm) al)) : list_forall2 (vmatch bc) (b1 :: bl)\n  (abuiltin_arg ae am rm a1 :: map (abuiltin_arg ae am rm) al).","proofString":"constructor; auto.\neapply abuiltin_arg_sound; eauto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (EM : ematch bc rs ae) (RM : romatch bc m rm) (MM : mmatch bc m am) (GM : genv_match bc ge) (SP : bc sp = BCstack) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : list_forall2 (vmatch bc) bl (map (abuiltin_arg ae am rm) al)) : vmatch bc b1 (abuiltin_arg ae am rm a1).","proofString":"eapply abuiltin_arg_sound; eauto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (v : val) (av : aval) (res : builtin_res reg) (H : ematch bc rs ae) (H0 : vmatch bc v av) : ematch bc (regmap_setres res v rs) (set_builtin_res res av ae).","proofString":"destruct res; simpl; auto.\napply ematch_update; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (v : val) (av : aval) (x : reg) (H : ematch bc rs ae) (H0 : vmatch bc v av) : ematch bc rs # x <- v (AE.set x av ae).","proofString":"apply ematch_update; auto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (H5 : match\n  builtin_function_sem bf (map val_of_aval (map (abuiltin_arg ae am rm) al))\nwith\n| Some v0 => aval_of_val v0\n| None => None\nend = Some va) (H6 : builtin_function_sem bf vl = Some v) : vmatch bc v va.","proofString":"exploit abuiltin_args_sound; eauto.\nset (vla := map (abuiltin_arg ae am rm) al) in *.\nintros VMA.\ndestruct (builtin_function_sem bf (map val_of_aval vla)) as [v0|] eqn:A; try discriminate.\nassert (LD: Val.lessdef v0 v).\napply val_inject_lessdef.\nexploit (bs_inject _ (builtin_function_sem bf)).\napply val_inject_list_lessdef.\neapply list_val_of_aval_sound; eauto.\nrewrite A, H6; simpl.\nauto.\ninv LD.\napply aval_of_val_sound; auto.\ndiscriminate."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (H5 : match\n  builtin_function_sem bf (map val_of_aval (map (abuiltin_arg ae am rm) al))\nwith\n| Some v0 => aval_of_val v0\n| None => None\nend = Some va) (H6 : builtin_function_sem bf vl = Some v) : list_forall2 (vmatch bc) vl (map (abuiltin_arg ae am rm) al) ->\nvmatch bc v va.","proofString":"set (vla := map (abuiltin_arg ae am rm) al) in *.\nintros VMA.\ndestruct (builtin_function_sem bf (map val_of_aval vla)) as [v0|] eqn:A; try discriminate.\nassert (LD: Val.lessdef v0 v).\napply val_inject_lessdef.\nexploit (bs_inject _ (builtin_function_sem bf)).\napply val_inject_list_lessdef.\neapply list_val_of_aval_sound; eauto.\nrewrite A, H6; simpl.\nauto.\ninv LD.\napply aval_of_val_sound; auto.\ndiscriminate."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (H5 : match builtin_function_sem bf (map val_of_aval vla) with\n| Some v0 => aval_of_val v0\n| None => None\nend = Some va) (H6 : builtin_function_sem bf vl = Some v) : list_forall2 (vmatch bc) vl vla -> vmatch bc v va.","proofString":"intros VMA.\ndestruct (builtin_function_sem bf (map val_of_aval vla)) as [v0|] eqn:A; try discriminate.\nassert (LD: Val.lessdef v0 v).\napply val_inject_lessdef.\nexploit (bs_inject _ (builtin_function_sem bf)).\napply val_inject_list_lessdef.\neapply list_val_of_aval_sound; eauto.\nrewrite A, H6; simpl.\nauto.\ninv LD.\napply aval_of_val_sound; auto.\ndiscriminate."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (H5 : match builtin_function_sem bf (map val_of_aval vla) with\n| Some v0 => aval_of_val v0\n| None => None\nend = Some va) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) : vmatch bc v va.","proofString":"destruct (builtin_function_sem bf (map val_of_aval vla)) as [v0|] eqn:A; try discriminate.\nassert (LD: Val.lessdef v0 v).\napply val_inject_lessdef.\nexploit (bs_inject _ (builtin_function_sem bf)).\napply val_inject_list_lessdef.\neapply list_val_of_aval_sound; eauto.\nrewrite A, H6; simpl.\nauto.\ninv LD.\napply aval_of_val_sound; auto.\ndiscriminate."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (v0 : val) (A : builtin_function_sem bf (map val_of_aval vla) = Some v0) (H5 : aval_of_val v0 = Some va) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) : vmatch bc v va.","proofString":"assert (LD: Val.lessdef v0 v).\napply val_inject_lessdef.\nexploit (bs_inject _ (builtin_function_sem bf)).\napply val_inject_list_lessdef.\neapply list_val_of_aval_sound; eauto.\nrewrite A, H6; simpl.\nauto.\ninv LD.\napply aval_of_val_sound; auto.\ndiscriminate."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (v0 : val) (A : builtin_function_sem bf (map val_of_aval vla) = Some v0) (H5 : aval_of_val v0 = Some va) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) : Val.lessdef v0 v.","proofString":"apply val_inject_lessdef.\nexploit (bs_inject _ (builtin_function_sem bf)).\napply val_inject_list_lessdef.\neapply list_val_of_aval_sound; eauto.\nrewrite A, H6; simpl.\nauto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (v0 : val) (A : builtin_function_sem bf (map val_of_aval vla) = Some v0) (H5 : aval_of_val v0 = Some va) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) : Val.inject (fun b : block => Some (b, 0)) v0 v.","proofString":"exploit (bs_inject _ (builtin_function_sem bf)).\napply val_inject_list_lessdef.\neapply list_val_of_aval_sound; eauto.\nrewrite A, H6; simpl.\nauto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (v0 : val) (A : builtin_function_sem bf (map val_of_aval vla) = Some v0) (H5 : aval_of_val v0 = Some va) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) : Val.inject (fun b : block => Some (b, 0)) v0 v ->\nVal.inject (fun b : block => Some (b, 0)) v0 v.","proofString":"auto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (v0 : val) (A : builtin_function_sem bf (map val_of_aval vla) = Some v0) (H5 : aval_of_val v0 = Some va) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) (LD : Val.lessdef v0 v) : vmatch bc v va.","proofString":"inv LD.\napply aval_of_val_sound; auto.\ndiscriminate."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (H5 : aval_of_val v = Some va) (A : builtin_function_sem bf (map val_of_aval vla) = Some v) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) : vmatch bc v va.","proofString":"apply aval_of_val_sound; auto."},{"statement":"(bc : block_classification) (ge : genv) (rs : regset) (sp : block) (m : mem) (ae : aenv) (rm : romem) (am : amem) (bf : builtin_function) (al : list (builtin_arg positive)) (vl : list val) (v : val) (va : aval) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp Ptrofs.zero) m al vl) (vla : list aval) (H5 : aval_of_val Vundef = Some va) (A : builtin_function_sem bf (map val_of_aval vla) = Some Vundef) (H6 : builtin_function_sem bf vl = Some v) (VMA : list_forall2 (vmatch bc) vl vla) : vmatch bc v va.","proofString":"discriminate."},{"statement":"(b : block) (ofs : ptrofs) (p : aptr) (H : pmatch bc b ofs p) : pmatch bc b ofs Nonstack.","proofString":"inv H; constructor; congruence."},{"statement":"(m : mem) (b : block) (p : aptr) (H : smatch bc m b p) : smatch bc m b Nonstack.","proofString":"destruct H as [A B].\nsplit; intros.\neapply vmatch_no_stack; eauto.\neapply pmatch_no_stack; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc v (Ifptr p)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) : smatch bc m b Nonstack.","proofString":"split; intros.\neapply vmatch_no_stack; eauto.\neapply pmatch_no_stack; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch bc v (Ifptr Nonstack).","proofString":"eapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch bc b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc b' ofs' Nonstack.","proofString":"eapply pmatch_no_stack; eauto."},{"statement":"(m : mem) (am : amem) (astk : ablock) (H : mmatch bc m am) : mmatch bc m\n  {|\n    am_stack := astk;\n    am_glob := PTree.empty ablock;\n    am_nonstack := Nonstack;\n    am_top := Nonstack\n  |}.","proofString":"destruct H.\nconstructor; simpl; intros.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\neapply smatch_no_stack; eauto.\neapply smatch_no_stack; eauto.\nauto."},{"statement":"(m : mem) (am : amem) (astk : ablock) (mmatch_stack : forall b : block, bc b = BCstack -> bmatch bc m b (am_stack am)) (mmatch_glob : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob am) ! id = Some ab -> bmatch bc m b ab) (mmatch_nonstack : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch bc m b (am_nonstack am)) (mmatch_top : forall b : block, bc b <> BCinvalid -> smatch bc m b (am_top am)) (mmatch_below : bc_below bc (Mem.nextblock m)) : mmatch bc m\n  {|\n    am_stack := astk;\n    am_glob := PTree.empty ablock;\n    am_nonstack := Nonstack;\n    am_top := Nonstack\n  |}.","proofString":"constructor; simpl; intros.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\neapply smatch_no_stack; eauto.\neapply smatch_no_stack; eauto.\nauto."},{"statement":"(m : mem) (am : amem) (astk : ablock) (mmatch_stack : forall b0 : block, bc b0 = BCstack -> bmatch bc m b0 (am_stack am)) (mmatch_glob : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch bc m b0 ab) (mmatch_nonstack : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch bc m b0 (am_nonstack am)) (mmatch_top : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 (am_top am)) (mmatch_below : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b = BCstack) : bmatch bc m b astk.","proofString":"elim (NOSTACK b); auto."},{"statement":"(m : mem) (am : amem) (astk : ablock) (mmatch_stack : forall b0 : block, bc b0 = BCstack -> bmatch bc m b0 (am_stack am)) (mmatch_glob : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob am) ! id0 = Some ab0 -> bmatch bc m b0 ab0) (mmatch_nonstack : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch bc m b0 (am_nonstack am)) (mmatch_top : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 (am_top am)) (mmatch_below : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) : bmatch bc m b ab.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(m : mem) (am : amem) (astk : ablock) (mmatch_stack : forall b0 : block, bc b0 = BCstack -> bmatch bc m b0 (am_stack am)) (mmatch_glob : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch bc m b0 ab) (mmatch_nonstack : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch bc m b0 (am_nonstack am)) (mmatch_top : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 (am_top am)) (mmatch_below : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid) : smatch bc m b Nonstack.","proofString":"eapply smatch_no_stack; eauto."},{"statement":"(m : mem) (am : amem) (astk : ablock) (mmatch_stack : forall b0 : block, bc b0 = BCstack -> bmatch bc m b0 (am_stack am)) (mmatch_glob : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch bc m b0 ab) (mmatch_nonstack : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch bc m b0 (am_nonstack am)) (mmatch_top : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 (am_top am)) (mmatch_below : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid) : smatch bc m b Nonstack.","proofString":"eapply smatch_no_stack; eauto."},{"statement":"(m : mem) (am : amem) (astk : ablock) (mmatch_stack : forall b : block, bc b = BCstack -> bmatch bc m b (am_stack am)) (mmatch_glob : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob am) ! id = Some ab -> bmatch bc m b ab) (mmatch_nonstack : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch bc m b (am_nonstack am)) (mmatch_top : forall b : block, bc b <> BCinvalid -> smatch bc m b (am_top am)) (mmatch_below : bc_below bc (Mem.nextblock m)) : bc_below bc (Mem.nextblock m).","proofString":"auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : exists bc' : block_classification,\n  bc_incr bc bc' /\\\n  bc' sp = BCstack /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mfunction_entry /\\\n  (forall b : positive, Plt b sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval),\n   vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)).","proofString":"exploit Mem.nextblock_alloc; eauto.\nintros NB.\nexploit Mem.alloc_result; eauto.\nintros SP.\nassert (SPINVALID: bc sp = BCinvalid).\nrewrite SP.\neapply bc_below_invalid.\napply Plt_strict.\neapply mmatch_below; eauto.\nset (f := fun b => if eq_block b sp then BCstack else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (BC'EQ: forall b, bc b <> BCinvalid -> bc' b = bc b).\nintros; simpl.\napply dec_eq_false.\ncongruence.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply BC'EQ; auto.\nassert (SM: forall b p, bc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack).\nintros.\napply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto.\nassert (SMSTACK: smatch bc' m' sp Pbot).\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nexists bc'; splitall.\nassumption.\nsimpl; apply dec_eq_true.\neapply genv_match_exten; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\napply romatch_exten with bc.\neapply romatch_alloc; eauto.\neapply mmatch_below; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\napply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor.\neapply SM; auto.\neapply mmatch_top; eauto.\nred; simpl; intros.\nrewrite NB.\ndestruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia.\nsimpl; intros.\napply dec_eq_false.\napply Plt_ne.\nauto.\nintros.\napply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : Mem.nextblock m' = Pos.succ (Mem.nextblock m) ->\nexists bc' : block_classification,\n  bc_incr bc bc' /\\\n  bc' sp = BCstack /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mfunction_entry /\\\n  (forall b : positive, Plt b sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval),\n   vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)).","proofString":"intros NB.\nexploit Mem.alloc_result; eauto.\nintros SP.\nassert (SPINVALID: bc sp = BCinvalid).\nrewrite SP.\neapply bc_below_invalid.\napply Plt_strict.\neapply mmatch_below; eauto.\nset (f := fun b => if eq_block b sp then BCstack else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (BC'EQ: forall b, bc b <> BCinvalid -> bc' b = bc b).\nintros; simpl.\napply dec_eq_false.\ncongruence.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply BC'EQ; auto.\nassert (SM: forall b p, bc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack).\nintros.\napply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto.\nassert (SMSTACK: smatch bc' m' sp Pbot).\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nexists bc'; splitall.\nassumption.\nsimpl; apply dec_eq_true.\neapply genv_match_exten; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\napply romatch_exten with bc.\neapply romatch_alloc; eauto.\neapply mmatch_below; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\napply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor.\neapply SM; auto.\neapply mmatch_top; eauto.\nred; simpl; intros.\nrewrite NB.\ndestruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia.\nsimpl; intros.\napply dec_eq_false.\napply Plt_ne.\nauto.\nintros.\napply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : exists bc' : block_classification,\n  bc_incr bc bc' /\\\n  bc' sp = BCstack /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mfunction_entry /\\\n  (forall b : positive, Plt b sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval),\n   vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)).","proofString":"exploit Mem.alloc_result; eauto.\nintros SP.\nassert (SPINVALID: bc sp = BCinvalid).\nrewrite SP.\neapply bc_below_invalid.\napply Plt_strict.\neapply mmatch_below; eauto.\nset (f := fun b => if eq_block b sp then BCstack else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (BC'EQ: forall b, bc b <> BCinvalid -> bc' b = bc b).\nintros; simpl.\napply dec_eq_false.\ncongruence.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply BC'EQ; auto.\nassert (SM: forall b p, bc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack).\nintros.\napply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto.\nassert (SMSTACK: smatch bc' m' sp Pbot).\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nexists bc'; splitall.\nassumption.\nsimpl; apply dec_eq_true.\neapply genv_match_exten; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\napply romatch_exten with bc.\neapply romatch_alloc; eauto.\neapply mmatch_below; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\napply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor.\neapply SM; auto.\neapply mmatch_top; eauto.\nred; simpl; intros.\nrewrite NB.\ndestruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia.\nsimpl; intros.\napply dec_eq_false.\napply Plt_ne.\nauto.\nintros.\napply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : sp = Mem.nextblock m ->\nexists bc' : block_classification,\n  bc_incr bc bc' /\\\n  bc' sp = BCstack /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mfunction_entry /\\\n  (forall b : positive, Plt b sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval),\n   vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)).","proofString":"intros SP.\nassert (SPINVALID: bc sp = BCinvalid).\nrewrite SP.\neapply bc_below_invalid.\napply Plt_strict.\neapply mmatch_below; eauto.\nset (f := fun b => if eq_block b sp then BCstack else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (BC'EQ: forall b, bc b <> BCinvalid -> bc' b = bc b).\nintros; simpl.\napply dec_eq_false.\ncongruence.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply BC'EQ; auto.\nassert (SM: forall b p, bc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack).\nintros.\napply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto.\nassert (SMSTACK: smatch bc' m' sp Pbot).\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nexists bc'; splitall.\nassumption.\nsimpl; apply dec_eq_true.\neapply genv_match_exten; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\napply romatch_exten with bc.\neapply romatch_alloc; eauto.\neapply mmatch_below; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\napply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor.\neapply SM; auto.\neapply mmatch_top; eauto.\nred; simpl; intros.\nrewrite NB.\ndestruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia.\nsimpl; intros.\napply dec_eq_false.\napply Plt_ne.\nauto.\nintros.\napply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) : exists bc' : block_classification,\n  bc_incr bc bc' /\\\n  bc' sp = BCstack /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mfunction_entry /\\\n  (forall b : positive, Plt b sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval),\n   vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)).","proofString":"assert (SPINVALID: bc sp = BCinvalid).\nrewrite SP.\neapply bc_below_invalid.\napply Plt_strict.\neapply mmatch_below; eauto.\nset (f := fun b => if eq_block b sp then BCstack else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (BC'EQ: forall b, bc b <> BCinvalid -> bc' b = bc b).\nintros; simpl.\napply dec_eq_false.\ncongruence.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply BC'EQ; auto.\nassert (SM: forall b p, bc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack).\nintros.\napply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto.\nassert (SMSTACK: smatch bc' m' sp Pbot).\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nexists bc'; splitall.\nassumption.\nsimpl; apply dec_eq_true.\neapply genv_match_exten; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\napply romatch_exten with bc.\neapply romatch_alloc; eauto.\neapply mmatch_below; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\napply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor.\neapply SM; auto.\neapply mmatch_top; eauto.\nred; simpl; intros.\nrewrite NB.\ndestruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia.\nsimpl; intros.\napply dec_eq_false.\napply Plt_ne.\nauto.\nintros.\napply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) : bc sp = BCinvalid.","proofString":"rewrite SP.\neapply bc_below_invalid.\napply Plt_strict.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) : bc (Mem.nextblock m) = BCinvalid.","proofString":"eapply bc_below_invalid.\napply Plt_strict.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) : exists bc' : block_classification,\n  bc_incr bc bc' /\\\n  bc' sp = BCstack /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mfunction_entry /\\\n  (forall b : positive, Plt b sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval),\n   vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)).","proofString":"set (f := fun b => if eq_block b sp then BCstack else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (BC'EQ: forall b, bc b <> BCinvalid -> bc' b = bc b).\nintros; simpl.\napply dec_eq_false.\ncongruence.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply BC'EQ; auto.\nassert (SM: forall b p, bc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack).\nintros.\napply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto.\nassert (SMSTACK: smatch bc' m' sp Pbot).\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nexists bc'; splitall.\nassumption.\nsimpl; apply dec_eq_true.\neapply genv_match_exten; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\napply romatch_exten with bc.\neapply romatch_alloc; eauto.\neapply mmatch_below; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\napply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor.\neapply SM; auto.\neapply mmatch_top; eauto.\nred; simpl; intros.\nrewrite NB.\ndestruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia.\nsimpl; intros.\napply dec_eq_false.\napply Plt_ne.\nauto.\nintros.\napply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (b : positive) (H : (if eq_block b sp then BCstack else bc b) = BCstack) : b = sp.","proofString":"destruct (eq_block b sp); auto.\neelim NOSTACK; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (b : positive) (n : b <> sp) (H : bc b = BCstack) : b = sp.","proofString":"eelim NOSTACK; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2.","proofString":"intros.\ntransitivity sp; auto.\nsymmetry; auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) (b1 b2 : positive) (H0 : f b1 = BCstack) (H1 : f b2 = BCstack) : b1 = b2.","proofString":"transitivity sp; auto.\nsymmetry; auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) (b1 b2 : positive) (H0 : f b1 = BCstack) (H1 : f b2 = BCstack) : sp = b2.","proofString":"symmetry; auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (H : (if eq_block b sp then BCstack else bc b) = BCglob id) : bc b = BCglob id.","proofString":"destruct (eq_block b sp).\ncongruence.\nauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (e : b = sp) (H : BCstack = BCglob id) : bc b = BCglob id.","proofString":"congruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (n : b <> sp) (H : bc b = BCglob id) : bc b = BCglob id.","proofString":"auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (H : forall (b : positive) (id : ident), f b = BCglob id -> bc b = BCglob id) : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2.","proofString":"intros.\neapply (bc_glob bc); eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (H : forall (b : positive) (id0 : ident), f b = BCglob id0 -> bc b = BCglob id0) (b1 b2 : positive) (id : ident) (H0 : f b1 = BCglob id) (H1 : f b2 = BCglob id) : b1 = b2.","proofString":"eapply (bc_glob bc); eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (b : block) (H : bc b <> BCinvalid) : (if eq_block b sp then BCstack else bc b) = bc b.","proofString":"apply dec_eq_false.\ncongruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (b : block) (H : bc b <> BCinvalid) : b <> sp.","proofString":"congruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) : bc_incr bc bc'.","proofString":"red; simpl; intros.\napply BC'EQ; auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack.","proofString":"intros.\napply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (b : block) (p : aptr) (H : bc b <> BCinvalid) (H0 : smatch bc m b p) : smatch bc' m' b Nonstack.","proofString":"apply smatch_incr with bc; auto.\napply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (b : block) (p : aptr) (H : bc b <> BCinvalid) (H0 : smatch bc m b p) : smatch bc m' b Nonstack.","proofString":"apply smatch_inv with m.\napply smatch_no_stack with p; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (b : block) (p : aptr) (H : bc b <> BCinvalid) (H0 : smatch bc m b p) : smatch bc m b Nonstack.","proofString":"apply smatch_no_stack with p; auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (b : block) (p : aptr) (H : bc b <> BCinvalid) (H0 : smatch bc m b p) : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"intros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (b : block) (p : aptr) (H : bc b <> BCinvalid) (H0 : smatch bc m b p) (ofs n : Z) (H1 : n >= 0) : Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"eapply Mem.loadbytes_alloc_unchanged; eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (b : block) (p : aptr) (H : bc b <> BCinvalid) (H0 : smatch bc m b p) (ofs n : Z) (H1 : n >= 0) : Mem.valid_block m b.","proofString":"eapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) : smatch bc' m' sp Pbot.","proofString":"split; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m' sp ofs = Some v) : vmatch bc' v (Ifptr Pbot).","proofString":"exploit Mem.load_alloc_same; eauto.\nintros EQ.\nsubst v.\nconstructor."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m' sp ofs = Some v) : v = Vundef -> vmatch bc' v (Ifptr Pbot).","proofString":"intros EQ.\nsubst v.\nconstructor."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m' sp ofs = Some v) (EQ : v = Vundef) : vmatch bc' v (Ifptr Pbot).","proofString":"subst v.\nconstructor."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (chunk : memory_chunk) (ofs : Z) (H : Mem.load chunk m' sp ofs = Some Vundef) : vmatch bc' Vundef (Ifptr Pbot).","proofString":"constructor."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H : Mem.loadbytes m' sp ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc' b' ofs' Pbot.","proofString":"exploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H : Mem.loadbytes m' sp ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : Fragment (Vptr b' ofs') q i = Undef -> pmatch bc' b' ofs' Pbot.","proofString":"congruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) : bc_incr bc bc'.","proofString":"assumption."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (id : ident) : bc b = BCglob id <-> (if eq_block b sp then BCstack else bc b) = BCglob id.","proofString":"destruct (eq_block b sp); intuition congruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (H : bc b = BCother) : (if eq_block b sp then BCstack else bc b) = BCother.","proofString":"destruct (eq_block b sp); congruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) : romatch bc m' rm.","proofString":"eapply romatch_alloc; eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) : bc_below bc (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (id : ident) : (if eq_block b sp then BCstack else bc b) = BCglob id <-> bc b = BCglob id.","proofString":"destruct (eq_block b sp); intuition auto with va."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (H : (if eq_block b sp then BCstack else bc b) = BCstack) : bmatch bc' m' b (ablock_init Pbot).","proofString":"apply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (H : (if eq_block b sp then BCstack else bc b) = BCstack) : smatch bc' m' b Pbot.","proofString":"destruct (eq_block b sp).\nsubst b.\napply SMSTACK.\nelim (NOSTACK b); auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (e : b = sp) (H : BCstack = BCstack) : smatch bc' m' b Pbot.","proofString":"subst b.\napply SMSTACK."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (H : BCstack = BCstack) : smatch bc' m' sp Pbot.","proofString":"apply SMSTACK."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (n : b <> sp) (H : bc b = BCstack) : smatch bc' m' b Pbot.","proofString":"elim (NOSTACK b); auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (id : ident) (ab : ablock) (b : block) (H : (if eq_block b sp then BCstack else bc b) = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) : bmatch bc' m' b ab.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (H : (if eq_block b sp then BCstack else bc b) <> BCstack) (H0 : (if eq_block b sp then BCstack else bc b) <> BCinvalid) : smatch bc' m' b Nonstack.","proofString":"destruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (e : b = sp) (H : BCstack <> BCstack) (H0 : BCstack <> BCinvalid) : smatch bc' m' b Nonstack.","proofString":"congruence."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (n : b <> sp) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid) : smatch bc' m' b Nonstack.","proofString":"eapply SM; auto.\neapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (H : (if eq_block b sp then BCstack else bc b) <> BCinvalid) : smatch bc' m' b Nonstack.","proofString":"destruct (eq_block b sp).\nsubst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor.\neapply SM; auto.\neapply mmatch_top; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (e : b = sp) (H : BCstack <> BCinvalid) : smatch bc' m' b Nonstack.","proofString":"subst b.\napply smatch_ge with Pbot.\napply SMSTACK.\nconstructor."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (H : BCstack <> BCinvalid) : smatch bc' m' sp Nonstack.","proofString":"apply smatch_ge with Pbot.\napply SMSTACK.\nconstructor."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (H : BCstack <> BCinvalid) : smatch bc' m' sp Pbot.","proofString":"apply SMSTACK."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (H : BCstack <> BCinvalid) : pge Nonstack Pbot.","proofString":"constructor."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : smatch bc' m' b Nonstack.","proofString":"eapply SM; auto.\neapply mmatch_top; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (H : (if eq_block b sp then BCstack else bc b) <> BCinvalid) : Plt b (Mem.nextblock m').","proofString":"rewrite NB.\ndestruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (H : (if eq_block b sp then BCstack else bc b) <> BCinvalid) : Plt b (Pos.succ (Mem.nextblock m)).","proofString":"destruct (eq_block b sp).\nsubst b; rewrite SP; extlia.\nexploit mmatch_below; eauto.\nextlia."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (e : b = sp) (H : BCstack <> BCinvalid) : Plt b (Pos.succ (Mem.nextblock m)).","proofString":"subst b; rewrite SP; extlia."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : Plt b (Pos.succ (Mem.nextblock m)).","proofString":"exploit mmatch_below; eauto.\nextlia."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : Plt b (Mem.nextblock m) -> Plt b (Pos.succ (Mem.nextblock m)).","proofString":"extlia."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : positive) (H : Plt b sp) : (if eq_block b sp then BCstack else bc b) = bc b.","proofString":"apply dec_eq_false.\napply Plt_ne.\nauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : positive) (H : Plt b sp) : b <> sp.","proofString":"apply Plt_ne.\nauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b0 : block, bc b0 <> BCinvalid -> bc' b0 = bc b0) (INCR : bc_incr bc bc') (SM : forall (b0 : block) (p : aptr),\nbc b0 <> BCinvalid -> smatch bc m b0 p -> smatch bc' m' b0 Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (b : positive) (H : Plt b sp) : Plt b sp.","proofString":"auto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack).","proofString":"intros.\napply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (v : val) (x : aval) (H : vmatch bc v x) : vmatch bc' v (Ifptr Nonstack).","proofString":"apply vmatch_incr with bc; auto.\neapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sz : Z) (m' : Mem.mem') (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (ALLOC : Mem.alloc m 0 sz = (m', sp)) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (SP : sp = Mem.nextblock m) (SPINVALID : bc sp = BCinvalid) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (BC'EQ : forall b : block, bc b <> BCinvalid -> bc' b = bc b) (INCR : bc_incr bc bc') (SM : forall (b : block) (p : aptr),\nbc b <> BCinvalid -> smatch bc m b p -> smatch bc' m' b Nonstack) (SMSTACK : smatch bc' m' sp Pbot) (v : val) (x : aval) (H : vmatch bc v x) : vmatch bc v (Ifptr Nonstack).","proofString":"eapply vmatch_no_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) : exists bc' : block_classification,\n  bc_nostack bc' /\\\n  bc' sp = BCother /\\\n  (forall b : block, b <> sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) /\\\n  genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop.","proofString":"set (f := fun b => if eq_block b sp then BCother else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nunfold f; intros.\ndestruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_stack; eauto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nunfold f; intros.\ndestruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_glob; eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (PM: forall b ofs p, pmatch bc b ofs p -> pmatch bc' b ofs Ptop).\nintros.\nassert (pmatch bc b ofs Ptop) by (eapply pmatch_top'; eauto).\ninv H0.\nconstructor; simpl.\ndestruct (eq_block b sp); congruence.\nassert (VM: forall v x, vmatch bc v x -> vmatch bc' v Vtop).\ninduction 1; constructor; eauto.\nassert (SM: forall b p, smatch bc m b p -> smatch bc' m b Ptop).\nintros.\ndestruct H as [S1 S2].\nsplit; intros.\neapply VM.\neapply S1; eauto.\neapply PM.\neapply S2; eauto.\nexists bc'; splitall.\nred; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nred; intros.\nelim n.\neapply bc_stack; eauto.\nsimpl; apply dec_eq_true.\nintros; simpl; apply dec_eq_false; auto.\nauto.\napply genv_match_exten with bc; auto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); auto.\napply romatch_exten with bc; auto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nelim n.\neapply bc_stack; eauto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\nsubst b.\neapply SM.\neapply mmatch_stack; eauto.\neapply SM.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst b.\neapply SM.\neapply mmatch_stack; eauto.\neapply SM.\neapply mmatch_top; eauto.\nred; simpl; intros.\ndestruct (eq_block b sp).\nsubst b.\neapply mmatch_below; eauto.\ncongruence.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (b1 b2 : positive) (H : (if eq_block b1 sp then BCother else bc b1) = BCstack) (H0 : (if eq_block b2 sp then BCother else bc b2) = BCstack) : b1 = b2.","proofString":"destruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (b1 b2 : positive) (n : b1 <> sp) (H : bc b1 = BCstack) (H0 : (if eq_block b2 sp then BCother else bc b2) = BCstack) : b1 = b2.","proofString":"destruct (eq_block b2 sp); try discriminate.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (b1 b2 : positive) (n : b1 <> sp) (H : bc b1 = BCstack) (n0 : b2 <> sp) (H0 : bc b2 = BCstack) : b1 = b2.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (b1 b2 : positive) (id : ident) (H : (if eq_block b1 sp then BCother else bc b1) = BCglob id) (H0 : (if eq_block b2 sp then BCother else bc b2) = BCglob id) : b1 = b2.","proofString":"destruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_glob; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (b1 b2 : positive) (id : ident) (n : b1 <> sp) (H : bc b1 = BCglob id) (H0 : (if eq_block b2 sp then BCother else bc b2) = BCglob id) : b1 = b2.","proofString":"destruct (eq_block b2 sp); try discriminate.\neapply bc_glob; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (b1 b2 : positive) (id : ident) (n : b1 <> sp) (H : bc b1 = BCglob id) (n0 : b2 <> sp) (H0 : bc b2 = BCglob id) : b1 = b2.","proofString":"eapply bc_glob; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (H : pmatch bc b ofs p) (H1 : bc b <> BCinvalid) : (if eq_block b sp then BCother else bc b) <> BCinvalid.","proofString":"destruct (eq_block b sp); congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch bc b ofs p -> pmatch bc' b ofs Ptop) : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop.","proofString":"induction 1; constructor; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) : forall (b : block) (p : aptr), smatch bc m b p -> smatch bc' m b Ptop.","proofString":"intros.\ndestruct H as [S1 S2].\nsplit; intros.\neapply VM.\neapply S1; eauto.\neapply PM.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p0 : aptr),\npmatch bc b0 ofs p0 -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (b : block) (p : aptr) (H : smatch bc m b p) : smatch bc' m b Ptop.","proofString":"destruct H as [S1 S2].\nsplit; intros.\neapply VM.\neapply S1; eauto.\neapply PM.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p0 : aptr),\npmatch bc b0 ofs p0 -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (b : block) (p : aptr) (S1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc v (Ifptr p)) (S2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) : smatch bc' m b Ptop.","proofString":"split; intros.\neapply VM.\neapply S1; eauto.\neapply PM.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npmatch bc b0 ofs0 p0 -> pmatch bc' b0 ofs0 Ptop) (VM : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc' v0 Vtop) (b : block) (p : aptr) (S1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc v0 (Ifptr p)) (S2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch bc' v (Ifptr Ptop).","proofString":"eapply VM.\neapply S1; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npmatch bc b0 ofs0 p0 -> pmatch bc' b0 ofs0 Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (b : block) (p : aptr) (S1 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc v (Ifptr p)) (S2 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch bc b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc' b' ofs' Ptop.","proofString":"eapply PM.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) : (if eq_block b sp then BCother else bc b) <> BCstack.","proofString":"destruct (eq_block b sp).\ncongruence.\nred; intros.\nelim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) : BCother <> BCstack.","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) : bc b <> BCstack.","proofString":"red; intros.\nelim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : False.","proofString":"elim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : b = sp.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b : block) (p : aptr), smatch bc m b p -> smatch bc' m b Ptop) : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop.","proofString":"auto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (id : ident) : bc b = BCglob id <-> (if eq_block b sp then BCother else bc b) = BCglob id.","proofString":"destruct (eq_block b sp); intuition congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : bc b = BCother) : (if eq_block b sp then BCother else bc b) = BCother.","proofString":"destruct (eq_block b sp); auto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (id : ident) : (if eq_block b sp then BCother else bc b) = BCglob id <-> bc b = BCglob id.","proofString":"destruct (eq_block b sp); intuition auto with va."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCother else bc b) = BCstack) : bmatch bc' m b (ablock_init Ptop).","proofString":"destruct (eq_block b sp).\ncongruence.\nelim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCother = BCstack) : bmatch bc' m b (ablock_init Ptop).","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : bmatch bc' m b (ablock_init Ptop).","proofString":"elim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : b = sp.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (id : ident) (ab : ablock) (b : block) (H : (if eq_block b sp then BCother else bc b) = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) : bmatch bc' m b ab.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCother else bc b) <> BCstack) (H0 : (if eq_block b sp then BCother else bc b) <> BCinvalid) : smatch bc' m b Ptop.","proofString":"destruct (eq_block b sp).\nsubst b.\neapply SM.\neapply mmatch_stack; eauto.\neapply SM.\neapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCother <> BCstack) (H0 : BCother <> BCinvalid) : smatch bc' m b Ptop.","proofString":"subst b.\neapply SM.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b : block) (p : aptr), smatch bc m b p -> smatch bc' m b Ptop) (H : BCother <> BCstack) (H0 : BCother <> BCinvalid) : smatch bc' m sp Ptop.","proofString":"eapply SM.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid) : smatch bc' m b Ptop.","proofString":"eapply SM.\neapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCother else bc b) <> BCinvalid) : smatch bc' m b Ptop.","proofString":"destruct (eq_block b sp).\nsubst b.\neapply SM.\neapply mmatch_stack; eauto.\neapply SM.\neapply mmatch_top; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCother <> BCinvalid) : smatch bc' m b Ptop.","proofString":"subst b.\neapply SM.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b : block) (p : aptr), smatch bc m b p -> smatch bc' m b Ptop) (H : BCother <> BCinvalid) : smatch bc' m sp Ptop.","proofString":"eapply SM.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : smatch bc' m b Ptop.","proofString":"eapply SM.\neapply mmatch_top; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCother else bc b) <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"destruct (eq_block b sp).\nsubst b.\neapply mmatch_below; eauto.\ncongruence.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCother <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"subst b.\neapply mmatch_below; eauto.\ncongruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b : block) (p : aptr), smatch bc m b p -> smatch bc' m b Ptop) (H : BCother <> BCinvalid) : Plt sp (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto.\ncongruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b : block) (p : aptr), smatch bc m b p -> smatch bc' m b Ptop) (H : BCother <> BCinvalid) : bc sp <> BCinvalid.","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr), smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) : exists bc' : block_classification,\n  bc_nostack bc' /\\\n  bc' sp = BCinvalid /\\\n  (forall b : block, b <> sp -> bc' b = bc b) /\\\n  (forall (v : val) (x : aval),\n   vge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) /\\\n  genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop.","proofString":"set (f := fun b => if eq_block b sp then BCinvalid else bc b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nunfold f; intros.\ndestruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_stack; eauto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nunfold f; intros.\ndestruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_glob; eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (PM: forall b ofs p, pge Nonstack p -> pmatch bc b ofs p -> pmatch bc' b ofs Ptop).\nintros.\nassert (pmatch bc b ofs Nonstack) by (eapply pmatch_ge; eauto).\ninv H1.\nconstructor; simpl; destruct (eq_block b sp); congruence.\nassert (VM: forall v x, vge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop).\nintros.\napply vmatch_ifptr; intros.\nsubst v.\ninv H0; inv H; eapply PM; eauto.\nassert (SM: forall b p, pge Nonstack p -> smatch bc m b p -> smatch bc' m b Ptop).\nintros.\ndestruct H0 as [S1 S2].\nsplit; intros.\neapply VM with (x := Ifptr p).\nconstructor; auto.\neapply S1; eauto.\neapply PM.\neauto.\neapply S2; eauto.\nexists bc'; splitall.\nred; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nred; intros.\nelim n.\neapply bc_stack; eauto.\nsimpl; apply dec_eq_true.\nintros; simpl; apply dec_eq_false; auto.\nauto.\napply genv_match_exten with bc; auto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\napply romatch_exten with bc; auto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nelim n.\neapply bc_stack; eauto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM.\neauto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\ncongruence.\neapply SM.\neauto.\neapply mmatch_nonstack; eauto.\nred; intros; elim n.\neapply bc_stack; eauto.\nred; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (b1 b2 : positive) (H : (if eq_block b1 sp then BCinvalid else bc b1) = BCstack) (H0 : (if eq_block b2 sp then BCinvalid else bc b2) = BCstack) : b1 = b2.","proofString":"destruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (b1 b2 : positive) (n : b1 <> sp) (H : bc b1 = BCstack) (H0 : (if eq_block b2 sp then BCinvalid else bc b2) = BCstack) : b1 = b2.","proofString":"destruct (eq_block b2 sp); try discriminate.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (b1 b2 : positive) (n : b1 <> sp) (H : bc b1 = BCstack) (n0 : b2 <> sp) (H0 : bc b2 = BCstack) : b1 = b2.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (b1 b2 : positive) (id : ident) (H : (if eq_block b1 sp then BCinvalid else bc b1) = BCglob id) (H0 : (if eq_block b2 sp then BCinvalid else bc b2) = BCglob id) : b1 = b2.","proofString":"destruct (eq_block b1 sp); try discriminate.\ndestruct (eq_block b2 sp); try discriminate.\neapply bc_glob; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (b1 b2 : positive) (id : ident) (n : b1 <> sp) (H : bc b1 = BCglob id) (H0 : (if eq_block b2 sp then BCinvalid else bc b2) = BCglob id) : b1 = b2.","proofString":"destruct (eq_block b2 sp); try discriminate.\neapply bc_glob; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (b1 b2 : positive) (id : ident) (n : b1 <> sp) (H : bc b1 = BCglob id) (n0 : b2 <> sp) (H0 : bc b2 = BCglob id) : b1 = b2.","proofString":"eapply bc_glob; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b ofs p -> pmatch bc' b ofs Ptop) : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop.","proofString":"intros.\napply vmatch_ifptr; intros.\nsubst v.\ninv H0; inv H; eapply PM; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b ofs p -> pmatch bc' b ofs Ptop) (v : val) (x : aval) (H : vge (Ifptr Nonstack) x) (H0 : vmatch bc v x) : vmatch bc' v Vtop.","proofString":"apply vmatch_ifptr; intros.\nsubst v.\ninv H0; inv H; eapply PM; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs0 p -> pmatch bc' b0 ofs0 Ptop) (v : val) (x : aval) (H : vge (Ifptr Nonstack) x) (H0 : vmatch bc v x) (b : block) (ofs : ptrofs) (H1 : v = Vptr b ofs) : pmatch bc' b ofs Ptop.","proofString":"subst v.\ninv H0; inv H; eapply PM; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs0 p -> pmatch bc' b0 ofs0 Ptop) (x : aval) (H : vge (Ifptr Nonstack) x) (b : block) (ofs : ptrofs) (H0 : vmatch bc (Vptr b ofs) x) : pmatch bc' b ofs Ptop.","proofString":"inv H0; inv H; eapply PM; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) : forall (b : block) (p : aptr),\npge Nonstack p -> smatch bc m b p -> smatch bc' m b Ptop.","proofString":"intros.\ndestruct H0 as [S1 S2].\nsplit; intros.\neapply VM with (x := Ifptr p).\nconstructor; auto.\neapply S1; eauto.\neapply PM.\neauto.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p0 : aptr),\npge Nonstack p0 -> pmatch bc b0 ofs p0 -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (b : block) (p : aptr) (H : pge Nonstack p) (H0 : smatch bc m b p) : smatch bc' m b Ptop.","proofString":"destruct H0 as [S1 S2].\nsplit; intros.\neapply VM with (x := Ifptr p).\nconstructor; auto.\neapply S1; eauto.\neapply PM.\neauto.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p0 : aptr),\npge Nonstack p0 -> pmatch bc b0 ofs p0 -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (b : block) (p : aptr) (H : pge Nonstack p) (S1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc v (Ifptr p)) (S2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) : smatch bc' m b Ptop.","proofString":"split; intros.\neapply VM with (x := Ifptr p).\nconstructor; auto.\neapply S1; eauto.\neapply PM.\neauto.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npge Nonstack p0 -> pmatch bc b0 ofs0 p0 -> pmatch bc' b0 ofs0 Ptop) (VM : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc' v0 Vtop) (b : block) (p : aptr) (H : pge Nonstack p) (S1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc v0 (Ifptr p)) (S2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vmatch bc' v (Ifptr Ptop).","proofString":"eapply VM with (x := Ifptr p).\nconstructor; auto.\neapply S1; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npge Nonstack p0 -> pmatch bc b0 ofs0 p0 -> pmatch bc' b0 ofs0 Ptop) (VM : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc' v0 Vtop) (b : block) (p : aptr) (H : pge Nonstack p) (S1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc v0 (Ifptr p)) (S2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vge (Ifptr Nonstack) (Ifptr p).","proofString":"constructor; auto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npge Nonstack p0 -> pmatch bc b0 ofs0 p0 -> pmatch bc' b0 ofs0 Ptop) (VM : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc' v0 Vtop) (b : block) (p : aptr) (H : pge Nonstack p) (S1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc v0 (Ifptr p)) (S2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vmatch bc v (Ifptr p).","proofString":"eapply S1; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npge Nonstack p0 -> pmatch bc b0 ofs0 p0 -> pmatch bc' b0 ofs0 Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (b : block) (p : aptr) (H : pge Nonstack p) (S1 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc v (Ifptr p)) (S2 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch bc b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc' b' ofs' Ptop.","proofString":"eapply PM.\neauto.\neapply S2; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) : (if eq_block b sp then BCinvalid else bc b) <> BCstack.","proofString":"destruct (eq_block b sp).\ncongruence.\nred; intros.\nelim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) : BCinvalid <> BCstack.","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) : bc b <> BCstack.","proofString":"red; intros.\nelim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : False.","proofString":"elim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : b = sp.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b ofs p -> pmatch bc' b ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b : block) (p : aptr),\npge Nonstack p -> smatch bc m b p -> smatch bc' m b Ptop) : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop.","proofString":"auto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (id : ident) : bc b = BCglob id <-> (if eq_block b sp then BCinvalid else bc b) = BCglob id.","proofString":"destruct (eq_block b sp); intuition congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : bc b = BCother) : (if eq_block b sp then BCinvalid else bc b) = BCother.","proofString":"destruct (eq_block b sp); congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (id : ident) : (if eq_block b sp then BCinvalid else bc b) = BCglob id <-> bc b = BCglob id.","proofString":"destruct (eq_block b sp); intuition auto with va."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCinvalid else bc b) = BCstack) : bmatch bc' m b (ablock_init Ptop).","proofString":"destruct (eq_block b sp).\ncongruence.\nelim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCinvalid = BCstack) : bmatch bc' m b (ablock_init Ptop).","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : bmatch bc' m b (ablock_init Ptop).","proofString":"elim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b = BCstack) : b = sp.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (id : ident) (ab : ablock) (b : block) (H : (if eq_block b sp then BCinvalid else bc b) = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) : bmatch bc' m b ab.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCinvalid else bc b) <> BCstack) (H0 : (if eq_block b sp then BCinvalid else bc b) <> BCinvalid) : smatch bc' m b Ptop.","proofString":"destruct (eq_block b sp).\ncongruence.\neapply SM.\neauto.\neapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCinvalid <> BCstack) (H0 : BCinvalid <> BCinvalid) : smatch bc' m b Ptop.","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid) : smatch bc' m b Ptop.","proofString":"eapply SM.\neauto.\neapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCinvalid else bc b) <> BCinvalid) : smatch bc' m b Ptop.","proofString":"destruct (eq_block b sp).\ncongruence.\neapply SM.\neauto.\neapply mmatch_nonstack; eauto.\nred; intros; elim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCinvalid <> BCinvalid) : smatch bc' m b Ptop.","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : smatch bc' m b Ptop.","proofString":"eapply SM.\neauto.\neapply mmatch_nonstack; eauto.\nred; intros; elim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : bc b <> BCstack.","proofString":"red; intros; elim n.\neapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) (H0 : bc b = BCstack) : b = sp.","proofString":"eapply bc_stack; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (H : (if eq_block b sp then BCinvalid else bc b) <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"destruct (eq_block b sp).\ncongruence.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (e : b = sp) (H : BCinvalid <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"congruence."},{"statement":"(m : mem) (sp : block) (bc : block_classification) (ge : genv) (rm : romem) (am : amem) (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (SP : bc sp = BCstack) (NOLEAK : pge Nonstack (am_nonstack am)) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npge Nonstack p -> pmatch bc b0 ofs p -> pmatch bc' b0 ofs Ptop) (VM : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (SM : forall (b0 : block) (p : aptr),\npge Nonstack p -> smatch bc m b0 p -> smatch bc' m b0 Ptop) (b : block) (n : b <> sp) (H : bc b <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) : exists bc : block_classification,\n  vmatch bc v Vtop /\\\n  ematch bc e ae /\\\n  romatch bc m rm /\\\n  mmatch bc m mafter_public_call /\\\n  genv_match bc ge /\\\n  bc sp = BCstack /\\ (forall b : positive, Plt b sp -> bc b = caller b).","proofString":"set (f := fun b => if eq_block b sp then BCstack else callee b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> callee b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob callee); eauto.\nset (bc := BC f F_stack F_glob).\nunfold f in bc.\nassert (INCR: bc_incr caller bc).\nred; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nsymmetry; apply SAME; auto.\nassert (PM: forall b ofs p, pmatch callee b ofs p -> pmatch bc b ofs Ptop).\nintros.\nassert (pmatch callee b ofs Ptop) by (eapply pmatch_top'; eauto).\ninv H0.\nconstructor; simpl.\ndestruct (eq_block b sp); congruence.\nassert (VM: forall v x, vmatch callee v x -> vmatch bc v Vtop).\nintros.\nassert (vmatch callee v0 Vtop) by (eapply vmatch_top; eauto).\ninv H0; constructor; eauto.\nassert (SM: forall b p, smatch callee m b p -> smatch bc m b Ptop).\nintros.\ndestruct H; split; intros.\neapply VM; eauto.\neapply PM; eauto.\nexists bc; splitall.\neapply VM; eauto.\neapply ematch_incr; eauto.\napply romatch_exten with callee; auto.\nintros; simpl.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\napply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\neapply SM.\neapply mmatch_nonstack; eauto.\ncongruence.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\neapply SM.\neapply mmatch_top; eauto.\ndestruct (eq_block b sp); congruence.\nred; simpl; intros.\ndestruct (eq_block b sp).\nsubst b.\neapply mmatch_below; eauto.\ncongruence.\neapply mmatch_below; eauto.\neapply genv_match_exten with caller; eauto.\nsimpl; intros.\ndestruct (eq_block b sp).\nintuition congruence.\nsplit; intros.\nrewrite SAME in H by eauto with va.\nauto.\napply <- (proj1 GE2) in H.\napply (proj1 GE1) in H.\nauto.\nsimpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nrewrite <- SAME; eauto with va.\nsimpl.\napply dec_eq_true.\nsimpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nsymmetry.\napply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (b : positive) (H : (if eq_block b sp then BCstack else callee b) = BCstack) : b = sp.","proofString":"destruct (eq_block b sp); auto.\neelim NOSTACK; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (b : positive) (n : b <> sp) (H : callee b = BCstack) : b = sp.","proofString":"eelim NOSTACK; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2.","proofString":"intros.\ntransitivity sp; auto.\nsymmetry; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) (b1 b2 : positive) (H0 : f b1 = BCstack) (H1 : f b2 = BCstack) : b1 = b2.","proofString":"transitivity sp; auto.\nsymmetry; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) (b1 b2 : positive) (H0 : f b1 = BCstack) (H1 : f b2 = BCstack) : sp = b2.","proofString":"symmetry; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (H : (if eq_block b sp then BCstack else callee b) = BCglob id) : callee b = BCglob id.","proofString":"destruct (eq_block b sp).\ncongruence.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (e0 : b = sp) (H : BCstack = BCglob id) : callee b = BCglob id.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (n : b <> sp) (H : callee b = BCglob id) : callee b = BCglob id.","proofString":"auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (H : forall (b : positive) (id : ident), f b = BCglob id -> callee b = BCglob id) : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2.","proofString":"intros.\neapply (bc_glob callee); eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (H : forall (b : positive) (id0 : ident),\nf b = BCglob id0 -> callee b = BCglob id0) (b1 b2 : positive) (id : ident) (H0 : f b1 = BCglob id) (H1 : f b2 = BCglob id) : b1 = b2.","proofString":"eapply (bc_glob callee); eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (b : block) (H : caller b <> BCinvalid) : (if eq_block b sp then BCstack else callee b) = caller b.","proofString":"destruct (eq_block b sp).\ncongruence.\nsymmetry; apply SAME; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (b : block) (H : caller b <> BCinvalid) (e0 : b = sp) : BCstack = caller b.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (b : block) (H : caller b <> BCinvalid) (n : b <> sp) : callee b = caller b.","proofString":"symmetry; apply SAME; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (b : block) (ofs : ptrofs) (p : aptr) (H : pmatch callee b ofs p) (H1 : callee b <> BCinvalid) : (if eq_block b sp then BCstack else callee b) <> BCinvalid.","proofString":"destruct (eq_block b sp); congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop.","proofString":"intros.\nassert (vmatch callee v0 Vtop) by (eapply vmatch_top; eauto).\ninv H0; constructor; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (v0 : val) (x : aval) (H : vmatch callee v0 x) : vmatch bc v0 Vtop.","proofString":"assert (vmatch callee v0 Vtop) by (eapply vmatch_top; eauto).\ninv H0; constructor; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (v0 : val) (x : aval) (H : vmatch callee v0 x) (H0 : vmatch callee v0 Vtop) : vmatch bc v0 Vtop.","proofString":"inv H0; constructor; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop.","proofString":"intros.\ndestruct H; split; intros.\neapply VM; eauto.\neapply PM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p0 : aptr),\npmatch callee b0 ofs p0 -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (b : block) (p : aptr) (H : smatch callee m b p) : smatch bc m b Ptop.","proofString":"destruct H; split; intros.\neapply VM; eauto.\neapply PM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npmatch callee b0 ofs0 p0 -> pmatch bc b0 ofs0 Ptop) (VM : forall (v1 : val) (x : aval), vmatch callee v1 x -> vmatch bc v1 Vtop) (b : block) (p : aptr) (H : forall (chunk0 : memory_chunk) (ofs0 : Z) (v1 : val),\nMem.load chunk0 m b ofs0 = Some v1 -> vmatch callee v1 (Ifptr p)) (H0 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch callee b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v0 : val) (H1 : Mem.load chunk m b ofs = Some v0) : vmatch bc v0 (Ifptr Ptop).","proofString":"eapply VM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npmatch callee b0 ofs0 p0 -> pmatch bc b0 ofs0 Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (b : block) (p : aptr) (H : forall (chunk : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk m b ofs0 = Some v0 -> vmatch callee v0 (Ifptr p)) (H0 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch callee b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc b' ofs' Ptop.","proofString":"eapply PM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop) : vmatch bc v Vtop.","proofString":"eapply VM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop) : ematch bc e ae.","proofString":"eapply ematch_incr; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) : (if eq_block b sp then BCstack else callee b) = BCglob id <->\ncallee b = BCglob id.","proofString":"destruct (eq_block b sp); intuition auto with va."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : (if eq_block b sp then BCstack else callee b) = BCstack) : bmatch bc m b (ablock_init Ptop).","proofString":"apply ablock_init_sound.\ndestruct (eq_block b sp).\nsubst b.\neapply SM.\neapply mmatch_nonstack; eauto.\ncongruence.\nelim (NOSTACK b); auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : (if eq_block b sp then BCstack else callee b) = BCstack) : smatch bc m b Ptop.","proofString":"destruct (eq_block b sp).\nsubst b.\neapply SM.\neapply mmatch_nonstack; eauto.\ncongruence.\nelim (NOSTACK b); auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (e0 : b = sp) (H : BCstack = BCstack) : smatch bc m b Ptop.","proofString":"subst b.\neapply SM.\neapply mmatch_nonstack; eauto.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop) (H : BCstack = BCstack) : smatch bc m sp Ptop.","proofString":"eapply SM.\neapply mmatch_nonstack; eauto.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop) (H : BCstack = BCstack) : callee sp <> BCinvalid.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (n : b <> sp) (H : callee b = BCstack) : smatch bc m b Ptop.","proofString":"elim (NOSTACK b); auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (id : ident) (ab : ablock) (b : block) (H : (if eq_block b sp then BCstack else callee b) = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) : bmatch bc m b ab.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : (if eq_block b sp then BCstack else callee b) <> BCstack) (H0 : (if eq_block b sp then BCstack else callee b) <> BCinvalid) : smatch bc m b Ptop.","proofString":"destruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (e0 : b = sp) (H : BCstack <> BCstack) (H0 : BCstack <> BCinvalid) : smatch bc m b Ptop.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (n : b <> sp) (H : callee b <> BCstack) (H0 : callee b <> BCinvalid) : smatch bc m b Ptop.","proofString":"eapply SM; auto.\neapply mmatch_nonstack; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : (if eq_block b sp then BCstack else callee b) <> BCinvalid) : smatch bc m b Ptop.","proofString":"eapply SM.\neapply mmatch_top; eauto.\ndestruct (eq_block b sp); congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : (if eq_block b sp then BCstack else callee b) <> BCinvalid) : callee b <> BCinvalid.","proofString":"destruct (eq_block b sp); congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : (if eq_block b sp then BCstack else callee b) <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"destruct (eq_block b sp).\nsubst b.\neapply mmatch_below; eauto.\ncongruence.\neapply mmatch_below; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (e0 : b = sp) (H : BCstack <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"subst b.\neapply mmatch_below; eauto.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop) (H : BCstack <> BCinvalid) : Plt sp (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop) (H : BCstack <> BCinvalid) : callee sp <> BCinvalid.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (n : b <> sp) (H : callee b <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) : caller b = BCglob id <->\n(if eq_block b sp then BCstack else callee b) = BCglob id.","proofString":"destruct (eq_block b sp).\nintuition congruence.\nsplit; intros.\nrewrite SAME in H by eauto with va.\nauto.\napply <- (proj1 GE2) in H.\napply (proj1 GE1) in H.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) (e0 : b = sp) : caller b = BCglob id <-> BCstack = BCglob id.","proofString":"intuition congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) (n : b <> sp) : caller b = BCglob id <-> callee b = BCglob id.","proofString":"split; intros.\nrewrite SAME in H by eauto with va.\nauto.\napply <- (proj1 GE2) in H.\napply (proj1 GE1) in H.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) (n : b <> sp) (H : caller b = BCglob id) : callee b = BCglob id.","proofString":"rewrite SAME in H by eauto with va.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) (n : b <> sp) (H : callee b = BCglob id) : callee b = BCglob id.","proofString":"auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) (n : b <> sp) (H : callee b = BCglob id) : caller b = BCglob id.","proofString":"apply <- (proj1 GE2) in H.\napply (proj1 GE1) in H.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) (n : b <> sp) (H : Genv.find_symbol ge id = Some b) : caller b = BCglob id.","proofString":"apply (proj1 GE1) in H.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (id : ident) (n : b <> sp) (H : caller b = BCglob id) : caller b = BCglob id.","proofString":"auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : caller b = BCother) : (if eq_block b sp then BCstack else callee b) = BCother.","proofString":"destruct (eq_block b sp).\ncongruence.\nrewrite <- SAME; eauto with va."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : caller b = BCother) (e0 : b = sp) : BCstack = BCother.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : block) (H : caller b = BCother) (n : b <> sp) : callee b = BCother.","proofString":"rewrite <- SAME; eauto with va."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Ptop) : (if eq_block sp sp then BCstack else callee sp) = BCstack.","proofString":"apply dec_eq_true."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : positive) (H : Plt b sp) : (if eq_block b sp then BCstack else callee b) = caller b.","proofString":"destruct (eq_block b sp).\ncongruence.\nsymmetry.\napply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : positive) (H : Plt b sp) (e0 : b = sp) : BCstack = caller b.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : positive) (H : Plt b sp) (n : b <> sp) : callee b = caller b.","proofString":"symmetry.\napply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : positive) (H : Plt b sp) (n : b <> sp) : caller b = callee b.","proofString":"apply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : positive) (H : Plt b sp) (n : b <> sp) : Plt b bound.","proofString":"eapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : Mem.mem') (rm : romem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCother) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR : bc_incr caller bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Ptop) (VM : forall (v0 : val) (x : aval), vmatch callee v0 x -> vmatch bc v0 Vtop) (SM : forall (b0 : block) (p : aptr), smatch callee m b0 p -> smatch bc m b0 Ptop) (b : positive) (H : Plt b sp) (n : b <> sp) : caller sp <> BCinvalid.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) : exists bc : block_classification,\n  vmatch bc v (Ifptr Nonstack) /\\\n  ematch bc e ae /\\\n  romatch bc m rm /\\\n  mmatch bc m (mafter_private_call am) /\\\n  genv_match bc ge /\\\n  bc sp = BCstack /\\ (forall b : positive, Plt b sp -> bc b = caller b).","proofString":"set (f := fun b => if eq_block b sp then BCstack else callee b).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> b = sp).\nunfold f; intros.\ndestruct (eq_block b sp); auto.\neelim NOSTACK; eauto.\nintros.\ntransitivity sp; auto.\nsymmetry; auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> callee b = BCglob id).\nunfold f; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nintros.\neapply (bc_glob callee); eauto.\nset (bc := BC f F_stack F_glob).\nunfold f in bc.\nassert (INCR1: bc_incr caller bc).\nred; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nsymmetry; apply SAME; auto.\nassert (INCR2: bc_incr callee bc).\nred; simpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nauto.\nassert (PM: forall b ofs p, pmatch callee b ofs p -> pmatch bc b ofs Nonstack).\nintros.\nassert (pmatch callee b ofs Ptop) by (eapply pmatch_top'; eauto).\ninv H0.\nconstructor; simpl; destruct (eq_block b sp); congruence.\nassert (VM: forall v x, vmatch callee v x -> vmatch bc v (Ifptr Nonstack)).\nintros.\nassert (vmatch callee v0 Vtop) by (eapply vmatch_top; eauto).\ninv H0; constructor; eauto.\nassert (SM: forall b p, smatch callee m b p -> smatch bc m b Nonstack).\nintros.\ndestruct H; split; intros.\neapply VM; eauto.\neapply PM; eauto.\nassert (BSTK: bmatch bc m sp (am_stack am)).\napply bmatch_incr with caller; eauto.\nexists bc; splitall.\neapply VM; eauto.\neapply ematch_incr; eauto.\napply romatch_exten with callee; auto.\nintros; simpl.\ndestruct (eq_block b sp); intuition auto with va.\nconstructor; simpl; intros.\ndestruct (eq_block b sp).\nsubst b.\nexact BSTK.\nelim (NOSTACK b); auto.\nrewrite PTree.gempty in H0; discriminate.\ndestruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto.\ndestruct (eq_block b sp).\nsubst.\napply smatch_ge with (ab_summary (am_stack am)).\napply BSTK.\napply pge_lub_l.\napply smatch_ge with Nonstack.\neapply SM.\neapply mmatch_top; eauto.\napply pge_lub_r.\nred; simpl; intros.\ndestruct (eq_block b sp).\nsubst b.\napply Pos.lt_le_trans with bound.\napply BELOW.\ncongruence.\nauto.\neapply mmatch_below; eauto.\neapply genv_match_exten; eauto.\nsimpl; intros.\ndestruct (eq_block b sp); intuition congruence.\nsimpl; intros.\ndestruct (eq_block b sp); congruence.\nsimpl.\napply dec_eq_true.\nsimpl; intros.\ndestruct (eq_block b sp).\ncongruence.\nsymmetry.\napply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (b : positive) (H : (if eq_block b sp then BCstack else callee b) = BCstack) : b = sp.","proofString":"destruct (eq_block b sp); auto.\neelim NOSTACK; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (b : positive) (n : b <> sp) (H : callee b = BCstack) : b = sp.","proofString":"eelim NOSTACK; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2.","proofString":"intros.\ntransitivity sp; auto.\nsymmetry; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) (b1 b2 : positive) (H0 : f b1 = BCstack) (H1 : f b2 = BCstack) : b1 = b2.","proofString":"transitivity sp; auto.\nsymmetry; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> b = sp) (b1 b2 : positive) (H0 : f b1 = BCstack) (H1 : f b2 = BCstack) : sp = b2.","proofString":"symmetry; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (H : (if eq_block b sp then BCstack else callee b) = BCglob id) : callee b = BCglob id.","proofString":"destruct (eq_block b sp).\ncongruence.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (e0 : b = sp) (H : BCstack = BCglob id) : callee b = BCglob id.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (n : b <> sp) (H : callee b = BCglob id) : callee b = BCglob id.","proofString":"auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (H : forall (b : positive) (id : ident), f b = BCglob id -> callee b = BCglob id) : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2.","proofString":"intros.\neapply (bc_glob callee); eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (H : forall (b : positive) (id0 : ident),\nf b = BCglob id0 -> callee b = BCglob id0) (b1 b2 : positive) (id : ident) (H0 : f b1 = BCglob id) (H1 : f b2 = BCglob id) : b1 = b2.","proofString":"eapply (bc_glob callee); eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (b : block) (H : caller b <> BCinvalid) : (if eq_block b sp then BCstack else callee b) = caller b.","proofString":"destruct (eq_block b sp).\ncongruence.\nsymmetry; apply SAME; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (b : block) (H : caller b <> BCinvalid) (e0 : b = sp) : BCstack = caller b.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (b : block) (H : caller b <> BCinvalid) (n : b <> sp) : callee b = caller b.","proofString":"symmetry; apply SAME; auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (b : block) (H : callee b <> BCinvalid) : (if eq_block b sp then BCstack else callee b) = callee b.","proofString":"destruct (eq_block b sp).\ncongruence.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (b : block) (H : callee b <> BCinvalid) (e0 : b = sp) : BCstack = callee b.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (b : block) (H : callee b <> BCinvalid) (n : b <> sp) : callee b = callee b.","proofString":"auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack).","proofString":"intros.\nassert (vmatch callee v0 Vtop) by (eapply vmatch_top; eauto).\ninv H0; constructor; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (v0 : val) (x : aval) (H : vmatch callee v0 x) : vmatch bc v0 (Ifptr Nonstack).","proofString":"assert (vmatch callee v0 Vtop) by (eapply vmatch_top; eauto).\ninv H0; constructor; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (v0 : val) (x : aval) (H : vmatch callee v0 x) (H0 : vmatch callee v0 Vtop) : vmatch bc v0 (Ifptr Nonstack).","proofString":"inv H0; constructor; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack.","proofString":"intros.\ndestruct H; split; intros.\neapply VM; eauto.\neapply PM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p0 : aptr),\npmatch callee b0 ofs p0 -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (b : block) (p : aptr) (H : smatch callee m b p) : smatch bc m b Nonstack.","proofString":"destruct H; split; intros.\neapply VM; eauto.\neapply PM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npmatch callee b0 ofs0 p0 -> pmatch bc b0 ofs0 Nonstack) (VM : forall (v1 : val) (x : aval),\nvmatch callee v1 x -> vmatch bc v1 (Ifptr Nonstack)) (b : block) (p : aptr) (H : forall (chunk0 : memory_chunk) (ofs0 : Z) (v1 : val),\nMem.load chunk0 m b ofs0 = Some v1 -> vmatch callee v1 (Ifptr p)) (H0 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch callee b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v0 : val) (H1 : Mem.load chunk m b ofs = Some v0) : vmatch bc v0 (Ifptr Nonstack).","proofString":"eapply VM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs0 : ptrofs) (p0 : aptr),\npmatch callee b0 ofs0 p0 -> pmatch bc b0 ofs0 Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (b : block) (p : aptr) (H : forall (chunk : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk m b ofs0 = Some v0 -> vmatch callee v0 (Ifptr p)) (H0 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch callee b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc b' ofs' Nonstack.","proofString":"eapply PM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) : bmatch bc m sp (am_stack am).","proofString":"apply bmatch_incr with caller; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) : vmatch bc v (Ifptr Nonstack).","proofString":"eapply VM; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) : ematch bc e ae.","proofString":"eapply ematch_incr; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (id : ident) : (if eq_block b sp then BCstack else callee b) = BCglob id <->\ncallee b = BCglob id.","proofString":"destruct (eq_block b sp); intuition auto with va."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (H : (if eq_block b sp then BCstack else callee b) = BCstack) : bmatch bc m b (am_stack am).","proofString":"destruct (eq_block b sp).\nsubst b.\nexact BSTK.\nelim (NOSTACK b); auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (e0 : b = sp) (H : BCstack = BCstack) : bmatch bc m b (am_stack am).","proofString":"subst b.\nexact BSTK."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack = BCstack) : bmatch bc m sp (am_stack am).","proofString":"exact BSTK."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (n : b <> sp) (H : callee b = BCstack) : bmatch bc m b (am_stack am).","proofString":"elim (NOSTACK b); auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (id : ident) (ab : ablock) (b : block) (H : (if eq_block b sp then BCstack else callee b) = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) : bmatch bc m b ab.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (H : (if eq_block b sp then BCstack else callee b) <> BCstack) (H0 : (if eq_block b sp then BCstack else callee b) <> BCinvalid) : smatch bc m b Nonstack.","proofString":"destruct (eq_block b sp).\ncongruence.\neapply SM; auto.\neapply mmatch_nonstack; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (e0 : b = sp) (H : BCstack <> BCstack) (H0 : BCstack <> BCinvalid) : smatch bc m b Nonstack.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (n : b <> sp) (H : callee b <> BCstack) (H0 : callee b <> BCinvalid) : smatch bc m b Nonstack.","proofString":"eapply SM; auto.\neapply mmatch_nonstack; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (H : (if eq_block b sp then BCstack else callee b) <> BCinvalid) : smatch bc m b (plub (ab_summary (am_stack am)) Nonstack).","proofString":"destruct (eq_block b sp).\nsubst.\napply smatch_ge with (ab_summary (am_stack am)).\napply BSTK.\napply pge_lub_l.\napply smatch_ge with Nonstack.\neapply SM.\neapply mmatch_top; eauto.\napply pge_lub_r."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (e0 : b = sp) (H : BCstack <> BCinvalid) : smatch bc m b (plub (ab_summary (am_stack am)) Nonstack).","proofString":"subst.\napply smatch_ge with (ab_summary (am_stack am)).\napply BSTK.\napply pge_lub_l."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack <> BCinvalid) : smatch bc m sp (plub (ab_summary (am_stack am)) Nonstack).","proofString":"apply smatch_ge with (ab_summary (am_stack am)).\napply BSTK.\napply pge_lub_l."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack <> BCinvalid) : smatch bc m sp (ab_summary (am_stack am)).","proofString":"apply BSTK."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack <> BCinvalid) : pge (plub (ab_summary (am_stack am)) Nonstack) (ab_summary (am_stack am)).","proofString":"apply pge_lub_l."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (n : b <> sp) (H : callee b <> BCinvalid) : smatch bc m b (plub (ab_summary (am_stack am)) Nonstack).","proofString":"apply smatch_ge with Nonstack.\neapply SM.\neapply mmatch_top; eauto.\napply pge_lub_r."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (n : b <> sp) (H : callee b <> BCinvalid) : smatch bc m b Nonstack.","proofString":"eapply SM.\neapply mmatch_top; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (n : b <> sp) (H : callee b <> BCinvalid) : pge (plub (ab_summary (am_stack am)) Nonstack) Nonstack.","proofString":"apply pge_lub_r."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (H : (if eq_block b sp then BCstack else callee b) <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"destruct (eq_block b sp).\nsubst b.\napply Pos.lt_le_trans with bound.\napply BELOW.\ncongruence.\nauto.\neapply mmatch_below; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (e0 : b = sp) (H : BCstack <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"subst b.\napply Pos.lt_le_trans with bound.\napply BELOW.\ncongruence.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack <> BCinvalid) : Plt sp (Mem.nextblock m).","proofString":"apply Pos.lt_le_trans with bound.\napply BELOW.\ncongruence.\nauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack <> BCinvalid) : (sp < bound)%positive.","proofString":"apply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack <> BCinvalid) : caller sp <> BCinvalid.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (H : BCstack <> BCinvalid) : (bound <= Mem.nextblock m)%positive.","proofString":"auto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (n : b <> sp) (H : callee b <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (id : ident) : callee b = BCglob id <->\n(if eq_block b sp then BCstack else callee b) = BCglob id.","proofString":"destruct (eq_block b sp); intuition congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : block) (H : callee b = BCother) : (if eq_block b sp then BCstack else callee b) = BCother.","proofString":"destruct (eq_block b sp); congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b : positive, Plt b bound -> b <> sp -> caller b = callee b) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b : block) (ofs : ptrofs) (p : aptr),\npmatch callee b ofs p -> pmatch bc b ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b : block) (p : aptr), smatch callee m b p -> smatch bc m b Nonstack) (BSTK : bmatch bc m sp (am_stack am)) : (if eq_block sp sp then BCstack else callee sp) = BCstack.","proofString":"apply dec_eq_true."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : positive) (H : Plt b sp) : (if eq_block b sp then BCstack else callee b) = caller b.","proofString":"destruct (eq_block b sp).\ncongruence.\nsymmetry.\napply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : positive) (H : Plt b sp) (e0 : b = sp) : BCstack = caller b.","proofString":"congruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : positive) (H : Plt b sp) (n : b <> sp) : callee b = caller b.","proofString":"symmetry.\napply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : positive) (H : Plt b sp) (n : b <> sp) : caller b = callee b.","proofString":"apply SAME; auto.\neapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : positive) (H : Plt b sp) (n : b <> sp) : Plt b bound.","proofString":"eapply Plt_trans.\neauto.\napply BELOW.\ncongruence."},{"statement":"(caller callee : block_classification) (bound sp : block) (ge : genv) (e : regset) (ae : aenv) (v : val) (m : mem) (rm : romem) (am : amem) (BELOW : bc_below caller bound) (SP1 : callee sp = BCinvalid) (SP2 : caller sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound -> b0 <> sp -> caller b0 = callee b0) (GE1 : genv_match caller ge) (EM : ematch caller e ae) (CONTENTS : bmatch caller m sp (am_stack am)) (BOUND : Ple bound (Mem.nextblock m)) (RESM : vmatch callee v Vtop) (RM : romatch callee m rm) (MM : mmatch callee m mtop) (GE2 : genv_match callee ge) (NOSTACK : bc_nostack callee) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc : block_classification) (INCR1 : bc_incr caller bc) (INCR2 : bc_incr callee bc) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch callee b0 ofs p -> pmatch bc b0 ofs Nonstack) (VM : forall (v0 : val) (x : aval),\nvmatch callee v0 x -> vmatch bc v0 (Ifptr Nonstack)) (SM : forall (b0 : block) (p : aptr),\nsmatch callee m b0 p -> smatch bc m b0 Nonstack) (BSTK : bmatch bc m sp (am_stack am)) (b : positive) (H : Plt b sp) (n : b <> sp) : caller sp <> BCinvalid.","proofString":"congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : exists bc' : block_classification,\n  bc_incr bc bc' /\\\n  (forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) /\\\n  vmatch bc' vres Vtop /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mtop /\\\n  bc_nostack bc' /\\\n  (forall (b : block) (ofs n : Z),\n   Mem.valid_block m b ->\n   bc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n).","proofString":"exploit (@external_call_mem_inject ef _ _ ge vargs m t vres m' (inj_of_bc bc) m vargs).\napply inj_of_bc_preserves_globals; auto.\nexact EC.\neapply mmatch_inj; eauto.\neapply mmatch_below; eauto.\nrevert ARGS.\ngeneralize vargs.\ninduction vargs0; simpl; intros; constructor.\neapply vmatch_inj; eauto.\nauto.\nintros (j' & vres' & m'' & EC' & IRES & IMEM & UNCH1 & UNCH2 & IINCR & ISEP).\nassert (JBELOW: forall b, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b).\nintros.\ndestruct (inj_of_bc bc b) as [[b' delta] | ] eqn:EQ.\neapply IINCR; eauto.\ndestruct (j' b) as [[b'' delta'] | ] eqn:EQ'; auto.\nexploit ISEP; eauto.\ntauto.\nset (f := fun b => if plt b (Mem.nextblock m)                     then bc b                     else match j' b with None => BCinvalid | Some _ => BCother end).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> bc b = BCstack).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\napply (bc_stack bc); auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply pred_dec_true.\neapply mmatch_below; eauto.\nassert (BC'INV: forall b, bc' b <> BCinvalid -> exists b' delta, j' b = Some(b', delta)).\nsimpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexists b, 0.\nrewrite JBELOW by auto.\napply inj_of_bc_valid; auto.\ndestruct (j' b) as [[b' delta] | ].\nexists b', delta; auto.\ncongruence.\nassert (PMTOP: forall b b' delta ofs, j' b = Some (b', delta) -> pmatch bc' b ofs Ptop).\nintros.\nconstructor.\nsimpl; unfold f.\ndestruct (plt b (Mem.nextblock m)).\nrewrite JBELOW in H by auto.\neapply inj_of_bc_inv; eauto.\nrewrite H; congruence.\nassert (VMTOP: forall v v', Val.inject j' v v' -> vmatch bc' v Vtop).\nintros.\ninv H; constructor.\neapply PMTOP; eauto.\nassert (SMTOP: forall b, bc' b <> BCinvalid -> smatch bc' m' b Ptop).\nintros; split; intros.\nexploit BC'INV; eauto.\nintros (b' & delta & J').\nexploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto.\nexploit BC'INV; eauto.\nintros (b'' & delta & J').\nexploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto.\nexists bc'; splitall.\nexact INCR.\nsimpl; intros.\napply pred_dec_true; auto.\neapply VMTOP; eauto.\napply genv_match_exten with bc; auto.\nsimpl; intros; split; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\ndestruct (plt b (Mem.nextblock m)).\nauto.\ndestruct (j' b); congruence.\nsimpl; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexploit RO; eauto.\nintros (R & P & Q).\nsplit; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto.\ndestruct (j' b); congruence.\nconstructor; simpl; intros.\napply ablock_init_sound.\napply SMTOP.\nsimpl; congruence.\nrewrite PTree.gempty in H0; discriminate.\napply SMTOP; auto.\napply SMTOP; auto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\neapply Pos.lt_le_trans.\neauto.\neapply external_call_nextblock; eauto.\ndestruct (j' b) as [[bx deltax] | ] eqn:J'.\neapply Mem.valid_block_inject_1; eauto.\ncongruence.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\napply NOSTACK; auto.\ndestruct (j' b); congruence.\nintros.\neapply Mem.loadbytes_unchanged_on_1; auto.\napply UNCH1; auto.\nintros; red.\nunfold inj_of_bc; rewrite H0; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : meminj_preserves_globals ge (inj_of_bc bc).","proofString":"apply inj_of_bc_preserves_globals; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : external_call ef ge vargs m t vres m'.","proofString":"exact EC."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : Mem.inject (inj_of_bc bc) m m.","proofString":"eapply mmatch_inj; eauto.\neapply mmatch_below; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : bc_below bc (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : Val.inject_list (inj_of_bc bc) vargs vargs.","proofString":"revert ARGS.\ngeneralize vargs.\ninduction vargs0; simpl; intros; constructor.\neapply vmatch_inj; eauto.\nauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : (forall v : val, In v vargs -> vmatch bc v Vtop) ->\nVal.inject_list (inj_of_bc bc) vargs vargs.","proofString":"generalize vargs.\ninduction vargs0; simpl; intros; constructor.\neapply vmatch_inj; eauto.\nauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : forall vargs0 : list val,\n(forall v : val, In v vargs0 -> vmatch bc v Vtop) ->\nVal.inject_list (inj_of_bc bc) vargs0 vargs0.","proofString":"induction vargs0; simpl; intros; constructor.\neapply vmatch_inj; eauto.\nauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (a : val) (vargs0 : list val) (IHvargs0 : (forall v : val, In v vargs0 -> vmatch bc v Vtop) ->\nVal.inject_list (inj_of_bc bc) vargs0 vargs0) (ARGS : forall v : val, a = v \\/ In v vargs0 -> vmatch bc v Vtop) : Val.inject (inj_of_bc bc) a a.","proofString":"eapply vmatch_inj; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (a : val) (vargs0 : list val) (IHvargs0 : (forall v : val, In v vargs0 -> vmatch bc v Vtop) ->\nVal.inject_list (inj_of_bc bc) vargs0 vargs0) (ARGS : forall v : val, a = v \\/ In v vargs0 -> vmatch bc v Vtop) : Val.inject_list (inj_of_bc bc) vargs0 vargs0.","proofString":"auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) : (exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef ge vargs m t vres' m2' /\\\n   Val.inject f' vres vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m2' /\\\n   inject_incr (inj_of_bc bc) f' /\\ inject_separated (inj_of_bc bc) f' m m) ->\nexists bc' : block_classification,\n  bc_incr bc bc' /\\\n  (forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) /\\\n  vmatch bc' vres Vtop /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mtop /\\\n  bc_nostack bc' /\\\n  (forall (b : block) (ofs n : Z),\n   Mem.valid_block m b ->\n   bc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n).","proofString":"intros (j' & vres' & m'' & EC' & IRES & IMEM & UNCH1 & UNCH2 & IINCR & ISEP).\nassert (JBELOW: forall b, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b).\nintros.\ndestruct (inj_of_bc bc b) as [[b' delta] | ] eqn:EQ.\neapply IINCR; eauto.\ndestruct (j' b) as [[b'' delta'] | ] eqn:EQ'; auto.\nexploit ISEP; eauto.\ntauto.\nset (f := fun b => if plt b (Mem.nextblock m)                     then bc b                     else match j' b with None => BCinvalid | Some _ => BCother end).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> bc b = BCstack).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\napply (bc_stack bc); auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply pred_dec_true.\neapply mmatch_below; eauto.\nassert (BC'INV: forall b, bc' b <> BCinvalid -> exists b' delta, j' b = Some(b', delta)).\nsimpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexists b, 0.\nrewrite JBELOW by auto.\napply inj_of_bc_valid; auto.\ndestruct (j' b) as [[b' delta] | ].\nexists b', delta; auto.\ncongruence.\nassert (PMTOP: forall b b' delta ofs, j' b = Some (b', delta) -> pmatch bc' b ofs Ptop).\nintros.\nconstructor.\nsimpl; unfold f.\ndestruct (plt b (Mem.nextblock m)).\nrewrite JBELOW in H by auto.\neapply inj_of_bc_inv; eauto.\nrewrite H; congruence.\nassert (VMTOP: forall v v', Val.inject j' v v' -> vmatch bc' v Vtop).\nintros.\ninv H; constructor.\neapply PMTOP; eauto.\nassert (SMTOP: forall b, bc' b <> BCinvalid -> smatch bc' m' b Ptop).\nintros; split; intros.\nexploit BC'INV; eauto.\nintros (b' & delta & J').\nexploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto.\nexploit BC'INV; eauto.\nintros (b'' & delta & J').\nexploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto.\nexists bc'; splitall.\nexact INCR.\nsimpl; intros.\napply pred_dec_true; auto.\neapply VMTOP; eauto.\napply genv_match_exten with bc; auto.\nsimpl; intros; split; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\ndestruct (plt b (Mem.nextblock m)).\nauto.\ndestruct (j' b); congruence.\nsimpl; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexploit RO; eauto.\nintros (R & P & Q).\nsplit; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto.\ndestruct (j' b); congruence.\nconstructor; simpl; intros.\napply ablock_init_sound.\napply SMTOP.\nsimpl; congruence.\nrewrite PTree.gempty in H0; discriminate.\napply SMTOP; auto.\napply SMTOP; auto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\neapply Pos.lt_le_trans.\neauto.\neapply external_call_nextblock; eauto.\ndestruct (j' b) as [[bx deltax] | ] eqn:J'.\neapply Mem.valid_block_inject_1; eauto.\ncongruence.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\napply NOSTACK; auto.\ndestruct (j' b); congruence.\nintros.\neapply Mem.loadbytes_unchanged_on_1; auto.\napply UNCH1; auto.\nintros; red.\nunfold inj_of_bc; rewrite H0; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) : exists bc' : block_classification,\n  bc_incr bc bc' /\\\n  (forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) /\\\n  vmatch bc' vres Vtop /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mtop /\\\n  bc_nostack bc' /\\\n  (forall (b : block) (ofs n : Z),\n   Mem.valid_block m b ->\n   bc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n).","proofString":"assert (JBELOW: forall b, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b).\nintros.\ndestruct (inj_of_bc bc b) as [[b' delta] | ] eqn:EQ.\neapply IINCR; eauto.\ndestruct (j' b) as [[b'' delta'] | ] eqn:EQ'; auto.\nexploit ISEP; eauto.\ntauto.\nset (f := fun b => if plt b (Mem.nextblock m)                     then bc b                     else match j' b with None => BCinvalid | Some _ => BCother end).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> bc b = BCstack).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\napply (bc_stack bc); auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply pred_dec_true.\neapply mmatch_below; eauto.\nassert (BC'INV: forall b, bc' b <> BCinvalid -> exists b' delta, j' b = Some(b', delta)).\nsimpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexists b, 0.\nrewrite JBELOW by auto.\napply inj_of_bc_valid; auto.\ndestruct (j' b) as [[b' delta] | ].\nexists b', delta; auto.\ncongruence.\nassert (PMTOP: forall b b' delta ofs, j' b = Some (b', delta) -> pmatch bc' b ofs Ptop).\nintros.\nconstructor.\nsimpl; unfold f.\ndestruct (plt b (Mem.nextblock m)).\nrewrite JBELOW in H by auto.\neapply inj_of_bc_inv; eauto.\nrewrite H; congruence.\nassert (VMTOP: forall v v', Val.inject j' v v' -> vmatch bc' v Vtop).\nintros.\ninv H; constructor.\neapply PMTOP; eauto.\nassert (SMTOP: forall b, bc' b <> BCinvalid -> smatch bc' m' b Ptop).\nintros; split; intros.\nexploit BC'INV; eauto.\nintros (b' & delta & J').\nexploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto.\nexploit BC'INV; eauto.\nintros (b'' & delta & J').\nexploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto.\nexists bc'; splitall.\nexact INCR.\nsimpl; intros.\napply pred_dec_true; auto.\neapply VMTOP; eauto.\napply genv_match_exten with bc; auto.\nsimpl; intros; split; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\ndestruct (plt b (Mem.nextblock m)).\nauto.\ndestruct (j' b); congruence.\nsimpl; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexploit RO; eauto.\nintros (R & P & Q).\nsplit; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto.\ndestruct (j' b); congruence.\nconstructor; simpl; intros.\napply ablock_init_sound.\napply SMTOP.\nsimpl; congruence.\nrewrite PTree.gempty in H0; discriminate.\napply SMTOP; auto.\napply SMTOP; auto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\neapply Pos.lt_le_trans.\neauto.\neapply external_call_nextblock; eauto.\ndestruct (j' b) as [[bx deltax] | ] eqn:J'.\neapply Mem.valid_block_inject_1; eauto.\ncongruence.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\napply NOSTACK; auto.\ndestruct (j' b); congruence.\nintros.\neapply Mem.loadbytes_unchanged_on_1; auto.\napply UNCH1; auto.\nintros; red.\nunfold inj_of_bc; rewrite H0; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b.","proofString":"intros.\ndestruct (inj_of_bc bc b) as [[b' delta] | ] eqn:EQ.\neapply IINCR; eauto.\ndestruct (j' b) as [[b'' delta'] | ] eqn:EQ'; auto.\nexploit ISEP; eauto.\ntauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (b : positive) (H : Plt b (Mem.nextblock m)) : j' b = inj_of_bc bc b.","proofString":"destruct (inj_of_bc bc b) as [[b' delta] | ] eqn:EQ.\neapply IINCR; eauto.\ndestruct (j' b) as [[b'' delta'] | ] eqn:EQ'; auto.\nexploit ISEP; eauto.\ntauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (b : positive) (H : Plt b (Mem.nextblock m)) (b' : block) (delta : Z) (EQ : inj_of_bc bc b = Some (b', delta)) : j' b = Some (b', delta).","proofString":"eapply IINCR; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (b : positive) (H : Plt b (Mem.nextblock m)) (EQ : inj_of_bc bc b = None) : j' b = None.","proofString":"destruct (j' b) as [[b'' delta'] | ] eqn:EQ'; auto.\nexploit ISEP; eauto.\ntauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (b : positive) (H : Plt b (Mem.nextblock m)) (EQ : inj_of_bc bc b = None) (b'' : block) (delta' : Z) (EQ' : j' b = Some (b'', delta')) : Some (b'', delta') = None.","proofString":"exploit ISEP; eauto.\ntauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (b : positive) (H : Plt b (Mem.nextblock m)) (EQ : inj_of_bc bc b = None) (b'' : block) (delta' : Z) (EQ' : j' b = Some (b'', delta')) : ~ Mem.valid_block m b /\\ ~ Mem.valid_block m b'' -> Some (b'', delta') = None.","proofString":"tauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) : exists bc' : block_classification,\n  bc_incr bc bc' /\\\n  (forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) /\\\n  vmatch bc' vres Vtop /\\\n  genv_match bc' ge /\\\n  romatch bc' m' rm /\\\n  mmatch bc' m' mtop /\\\n  bc_nostack bc' /\\\n  (forall (b : block) (ofs n : Z),\n   Mem.valid_block m b ->\n   bc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n).","proofString":"set (f := fun b => if plt b (Mem.nextblock m)                     then bc b                     else match j' b with None => BCinvalid | Some _ => BCother end).\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nassert (forall b, f b = BCstack -> bc b = BCstack).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\napply (bc_stack bc); auto.\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nassert (forall b id, f b = BCglob id -> bc b = BCglob id).\nunfold f; intros.\ndestruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate.\nintros.\neapply (bc_glob bc); eauto.\nset (bc' := BC f F_stack F_glob).\nunfold f in bc'.\nassert (INCR: bc_incr bc bc').\nred; simpl; intros.\napply pred_dec_true.\neapply mmatch_below; eauto.\nassert (BC'INV: forall b, bc' b <> BCinvalid -> exists b' delta, j' b = Some(b', delta)).\nsimpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexists b, 0.\nrewrite JBELOW by auto.\napply inj_of_bc_valid; auto.\ndestruct (j' b) as [[b' delta] | ].\nexists b', delta; auto.\ncongruence.\nassert (PMTOP: forall b b' delta ofs, j' b = Some (b', delta) -> pmatch bc' b ofs Ptop).\nintros.\nconstructor.\nsimpl; unfold f.\ndestruct (plt b (Mem.nextblock m)).\nrewrite JBELOW in H by auto.\neapply inj_of_bc_inv; eauto.\nrewrite H; congruence.\nassert (VMTOP: forall v v', Val.inject j' v v' -> vmatch bc' v Vtop).\nintros.\ninv H; constructor.\neapply PMTOP; eauto.\nassert (SMTOP: forall b, bc' b <> BCinvalid -> smatch bc' m' b Ptop).\nintros; split; intros.\nexploit BC'INV; eauto.\nintros (b' & delta & J').\nexploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto.\nexploit BC'INV; eauto.\nintros (b'' & delta & J').\nexploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto.\nexists bc'; splitall.\nexact INCR.\nsimpl; intros.\napply pred_dec_true; auto.\neapply VMTOP; eauto.\napply genv_match_exten with bc; auto.\nsimpl; intros; split; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\ndestruct (plt b (Mem.nextblock m)).\nauto.\ndestruct (j' b); congruence.\nsimpl; intros.\nrewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\nexploit RO; eauto.\nintros (R & P & Q).\nsplit; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto.\ndestruct (j' b); congruence.\nconstructor; simpl; intros.\napply ablock_init_sound.\napply SMTOP.\nsimpl; congruence.\nrewrite PTree.gempty in H0; discriminate.\napply SMTOP; auto.\napply SMTOP; auto.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\neapply Pos.lt_le_trans.\neauto.\neapply external_call_nextblock; eauto.\ndestruct (j' b) as [[bx deltax] | ] eqn:J'.\neapply Mem.valid_block_inject_1; eauto.\ncongruence.\nred; simpl; intros.\ndestruct (plt b (Mem.nextblock m)).\napply NOSTACK; auto.\ndestruct (j' b); congruence.\nintros.\neapply Mem.loadbytes_unchanged_on_1; auto.\napply UNCH1; auto.\nintros; red.\nunfold inj_of_bc; rewrite H0; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (b : positive) (H : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = BCstack) : bc b = BCstack.","proofString":"destruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (b : positive) (n : ~ Plt b (Mem.nextblock m)) (H : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend = BCstack) : bc b = BCstack.","proofString":"destruct (j' b); discriminate."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> bc b = BCstack) : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2.","proofString":"intros.\napply (bc_stack bc); auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (H : forall b : positive, f b = BCstack -> bc b = BCstack) (b1 b2 : positive) (H0 : f b1 = BCstack) (H1 : f b2 = BCstack) : b1 = b2.","proofString":"apply (bc_stack bc); auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (H : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = BCglob id) : bc b = BCglob id.","proofString":"destruct (plt b (Mem.nextblock m)); auto.\ndestruct (j' b); discriminate."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (b : positive) (id : ident) (n : ~ Plt b (Mem.nextblock m)) (H : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend = BCglob id) : bc b = BCglob id.","proofString":"destruct (j' b); discriminate."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (H : forall (b : positive) (id : ident), f b = BCglob id -> bc b = BCglob id) : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2.","proofString":"intros.\neapply (bc_glob bc); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (H : forall (b : positive) (id0 : ident), f b = BCglob id0 -> bc b = BCglob id0) (b1 b2 : positive) (id : ident) (H0 : f b1 = BCglob id) (H1 : f b2 = BCglob id) : b1 = b2.","proofString":"eapply (bc_glob bc); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (b : block) (H : bc b <> BCinvalid) : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = bc b.","proofString":"apply pred_dec_true.\neapply mmatch_below; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (b : block) (H : bc b <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (b : block) (H : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) <> BCinvalid) : exists (b' : block) (delta : Z), j' b = Some (b', delta).","proofString":"destruct (plt b (Mem.nextblock m)).\nexists b, 0.\nrewrite JBELOW by auto.\napply inj_of_bc_valid; auto.\ndestruct (j' b) as [[b' delta] | ].\nexists b', delta; auto.\ncongruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (b : block) (p : Plt b (Mem.nextblock m)) (H : bc b <> BCinvalid) : exists (b' : block) (delta : Z), j' b = Some (b', delta).","proofString":"exists b, 0.\nrewrite JBELOW by auto.\napply inj_of_bc_valid; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (b : block) (p : Plt b (Mem.nextblock m)) (H : bc b <> BCinvalid) : j' b = Some (b, 0).","proofString":"rewrite JBELOW by auto.\napply inj_of_bc_valid; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (b : block) (p : Plt b (Mem.nextblock m)) (H : bc b <> BCinvalid) : inj_of_bc bc b = Some (b, 0).","proofString":"apply inj_of_bc_valid; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (b : block) (n : ~ Plt b (Mem.nextblock m)) (H : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend <> BCinvalid) : exists (b' : block) (delta : Z), j' b = Some (b', delta).","proofString":"destruct (j' b) as [[b' delta] | ].\nexists b', delta; auto.\ncongruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (b : block) (n : ~ Plt b (Mem.nextblock m)) (b' : block) (delta : Z) (H : BCother <> BCinvalid) : exists (b'0 : block) (delta0 : Z), Some (b', delta) = Some (b'0, delta0).","proofString":"exists b', delta; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (b : block) (n : ~ Plt b (Mem.nextblock m)) (H : BCinvalid <> BCinvalid) : exists (b' : block) (delta : Z), None = Some (b', delta).","proofString":"congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (ofs : ptrofs) (H : j' b = Some (b', delta)) : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) <> BCinvalid.","proofString":"destruct (plt b (Mem.nextblock m)).\nrewrite JBELOW in H by auto.\neapply inj_of_bc_inv; eauto.\nrewrite H; congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (ofs : ptrofs) (H : j' b = Some (b', delta)) (p : Plt b (Mem.nextblock m)) : bc b <> BCinvalid.","proofString":"rewrite JBELOW in H by auto.\neapply inj_of_bc_inv; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (ofs : ptrofs) (H : inj_of_bc bc b = Some (b', delta)) (p : Plt b (Mem.nextblock m)) : bc b <> BCinvalid.","proofString":"eapply inj_of_bc_inv; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (ofs : ptrofs) (H : j' b = Some (b', delta)) (n : ~ Plt b (Mem.nextblock m)) : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend <> BCinvalid.","proofString":"rewrite H; congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b : block,\nbc' b <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b = Some (b', delta)) (PMTOP : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nj' b = Some (b', delta) -> pmatch bc' b ofs Ptop) : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop.","proofString":"intros.\ninv H; constructor.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v0 : val, In v0 vargs -> vmatch bc v0 Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b : block,\nbc' b <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b = Some (b', delta)) (PMTOP : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nj' b = Some (b', delta) -> pmatch bc' b ofs Ptop) (v v' : val) (H : Val.inject j' v v') : vmatch bc' v Vtop.","proofString":"inv H; constructor.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b0 b3 : positive, f b0 = BCstack -> f b3 = BCstack -> b0 = b3) (F_glob : forall (b0 b3 : positive) (id : ident),\nf b0 = BCglob id -> f b3 = BCglob id -> b0 = b3) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b : block,\nbc' b <> BCinvalid ->\nexists (b' : block) (delta0 : Z), j' b = Some (b', delta0)) (PMTOP : forall (b b' : block) (delta0 : Z) (ofs : ptrofs),\nj' b = Some (b', delta0) -> pmatch bc' b ofs Ptop) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : j' b1 = Some (b2, delta)) : pmatch bc' b1 ofs1 Ptop.","proofString":"eapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b : block,\nbc' b <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b = Some (b', delta)) (PMTOP : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nj' b = Some (b', delta) -> pmatch bc' b ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) : forall b : block, bc' b <> BCinvalid -> smatch bc' m' b Ptop.","proofString":"intros; split; intros.\nexploit BC'INV; eauto.\nintros (b' & delta & J').\nexploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto.\nexploit BC'INV; eauto.\nintros (b'' & delta & J').\nexploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v0 : val, In v0 vargs -> vmatch bc v0 Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v0 v' : val, Val.inject j' v0 v' -> vmatch bc' v0 Vtop) (b : block) (H : bc' b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) : vmatch bc' v (Ifptr Ptop).","proofString":"exploit BC'INV; eauto.\nintros (b' & delta & J').\nexploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v0 : val, In v0 vargs -> vmatch bc v0 Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v0 v' : val, Val.inject j' v0 v' -> vmatch bc' v0 Vtop) (b : block) (H : bc' b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) : (exists (b' : block) (delta : Z), j' b = Some (b', delta)) ->\nvmatch bc' v (Ifptr Ptop).","proofString":"intros (b' & delta & J').\nexploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v0 : val, In v0 vargs -> vmatch bc v0 Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (PMTOP : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta0) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v0 v' : val, Val.inject j' v0 v' -> vmatch bc' v0 Vtop) (b : block) (H : bc' b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (b' : block) (delta : Z) (J' : j' b = Some (b', delta)) : vmatch bc' v (Ifptr Ptop).","proofString":"exploit Mem.load_inject.\neexact IMEM.\neauto.\neauto.\nintros (v' & A & B).\neapply VMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v0 : val, In v0 vargs -> vmatch bc v0 Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (PMTOP : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta0) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v0 v'0 : val, Val.inject j' v0 v'0 -> vmatch bc' v0 Vtop) (b : block) (H : bc' b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (b' : block) (delta : Z) (J' : j' b = Some (b', delta)) (v' : val) (A : Mem.load chunk m'' b' (ofs + delta) = Some v') (B : Val.inject j' v v') : vmatch bc' v (Ifptr Ptop).","proofString":"eapply VMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta : Z), j' b0 = Some (b'0, delta)) (PMTOP : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (b : block) (H : bc' b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc' b' ofs' Ptop.","proofString":"exploit BC'INV; eauto.\nintros (b'' & delta & J').\nexploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta : Z), j' b0 = Some (b'0, delta)) (PMTOP : forall (b0 b'0 : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (b : block) (H : bc' b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : (exists (b'0 : block) (delta : Z), j' b = Some (b'0, delta)) ->\npmatch bc' b' ofs' Ptop.","proofString":"intros (b'' & delta & J').\nexploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (PMTOP : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta0) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (b : block) (H : bc' b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (b'' : block) (delta : Z) (J' : j' b = Some (b'', delta)) : pmatch bc' b' ofs' Ptop.","proofString":"exploit Mem.loadbytes_inject.\neexact IMEM.\neauto.\neauto.\nintros (bytes & A & B).\ninv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (PMTOP : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta0) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (b : block) (H : bc' b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (b'' : block) (delta : Z) (J' : j' b = Some (b'', delta)) (bytes : list memval) (A : Mem.loadbytes m'' b'' (ofs + delta) 1 = Some bytes) (B : list_forall2 (memval_inject j') (Fragment (Vptr b' ofs') q i :: nil) bytes) : pmatch bc' b' ofs' Ptop.","proofString":"inv B.\ninv H3.\ninv H7.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b0 b2 : positive, f b0 = BCstack -> f b2 = BCstack -> b0 = b2) (F_glob : forall (b0 b2 : positive) (id : ident),\nf b0 = BCglob id -> f b2 = BCglob id -> b0 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (PMTOP : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta0) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (b : block) (H : bc' b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (b'' : block) (delta : Z) (J' : j' b = Some (b'', delta)) (b1 : memval) (bl : list memval) (A : Mem.loadbytes m'' b'' (ofs + delta) 1 = Some (b1 :: bl)) (H3 : memval_inject j' (Fragment (Vptr b' ofs') q i) b1) (H5 : list_forall2 (memval_inject j') nil bl) : pmatch bc' b' ofs' Ptop.","proofString":"inv H3.\ninv H7.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta0 : Z), j' b0 = Some (b'0, delta0)) (PMTOP : forall (b0 b'0 : block) (delta0 : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta0) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (b : block) (H : bc' b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (b'' : block) (delta : Z) (J' : j' b = Some (b'', delta)) (bl : list memval) (v2 : val) (A : Mem.loadbytes m'' b'' (ofs + delta) 1 = Some (Fragment v2 q i :: bl)) (H5 : list_forall2 (memval_inject j') nil bl) (H7 : Val.inject j' (Vptr b' ofs') v2) : pmatch bc' b' ofs' Ptop.","proofString":"inv H7.\neapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b0 : positive, f b1 = BCstack -> f b0 = BCstack -> b1 = b0) (F_glob : forall (b1 b0 : positive) (id : ident),\nf b1 = BCglob id -> f b0 = BCglob id -> b1 = b0) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b'0 : block) (delta1 : Z), j' b0 = Some (b'0, delta1)) (PMTOP : forall (b0 b'0 : block) (delta1 : Z) (ofs0 : ptrofs),\nj' b0 = Some (b'0, delta1) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (b : block) (H : bc' b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (b'' : block) (delta : Z) (J' : j' b = Some (b'', delta)) (bl : list memval) (b2 : block) (delta0 : Z) (A : Mem.loadbytes m'' b'' (ofs + delta) 1 =\nSome (Fragment (Vptr b2 (Ptrofs.add ofs' (Ptrofs.repr delta0))) q i :: bl)) (H5 : list_forall2 (memval_inject j') nil bl) (H3 : j' b' = Some (b2, delta0)) : pmatch bc' b' ofs' Ptop.","proofString":"eapply PMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b : block,\nbc' b <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b = Some (b', delta)) (PMTOP : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nj' b = Some (b', delta) -> pmatch bc' b ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b : block, bc' b <> BCinvalid -> smatch bc' m' b Ptop) : bc_incr bc bc'.","proofString":"exact INCR."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : positive) (H : Plt b (Mem.nextblock m)) : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = bc b.","proofString":"apply pred_dec_true; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b : block,\nbc' b <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b = Some (b', delta)) (PMTOP : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nj' b = Some (b', delta) -> pmatch bc' b ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b : block, bc' b <> BCinvalid -> smatch bc' m' b Ptop) : vmatch bc' vres Vtop.","proofString":"eapply VMTOP; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (H : bc b = BCglob id) : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = BCglob id.","proofString":"rewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (H : bc b = BCglob id) : bc b = BCglob id.","proofString":"auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (H : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = BCglob id) : bc b = BCglob id.","proofString":"destruct (plt b (Mem.nextblock m)).\nauto.\ndestruct (j' b); congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) : bc b = BCglob id.","proofString":"auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (n : ~ Plt b (Mem.nextblock m)) (H : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend = BCglob id) : bc b = BCglob id.","proofString":"destruct (j' b); congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (H : bc b = BCother) : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = BCother.","proofString":"rewrite pred_dec_true by (eapply mmatch_below; eauto with va).\nauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (H : bc b = BCother) : bc b = BCother.","proofString":"auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (H : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = BCglob id) (H0 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc' m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","proofString":"destruct (plt b (Mem.nextblock m)).\nexploit RO; eauto.\nintros (R & P & Q).\nsplit; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto.\ndestruct (j' b); congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc' m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","proofString":"exploit RO; eauto.\nintros (R & P & Q).\nsplit; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch bc' m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","proofString":"intros (R & P & Q).\nsplit; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : pge Glob (ab_summary ab) /\\\nbmatch bc' m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","proofString":"split; auto.\nsplit.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : bmatch bc' m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","proofString":"split.\napply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto.\nintros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : bmatch bc' m' b ab.","proofString":"apply bmatch_incr with bc; auto.\napply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : bmatch bc m' b ab.","proofString":"apply bmatch_ext with m; auto.\nintros.\neapply external_call_readonly with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes.","proofString":"intros.\neapply external_call_readonly with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' b ofs n = Some bytes) (H2 : n >= 0) : Mem.loadbytes m b ofs n = Some bytes.","proofString":"eapply external_call_readonly with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : forall ofs : Z, ~ Mem.perm m' b ofs Max Writable.","proofString":"intros; red; intros; elim (Q ofs).\neapply external_call_max_perm with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (p : Plt b (Mem.nextblock m)) (H : bc b = BCglob id) (H0 : rm ! id = Some ab) (R : pge Glob (ab_summary ab)) (P : bmatch bc m b ab) (Q : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs : Z) (H1 : Mem.perm m' b ofs Max Writable) : Mem.perm m b ofs Max Writable.","proofString":"eapply external_call_max_perm with (m2 := m'); eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (id : ident) (ab : ablock) (n : ~ Plt b (Mem.nextblock m)) (H : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend = BCglob id) (H0 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc' m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","proofString":"destruct (j' b); congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (id : ident) (ab : ablock) (b : block) (H : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) : bmatch bc' m' b ab.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (H : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) <> BCinvalid) : Plt b (Mem.nextblock m').","proofString":"destruct (plt b (Mem.nextblock m)).\neapply Pos.lt_le_trans.\neauto.\neapply external_call_nextblock; eauto.\ndestruct (j' b) as [[bx deltax] | ] eqn:J'.\neapply Mem.valid_block_inject_1; eauto.\ncongruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (p : Plt b (Mem.nextblock m)) (H : bc b <> BCinvalid) : Plt b (Mem.nextblock m').","proofString":"eapply Pos.lt_le_trans.\neauto.\neapply external_call_nextblock; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (n : ~ Plt b (Mem.nextblock m)) (H : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend <> BCinvalid) : Plt b (Mem.nextblock m').","proofString":"destruct (j' b) as [[bx deltax] | ] eqn:J'.\neapply Mem.valid_block_inject_1; eauto.\ncongruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (n : ~ Plt b (Mem.nextblock m)) (bx : block) (deltax : Z) (J' : j' b = Some (bx, deltax)) (H : BCother <> BCinvalid) : Plt b (Mem.nextblock m').","proofString":"eapply Mem.valid_block_inject_1; eauto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (n : ~ Plt b (Mem.nextblock m)) (J' : j' b = None) (H : BCinvalid <> BCinvalid) : Plt b (Mem.nextblock m').","proofString":"congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) : (if plt b (Mem.nextblock m)\n then bc b\n else match j' b with\n      | Some _ => BCother\n      | None => BCinvalid\n      end) <> BCstack.","proofString":"destruct (plt b (Mem.nextblock m)).\napply NOSTACK; auto.\ndestruct (j' b); congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (p : Plt b (Mem.nextblock m)) : bc b <> BCstack.","proofString":"apply NOSTACK; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (n : ~ Plt b (Mem.nextblock m)) : match j' b with\n| Some _ => BCother\n| None => BCinvalid\nend <> BCstack.","proofString":"destruct (j' b); congruence."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b : positive, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b : block,\nbc' b <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b = Some (b', delta)) (PMTOP : forall (b b' : block) (delta : Z) (ofs : ptrofs),\nj' b = Some (b', delta) -> pmatch bc' b ofs Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b : block, bc' b <> BCinvalid -> smatch bc' m' b Ptop) : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"intros.\neapply Mem.loadbytes_unchanged_on_1; auto.\napply UNCH1; auto.\nintros; red.\nunfold inj_of_bc; rewrite H0; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (ofs n : Z) (H : Mem.valid_block m b) (H0 : bc b = BCinvalid) : Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"eapply Mem.loadbytes_unchanged_on_1; auto.\napply UNCH1; auto.\nintros; red.\nunfold inj_of_bc; rewrite H0; auto."},{"statement":"(ef : external_function) (ge : genv) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (bc : block_classification) (rm : romem) (am : amem) (EC : external_call ef ge vargs m t vres m') (GENV : genv_match bc ge) (ARGS : forall v : val, In v vargs -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m am) (NOSTACK : bc_nostack bc) (j' : meminj) (vres' : val) (m'' : mem) (EC' : external_call ef ge vargs m t vres' m'') (IRES : Val.inject j' vres vres') (IMEM : Mem.inject j' m' m'') (UNCH1 : Mem.unchanged_on (loc_unmapped (inj_of_bc bc)) m m') (UNCH2 : Mem.unchanged_on (loc_out_of_reach (inj_of_bc bc) m) m m'') (IINCR : inject_incr (inj_of_bc bc) j') (ISEP : inject_separated (inj_of_bc bc) j' m m) (JBELOW : forall b0 : positive, Plt b0 (Mem.nextblock m) -> j' b0 = inj_of_bc bc b0) (f : positive -> block_class) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (bc' : block_classification) (INCR : bc_incr bc bc') (BC'INV : forall b0 : block,\nbc' b0 <> BCinvalid ->\nexists (b' : block) (delta : Z), j' b0 = Some (b', delta)) (PMTOP : forall (b0 b' : block) (delta : Z) (ofs0 : ptrofs),\nj' b0 = Some (b', delta) -> pmatch bc' b0 ofs0 Ptop) (VMTOP : forall v v' : val, Val.inject j' v v' -> vmatch bc' v Vtop) (SMTOP : forall b0 : block, bc' b0 <> BCinvalid -> smatch bc' m' b0 Ptop) (b : block) (ofs n : Z) (H : Mem.valid_block m b) (H0 : bc b = BCinvalid) (i : Z) (H1 : ofs <= i < ofs + n) : inj_of_bc bc b = None.","proofString":"unfold inj_of_bc; rewrite H0; auto."},{"statement":"(m' : mem) (bc : block_classification) (m : mem) (bound : block) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) : sound_stack bc nil m' bound.","proofString":"constructor."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) : sound_stack bc (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk) m' bound.","proofString":"assert (Plt sp bound') by eauto with va.\neapply sound_stack_public_call; eauto.\napply IHsound_stack; intros.\napply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H0 : Plt sp bound') : sound_stack bc (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk) m' bound.","proofString":"eapply sound_stack_public_call; eauto.\napply IHsound_stack; intros.\napply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H0 : Plt sp bound') : sound_stack bc' stk m' sp.","proofString":"apply IHsound_stack; intros.\napply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Mem.loadbytes m b ofs n = Some bytes.","proofString":"apply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Plt b bound.","proofString":"extlia."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : bc b = BCinvalid.","proofString":"rewrite SAME; auto with ordered_type.\nextlia."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Plt b bound'.","proofString":"extlia."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : n >= 0.","proofString":"auto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Mem.loadbytes m' b ofs n = Some bytes.","proofString":"auto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) : sound_stack bc (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk) m' bound.","proofString":"assert (Plt sp bound') by eauto with va.\neapply sound_stack_private_call; eauto.\napply IHsound_stack; intros.\napply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto.\napply bmatch_ext with m; auto.\nintros.\napply INV.\nextlia.\nauto.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H0 : Plt sp bound') : sound_stack bc (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk) m' bound.","proofString":"eapply sound_stack_private_call; eauto.\napply IHsound_stack; intros.\napply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto.\napply bmatch_ext with m; auto.\nintros.\napply INV.\nextlia.\nauto.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H0 : Plt sp bound') : sound_stack bc' stk m' sp.","proofString":"apply IHsound_stack; intros.\napply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Mem.loadbytes m b ofs n = Some bytes.","proofString":"apply INV.\nextlia.\nrewrite SAME; auto with ordered_type.\nextlia.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Plt b bound.","proofString":"extlia."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : bc b = BCinvalid.","proofString":"rewrite SAME; auto with ordered_type.\nextlia."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Plt b bound'.","proofString":"extlia."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : n >= 0.","proofString":"auto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b0 sp ->\n bc' b0 = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b0 ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b0 : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b sp) (H2 : bc' b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Mem.loadbytes m' b ofs n = Some bytes.","proofString":"auto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H0 : Plt sp bound') : bmatch bc' m' sp (am_stack am).","proofString":"apply bmatch_ext with m; auto.\nintros.\napply INV.\nextlia.\nauto.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs n : Z) (bytes : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n >= 0 ->\n Mem.loadbytes m' b ofs n = Some bytes ->\n Mem.loadbytes m b ofs n = Some bytes) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H0 : Plt sp bound') : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' sp ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m sp ofs n = Some bytes.","proofString":"intros.\napply INV.\nextlia.\nauto.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' sp ofs n = Some bytes) (H2 : n >= 0) : Mem.loadbytes m sp ofs n = Some bytes.","proofString":"apply INV.\nextlia.\nauto.\nauto.\nauto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' sp ofs n = Some bytes) (H2 : n >= 0) : Plt sp bound.","proofString":"extlia."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' sp ofs n = Some bytes) (H2 : n >= 0) : bc sp = BCinvalid.","proofString":"auto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' sp ofs n = Some bytes) (H2 : n >= 0) : n >= 0.","proofString":"auto."},{"statement":"(m' : mem) (bc : block_classification) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk : list stackframe) (m : mem) (bound : positive) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (H : sound_stack bc' stk m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (IHsound_stack : (forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\n Plt b sp ->\n bc' b = BCinvalid ->\n n0 >= 0 ->\n Mem.loadbytes m' b ofs0 n0 = Some bytes0 ->\n Mem.loadbytes m b ofs0 n0 = Some bytes0) -> sound_stack bc' stk m' sp) (INV : forall (b : positive) (ofs0 n0 : Z) (bytes0 : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn0 >= 0 ->\nMem.loadbytes m' b ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b ofs0 n0 = Some bytes0) (H0 : Plt sp bound') (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' sp ofs n = Some bytes) (H2 : n >= 0) : Mem.loadbytes m' sp ofs n = Some bytes.","proofString":"auto."},{"statement":"(m' : mem) (bc : block_classification) (stk : list stackframe) (m : mem) (bound : block) (H : sound_stack bc stk m bound) (H0 : forall (b : positive) (ofs n : Z),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : sound_stack bc stk m' bound.","proofString":"eapply sound_stack_ext; eauto.\nintros.\nrewrite <- H0; auto."},{"statement":"(m' : mem) (bc : block_classification) (stk : list stackframe) (m : mem) (bound : block) (H : sound_stack bc stk m bound) (H0 : forall (b : positive) (ofs n : Z),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : forall (b : positive) (ofs n : Z) (bytes : list memval),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes.","proofString":"intros.\nrewrite <- H0; auto."},{"statement":"(m' : mem) (bc : block_classification) (stk : list stackframe) (m : mem) (bound : block) (H : sound_stack bc stk m bound) (H0 : forall (b0 : positive) (ofs0 n0 : Z),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn0 >= 0 -> Mem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (b : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b bound) (H2 : bc b = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b ofs n = Some bytes) : Mem.loadbytes m b ofs n = Some bytes.","proofString":"rewrite <- H0; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (addr v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storev chunk m addr v = Some m') (H0 : vmatch bc addr aaddr) (H1 : sound_stack bc stk m bound) : sound_stack bc stk m' bound.","proofString":"apply sound_stack_inv with m; auto.\ndestruct addr; simpl in H; try discriminate.\nassert (A: pmatch bc b i Ptop).\ninv H0; eapply pmatch_top'; eauto.\ninv A.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (addr v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storev chunk m addr v = Some m') (H0 : vmatch bc addr aaddr) (H1 : sound_stack bc stk m bound) : forall (b : positive) (ofs n : Z),\nPlt b bound ->\nbc b = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"destruct addr; simpl in H; try discriminate.\nassert (A: pmatch bc b i Ptop).\ninv H0; eapply pmatch_top'; eauto.\ninv A.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : vmatch bc (Vptr b i) aaddr) (H1 : sound_stack bc stk m bound) : forall (b0 : positive) (ofs n : Z),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n.","proofString":"assert (A: pmatch bc b i Ptop).\ninv H0; eapply pmatch_top'; eauto.\ninv A.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : vmatch bc (Vptr b i) aaddr) (H1 : sound_stack bc stk m bound) : pmatch bc b i Ptop.","proofString":"inv H0; eapply pmatch_top'; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : vmatch bc (Vptr b i) aaddr) (H1 : sound_stack bc stk m bound) (A : pmatch bc b i Ptop) : forall (b0 : positive) (ofs n : Z),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n.","proofString":"inv A.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : vmatch bc (Vptr b i) aaddr) (H1 : sound_stack bc stk m bound) (H2 : bc b <> BCinvalid) : forall (b0 : positive) (ofs n : Z),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n.","proofString":"intros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : vmatch bc (Vptr b i) aaddr) (H1 : sound_stack bc stk m bound) (H2 : bc b <> BCinvalid) (b0 : positive) (ofs n : Z) (H3 : Plt b0 bound) (H4 : bc b0 = BCinvalid) (H5 : n >= 0) : Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n.","proofString":"eapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : vmatch bc (Vptr b i) aaddr) (H1 : sound_stack bc stk m bound) (H2 : bc b <> BCinvalid) (b0 : positive) (ofs n : Z) (H3 : Plt b0 bound) (H4 : bc b0 = BCinvalid) (H5 : n >= 0) : b0 <> b \\/\nn <= 0 \\/\nofs + n <= Ptrofs.unsigned i \\/ Ptrofs.unsigned i + size_chunk chunk <= ofs.","proofString":"left; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H0 : vmatch bc (Vptr b ofs) aaddr) (H1 : sound_stack bc stk m bound) : sound_stack bc stk m' bound.","proofString":"apply sound_stack_inv with m; auto.\nassert (A: pmatch bc b ofs Ptop).\ninv H0; eapply pmatch_top'; eauto.\ninv A.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H0 : vmatch bc (Vptr b ofs) aaddr) (H1 : sound_stack bc stk m bound) : forall (b0 : positive) (ofs0 n : Z),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","proofString":"assert (A: pmatch bc b ofs Ptop).\ninv H0; eapply pmatch_top'; eauto.\ninv A.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H0 : vmatch bc (Vptr b ofs) aaddr) (H1 : sound_stack bc stk m bound) : pmatch bc b ofs Ptop.","proofString":"inv H0; eapply pmatch_top'; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H0 : vmatch bc (Vptr b ofs) aaddr) (H1 : sound_stack bc stk m bound) (A : pmatch bc b ofs Ptop) : forall (b0 : positive) (ofs0 n : Z),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","proofString":"inv A.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H0 : vmatch bc (Vptr b ofs) aaddr) (H1 : sound_stack bc stk m bound) (H2 : bc b <> BCinvalid) : forall (b0 : positive) (ofs0 n : Z),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","proofString":"intros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H0 : vmatch bc (Vptr b ofs) aaddr) (H1 : sound_stack bc stk m bound) (H2 : bc b <> BCinvalid) (b0 : positive) (ofs0 n : Z) (H3 : Plt b0 bound) (H4 : bc b0 = BCinvalid) (H5 : n >= 0) : Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","proofString":"eapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (bc : block_classification) (aaddr : aval) (stk : list stackframe) (bound : block) (H : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (H0 : vmatch bc (Vptr b ofs) aaddr) (H1 : sound_stack bc stk m bound) (H2 : bc b <> BCinvalid) (b0 : positive) (ofs0 n : Z) (H3 : Plt b0 bound) (H4 : bc b0 = BCinvalid) (H5 : n >= 0) : b0 <> b \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= ofs0.","proofString":"left; congruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (bc : block_classification) (stk : list stackframe) (bound : block) (H : Mem.free m b lo hi = Some m') (H0 : sound_stack bc stk m bound) : sound_stack bc stk m' bound.","proofString":"eapply sound_stack_ext; eauto.\nintros.\neapply Mem.loadbytes_free_2; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (bc : block_classification) (stk : list stackframe) (bound : block) (H : Mem.free m b lo hi = Some m') (H0 : sound_stack bc stk m bound) : forall (b0 : positive) (ofs n : Z) (bytes : list memval),\nPlt b0 bound ->\nbc b0 = BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes.","proofString":"intros.\neapply Mem.loadbytes_free_2; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (bc : block_classification) (stk : list stackframe) (bound : block) (H : Mem.free m b lo hi = Some m') (H0 : sound_stack bc stk m bound) (b0 : positive) (ofs n : Z) (bytes : list memval) (H1 : Plt b0 bound) (H2 : bc b0 = BCinvalid) (H3 : n >= 0) (H4 : Mem.loadbytes m' b0 ofs n = Some bytes) : Mem.loadbytes m b0 ofs n = Some bytes.","proofString":"eapply Mem.loadbytes_free_2; eauto."},{"statement":"(bc : block_classification) (stk : list stackframe) (m : mem) (bound : block) (bound' : positive) (H : sound_stack bc stk m bound) (H0 : Ple bound bound') : sound_stack bc stk m bound'.","proofString":"inv H.\nconstructor.\neapply sound_stack_public_call with (bound' := bound'0); eauto.\nextlia.\neapply sound_stack_private_call with (bound' := bound'0); eauto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bound' : positive) (H0 : Ple bound bound') : sound_stack bc nil m bound'.","proofString":"constructor."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bound' : positive) (H0 : Ple bound bound') (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound'0 : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound'0 bound) (BELOW : bc_below bc' bound'0) (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound'0 -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) : sound_stack bc (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk0) m bound'.","proofString":"eapply sound_stack_public_call with (bound' := bound'0); eauto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bound' : positive) (H0 : Ple bound bound') (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound'0 : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound'0 bound) (BELOW : bc_below bc' bound'0) (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound'0 -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) : Ple bound'0 bound'.","proofString":"extlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bound' : positive) (H0 : Ple bound bound') (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound'0 : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound'0 bound) (BELOW : bc_below bc' bound'0) (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound'0 -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) : sound_stack bc (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk0) m bound'.","proofString":"eapply sound_stack_private_call with (bound' := bound'0); eauto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bound' : positive) (H0 : Ple bound bound') (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound'0 : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound'0 bound) (BELOW : bc_below bc' bound'0) (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound'0 -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) : Ple bound'0 bound'.","proofString":"extlia."},{"statement":"(bc : block_classification) (stk : list stackframe) (m : mem) (bound : block) (bc1 : block_classification) (H : sound_stack bc stk m bound) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) : sound_stack bc1 stk m bound.","proofString":"inv H.\nconstructor.\nassert (Plt sp bound') by eauto with va.\neapply sound_stack_public_call; eauto.\nrewrite H0; auto.\nextlia.\nintros.\nrewrite H0; auto.\nextlia.\nassert (Plt sp bound') by eauto with va.\neapply sound_stack_private_call; eauto.\nrewrite H0; auto.\nextlia.\nintros.\nrewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) : sound_stack bc1 nil m bound.","proofString":"constructor."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) : sound_stack bc1 (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk0) m bound.","proofString":"assert (Plt sp bound') by eauto with va.\neapply sound_stack_public_call; eauto.\nrewrite H0; auto.\nextlia.\nintros.\nrewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (H : Plt sp bound') : sound_stack bc1 (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk0) m bound.","proofString":"eapply sound_stack_public_call; eauto.\nrewrite H0; auto.\nextlia.\nintros.\nrewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (H : Plt sp bound') : bc1 sp = BCother.","proofString":"rewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (H : Plt sp bound') : Plt sp bound.","proofString":"extlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (H : Plt sp bound') : forall b : positive, Plt b bound' -> b <> sp -> bc1 b = bc' b.","proofString":"intros.\nrewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b0 : positive, Plt b0 bound -> bc1 b0 = bc b0) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (H : Plt sp bound') (b : positive) (H1 : Plt b bound') (H2 : b <> sp) : bc1 b = bc' b.","proofString":"rewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b0 : positive, Plt b0 bound -> bc1 b0 = bc b0) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCother) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' e ae) (H : Plt sp bound') (b : positive) (H1 : Plt b bound') (H2 : b <> sp) : Plt b bound.","proofString":"extlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) : sound_stack bc1 (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk0) m bound.","proofString":"assert (Plt sp bound') by eauto with va.\neapply sound_stack_private_call; eauto.\nrewrite H0; auto.\nextlia.\nintros.\nrewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (H : Plt sp bound') : sound_stack bc1 (Stackframe res f (Vptr sp Ptrofs.zero) pc e :: stk0) m bound.","proofString":"eapply sound_stack_private_call; eauto.\nrewrite H0; auto.\nextlia.\nintros.\nrewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (H : Plt sp bound') : bc1 sp = BCinvalid.","proofString":"rewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (H : Plt sp bound') : Plt sp bound.","proofString":"extlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b : positive, Plt b bound -> bc1 b = bc b) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp -> bc b = bc' b) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (H : Plt sp bound') : forall b : positive, Plt b bound' -> b <> sp -> bc1 b = bc' b.","proofString":"intros.\nrewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b0 : positive, Plt b0 bound -> bc1 b0 = bc b0) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (H : Plt sp bound') (b : positive) (H1 : Plt b bound') (H2 : b <> sp) : bc1 b = bc' b.","proofString":"rewrite H0; auto.\nextlia."},{"statement":"(bc : block_classification) (m : mem) (bound : block) (bc1 : block_classification) (H0 : forall b0 : positive, Plt b0 bound -> bc1 b0 = bc b0) (res : positive) (f : function) (sp : block) (pc : positive) (e : regset) (stk0 : list stackframe) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK : sound_stack bc' stk0 m sp) (INCR : Ple bound' bound) (BELOW : bc_below bc' bound') (SP : bc sp = BCinvalid) (SP' : bc' sp = BCstack) (SAME : forall b0 : positive, Plt b0 bound' -> b0 <> sp -> bc b0 = bc' b0) (GE : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' e ae) (CONTENTS : bmatch bc' m sp (am_stack am)) (H : Plt sp bound') (b : positive) (H1 : Plt b bound') (H2 : b <> sp) : Plt b bound.","proofString":"extlia."},{"statement":"(bc : block_classification) (pc : positive) (ae : aenv) (am : amem) (instr : instruction) (ae' : aenv) (am' : amem) (s : list stackframe) (f : function) (sp : block) (pc' : node) (e' : regset) (m' : mem) (H : (analyze rm f) # pc = VA.State ae am) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) (H2 : transfer f rm pc ae am = VA.State ae' am') (H3 : ematch bc e' ae') (H4 : mmatch bc m' am') (H5 : romatch bc m' rm) (H6 : genv_match bc ge) (H7 : bc sp = BCstack) (H8 : sound_stack bc s m' sp) : sound_state_base (State s f (Vptr sp Ptrofs.zero) pc' e' m').","proofString":"exploit analyze_succ; eauto.\nintros (ae'' & am'' & AN & EM & MM).\neconstructor; eauto."},{"statement":"(bc : block_classification) (pc : positive) (ae : aenv) (am : amem) (instr : instruction) (ae' : aenv) (am' : amem) (s : list stackframe) (f : function) (sp : block) (pc' : node) (e' : regset) (m' : mem) (H : (analyze rm f) # pc = VA.State ae am) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) (H2 : transfer f rm pc ae am = VA.State ae' am') (H3 : ematch bc e' ae') (H4 : mmatch bc m' am') (H5 : romatch bc m' rm) (H6 : genv_match bc ge) (H7 : bc sp = BCstack) (H8 : sound_stack bc s m' sp) : (exists (ae'' : aenv) (am'' : amem),\n   (analyze rm f) # pc' = VA.State ae'' am'' /\\\n   ematch bc e' ae'' /\\ mmatch bc m' am'') ->\nsound_state_base (State s f (Vptr sp Ptrofs.zero) pc' e' m').","proofString":"intros (ae'' & am'' & AN & EM & MM).\neconstructor; eauto."},{"statement":"(bc : block_classification) (pc : positive) (ae : aenv) (am : amem) (instr : instruction) (ae' : aenv) (am' : amem) (s : list stackframe) (f : function) (sp : block) (pc' : node) (e' : regset) (m' : mem) (H : (analyze rm f) # pc = VA.State ae am) (H0 : (fn_code f) ! pc = Some instr) (H1 : In pc' (successors_instr instr)) (H2 : transfer f rm pc ae am = VA.State ae' am') (H3 : ematch bc e' ae') (H4 : mmatch bc m' am') (H5 : romatch bc m' rm) (H6 : genv_match bc ge) (H7 : bc sp = BCstack) (H8 : sound_stack bc s m' sp) (ae'' : aenv) (am'' : amem) (AN : (analyze rm f) # pc' = VA.State ae'' am'') (EM : ematch bc e' ae'') (MM : mmatch bc m' am'') : sound_state_base (State s f (Vptr sp Ptrofs.zero) pc' e' m').","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc' rs m).","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : In pc' (successors_instr (Inop pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : transfer f rm pc ae am = VA.State ae am.","proofString":"unfold transfer; rewrite H.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : VA.State ae am = VA.State ae am.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m).","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neauto.\napply ematch_update; auto.\neapply eval_static_operation_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : In pc' (successors_instr (Iop op args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : vmatch bc v (eval_static_operation op (aregs ae args)).","proofString":"eapply eval_static_operation_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m).","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neauto.\napply ematch_update; auto.\neapply loadv_sound; eauto with va.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : In pc' (successors_instr (Iload chunk addr args dst pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : vmatch bc v (loadv chunk rm am (eval_static_addressing addr (aregs ae args))).","proofString":"eapply loadv_sound; eauto with va.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : vmatch bc a (eval_static_addressing addr (aregs ae args)).","proofString":"eapply eval_static_addressing_sound; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc' rs m').","proofString":"exploit eval_static_addressing_sound; eauto with va.\nintros VMADDR.\neapply sound_succ_state; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neauto.\neapply storev_sound; eauto.\ndestruct a; simpl in H1; try discriminate.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : vmatch bc a (eval_static_addressing addr (aregs ae args)) ->\nsound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc' rs m').","proofString":"intros VMADDR.\neapply sound_succ_state; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neauto.\neapply storev_sound; eauto.\ndestruct a; simpl in H1; try discriminate.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (VMADDR : vmatch bc a (eval_static_addressing addr (aregs ae args))) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc' rs m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\nunfold transfer; rewrite H.\neauto.\neapply storev_sound; eauto.\ndestruct a; simpl in H1; try discriminate.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (VMADDR : vmatch bc a (eval_static_addressing addr (aregs ae args))) : In pc' (successors_instr (Istore chunk addr args src pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (VMADDR : vmatch bc a (eval_static_addressing addr (aregs ae args))) : romatch bc m' rm.","proofString":"destruct a; simpl in H1; try discriminate.\neapply romatch_store; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (b : block) (i : ptrofs) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some (Vptr b i)) (H1 : Mem.store chunk m b (Ptrofs.unsigned i) rs # src = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (VMADDR : vmatch bc (Vptr b i) (eval_static_addressing addr (aregs ae args))) : romatch bc m' rm.","proofString":"eapply romatch_store; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (VMADDR : vmatch bc a (eval_static_addressing addr (aregs ae args))) : sound_stack bc s m' sp0.","proofString":"eapply sound_stack_storev; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"assert (TR: transfer f rm pc ae am = transfer_call ae am args res).\nunfold transfer; rewrite H; auto.\nunfold transfer_call, analyze_call in TR.\ndestruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) (aregs ae args)) eqn:NOLEAK.\nInvBooleans.\nexploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va.\nexploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : transfer f rm pc ae am = transfer_call ae am args res.","proofString":"unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am = transfer_call ae am args res) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"unfold transfer_call, analyze_call in TR.\ndestruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) (aregs ae args)) eqn:NOLEAK.\nInvBooleans.\nexploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va.\nexploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\n(let (av, am') :=\n   if\n    pincl (am_nonstack am) Nonstack &&\n    forallb (fun av : aval => vpincl av Nonstack) (aregs ae args)\n   then (Ifptr Nonstack, mafter_private_call am)\n   else (Vtop, mafter_public_call) in\n VA.State (AE.set res av ae) am')) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"destruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) (aregs ae args)) eqn:NOLEAK.\nInvBooleans.\nexploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va.\nexploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"InvBooleans.\nexploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"exploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) ->\nsound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"intros SUCC.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"exploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) : pge Nonstack (am_nonstack am).","proofString":"apply pincl_ge; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) : (exists bc' : block_classification,\n   bc_nostack bc' /\\\n   bc' sp0 = BCinvalid /\\\n   (forall b : block, b <> sp0 -> bc' b = bc b) /\\\n   (forall (v : val) (x : aval),\n    vge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) /\\\n   genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop) ->\nsound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"intros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"apply sound_call_state with bc'; auto.\neapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) m\n  (Mem.nextblock m).","proofString":"eapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\neapply mmatch_stack; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : Ple (Mem.nextblock m) (Mem.nextblock m).","proofString":"apply Ple_refl."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : bc_below bc (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : bmatch bc m sp0 (am_stack am).","proofString":"eapply mmatch_stack; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : forall v : val, In v rs ## args -> vmatch bc' v Vtop.","proofString":"intros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H3 : In v rs ## args) : vmatch bc' v Vtop.","proofString":"exploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H3 : In v rs ## args) : (exists x : positive, v = (fun r : positive => rs # r) x /\\ In x args) ->\nvmatch bc' v Vtop.","proofString":"intros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H3 : In v rs ## args) (r : positive) (P : v = rs # r) (Q : In r args) : vmatch bc' v Vtop.","proofString":"subst v.\napply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H3 : In rs # r rs ## args) (Q : In r args) : vmatch bc' rs # r Vtop.","proofString":"apply D with (areg ae r).\nrewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto.\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H3 : In rs # r rs ## args) (Q : In r args) : vge (Ifptr Nonstack) (areg ae r).","proofString":"rewrite forallb_forall in H2.\napply vpincl_ge.\napply H2.\napply in_map; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forall x : aval, In x (aregs ae args) -> vpincl x Nonstack = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H3 : In rs # r rs ## args) (Q : In r args) : vge (Ifptr Nonstack) (areg ae r).","proofString":"apply vpincl_ge.\napply H2.\napply in_map; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forall x : aval, In x (aregs ae args) -> vpincl x Nonstack = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H3 : In rs # r rs ## args) (Q : In r args) : vpincl (areg ae r) Nonstack = true.","proofString":"apply H2.\napply in_map; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forall x : aval, In x (aregs ae args) -> vpincl x Nonstack = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H3 : In rs # r rs ## args) (Q : In r args) : In (areg ae r) (aregs ae args).","proofString":"apply in_map; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (TR : transfer f rm pc ae am =\nVA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am)) (H1 : pincl (am_nonstack am) Nonstack = true) (H2 : forallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = true) (SUCC : VA.ge (analyze rm f) # pc'\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H3 : In rs # r rs ## args) (Q : In r args) : vmatch bc rs # r (areg ae r).","proofString":"auto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"exploit analyze_successor; eauto.\nsimpl; eauto.\nrewrite TR.\nintros SUCC.\nexploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call) ->\nsound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"intros SUCC.\nexploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"exploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) : (exists bc' : block_classification,\n   bc_nostack bc' /\\\n   bc' sp0 = BCother /\\\n   (forall b : block, b <> sp0 -> bc' b = bc b) /\\\n   (forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) /\\\n   genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop) ->\nsound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"intros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_state_base\n  (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n     rs ## args m).","proofString":"apply sound_call_state with bc'; auto.\neapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) m\n  (Mem.nextblock m).","proofString":"eapply sound_stack_public_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.\napply Ple_refl.\neapply mmatch_below; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : Ple (Mem.nextblock m) (Mem.nextblock m).","proofString":"apply Ple_refl."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : bc_below bc (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : forall v : val, In v rs ## args -> vmatch bc' v Vtop.","proofString":"intros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H1 : In v rs ## args) : vmatch bc' v Vtop.","proofString":"exploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H1 : In v rs ## args) : (exists x : positive, v = (fun r : positive => rs # r) x /\\ In x args) ->\nvmatch bc' v Vtop.","proofString":"intros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H1 : In v rs ## args) (r : positive) (P : v = rs # r) (Q : In r args) : vmatch bc' v Vtop.","proofString":"subst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H1 : In rs # r rs ## args) (Q : In r args) : vmatch bc' rs # r Vtop.","proofString":"apply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) (aregs ae args) = false) (TR : transfer f rm pc ae am = VA.State (AE.set res Vtop ae) mafter_public_call) (SUCC : VA.ge (analyze rm f) # pc' (VA.State (AE.set res Vtop ae) mafter_public_call)) (bc' : block_classification) (A : bc_nostack bc') (B : bc' sp0 = BCother) (C : forall b : block, b <> sp0 -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H1 : In rs # r rs ## args) (Q : In r args) : vmatch bc rs # r (areg ae r).","proofString":"auto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) : sound_state_base (Callstate s fd rs ## args m').","proofString":"exploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\nerewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto.\ncongruence.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va.\neapply romatch_free; eauto.\neapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) : (exists bc' : block_classification,\n   bc_nostack bc' /\\\n   bc' stk = BCother /\\\n   (forall b : block, b <> stk -> bc' b = bc b) /\\\n   (forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) /\\\n   genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop) ->\nsound_state_base (Callstate s fd rs ## args m').","proofString":"intros (bc' & A & B & C & D & E & F & G).\napply sound_call_state with bc'; auto.\nerewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto.\ncongruence.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va.\neapply romatch_free; eauto.\neapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_state_base (Callstate s fd rs ## args m').","proofString":"apply sound_call_state with bc'; auto.\nerewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto.\ncongruence.\nintros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va.\neapply romatch_free; eauto.\neapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' s m' (Mem.nextblock m').","proofString":"erewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' s m' (Mem.nextblock m).","proofString":"apply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' s m' stk.","proofString":"apply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc s m' stk.","proofString":"eapply sound_stack_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : forall b : positive, Plt b stk -> bc' b = bc b.","proofString":"intros.\napply C.\napply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b0 : block, b0 <> stk -> bc' b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (b : positive) (H1 : Plt b stk) : bc' b = bc b.","proofString":"apply C.\napply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b0 : block, b0 <> stk -> bc' b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (b : positive) (H1 : Plt b stk) : b <> stk.","proofString":"apply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : Ple stk (Mem.nextblock m).","proofString":"apply Plt_Ple.\neapply mmatch_below; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : Plt stk (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : bc' stk <> BCinvalid.","proofString":"congruence."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : forall v : val, In v rs ## args -> vmatch bc' v Vtop.","proofString":"intros.\nexploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H1 : In v rs ## args) : vmatch bc' v Vtop.","proofString":"exploit list_in_map_inv; eauto.\nintros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H1 : In v rs ## args) : (exists x : positive, v = (fun r : positive => rs # r) x /\\ In x args) ->\nvmatch bc' v Vtop.","proofString":"intros (r & P & Q).\nsubst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc' v0 Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (v : val) (H1 : In v rs ## args) (r : positive) (P : v = rs # r) (Q : In r args) : vmatch bc' v Vtop.","proofString":"subst v.\napply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H1 : In rs # r rs ## args) (Q : In r args) : vmatch bc' rs # r Vtop.","proofString":"apply D with (areg ae r).\nauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (r : positive) (H1 : In rs # r rs ## args) (Q : In r args) : vmatch bc rs # r (areg ae r).","proofString":"auto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : romatch bc' m' rm.","proofString":"eapply romatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : mmatch bc' m' mtop.","proofString":"eapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"assert (SPVALID: Plt sp0 (Mem.nextblock m)) by (eapply mmatch_below; eauto with va).\nassert (TR: transfer f rm pc ae am = transfer_builtin ae am rm ef args res).\nunfold transfer; rewrite H; auto.\nassert (DEFAULT:            transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->            sound_state_base               (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')).\nunfold transfer_builtin_default, analyze_call; intros TR'.\nset (aargs := map (abuiltin_arg ae am rm) args) in *.\nassert (ARGS: list_forall2 (vmatch bc) vargs aargs) by (eapply abuiltin_args_sound; eauto).\ndestruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) aargs)        eqn: NOLEAK.\nInvBooleans.\nrewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nexploit anonymize_stack; eauto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nunfold transfer_builtin in TR.\ndestruct ef; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (eval_static_builtin_function ae am rm bf args) as [av|] eqn:ES; auto.\nsimpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\ninv H0; auto.\ninv H3; auto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"assert (TR: transfer f rm pc ae am = transfer_builtin ae am rm ef args res).\nunfold transfer; rewrite H; auto.\nassert (DEFAULT:            transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->            sound_state_base               (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')).\nunfold transfer_builtin_default, analyze_call; intros TR'.\nset (aargs := map (abuiltin_arg ae am rm) args) in *.\nassert (ARGS: list_forall2 (vmatch bc) vargs aargs) by (eapply abuiltin_args_sound; eauto).\ndestruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) aargs)        eqn: NOLEAK.\nInvBooleans.\nrewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nexploit anonymize_stack; eauto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nunfold transfer_builtin in TR.\ndestruct ef; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (eval_static_builtin_function ae am rm bf args) as [av|] eqn:ES; auto.\nsimpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\ninv H0; auto.\ninv H3; auto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) : transfer f rm pc ae am = transfer_builtin ae am rm ef args res.","proofString":"unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"assert (DEFAULT:            transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->            sound_state_base               (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')).\nunfold transfer_builtin_default, analyze_call; intros TR'.\nset (aargs := map (abuiltin_arg ae am rm) args) in *.\nassert (ARGS: list_forall2 (vmatch bc) vargs aargs) by (eapply abuiltin_args_sound; eauto).\ndestruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) aargs)        eqn: NOLEAK.\nInvBooleans.\nrewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nexploit anonymize_stack; eauto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nunfold transfer_builtin in TR.\ndestruct ef; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (eval_static_builtin_function ae am rm bf args) as [av|] eqn:ES; auto.\nsimpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\ninv H0; auto.\ninv H3; auto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"unfold transfer_builtin_default, analyze_call; intros TR'.\nset (aargs := map (abuiltin_arg ae am rm) args) in *.\nassert (ARGS: list_forall2 (vmatch bc) vargs aargs) by (eapply abuiltin_args_sound; eauto).\ndestruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) aargs)        eqn: NOLEAK.\nInvBooleans.\nrewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nexploit anonymize_stack; eauto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (TR' : transfer f rm pc ae am =\n(let (av, am') :=\n   if\n    pincl (am_nonstack am) Nonstack &&\n    forallb (fun av : aval => vpincl av Nonstack)\n      (map (abuiltin_arg ae am rm) args)\n   then (Ifptr Nonstack, mafter_private_call am)\n   else (Vtop, mafter_public_call) in\n VA.State (set_builtin_res res av ae) am')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"set (aargs := map (abuiltin_arg ae am rm) args) in *.\nassert (ARGS: list_forall2 (vmatch bc) vargs aargs) by (eapply abuiltin_args_sound; eauto).\ndestruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) aargs)        eqn: NOLEAK.\nInvBooleans.\nrewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nexploit anonymize_stack; eauto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\n(let (av, am') :=\n   if\n    pincl (am_nonstack am) Nonstack &&\n    forallb (fun av : aval => vpincl av Nonstack) aargs\n   then (Ifptr Nonstack, mafter_private_call am)\n   else (Vtop, mafter_public_call) in\n VA.State (set_builtin_res res av ae) am')) (ARGS : list_forall2 (vmatch bc) vargs aargs) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"destruct (pincl (am_nonstack am) Nonstack &&            forallb (fun av => vpincl av Nonstack) aargs)        eqn: NOLEAK.\nInvBooleans.\nrewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA.\nexploit anonymize_stack; eauto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = true) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"InvBooleans.\nrewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forallb (fun av : aval => vpincl av Nonstack) aargs = true) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"rewrite forallb_forall in H3.\nexploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"exploit hide_stack; eauto.\napply pincl_ge; auto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) : pge Nonstack (am_nonstack am).","proofString":"apply pincl_ge; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) : (exists bc' : block_classification,\n   bc_nostack bc' /\\\n   bc' sp0 = BCinvalid /\\\n   (forall b : block, b <> sp0 -> bc' b = bc b) /\\\n   (forall (v : val) (x : aval),\n    vge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc' v Vtop) /\\\n   genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop) ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"intros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"exploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) : forall v : val, In v vargs -> vmatch bc1 v Vtop.","proofString":"intros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H4 : In v vargs) : vmatch bc1 v Vtop.","proofString":"exploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H4 : In v vargs) : (exists x2 : aval, In x2 aargs /\\ vmatch bc v x2) -> vmatch bc1 v Vtop.","proofString":"intros (av & U & V).\neapply D; eauto with va.\napply vpincl_ge.\napply H3; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H4 : In v vargs) (av : aval) (U : In av aargs) (V : vmatch bc v av) : vmatch bc1 v Vtop.","proofString":"eapply D; eauto with va.\napply vpincl_ge.\napply H3; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H4 : In v vargs) (av : aval) (U : In av aargs) (V : vmatch bc v av) : vge (Ifptr Nonstack) av.","proofString":"apply vpincl_ge.\napply H3; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H4 : In v vargs) (av : aval) (U : In av aargs) (V : vmatch bc v av) : vpincl av Nonstack = true.","proofString":"apply H3; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) : (exists bc' : block_classification,\n   bc_incr bc1 bc' /\\\n   (forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc1 b) /\\\n   vmatch bc' vres Vtop /\\\n   genv_match bc' ge /\\\n   romatch bc' m' rm /\\\n   mmatch bc' m' mtop /\\\n   bc_nostack bc' /\\\n   (forall (b : block) (ofs n : Z),\n    Mem.valid_block m b ->\n    bc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n)) ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"intros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"exploit (return_from_private_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\napply Q; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : bc2 sp0 = BCinvalid.","proofString":"rewrite K; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs n : Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid -> Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n) (b : positive) (H4 : Plt b (Mem.nextblock m)) (H5 : b <> sp0) : bc b = bc2 b.","proofString":"rewrite K; auto.\nrewrite C; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs n : Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid -> Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n) (b : positive) (H4 : Plt b (Mem.nextblock m)) (H5 : b <> sp0) : bc b = bc1 b.","proofString":"rewrite C; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' sp0 ofs n = Mem.loadbytes m sp0 ofs n.","proofString":"intros.\napply Q; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs0 n0 : Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs0 n0 = Mem.loadbytes m b ofs0 n0) (ofs n : Z) (H4 : n >= 0) : Mem.loadbytes m' sp0 ofs n = Mem.loadbytes m sp0 ofs n.","proofString":"apply Q; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"eapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : In pc' (successors_instr (Ibuiltin ef args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : ematch bc3 (regmap_setres res vres rs)\n  (set_builtin_res res (Ifptr Nonstack) ae).","proofString":"apply set_builtin_res_sound; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_stack bc3 s m' sp0.","proofString":"apply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_stack bc s m' sp0.","proofString":"apply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_stack bc s m sp0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : forall (b : positive) (ofs n : BinNums.Z),\nPlt b sp0 ->\nbc b = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"intros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H4 : Plt b sp0) (H5 : bc b = BCinvalid) (H6 : n >= 0) : Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"apply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H4 : Plt b sp0) (H5 : bc b = BCinvalid) (H6 : n >= 0) : Mem.valid_block m b.","proofString":"red.\neapply Plt_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H4 : Plt b sp0) (H5 : bc b = BCinvalid) (H6 : n >= 0) : Plt b (Mem.nextblock m).","proofString":"eapply Plt_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H4 : Plt b sp0) (H5 : bc b = BCinvalid) (H6 : n >= 0) : bc1 b = BCinvalid.","proofString":"rewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res (Ifptr Nonstack) ae) (mafter_private_call am)) (ARGS : list_forall2 (vmatch bc) vargs aargs) (H2 : pincl (am_nonstack am) Nonstack = true) (H3 : forall x : aval, In x aargs -> vpincl x Nonstack = true) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCinvalid) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval),\nvge (Ifptr Nonstack) x -> vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres (Ifptr Nonstack)) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' (mafter_private_call am)) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : forall b : positive, Plt b sp0 -> bc3 b = bc b.","proofString":"exact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"exploit anonymize_stack; eauto.\nintros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) : (exists bc' : block_classification,\n   bc_nostack bc' /\\\n   bc' sp0 = BCother /\\\n   (forall b : block, b <> sp0 -> bc' b = bc b) /\\\n   (forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) /\\\n   genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop) ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"intros (bc1 & A & B & C & D & E & F & G).\nexploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"exploit external_call_match; eauto.\nintros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va.\nintros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) : forall v : val, In v vargs -> vmatch bc1 v Vtop.","proofString":"intros.\nexploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H2 : In v vargs) : vmatch bc1 v Vtop.","proofString":"exploit list_forall2_in_left; eauto.\nintros (av & U & V).\neapply D; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H2 : In v vargs) : (exists x2 : aval, In x2 aargs /\\ vmatch bc v x2) -> vmatch bc1 v Vtop.","proofString":"intros (av & U & V).\neapply D; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av0 : aval => vpincl av0 Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v0 : val) (x : aval), vmatch bc v0 x -> vmatch bc1 v0 Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (v : val) (H2 : In v vargs) (av : aval) (U : In av aargs) (V : vmatch bc v av) : vmatch bc1 v Vtop.","proofString":"eapply D; eauto with va."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) : (exists bc' : block_classification,\n   bc_incr bc1 bc' /\\\n   (forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc1 b) /\\\n   vmatch bc' vres Vtop /\\\n   genv_match bc' ge /\\\n   romatch bc' m' rm /\\\n   mmatch bc' m' mtop /\\\n   bc_nostack bc' /\\\n   (forall (b : block) (ofs n : Z),\n    Mem.valid_block m b ->\n    bc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n)) ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"intros (bc2 & J & K & L & M & N & O & P & Q).\nexploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"exploit (return_from_public_call bc bc2); eauto.\neapply mmatch_below; eauto.\nrewrite K; auto.\nintros.\nrewrite K; auto.\nrewrite C; auto.\neapply external_call_nextblock; eauto.\nintros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : bc2 sp0 = BCother.","proofString":"rewrite K; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs n : Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid -> Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n) (b : positive) (H2 : Plt b (Mem.nextblock m)) (H3 : b <> sp0) : bc b = bc2 b.","proofString":"rewrite K; auto.\nrewrite C; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs n : Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid -> Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n) (b : positive) (H2 : Plt b (Mem.nextblock m)) (H3 : b <> sp0) : bc b = bc1 b.","proofString":"rewrite C; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : (exists bc0 : block_classification,\n   vmatch bc0 vres Vtop /\\\n   ematch bc0 rs ae /\\\n   romatch bc0 m' rm /\\\n   mmatch bc0 m' mafter_public_call /\\\n   genv_match bc0 ge /\\\n   bc0 sp0 = BCstack /\\ (forall b : positive, Plt b sp0 -> bc0 b = bc b)) ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"intros (bc3 & U & V & W & X & Y & Z & AA).\neapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"eapply sound_succ_state with (bc := bc3); eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\napply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : In pc' (successors_instr (Ibuiltin ef args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : ematch bc3 (regmap_setres res vres rs) (set_builtin_res res Vtop ae).","proofString":"apply set_builtin_res_sound; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_stack bc3 s m' sp0.","proofString":"apply sound_stack_exten with bc.\napply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type.\nexact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_stack bc s m' sp0.","proofString":"apply sound_stack_inv with m.\nauto.\nintros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : sound_stack bc s m sp0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : forall (b : positive) (ofs n : BinNums.Z),\nPlt b sp0 ->\nbc b = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"intros.\napply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H2 : Plt b sp0) (H3 : bc b = BCinvalid) (H4 : n >= 0) : Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"apply Q.\nred.\neapply Plt_trans; eauto.\nrewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H2 : Plt b sp0) (H3 : bc b = BCinvalid) (H4 : n >= 0) : Mem.valid_block m b.","proofString":"red.\neapply Plt_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H2 : Plt b sp0) (H3 : bc b = BCinvalid) (H4 : n >= 0) : Plt b (Mem.nextblock m).","proofString":"eapply Plt_trans; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b0 : block, b0 <> sp0 -> bc1 b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b0 : positive, Plt b0 (Mem.nextblock m) -> bc2 b0 = bc1 b0) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b0 : block) (ofs0 n0 : BinNums.Z),\nMem.valid_block m b0 ->\nbc1 b0 = BCinvalid ->\nMem.loadbytes m' b0 ofs0 n0 = Mem.loadbytes m b0 ofs0 n0) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b0 : positive, Plt b0 sp0 -> bc3 b0 = bc b0) (b : positive) (ofs n : BinNums.Z) (H2 : Plt b sp0) (H3 : bc b = BCinvalid) (H4 : n >= 0) : bc1 b = BCinvalid.","proofString":"rewrite C; auto with ordered_type."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (aargs : list aval) (NOLEAK : pincl (am_nonstack am) Nonstack &&\nforallb (fun av : aval => vpincl av Nonstack) aargs = false) (TR' : transfer f rm pc ae am =\nVA.State (set_builtin_res res Vtop ae) mafter_public_call) (ARGS : list_forall2 (vmatch bc) vargs aargs) (bc1 : block_classification) (A : bc_nostack bc1) (B : bc1 sp0 = BCother) (C : forall b : block, b <> sp0 -> bc1 b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc1 v Vtop) (E : genv_match bc1 ge) (F : romatch bc1 m rm) (G : mmatch bc1 m mtop) (bc2 : block_classification) (J : bc_incr bc1 bc2) (K : forall b : positive, Plt b (Mem.nextblock m) -> bc2 b = bc1 b) (L : vmatch bc2 vres Vtop) (M : genv_match bc2 ge) (N : romatch bc2 m' rm) (O : mmatch bc2 m' mtop) (P : bc_nostack bc2) (Q : forall (b : block) (ofs n : BinNums.Z),\nMem.valid_block m b ->\nbc1 b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) (bc3 : block_classification) (U : vmatch bc3 vres Vtop) (V : ematch bc3 rs ae) (W : romatch bc3 m' rm) (X : mmatch bc3 m' mafter_public_call) (Y : genv_match bc3 ge) (Z : bc3 sp0 = BCstack) (AA : forall b : positive, Plt b sp0 -> bc3 b = bc b) : forall b : positive, Plt b sp0 -> bc3 b = bc b.","proofString":"exact AA."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = transfer_builtin ae am rm ef args res) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"unfold transfer_builtin in TR.\ndestruct ef; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (eval_static_builtin_function ae am rm bf args) as [av|] eqn:ES; auto.\nsimpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\ninv H0; auto.\ninv H3; auto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch ef with\n| EF_builtin name sg =>\n    match lookup_builtin_function name sg with\n    | Some bf =>\n        match eval_static_builtin_function ae am rm bf args with\n        | Some av => VA.State (set_builtin_res res av ae) am\n        | None => transfer_builtin_default ae am rm args res\n        end\n    | None => transfer_builtin_default ae am rm args res\n    end\n| EF_vload chunk =>\n    match args with\n    | nil => transfer_builtin_default ae am rm args res\n    | addr :: nil =>\n        VA.State\n          (set_builtin_res res\n             (if va_strict tt\n              then\n               vlub (loadv chunk rm am (abuiltin_arg ae am rm addr))\n                 (vnormalize chunk (Ifptr Glob))\n              else vnormalize chunk Vtop) ae) am\n    | addr :: _ :: _ => transfer_builtin_default ae am rm args res\n    end\n| EF_vstore chunk =>\n    match args with\n    | nil => transfer_builtin_default ae am rm args res\n    | addr :: nil => transfer_builtin_default ae am rm args res\n    | addr :: v :: nil =>\n        VA.State (set_builtin_res res ntop ae)\n          (mlub am\n             (storev chunk am (abuiltin_arg ae am rm addr)\n                (abuiltin_arg ae am rm v)))\n    | addr :: v :: _ :: _ => transfer_builtin_default ae am rm args res\n    end\n| EF_memcpy sz _ =>\n    match args with\n    | nil => transfer_builtin_default ae am rm args res\n    | dst :: nil => transfer_builtin_default ae am rm args res\n    | dst :: src :: nil =>\n        VA.State (set_builtin_res res ntop ae)\n          (storebytes am (aptr_of_aval (abuiltin_arg ae am rm dst)) sz\n             (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm src))))\n    | dst :: src :: _ :: _ => transfer_builtin_default ae am rm args res\n    end\n| EF_annot_val _ _ _ =>\n    match args with\n    | nil => transfer_builtin_default ae am rm args res\n    | v :: nil =>\n        VA.State (set_builtin_res res (abuiltin_arg ae am rm v) ae) am\n    | v :: _ :: _ => transfer_builtin_default ae am rm args res\n    end\n| EF_annot _ _ _ | EF_debug _ _ _ =>\n    VA.State (set_builtin_res res ntop ae) am\n| _ => transfer_builtin_default ae am rm args res\nend) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"destruct ef; auto.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (eval_static_builtin_function ae am rm bf args) as [av|] eqn:ES; auto.\nsimpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto.\ninv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\ninv H0; auto.\ninv H3; auto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch lookup_builtin_function name sg with\n| Some bf =>\n    match eval_static_builtin_function ae am rm bf args with\n    | Some av => VA.State (set_builtin_res res av ae) am\n    | None => transfer_builtin_default ae am rm args res\n    end\n| None => transfer_builtin_default ae am rm args res\nend) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"destruct (lookup_builtin_function name sg) as [bf|] eqn:LK; auto.\ndestruct (eval_static_builtin_function ae am rm bf args) as [av|] eqn:ES; auto.\nsimpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (TR : transfer f rm pc ae am =\nmatch eval_static_builtin_function ae am rm bf args with\n| Some av => VA.State (set_builtin_res res av ae) am\n| None => transfer_builtin_default ae am rm args res\nend) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"destruct (eval_static_builtin_function ae am rm bf args) as [av|] eqn:ES; auto.\nsimpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_builtin name sg) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"simpl in H1.\nred in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : builtin_or_external_sem name sg ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"red in H1.\nrewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (bf : builtin_function) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"rewrite LK in H1.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (bf : builtin_function) (H1 : known_builtin_sem bf ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (bf : builtin_function) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : builtin_function_sem bf vargs = Some vres) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (bf : builtin_function) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : builtin_function_sem bf vargs = Some vres) : In pc' (successors_instr (Ibuiltin (EF_builtin name sg) args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (bf : builtin_function) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : builtin_function_sem bf vargs = Some vres) : ematch bc (regmap_setres res vres rs) (set_builtin_res res av ae).","proofString":"apply set_builtin_res_sound; auto.\neapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (name : string) (sg : signature) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_builtin name sg) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (bf : builtin_function) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (LK : lookup_builtin_function name sg = Some bf) (av : aval) (ES : eval_static_builtin_function ae am rm bf args = Some av) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res av ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : builtin_function_sem bf vargs = Some vres) : vmatch bc vres av.","proofString":"eapply eval_static_builtin_function_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_vload chunk) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch args with\n| nil => transfer_builtin_default ae am rm args res\n| addr :: nil =>\n    VA.State\n      (set_builtin_res res\n         (if va_strict tt\n          then\n           vlub (loadv chunk rm am (abuiltin_arg ae am rm addr))\n             (vnormalize chunk (Ifptr Glob))\n          else vnormalize chunk Vtop) ae) am\n| addr :: _ :: _ => transfer_builtin_default ae am rm args res\nend) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H0; auto.\ninv H3; auto.\ninv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: al) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : external_call (EF_vload chunk) ge (b1 :: bl) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: al) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (TR : transfer f rm pc ae am =\nmatch al with\n| nil =>\n    VA.State\n      (set_builtin_res res\n         (if va_strict tt\n          then\n           vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n             (vnormalize chunk (Ifptr Glob))\n          else vnormalize chunk Vtop) ae) am\n| _ :: _ => transfer_builtin_default ae am rm (a1 :: al) res\nend) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H3 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  al bl) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H3; auto.\ninv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (b1 : val) (H1 : external_call (EF_vload chunk) ge (b1 :: nil) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H1.\nexploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (H3 : volatile_load ge chunk m' b ofs t vres) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"exploit abuiltin_arg_sound; eauto.\nintros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (H3 : volatile_load ge chunk m' b ofs t vres) : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1) ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"intros VM1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (H3 : volatile_load ge chunk m' b ofs t vres) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (H3 : volatile_load ge chunk m' b ofs t vres) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) : In pc' (successors_instr (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (H3 : volatile_load ge chunk m' b ofs t vres) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) : ematch bc (regmap_setres res vres rs)\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae).","proofString":"apply set_builtin_res_sound; auto.\ninv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (H3 : volatile_load ge chunk m' b ofs t vres) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) : vmatch bc vres\n  (if va_strict tt\n   then\n    vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n      (vnormalize chunk (Ifptr Glob))\n   else vnormalize chunk Vtop).","proofString":"inv H3.\nassert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor.\nexploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) : vmatch bc (Val.load_result chunk v)\n  (if va_strict tt\n   then\n    vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n      (vnormalize chunk (Ifptr Glob))\n   else vnormalize chunk Vtop).","proofString":"assert (V: vmatch bc v (Ifptr Glob)).\ninv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto.\ndestruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) : vmatch bc v (Ifptr Glob).","proofString":"inv H4; simpl in *; constructor.\neconstructor.\neapply GE; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (b0 : block) (ofs0 : ptrofs) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk (Vptr b0 ofs0)) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (H0 : Genv.block_is_volatile ge b = true) (H1 : Genv.find_symbol ge id = Some b) (id0 : ident) (H5 : Genv.public_symbol ge id0 = true) (H7 : Genv.find_symbol ge id0 = Some b0) (H3 : Tptr = type_of_chunk chunk) : pmatch bc b0 ofs0 Glob.","proofString":"econstructor.\neapply GE; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : vmatch bc (Val.load_result chunk v)\n  (if va_strict tt\n   then\n    vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n      (vnormalize chunk (Ifptr Glob))\n   else vnormalize chunk Vtop).","proofString":"destruct (va_strict tt).\napply vmatch_lub_r.\napply vnormalize_sound.\nauto.\napply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n        (vnormalize chunk (Ifptr Glob))) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : vmatch bc (Val.load_result chunk v)\n  (vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n     (vnormalize chunk (Ifptr Glob))).","proofString":"apply vmatch_lub_r.\napply vnormalize_sound.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n        (vnormalize chunk (Ifptr Glob))) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : vmatch bc (Val.load_result chunk v) (vnormalize chunk (Ifptr Glob)).","proofString":"apply vnormalize_sound.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n        (vnormalize chunk (Ifptr Glob))) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : vmatch bc v (Ifptr Glob).","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (vnormalize chunk Vtop) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : vmatch bc (Val.load_result chunk v) (vnormalize chunk Vtop).","proofString":"apply vnormalize_sound.\neapply vmatch_ge; eauto.\nconstructor.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (vnormalize chunk Vtop) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : vmatch bc v Vtop.","proofString":"eapply vmatch_ge; eauto.\nconstructor.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (vnormalize chunk Vtop) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : vge Vtop (Ifptr Glob).","proofString":"constructor.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (vnormalize chunk Vtop) ae) am) (v : val) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc'\n     (regmap_setres res (Val.load_result chunk v) rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v) (V : vmatch bc v (Ifptr Glob)) : pge Ptop Glob.","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) : vmatch bc vres\n  (if va_strict tt\n   then\n    vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n      (vnormalize chunk (Ifptr Glob))\n   else vnormalize chunk Vtop).","proofString":"exploit loadv_sound; eauto.\nsimpl; eauto.\nintros V.\ndestruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (if va_strict tt\n      then\n       vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n         (vnormalize chunk (Ifptr Glob))\n      else vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (V : vmatch bc vres (loadv chunk rm am (abuiltin_arg ae am rm a1))) : vmatch bc vres\n  (if va_strict tt\n   then\n    vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n      (vnormalize chunk (Ifptr Glob))\n   else vnormalize chunk Vtop).","proofString":"destruct (va_strict tt).\napply vmatch_lub_l.\nauto.\neapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n        (vnormalize chunk (Ifptr Glob))) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (V : vmatch bc vres (loadv chunk rm am (abuiltin_arg ae am rm a1))) : vmatch bc vres\n  (vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n     (vnormalize chunk (Ifptr Glob))).","proofString":"apply vmatch_lub_l.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State\n  (set_builtin_res res\n     (vlub (loadv chunk rm am (abuiltin_arg ae am rm a1))\n        (vnormalize chunk (Ifptr Glob))) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (V : vmatch bc vres (loadv chunk rm am (abuiltin_arg ae am rm a1))) : vmatch bc vres (loadv chunk rm am (abuiltin_arg ae am rm a1)).","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (V : vmatch bc vres (loadv chunk rm am (abuiltin_arg ae am rm a1))) : vmatch bc vres (vnormalize chunk Vtop).","proofString":"eapply vnormalize_cast; eauto.\neapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vload chunk) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (vnormalize chunk Vtop) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H0 : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some vres) (V : vmatch bc vres (loadv chunk rm am (abuiltin_arg ae am rm a1))) : vmatch bc vres (Ifptr Ptop).","proofString":"eapply vmatch_top; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vstore chunk) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_vstore chunk) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch args with\n| nil => transfer_builtin_default ae am rm args res\n| addr :: nil => transfer_builtin_default ae am rm args res\n| addr :: v :: nil =>\n    VA.State (set_builtin_res res ntop ae)\n      (mlub am\n         (storev chunk am (abuiltin_arg ae am rm addr)\n            (abuiltin_arg ae am rm v)))\n| addr :: v :: _ :: _ => transfer_builtin_default ae am rm args res\nend) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_vstore chunk) (a1 :: al) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : external_call (EF_vstore chunk) ge (b1 :: bl) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: al) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (TR : transfer f rm pc ae am =\nmatch al with\n| nil => transfer_builtin_default ae am rm (a1 :: al) res\n| v :: nil =>\n    VA.State (set_builtin_res res ntop ae)\n      (mlub am\n         (storev chunk am (abuiltin_arg ae am rm a1)\n            (abuiltin_arg ae am rm v)))\n| v :: _ :: _ => transfer_builtin_default ae am rm (a1 :: al) res\nend) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H3 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  al bl) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 a0 : builtin_arg positive) (al0 : list (builtin_arg positive)) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: al0) res pc')) (sp0 : block) (b1 b0 : val) (bl0 : list val) (H1 : external_call (EF_vstore chunk) ge (b1 :: b0 :: bl0) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch al0 with\n| nil =>\n    VA.State (set_builtin_res res ntop ae)\n      (mlub am\n         (storev chunk am (abuiltin_arg ae am rm a1)\n            (abuiltin_arg ae am rm a0)))\n| _ :: _ => transfer_builtin_default ae am rm (a1 :: a0 :: al0) res\nend) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: al0) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  al0 bl0) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b1 b0 : val) (H1 : external_call (EF_vstore chunk) ge (b1 :: b0 :: nil) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (H9 : volatile_store ge chunk m b ofs b0 t m') : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"exploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (H9 : volatile_store ge chunk m b ofs b0 t m') (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"exploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\ninv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (t : trace) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (H9 : volatile_store ge chunk m b ofs b0 t m') (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"inv H9.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a0\n  b0) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk b0)) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_l; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a0\n  b0) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk b0)) : In pc'\n  (successors_instr (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a0\n  b0) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk b0)) : ematch bc (regmap_setres res Vundef rs) (set_builtin_res res ntop ae).","proofString":"apply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a0\n  b0) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk b0)) : vmatch bc Vundef ntop.","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a0\n  b0) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  (Vptr b ofs)) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (id : ident) (ev : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk b0)) : mmatch bc m'\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0))).","proofString":"apply mmatch_lub_l; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\napply mmatch_lub_r.\neapply storev_sound; eauto.\nauto.\neapply romatch_store; eauto.\neapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : In pc'\n  (successors_instr (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : ematch bc (regmap_setres res Vundef rs) (set_builtin_res res ntop ae).","proofString":"apply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : vmatch bc Vundef ntop.","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : mmatch bc m'\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0))).","proofString":"apply mmatch_lub_r.\neapply storev_sound; eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : mmatch bc m'\n  (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)).","proofString":"eapply storev_sound; eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : Mem.storev chunk m (Vptr b ofs) b0 = Some m'.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : romatch bc m' rm.","proofString":"eapply romatch_store; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_vstore chunk) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b0 : val) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (mlub am\n     (storev chunk am (abuiltin_arg ae am rm a1) (abuiltin_arg ae am rm a0)))) (b : block) (ofs : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr b ofs)) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (VM1 : vmatch bc b0 (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a1)) (H1 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m b (Ptrofs.unsigned ofs) b0 = Some m') : sound_stack bc s m' sp0.","proofString":"eapply sound_stack_storev; eauto.\nsimpl; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_memcpy sz al) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch args with\n| nil => transfer_builtin_default ae am rm args res\n| dst :: nil => transfer_builtin_default ae am rm args res\n| dst :: src :: nil =>\n    VA.State (set_builtin_res res ntop ae)\n      (storebytes am (aptr_of_aval (abuiltin_arg ae am rm dst)) sz\n         (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm src))))\n| dst :: src :: _ :: _ => transfer_builtin_default ae am rm args res\nend) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H0; auto.\ninv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (al0 : list (builtin_arg positive)) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_memcpy sz al) (a1 :: al0) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : external_call (EF_memcpy sz al) ge (b1 :: bl) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: al0) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (TR : transfer f rm pc ae am =\nmatch al0 with\n| nil => transfer_builtin_default ae am rm (a1 :: al0) res\n| src :: nil =>\n    VA.State (set_builtin_res res ntop ae)\n      (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n         (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm src))))\n| src :: _ :: _ => transfer_builtin_default ae am rm (a1 :: al0) res\nend) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H3 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  al0 bl) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H3; auto.\ninv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 a0 : builtin_arg positive) (al1 : list (builtin_arg positive)) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: al1) res pc')) (sp0 : block) (b1 b0 : val) (bl0 : list val) (H1 : external_call (EF_memcpy sz al) ge (b1 :: b0 :: bl0) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch al1 with\n| nil =>\n    VA.State (set_builtin_res res ntop ae)\n      (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n         (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))\n| _ :: _ => transfer_builtin_default ae am rm (a1 :: a0 :: al1) res\nend) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: al1) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) (H4 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  al1 bl0) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H4; auto.\ninv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (b1 b0 : val) (H1 : external_call (EF_memcpy sz al) ge (b1 :: b0 :: nil) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  b0) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"exploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H0.\nintros VM1.\nexploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"exploit abuiltin_arg_sound.\neauto.\neauto.\neauto.\neauto.\neauto.\neexact H2.\nintros VM2.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor.\neapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply romatch_storebytes; eauto.\neapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : In pc'\n  (successors_instr (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : ematch bc (regmap_setres res Vundef rs) (set_builtin_res res ntop ae).","proofString":"apply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : vmatch bc Vundef ntop.","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : mmatch bc m'\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0)))).","proofString":"eapply storebytes_sound; eauto.\napply match_aptr_of_aval; auto.\neapply Mem.loadbytes_length; eauto.\nintros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : pmatch bc bdst odst (aptr_of_aval (abuiltin_arg ae am rm a1)).","proofString":"apply match_aptr_of_aval; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : Datatypes.length bytes = Z.to_nat sz.","proofString":"eapply Mem.loadbytes_length; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes ->\npmatch bc b' ofs' (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))).","proofString":"intros.\neapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat) (H1 : In (Fragment (Vptr b' ofs') qt i) bytes) : pmatch bc b' ofs' (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))).","proofString":"eapply loadbytes_sound; eauto.\napply match_aptr_of_aval; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat) (H1 : In (Fragment (Vptr b' ofs') qt i) bytes) : pmatch bc bsrc osrc (aptr_of_aval (abuiltin_arg ae am rm a0)).","proofString":"apply match_aptr_of_aval; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : romatch bc m' rm.","proofString":"eapply romatch_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (sz al : Z) (res : builtin_res reg) (pc' : node) (m' : mem) (a1 a0 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_memcpy sz al) (a1 :: a0 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am =\ntransfer_builtin_default ae am rm (a1 :: a0 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res ntop ae)\n  (storebytes am (aptr_of_aval (abuiltin_arg ae am rm a1)) sz\n     (loadbytes am rm (aptr_of_aval (abuiltin_arg ae am rm a0))))) (bdst : block) (odst : ptrofs) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  (Vptr bdst odst)) (bsrc : block) (osrc : ptrofs) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a0\n  (Vptr bsrc osrc)) (bytes : list memval) (H5 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H6 : sz >= 0) (H7 : (al | sz)) (H8 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H9 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H10 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H11 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H16 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') (VM1 : vmatch bc (Vptr bsrc osrc) (abuiltin_arg ae am rm a0)) (VM2 : vmatch bc (Vptr bdst odst) (abuiltin_arg ae am rm a1)) : sound_stack bc s m' sp0.","proofString":"eapply sound_stack_storebytes; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (kind : positive) (text : string) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_annot kind text targs) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (args0 : list eventval) (H2 : eventval_list_match ge args0 targs vargs) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (args0 : list eventval) (H2 : eventval_list_match ge args0 targs vargs) : In pc' (successors_instr (Ibuiltin (EF_annot kind text targs) args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (args0 : list eventval) (H2 : eventval_list_match ge args0 targs vargs) : ematch bc (regmap_setres res Vundef rs) (set_builtin_res res ntop ae).","proofString":"apply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) (args0 : list eventval) (H2 : eventval_list_match ge args0 targs vargs) : vmatch bc Vundef ntop.","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (kind : positive) (text : string) (targ : typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_annot_val kind text targ) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_annot_val kind text targ) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nmatch args with\n| nil => transfer_builtin_default ae am rm args res\n| v :: nil => VA.State (set_builtin_res res (abuiltin_arg ae am rm v) ae) am\n| v :: _ :: _ => transfer_builtin_default ae am rm args res\nend) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H0; auto.\ninv H3; auto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (kind : positive) (text : string) (targ : typ) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_annot_val kind text targ) (a1 :: al) res pc')) (sp0 : block) (b1 : val) (bl : list val) (H1 : external_call (EF_annot_val kind text targ) ge (b1 :: bl) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: al) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (TR : transfer f rm pc ae am =\nmatch al with\n| nil => VA.State (set_builtin_res res (abuiltin_arg ae am rm a1) ae) am\n| _ :: _ => transfer_builtin_default ae am rm (a1 :: al) res\nend) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) (H3 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m)\n  al bl) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H3; auto.\ninv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (kind : positive) (text : string) (targ : typ) (res : builtin_res reg) (pc' : node) (t : trace) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_annot_val kind text targ) (a1 :: nil) res pc')) (sp0 : block) (b1 : val) (H1 : external_call (EF_annot_val kind text targ) ge (b1 :: nil) m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (abuiltin_arg ae am rm a1) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m a1\n  b1) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targ : typ) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_annot_val kind text targ) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (abuiltin_arg ae am rm a1) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  vres) (arg : eventval) (H3 : eventval_match ge arg targ vres) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targ : typ) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_annot_val kind text targ) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (abuiltin_arg ae am rm a1) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  vres) (arg : eventval) (H3 : eventval_match ge arg targ vres) : In pc'\n  (successors_instr\n     (Ibuiltin (EF_annot_val kind text targ) (a1 :: nil) res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targ : typ) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_annot_val kind text targ) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (abuiltin_arg ae am rm a1) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  vres) (arg : eventval) (H3 : eventval_match ge arg targ vres) : ematch bc (regmap_setres res vres rs)\n  (set_builtin_res res (abuiltin_arg ae am rm a1) ae).","proofString":"apply set_builtin_res_sound; auto.\neapply abuiltin_arg_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : string) (targ : typ) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (a1 : builtin_arg positive) (H : (fn_code f) ! pc =\nSome (Ibuiltin (EF_annot_val kind text targ) (a1 :: nil) res pc')) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am =\nVA.State (set_builtin_res res (abuiltin_arg ae am rm a1) ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm (a1 :: nil) res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) (H2 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m' a1\n  vres) (arg : eventval) (H3 : eventval_match ge arg targ vres) : vmatch bc vres (abuiltin_arg ae am rm a1).","proofString":"eapply abuiltin_arg_sound; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call (EF_debug kind text targs) ge vargs m t vres m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m)) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m').","proofString":"inv H1.\neapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m').","proofString":"eapply sound_succ_state; eauto.\nsimpl; auto.\napply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) : In pc' (successors_instr (Ibuiltin (EF_debug kind text targs) args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) : ematch bc (regmap_setres res Vundef rs) (set_builtin_res res ntop ae).","proofString":"apply set_builtin_res_sound; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin (EF_debug kind text targs) args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m' args vargs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m' sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (MM : mmatch bc m' am) (RO : romatch bc m' rm) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) (SPVALID : Plt sp0 (Mem.nextblock m')) (TR : transfer f rm pc ae am = VA.State (set_builtin_res res ntop ae) am) (DEFAULT : transfer f rm pc ae am = transfer_builtin_default ae am rm args res ->\nsound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res Vundef rs) m')) : vmatch bc Vundef ntop.","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base\n  (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m).","proofString":"eapply sound_succ_state; eauto.\nsimpl.\ndestruct b; auto.\nunfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : In (if b then ifso else ifnot)\n  (successors_instr (Icond cond args ifso ifnot)).","proofString":"simpl.\ndestruct b; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : ifso = (if b then ifso else ifnot) \\/\nifnot = (if b then ifso else ifnot) \\/ False.","proofString":"destruct b; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : transfer f rm pc ae am = VA.State ae am.","proofString":"unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc' rs m).","proofString":"eapply sound_succ_state; eauto.\nsimpl.\neapply list_nth_z_in; eauto.\nunfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : In pc' (successors_instr (Ijumptable arg tbl)).","proofString":"simpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : In pc' tbl.","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m sp0) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc sp0 = BCstack) : transfer f rm pc ae am = VA.State ae am.","proofString":"unfold transfer; rewrite H; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) : sound_state_base (Returnstate s (regmap_optget or Vundef rs) m').","proofString":"exploit anonymize_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\napply sound_return_state with bc'; auto.\nerewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto with va.\ndestruct or; simpl.\neapply D; eauto.\nconstructor.\neapply romatch_free; eauto.\neapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) : (exists bc' : block_classification,\n   bc_nostack bc' /\\\n   bc' stk = BCother /\\\n   (forall b : block, b <> stk -> bc' b = bc b) /\\\n   (forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) /\\\n   genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop) ->\nsound_state_base (Returnstate s (regmap_optget or Vundef rs) m').","proofString":"intros (bc' & A & B & C & D & E & F & G).\napply sound_return_state with bc'; auto.\nerewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto with va.\ndestruct or; simpl.\neapply D; eauto.\nconstructor.\neapply romatch_free; eauto.\neapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_state_base (Returnstate s (regmap_optget or Vundef rs) m').","proofString":"apply sound_return_state with bc'; auto.\nerewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto with va.\ndestruct or; simpl.\neapply D; eauto.\nconstructor.\neapply romatch_free; eauto.\neapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' s m' (Mem.nextblock m').","proofString":"erewrite Mem.nextblock_free by eauto.\napply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' s m' (Mem.nextblock m).","proofString":"apply sound_stack_new_bound with stk.\napply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto.\napply Plt_Ple.\neapply mmatch_below; eauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc' s m' stk.","proofString":"apply sound_stack_exten with bc.\neapply sound_stack_free; eauto.\nintros.\napply C.\napply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : sound_stack bc s m' stk.","proofString":"eapply sound_stack_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : forall b : positive, Plt b stk -> bc' b = bc b.","proofString":"intros.\napply C.\napply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b0 : block, b0 <> stk -> bc' b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (b : positive) (H1 : Plt b stk) : bc' b = bc b.","proofString":"apply C.\napply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b0 : block, b0 <> stk -> bc' b0 = bc b0) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) (b : positive) (H1 : Plt b stk) : b <> stk.","proofString":"apply Plt_ne; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : Ple stk (Mem.nextblock m).","proofString":"apply Plt_Ple.\neapply mmatch_below; eauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : Plt stk (Mem.nextblock m).","proofString":"eapply mmatch_below; eauto with va."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : vmatch bc' (regmap_optget or Vundef rs) Vtop.","proofString":"destruct or; simpl.\neapply D; eauto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (r : reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn (Some r))) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : vmatch bc' rs # r Vtop.","proofString":"eapply D; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : vmatch bc' Vundef Vtop.","proofString":"constructor."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : romatch bc' m' rm.","proofString":"eapply romatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack bc s m stk) (AN : (analyze rm f) # pc = VA.State ae am) (EM : ematch bc rs ae) (RO : romatch bc m rm) (MM : mmatch bc m am) (GE : genv_match bc ge) (SP : bc stk = BCstack) (bc' : block_classification) (A : bc_nostack bc') (B : bc' stk = BCother) (C : forall b : block, b <> stk -> bc' b = bc b) (D : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v Vtop) (E : genv_match bc' ge) (F : romatch bc' m rm) (G : mmatch bc' m mtop) : mmatch bc' m' mtop.","proofString":"eapply mmatch_free; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) : sound_state_base\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"exploit allocate_stack; eauto.\nintros (bc' & A & B & C & D & E & F & G).\nexploit (analyze_entrypoint rm f args m' bc'); eauto.\nintros (ae & am & AN & EM & MM').\neconstructor; eauto.\nerewrite Mem.alloc_result by eauto.\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) : (exists bc' : block_classification,\n   bc_incr bc bc' /\\\n   bc' stk = BCstack /\\\n   genv_match bc' ge /\\\n   romatch bc' m' rm /\\\n   mmatch bc' m' mfunction_entry /\\\n   (forall b : positive, Plt b stk -> bc' b = bc b) /\\\n   (forall (v : val) (x : aval),\n    vmatch bc v x -> vmatch bc' v (Ifptr Nonstack))) ->\nsound_state_base\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"intros (bc' & A & B & C & D & E & F & G).\nexploit (analyze_entrypoint rm f args m' bc'); eauto.\nintros (ae & am & AN & EM & MM').\neconstructor; eauto.\nerewrite Mem.alloc_result by eauto.\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) : sound_state_base\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"exploit (analyze_entrypoint rm f args m' bc'); eauto.\nintros (ae & am & AN & EM & MM').\neconstructor; eauto.\nerewrite Mem.alloc_result by eauto.\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) : (exists (ae : aenv) (am : amem),\n   (analyze rm f) # (fn_entrypoint f) = VA.State ae am /\\\n   ematch bc' (init_regs args (fn_params f)) ae /\\ mmatch bc' m' am) ->\nsound_state_base\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"intros (ae & am & AN & EM & MM').\neconstructor; eauto.\nerewrite Mem.alloc_result by eauto.\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) : sound_state_base\n  (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n     (init_regs args (fn_params f)) m').","proofString":"econstructor; eauto.\nerewrite Mem.alloc_result by eauto.\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) : sound_stack bc' s m' stk.","proofString":"erewrite Mem.alloc_result by eauto.\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) : sound_stack bc' s m' (Mem.nextblock m).","proofString":"apply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) : sound_stack bc s m' (Mem.nextblock m).","proofString":"apply sound_stack_inv with m; auto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) : forall (b : positive) (ofs n : Z),\nPlt b (Mem.nextblock m) ->\nbc b = BCinvalid ->\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"intros.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b0 : positive, Plt b0 stk -> bc' b0 = bc b0) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) (b : positive) (ofs n : Z) (H1 : Plt b (Mem.nextblock m)) (H2 : bc b = BCinvalid) (H3 : n >= 0) : Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n.","proofString":"eapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b : positive, Plt b stk -> bc' b = bc b) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) : forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b.","proofString":"intros.\napply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b0 : positive, Plt b0 stk -> bc' b0 = bc b0) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) (b : positive) (H1 : Plt b (Mem.nextblock m)) : bc' b = bc b.","proofString":"apply F.\nerewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b0 : positive, Plt b0 stk -> bc' b0 = bc b0) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) (b : positive) (H1 : Plt b (Mem.nextblock m)) : Plt b stk.","proofString":"erewrite Mem.alloc_result by eauto.\nauto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : bc' stk = BCstack) (C : genv_match bc' ge) (D : romatch bc' m' rm) (E : mmatch bc' m' mfunction_entry) (F : forall b0 : positive, Plt b0 stk -> bc' b0 = bc b0) (G : forall (v : val) (x : aval), vmatch bc v x -> vmatch bc' v (Ifptr Nonstack)) (ae : aenv) (am : amem) (AN : (analyze rm f) # (fn_entrypoint f) = VA.State ae am) (EM : ematch bc' (init_regs args (fn_params f)) ae) (MM' : mmatch bc' m' am) (b : positive) (H1 : Plt b (Mem.nextblock m)) : Plt b (Mem.nextblock m).","proofString":"auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) : sound_state_base (Returnstate s res m').","proofString":"exploit external_call_match; eauto with va.\nintros (bc' & A & B & C & D & E & F & G & K).\neconstructor; eauto.\napply sound_stack_new_bound with (Mem.nextblock m).\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) : (exists bc' : block_classification,\n   bc_incr bc bc' /\\\n   (forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) /\\\n   vmatch bc' res Vtop /\\\n   genv_match bc' ge /\\\n   romatch bc' m' rm /\\\n   mmatch bc' m' mtop /\\\n   bc_nostack bc' /\\\n   (forall (b : block) (ofs n : Z),\n    Mem.valid_block m b ->\n    bc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n)) ->\nsound_state_base (Returnstate s res m').","proofString":"intros (bc' & A & B & C & D & E & F & G & K).\neconstructor; eauto.\napply sound_stack_new_bound with (Mem.nextblock m).\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) (C : vmatch bc' res Vtop) (D : genv_match bc' ge) (E : romatch bc' m' rm) (F : mmatch bc' m' mtop) (G : bc_nostack bc') (K : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : sound_state_base (Returnstate s res m').","proofString":"econstructor; eauto.\napply sound_stack_new_bound with (Mem.nextblock m).\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) (C : vmatch bc' res Vtop) (D : genv_match bc' ge) (E : romatch bc' m' rm) (F : mmatch bc' m' mtop) (G : bc_nostack bc') (K : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : sound_stack bc' s m' (Mem.nextblock m').","proofString":"apply sound_stack_new_bound with (Mem.nextblock m).\napply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) (C : vmatch bc' res Vtop) (D : genv_match bc' ge) (E : romatch bc' m' rm) (F : mmatch bc' m' mtop) (G : bc_nostack bc') (K : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : sound_stack bc' s m' (Mem.nextblock m).","proofString":"apply sound_stack_exten with bc; auto.\napply sound_stack_inv with m; auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) (C : vmatch bc' res Vtop) (D : genv_match bc' ge) (E : romatch bc' m' rm) (F : mmatch bc' m' mtop) (G : bc_nostack bc') (K : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : sound_stack bc s m' (Mem.nextblock m).","proofString":"apply sound_stack_inv with m; auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (bc : block_classification) (STK : sound_stack bc s m (Mem.nextblock m)) (ARGS : forall v : val, In v args -> vmatch bc v Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (bc' : block_classification) (A : bc_incr bc bc') (B : forall b : positive, Plt b (Mem.nextblock m) -> bc' b = bc b) (C : vmatch bc' res Vtop) (D : genv_match bc' ge) (E : romatch bc' m' rm) (F : mmatch bc' m' mtop) (G : bc_nostack bc') (K : forall (b : block) (ofs n : Z),\nMem.valid_block m b ->\nbc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : Ple (Mem.nextblock m) (Mem.nextblock m').","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (STK : sound_stack bc (Stackframe res f sp pc rs :: s) m (Mem.nextblock m)) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) : sound_state_base (State s f sp pc rs # res <- vres m).","proofString":"inv STK.\nexploit return_from_public_call; eauto.\nintros; rewrite SAME; auto.\nintros (bc1 & A & B & C & D & E & F & G).\ndestruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto.\nexploit return_from_private_call; eauto.\nintros; rewrite SAME; auto.\nintros (bc1 & A & B & C & D & E & F & G).\ndestruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' rs ae) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"exploit return_from_public_call; eauto.\nintros; rewrite SAME; auto.\nintros (bc1 & A & B & C & D & E & F & G).\ndestruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' rs ae) : forall b : positive, Plt b bound' -> b <> sp0 -> bc' b = bc b.","proofString":"intros; rewrite SAME; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' rs ae) : (exists bc0 : block_classification,\n   vmatch bc0 vres Vtop /\\\n   ematch bc0 rs ae /\\\n   romatch bc0 m rm /\\\n   mmatch bc0 m mafter_public_call /\\\n   genv_match bc0 ge /\\\n   bc0 sp0 = BCstack /\\ (forall b : positive, Plt b sp0 -> bc0 b = bc' b)) ->\nsound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"intros (bc1 & A & B & C & D & E & F & G).\ndestruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc (VA.State (AE.set res Vtop ae) mafter_public_call)) (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"destruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (AN : AE.ge ae' (AE.set res Vtop ae) /\\\n(forall (bc0 : block_classification) (m0 : mem),\n mmatch bc0 m0 mafter_public_call -> mmatch bc0 m0 am')) (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"destruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res Vtop ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mafter_public_call -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"eapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res Vtop ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mafter_public_call -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_stack bc1 s m sp0.","proofString":"apply sound_stack_exten with bc'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res Vtop ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mafter_public_call -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : ematch bc1 rs # res <- vres ae'.","proofString":"eapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res Vtop ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mafter_public_call -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : ematch bc1 rs # res <- vres (AE.set res Vtop ae).","proofString":"apply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res Vtop ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mafter_public_call -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : ematch bc1 rs ae.","proofString":"auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCother) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res Vtop ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 mafter_public_call -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (bc1 : block_classification) (A : vmatch bc1 vres Vtop) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m mafter_public_call) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : vmatch bc1 vres Vtop.","proofString":"auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"exploit return_from_private_call; eauto.\nintros; rewrite SAME; auto.\nintros (bc1 & A & B & C & D & E & F & G).\ndestruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) : forall b : positive, Plt b bound' -> b <> sp0 -> bc' b = bc b.","proofString":"intros; rewrite SAME; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) : (exists bc0 : block_classification,\n   vmatch bc0 vres (Ifptr Nonstack) /\\\n   ematch bc0 rs ae /\\\n   romatch bc0 m rm /\\\n   mmatch bc0 m (mafter_private_call am) /\\\n   genv_match bc0 ge /\\\n   bc0 sp0 = BCstack /\\ (forall b : positive, Plt b sp0 -> bc0 b = bc' b)) ->\nsound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"intros (bc1 & A & B & C & D & E & F & G).\ndestruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (AN : VA.ge (analyze rm f) # pc\n  (VA.State (AE.set res (Ifptr Nonstack) ae) (mafter_private_call am))) (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"destruct (analyze rm f)#pc as [ |ae' am'] eqn:EQ; simpl in AN; try contradiction.\ndestruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (AN : AE.ge ae' (AE.set res (Ifptr Nonstack) ae) /\\\n(forall (bc0 : block_classification) (m0 : mem),\n mmatch bc0 m0 (mafter_private_call am) -> mmatch bc0 m0 am')) (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"destruct AN as [A1 A2].\neapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res (Ifptr Nonstack) ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 (mafter_private_call am) -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_state_base (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m).","proofString":"eapply sound_regular_state with (bc := bc1); eauto.\napply sound_stack_exten with bc'; auto.\neapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res (Ifptr Nonstack) ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 (mafter_private_call am) -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : sound_stack bc1 s m sp0.","proofString":"apply sound_stack_exten with bc'; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res (Ifptr Nonstack) ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 (mafter_private_call am) -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : ematch bc1 rs # res <- vres ae'.","proofString":"eapply ematch_ge; eauto.\napply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res (Ifptr Nonstack) ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 (mafter_private_call am) -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : ematch bc1 rs # res <- vres (AE.set res (Ifptr Nonstack) ae).","proofString":"apply ematch_update.\nauto.\nauto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res (Ifptr Nonstack) ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 (mafter_private_call am) -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : ematch bc1 rs ae.","proofString":"auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bc : block_classification) (RES : vmatch bc vres Vtop) (RO : romatch bc m rm) (MM : mmatch bc m mtop) (GE : genv_match bc ge) (NOSTK : bc_nostack bc) (sp0 : block) (bc' : block_classification) (bound' : positive) (ae : AE.t) (am : amem) (STK0 : sound_stack bc' s m sp0) (INCR : Ple bound' (Mem.nextblock m)) (BELOW : bc_below bc' bound') (SP : bc sp0 = BCinvalid) (SP' : bc' sp0 = BCstack) (SAME : forall b : positive, Plt b bound' -> b <> sp0 -> bc b = bc' b) (GE0 : genv_match bc' ge) (ae' : aenv) (am' : amem) (EQ : (analyze rm f) # pc = VA.State ae' am') (A1 : AE.ge ae' (AE.set res (Ifptr Nonstack) ae)) (A2 : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 (mafter_private_call am) -> mmatch bc0 m0 am') (EM : ematch bc' rs ae) (CONTENTS : bmatch bc' m sp0 (am_stack am)) (bc1 : block_classification) (A : vmatch bc1 vres (Ifptr Nonstack)) (B : ematch bc1 rs ae) (C : romatch bc1 m rm) (D : mmatch bc1 m (mafter_private_call am)) (E : genv_match bc1 ge) (F : bc1 sp0 = BCstack) (G : forall b : positive, Plt b sp0 -> bc1 b = bc' b) : vmatch bc1 vres (Ifptr Nonstack).","proofString":"auto."},{"statement":"(st : state) (t : trace) (st' : state) (H : step ge st t st') (H0 : sound_state st) : sound_state st'.","proofString":"inv H0.\nconstructor; intros.\neapply sound_step_base; eauto."},{"statement":"(st : state) (t : trace) (st' : state) (H : step ge st t st') (H1 : forall cunit : program, linkorder cunit prog -> sound_state_base cunit ge st) : sound_state st'.","proofString":"constructor; intros.\neapply sound_step_base; eauto."},{"statement":"(st : state) (t : trace) (st' : state) (H : step ge st t st') (H1 : forall cunit0 : program,\nlinkorder cunit0 prog -> sound_state_base cunit0 ge st) (cunit : program) (H0 : linkorder cunit prog) : sound_state_base cunit ge st'.","proofString":"eapply sound_step_base; eauto."},{"statement":"(st : state) (cunit : program) (H : sound_state st) (H0 : linkorder cunit prog) : sound_state_base cunit ge st.","proofString":"inv H.\neauto."},{"statement":"(st : state) (cunit : program) (H0 : linkorder cunit prog) (H1 : forall cunit0 : program,\nlinkorder cunit0 prog -> sound_state_base cunit0 ge st) : sound_state_base cunit ge st.","proofString":"eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : exists bc : block_classification,\n  genv_match bc ge /\\\n  bc_below bc (Mem.nextblock m) /\\\n  bc_nostack bc /\\\n  (forall (b : block) (id : ident),\n   bc b = BCglob id -> Genv.find_symbol ge id = Some b) /\\\n  (forall b : block, Mem.valid_block m b -> bc b <> BCinvalid).","proofString":"set (f := fun b =>              if plt b (Genv.genv_next ge) then                match Genv.invert_symbol ge b with None => BCother | Some id => BCglob id end              else                BCinvalid).\nassert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).\nunfold f; intros.\ndestruct (plt b1 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b1) as [id1|] eqn:I1; inv H0.\ndestruct (plt b2 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b2) as [id2|] eqn:I2; inv H1.\nexploit Genv.invert_find_symbol.\neexact I1.\nexploit Genv.invert_find_symbol.\neexact I2.\ncongruence.\nassert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).\nunfold f; intros.\ndestruct (plt b1 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b1); discriminate.\nset (bc := BC f F_stack F_glob).\nunfold f in bc.\nexists bc; splitall.\nsplit; simpl; intros.\nsplit; intros.\nrewrite pred_dec_true by (eapply Genv.genv_symb_range; eauto).\nerewrite Genv.find_invert_symbol; eauto.\napply Genv.invert_find_symbol.\ndestruct (plt b (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b); congruence.\nrewrite ! pred_dec_true by assumption.\ndestruct (Genv.invert_symbol); split; congruence.\nred; simpl; intros.\ndestruct (plt b (Genv.genv_next ge)); try congruence.\nerewrite <- Genv.init_mem_genv_next by eauto.\nauto.\nred; simpl; intros.\ndestruct (plt b (Genv.genv_next ge)).\ndestruct (Genv.invert_symbol ge b); congruence.\ncongruence.\nsimpl; intros.\ndestruct (plt b (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b) as [id' | ] eqn:IS; inv H0.\napply Genv.invert_find_symbol; auto.\nintros; simpl.\nunfold ge; erewrite Genv.init_mem_genv_next by eauto.\nrewrite pred_dec_true by assumption.\ndestruct (Genv.invert_symbol (Genv.globalenv prog) b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (b1 b2 : positive) (id : ident) (H0 : (if plt b1 (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b1 with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id) (H1 : (if plt b2 (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b2 with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id) : b1 = b2.","proofString":"destruct (plt b1 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b1) as [id1|] eqn:I1; inv H0.\ndestruct (plt b2 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b2) as [id2|] eqn:I2; inv H1.\nexploit Genv.invert_find_symbol.\neexact I1.\nexploit Genv.invert_find_symbol.\neexact I2.\ncongruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (b1 b2 : positive) (id : ident) (p : Plt b1 (Genv.genv_next ge)) (H0 : match Genv.invert_symbol ge b1 with\n| Some id0 => BCglob id0\n| None => BCother\nend = BCglob id) (H1 : (if plt b2 (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b2 with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id) : b1 = b2.","proofString":"destruct (Genv.invert_symbol ge b1) as [id1|] eqn:I1; inv H0.\ndestruct (plt b2 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b2) as [id2|] eqn:I2; inv H1.\nexploit Genv.invert_find_symbol.\neexact I1.\nexploit Genv.invert_find_symbol.\neexact I2.\ncongruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (b1 b2 : positive) (id : ident) (p : Plt b1 (Genv.genv_next ge)) (I1 : Genv.invert_symbol ge b1 = Some id) (H1 : (if plt b2 (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b2 with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id) : b1 = b2.","proofString":"destruct (plt b2 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b2) as [id2|] eqn:I2; inv H1.\nexploit Genv.invert_find_symbol.\neexact I1.\nexploit Genv.invert_find_symbol.\neexact I2.\ncongruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (b1 b2 : positive) (id : ident) (p : Plt b1 (Genv.genv_next ge)) (I1 : Genv.invert_symbol ge b1 = Some id) (p0 : Plt b2 (Genv.genv_next ge)) (H1 : match Genv.invert_symbol ge b2 with\n| Some id0 => BCglob id0\n| None => BCother\nend = BCglob id) : b1 = b2.","proofString":"destruct (Genv.invert_symbol ge b2) as [id2|] eqn:I2; inv H1.\nexploit Genv.invert_find_symbol.\neexact I1.\nexploit Genv.invert_find_symbol.\neexact I2.\ncongruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (b1 b2 : positive) (id : ident) (p : Plt b1 (Genv.genv_next ge)) (I1 : Genv.invert_symbol ge b1 = Some id) (p0 : Plt b2 (Genv.genv_next ge)) (I2 : Genv.invert_symbol ge b2 = Some id) : b1 = b2.","proofString":"exploit Genv.invert_find_symbol.\neexact I1.\nexploit Genv.invert_find_symbol.\neexact I2.\ncongruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b0 b3 : positive) (id : ident),\nf b0 = BCglob id -> f b3 = BCglob id -> b0 = b3) (b1 b2 : positive) (H0 : (if plt b1 (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b1 with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) = BCstack) (H1 : (if plt b2 (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b2 with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) = BCstack) : b1 = b2.","proofString":"destruct (plt b1 (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b1); discriminate."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b0 b3 : positive) (id : ident),\nf b0 = BCglob id -> f b3 = BCglob id -> b0 = b3) (b1 b2 : positive) (p : Plt b1 (Genv.genv_next ge)) (H0 : match Genv.invert_symbol ge b1 with\n| Some id => BCglob id\n| None => BCother\nend = BCstack) (H1 : (if plt b2 (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b2 with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) = BCstack) : b1 = b2.","proofString":"destruct (Genv.invert_symbol ge b1); discriminate."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (id : ident) (b : block) : Genv.find_symbol ge id = Some b <->\n(if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id.","proofString":"split; intros.\nrewrite pred_dec_true by (eapply Genv.genv_symb_range; eauto).\nerewrite Genv.find_invert_symbol; eauto.\napply Genv.invert_find_symbol.\ndestruct (plt b (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (id : ident) (b : block) (H0 : Genv.find_symbol ge id = Some b) : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id.","proofString":"rewrite pred_dec_true by (eapply Genv.genv_symb_range; eauto).\nerewrite Genv.find_invert_symbol; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (id : ident) (b : block) (H0 : Genv.find_symbol ge id = Some b) : match Genv.invert_symbol ge b with\n| Some id0 => BCglob id0\n| None => BCother\nend = BCglob id.","proofString":"erewrite Genv.find_invert_symbol; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (id : ident) (b : block) (H0 : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id) : Genv.find_symbol ge id = Some b.","proofString":"apply Genv.invert_find_symbol.\ndestruct (plt b (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (id : ident) (b : block) (H0 : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id) : Genv.invert_symbol ge b = Some id.","proofString":"destruct (plt b (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (id : ident) (b : block) (p : Plt b (Genv.genv_next ge)) (H0 : match Genv.invert_symbol ge b with\n| Some id0 => BCglob id0\n| None => BCother\nend = BCglob id) : Genv.invert_symbol ge b = Some id.","proofString":"destruct (Genv.invert_symbol ge b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : positive) (H0 : Plt b (Genv.genv_next ge)) : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) <> BCinvalid /\\\n(if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) <> BCstack.","proofString":"rewrite ! pred_dec_true by assumption.\ndestruct (Genv.invert_symbol); split; congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : positive) (H0 : Plt b (Genv.genv_next ge)) : match Genv.invert_symbol ge b with\n| Some id => BCglob id\n| None => BCother\nend <> BCinvalid /\\\nmatch Genv.invert_symbol ge b with\n| Some id => BCglob id\n| None => BCother\nend <> BCstack.","proofString":"destruct (Genv.invert_symbol); split; congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (H0 : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"destruct (plt b (Genv.genv_next ge)); try congruence.\nerewrite <- Genv.init_mem_genv_next by eauto.\nauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (p : Plt b (Genv.genv_next ge)) (H0 : match Genv.invert_symbol ge b with\n| Some id => BCglob id\n| None => BCother\nend <> BCinvalid) : Plt b (Mem.nextblock m).","proofString":"erewrite <- Genv.init_mem_genv_next by eauto.\nauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (p : Plt b (Genv.genv_next ge)) (H0 : match Genv.invert_symbol ge b with\n| Some id => BCglob id\n| None => BCother\nend <> BCinvalid) : Plt b (Genv.genv_next (Genv.globalenv prog)).","proofString":"auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) <> BCstack.","proofString":"destruct (plt b (Genv.genv_next ge)).\ndestruct (Genv.invert_symbol ge b); congruence.\ncongruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (p : Plt b (Genv.genv_next ge)) : match Genv.invert_symbol ge b with\n| Some id => BCglob id\n| None => BCother\nend <> BCstack.","proofString":"destruct (Genv.invert_symbol ge b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (n : ~ Plt b (Genv.genv_next ge)) : BCinvalid <> BCstack.","proofString":"congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (id : ident) (H0 : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id0 => BCglob id0\n  | None => BCother\n  end\n else BCinvalid) = BCglob id) : Genv.find_symbol ge id = Some b.","proofString":"destruct (plt b (Genv.genv_next ge)); try discriminate.\ndestruct (Genv.invert_symbol ge b) as [id' | ] eqn:IS; inv H0.\napply Genv.invert_find_symbol; auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (id : ident) (p : Plt b (Genv.genv_next ge)) (H0 : match Genv.invert_symbol ge b with\n| Some id0 => BCglob id0\n| None => BCother\nend = BCglob id) : Genv.find_symbol ge id = Some b.","proofString":"destruct (Genv.invert_symbol ge b) as [id' | ] eqn:IS; inv H0.\napply Genv.invert_find_symbol; auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id0 : ident),\nf b1 = BCglob id0 -> f b2 = BCglob id0 -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (id : ident) (p : Plt b (Genv.genv_next ge)) (IS : Genv.invert_symbol ge b = Some id) : Genv.find_symbol ge id = Some b.","proofString":"apply Genv.invert_find_symbol; auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (H0 : Mem.valid_block m b) : (if plt b (Genv.genv_next ge)\n then\n  match Genv.invert_symbol ge b with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) <> BCinvalid.","proofString":"unfold ge; erewrite Genv.init_mem_genv_next by eauto.\nrewrite pred_dec_true by assumption.\ndestruct (Genv.invert_symbol (Genv.globalenv prog) b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (H0 : Mem.valid_block m b) : (if plt b (Mem.nextblock m)\n then\n  match Genv.invert_symbol (Genv.globalenv prog) b with\n  | Some id => BCglob id\n  | None => BCother\n  end\n else BCinvalid) <> BCinvalid.","proofString":"rewrite pred_dec_true by assumption.\ndestruct (Genv.invert_symbol (Genv.globalenv prog) b); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (f : positive -> block_class) (F_glob : forall (b1 b2 : positive) (id : ident),\nf b1 = BCglob id -> f b2 = BCglob id -> b1 = b2) (F_stack : forall b1 b2 : positive, f b1 = BCstack -> f b2 = BCstack -> b1 = b2) (bc : block_classification) (b : block) (H0 : Mem.valid_block m b) : match Genv.invert_symbol (Genv.globalenv prog) b with\n| Some id => BCglob id\n| None => BCother\nend <> BCinvalid.","proofString":"destruct (Genv.invert_symbol (Genv.globalenv prog) b); congruence."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) : pge Glob (ab_summary (store_init_data ab p id)).","proofString":"assert (DFL: forall chunk av,               vge (Ifptr Glob) av ->               pge Glob (ab_summary (ablock_store chunk ab p av))).\nintros.\nsimpl.\nunfold vplub; destruct av; auto.\ninv H0.\napply plub_least; auto.\ninv H0.\napply plub_least; auto.\ndestruct id; auto.\nsimpl.\ndestruct (propagate_float_constants tt); auto.\nsimpl.\ndestruct (propagate_float_constants tt); auto.\napply DFL.\nconstructor.\nconstructor."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av)).","proofString":"intros.\nsimpl.\nunfold vplub; destruct av; auto.\ninv H0.\napply plub_least; auto.\ninv H0.\napply plub_least; auto."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) (chunk : memory_chunk) (av : aval) (H0 : vge (Ifptr Glob) av) : pge Glob (ab_summary (ablock_store chunk ab p av)).","proofString":"simpl.\nunfold vplub; destruct av; auto.\ninv H0.\napply plub_least; auto.\ninv H0.\napply plub_least; auto."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) (chunk : memory_chunk) (av : aval) (H0 : vge (Ifptr Glob) av) : pge Glob (vplub av (ab_summary ab)).","proofString":"unfold vplub; destruct av; auto.\ninv H0.\napply plub_least; auto.\ninv H0.\napply plub_least; auto."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) (chunk : memory_chunk) (p0 : aptr) (H0 : vge (Ifptr Glob) (Ptr p0)) : pge Glob (plub p0 (ab_summary ab)).","proofString":"inv H0.\napply plub_least; auto."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) (chunk : memory_chunk) (p0 : aptr) (H3 : pge Glob p0) : pge Glob (plub p0 (ab_summary ab)).","proofString":"apply plub_least; auto."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) (chunk : memory_chunk) (p0 : aptr) (H0 : vge (Ifptr Glob) (Ifptr p0)) : pge Glob (plub p0 (ab_summary ab)).","proofString":"inv H0.\napply plub_least; auto."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) (chunk : memory_chunk) (p0 : aptr) (H3 : pge Glob p0) : pge Glob (plub p0 (ab_summary ab)).","proofString":"apply plub_least; auto."},{"statement":"(ab : ablock) (p : Z) (id : init_data) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : pge Glob (ab_summary (store_init_data ab p id)).","proofString":"destruct id; auto.\nsimpl.\ndestruct (propagate_float_constants tt); auto.\nsimpl.\ndestruct (propagate_float_constants tt); auto.\napply DFL.\nconstructor.\nconstructor."},{"statement":"(ab : ablock) (p : Z) (f : float32) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : pge Glob (ab_summary (store_init_data ab p (Init_float32 f))).","proofString":"simpl.\ndestruct (propagate_float_constants tt); auto."},{"statement":"(ab : ablock) (p : Z) (f : float32) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : pge Glob\n  (vplub (if propagate_float_constants tt then FS f else ntop)\n     (ab_summary ab)).","proofString":"destruct (propagate_float_constants tt); auto."},{"statement":"(ab : ablock) (p : Z) (f : float) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : pge Glob (ab_summary (store_init_data ab p (Init_float64 f))).","proofString":"simpl.\ndestruct (propagate_float_constants tt); auto."},{"statement":"(ab : ablock) (p : Z) (f : float) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : pge Glob\n  (vplub (if propagate_float_constants tt then F f else ntop) (ab_summary ab)).","proofString":"destruct (propagate_float_constants tt); auto."},{"statement":"(ab : ablock) (p : Z) (i : ident) (i0 : ptrofs) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : pge Glob (ab_summary (store_init_data ab p (Init_addrof i i0))).","proofString":"apply DFL.\nconstructor.\nconstructor."},{"statement":"(ab : ablock) (p : Z) (i : ident) (i0 : ptrofs) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : vge (Ifptr Glob) (Ptr (Gl i i0)).","proofString":"constructor.\nconstructor."},{"statement":"(ab : ablock) (p : Z) (i : ident) (i0 : ptrofs) (H : pge Glob (ab_summary ab)) (DFL : forall (chunk : memory_chunk) (av : aval),\nvge (Ifptr Glob) av -> pge Glob (ab_summary (ablock_store chunk ab p av))) : pge Glob (Gl i i0).","proofString":"constructor."},{"statement":"(ab : ablock) (p : Z) (H : pge Glob (ab_summary ab)) : pge Glob (ab_summary ab).","proofString":"auto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (ab0 : ablock) (p0 : Z),\npge Glob (ab_summary ab0) ->\npge Glob (ab_summary (store_init_data_list ab0 p0 idl))) (ab : ablock) (p : Z) (H : pge Glob (ab_summary ab)) : pge Glob\n  (ab_summary\n     (store_init_data_list (store_init_data ab p a) \n        (p + init_data_size a) idl)).","proofString":"apply IHidl.\napply store_init_data_summary; auto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (ab0 : ablock) (p0 : Z),\npge Glob (ab_summary ab0) ->\npge Glob (ab_summary (store_init_data_list ab0 p0 idl))) (ab : ablock) (p : Z) (H : pge Glob (ab_summary ab)) : pge Glob (ab_summary (store_init_data ab p a)).","proofString":"apply store_init_data_summary; auto."},{"statement":"(m : mem) (b : block) (p : Z) (id : init_data) (m' : mem) (ab : ablock) (H : Genv.store_init_data ge m b p id = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p id).","proofString":"destruct id; try (eapply ablock_store_sound; eauto; constructor).\nsimpl.\ndestruct (propagate_float_constants tt); eapply ablock_store_sound; eauto; constructor.\nsimpl.\ndestruct (propagate_float_constants tt); eapply ablock_store_sound; eauto; constructor.\nsimpl in H.\ninv H.\nauto.\nsimpl in H.\ndestruct (Genv.find_symbol ge i) as [b'|] eqn:FS; try discriminate.\neapply ablock_store_sound; eauto.\nconstructor.\nconstructor.\napply GMATCH; auto."},{"statement":"(m : mem) (b : block) (p : Z) (f : float32) (m' : mem) (ab : ablock) (H : Genv.store_init_data ge m b p (Init_float32 f) = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p (Init_float32 f)).","proofString":"simpl.\ndestruct (propagate_float_constants tt); eapply ablock_store_sound; eauto; constructor."},{"statement":"(m : mem) (b : block) (p : Z) (f : float32) (m' : mem) (ab : ablock) (H : Genv.store_init_data ge m b p (Init_float32 f) = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b\n  (ablock_store Mfloat32 ab p\n     (if propagate_float_constants tt then FS f else ntop)).","proofString":"destruct (propagate_float_constants tt); eapply ablock_store_sound; eauto; constructor."},{"statement":"(m : mem) (b : block) (p : Z) (f : float) (m' : mem) (ab : ablock) (H : Genv.store_init_data ge m b p (Init_float64 f) = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p (Init_float64 f)).","proofString":"simpl.\ndestruct (propagate_float_constants tt); eapply ablock_store_sound; eauto; constructor."},{"statement":"(m : mem) (b : block) (p : Z) (f : float) (m' : mem) (ab : ablock) (H : Genv.store_init_data ge m b p (Init_float64 f) = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b\n  (ablock_store Mfloat64 ab p\n     (if propagate_float_constants tt then F f else ntop)).","proofString":"destruct (propagate_float_constants tt); eapply ablock_store_sound; eauto; constructor."},{"statement":"(m : mem) (b : block) (p z : Z) (m' : mem) (ab : ablock) (H : Genv.store_init_data ge m b p (Init_space z) = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p (Init_space z)).","proofString":"simpl in H.\ninv H.\nauto."},{"statement":"(m : mem) (b : block) (p z : Z) (m' : mem) (ab : ablock) (H : Some m = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p (Init_space z)).","proofString":"inv H.\nauto."},{"statement":"(b : block) (p z : Z) (m' : mem) (ab : ablock) (H0 : bmatch bc m' b ab) : bmatch bc m' b (store_init_data ab p (Init_space z)).","proofString":"auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (H : Genv.store_init_data ge m b p (Init_addrof i i0) = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p (Init_addrof i i0)).","proofString":"simpl in H.\ndestruct (Genv.find_symbol ge i) as [b'|] eqn:FS; try discriminate.\neapply ablock_store_sound; eauto.\nconstructor.\nconstructor.\napply GMATCH; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (H : match Genv.find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p (Init_addrof i i0)).","proofString":"destruct (Genv.find_symbol ge i) as [b'|] eqn:FS; try discriminate.\neapply ablock_store_sound; eauto.\nconstructor.\nconstructor.\napply GMATCH; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (b' : block) (FS : Genv.find_symbol ge i = Some b') (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b (store_init_data ab p (Init_addrof i i0)).","proofString":"eapply ablock_store_sound; eauto.\nconstructor.\nconstructor.\napply GMATCH; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (b' : block) (FS : Genv.find_symbol ge i = Some b') (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : bmatch bc m b ab) : vmatch bc (Vptr b' i0) (Ptr (Gl i i0)).","proofString":"constructor.\nconstructor.\napply GMATCH; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (b' : block) (FS : Genv.find_symbol ge i = Some b') (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : bmatch bc m b ab) : pmatch bc b' i0 (Gl i i0).","proofString":"constructor.\napply GMATCH; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (b' : block) (FS : Genv.find_symbol ge i = Some b') (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : bmatch bc m b ab) : bc b' = BCglob i.","proofString":"apply GMATCH; auto."},{"statement":"(m : mem) (b : block) (p : Z) (m' : mem) (ab : ablock) (H : Some m = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b ab.","proofString":"inv H; auto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (p0 : Z) (m'0 : mem) (ab0 : ablock),\nGenv.store_init_data_list ge m0 b0 p0 idl = Some m'0 ->\nbmatch bc m0 b0 ab0 -> bmatch bc m'0 b0 (store_init_data_list ab0 p0 idl)) (m : mem) (b : block) (p : Z) (m' : mem) (ab : ablock) (H : match Genv.store_init_data ge m b p a with\n| Some m'0 => Genv.store_init_data_list ge m'0 b (p + init_data_size a) idl\n| None => None\nend = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b\n  (store_init_data_list (store_init_data ab p a) (p + init_data_size a) idl).","proofString":"destruct (Genv.store_init_data ge m b p a) as [m1|] eqn:SI; try discriminate.\neapply IHidl; eauto.\neapply store_init_data_sound; eauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (p0 : Z) (m'0 : mem) (ab0 : ablock),\nGenv.store_init_data_list ge m0 b0 p0 idl = Some m'0 ->\nbmatch bc m0 b0 ab0 -> bmatch bc m'0 b0 (store_init_data_list ab0 p0 idl)) (m : mem) (b : block) (p : Z) (m' : mem) (ab : ablock) (m1 : mem) (SI : Genv.store_init_data ge m b p a = Some m1) (H : Genv.store_init_data_list ge m1 b (p + init_data_size a) idl = Some m') (H0 : bmatch bc m b ab) : bmatch bc m' b\n  (store_init_data_list (store_init_data ab p a) (p + init_data_size a) idl).","proofString":"eapply IHidl; eauto.\neapply store_init_data_sound; eauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (p0 : Z) (m'0 : mem) (ab0 : ablock),\nGenv.store_init_data_list ge m0 b0 p0 idl = Some m'0 ->\nbmatch bc m0 b0 ab0 -> bmatch bc m'0 b0 (store_init_data_list ab0 p0 idl)) (m : mem) (b : block) (p : Z) (m' : mem) (ab : ablock) (m1 : mem) (SI : Genv.store_init_data ge m b p a = Some m1) (H : Genv.store_init_data_list ge m1 b (p + init_data_size a) idl = Some m') (H0 : bmatch bc m b ab) : bmatch bc m1 b (store_init_data ab p a).","proofString":"eapply store_init_data_sound; eauto."},{"statement":"(m : mem) (b : block) (p : Z) (id : init_data) (m' : mem) (ab : ablock) (b' : block) (H : Genv.store_init_data ge m b p id = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m' b' ab.","proofString":"eapply bmatch_inv; eauto.\nintros.\ndestruct id; try (eapply Mem.loadbytes_store_other; eauto; fail); simpl in H.\ninv H; auto.\ndestruct (Genv.find_symbol ge i); try discriminate.\neapply Mem.loadbytes_store_other; eauto."},{"statement":"(m : mem) (b : block) (p : Z) (id : init_data) (m' : mem) (ab : ablock) (b' : block) (H : Genv.store_init_data ge m b p id = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b' ofs n = Mem.loadbytes m b' ofs n.","proofString":"intros.\ndestruct id; try (eapply Mem.loadbytes_store_other; eauto; fail); simpl in H.\ninv H; auto.\ndestruct (Genv.find_symbol ge i); try discriminate.\neapply Mem.loadbytes_store_other; eauto."},{"statement":"(m : mem) (b : block) (p : Z) (id : init_data) (m' : mem) (ab : ablock) (b' : block) (H : Genv.store_init_data ge m b p id = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) (ofs n : Z) (H2 : n >= 0) : Mem.loadbytes m' b' ofs n = Mem.loadbytes m b' ofs n.","proofString":"destruct id; try (eapply Mem.loadbytes_store_other; eauto; fail); simpl in H.\ninv H; auto.\ndestruct (Genv.find_symbol ge i); try discriminate.\neapply Mem.loadbytes_store_other; eauto."},{"statement":"(m : mem) (b : block) (p z : Z) (m' : mem) (ab : ablock) (b' : block) (H : Some m = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) (ofs n : Z) (H2 : n >= 0) : Mem.loadbytes m' b' ofs n = Mem.loadbytes m b' ofs n.","proofString":"inv H; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (b' : block) (H : match Genv.find_symbol ge i with\n| Some b'0 => Mem.store Mptr m b p (Vptr b'0 i0)\n| None => None\nend = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) (ofs n : Z) (H2 : n >= 0) : Mem.loadbytes m' b' ofs n = Mem.loadbytes m b' ofs n.","proofString":"destruct (Genv.find_symbol ge i); try discriminate.\neapply Mem.loadbytes_store_other; eauto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (ab : ablock) (b' b0 : block) (H : Mem.store Mptr m b p (Vptr b0 i0) = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) (ofs n : Z) (H2 : n >= 0) : Mem.loadbytes m' b' ofs n = Mem.loadbytes m b' ofs n.","proofString":"eapply Mem.loadbytes_store_other; eauto."},{"statement":"(b b' : block) (ab : ablock) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m' b' ab.","proofString":"inv H; auto."},{"statement":"(b b' : block) (ab : ablock) (a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nGenv.store_init_data_list ge m0 b p0 idl = Some m'0 ->\nb' <> b -> bmatch bc m0 b' ab -> bmatch bc m'0 b' ab) (m : mem) (p : Z) (m' : mem) (H : match Genv.store_init_data ge m b p a with\n| Some m'0 => Genv.store_init_data_list ge m'0 b (p + init_data_size a) idl\n| None => None\nend = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m' b' ab.","proofString":"destruct (Genv.store_init_data ge m b p a) as [m1|] eqn:SI; try discriminate.\neapply IHidl; eauto.\neapply store_init_data_other; eauto."},{"statement":"(b b' : block) (ab : ablock) (a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nGenv.store_init_data_list ge m0 b p0 idl = Some m'0 ->\nb' <> b -> bmatch bc m0 b' ab -> bmatch bc m'0 b' ab) (m : mem) (p : Z) (m' m1 : mem) (SI : Genv.store_init_data ge m b p a = Some m1) (H : Genv.store_init_data_list ge m1 b (p + init_data_size a) idl = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m' b' ab.","proofString":"eapply IHidl; eauto.\neapply store_init_data_other; eauto."},{"statement":"(b b' : block) (ab : ablock) (a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nGenv.store_init_data_list ge m0 b p0 idl = Some m'0 ->\nb' <> b -> bmatch bc m0 b' ab -> bmatch bc m'0 b' ab) (m : mem) (p : Z) (m' m1 : mem) (SI : Genv.store_init_data ge m b p a = Some m1) (H : Genv.store_init_data_list ge m1 b (p + init_data_size a) idl = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m1 b' ab.","proofString":"eapply store_init_data_other; eauto."},{"statement":"(p : aptr) (m : mem) (b : block) (pos n : Z) : forall m' : mem,\nstore_zeros m b pos n = Some m' -> smatch bc m b p -> smatch bc m' b p.","proofString":"functional induction (store_zeros m b pos n); intros.\ninv H.\nauto.\neapply IHo; eauto.\nchange p with (vplub (I Int.zero) p).\neapply smatch_store; eauto.\nconstructor.\ndiscriminate."},{"statement":"(p : aptr) (m : mem) (b : block) (p0 n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (H0 : smatch bc m b p) : smatch bc m' b p.","proofString":"inv H.\nauto."},{"statement":"(p : aptr) (b : block) (p0 n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H0 : smatch bc m' b p) : smatch bc m' b p.","proofString":"auto."},{"statement":"(p : aptr) (m : mem) (b : block) (p0 n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p0 Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p0 + 1) (n - 1) = Some m'1 ->\nsmatch bc m' b p -> smatch bc m'1 b p) (m'0 : mem) (H : store_zeros m' b (p0 + 1) (n - 1) = Some m'0) (H0 : smatch bc m b p) : smatch bc m'0 b p.","proofString":"eapply IHo; eauto.\nchange p with (vplub (I Int.zero) p).\neapply smatch_store; eauto.\nconstructor."},{"statement":"(p : aptr) (m : mem) (b : block) (p0 n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p0 Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p0 + 1) (n - 1) = Some m'1 ->\nsmatch bc m' b p -> smatch bc m'1 b p) (m'0 : mem) (H : store_zeros m' b (p0 + 1) (n - 1) = Some m'0) (H0 : smatch bc m b p) : smatch bc m' b p.","proofString":"change p with (vplub (I Int.zero) p).\neapply smatch_store; eauto.\nconstructor."},{"statement":"(p : aptr) (m : mem) (b : block) (p0 n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p0 Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p0 + 1) (n - 1) = Some m'1 ->\nsmatch bc m' b p -> smatch bc m'1 b p) (m'0 : mem) (H : store_zeros m' b (p0 + 1) (n - 1) = Some m'0) (H0 : smatch bc m b p) : smatch bc m' b (vplub (I Int.zero) p).","proofString":"eapply smatch_store; eauto.\nconstructor."},{"statement":"(p : aptr) (m : mem) (b : block) (p0 n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p0 Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p0 + 1) (n - 1) = Some m'1 ->\nsmatch bc m' b p -> smatch bc m'1 b p) (m'0 : mem) (H : store_zeros m' b (p0 + 1) (n - 1) = Some m'0) (H0 : smatch bc m b p) : vmatch bc Vzero (I Int.zero).","proofString":"constructor."},{"statement":"(p : aptr) (m : mem) (b : block) (p0 n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p0 Vzero = None) (m' : mem) (H : None = Some m') (H0 : smatch bc m b p) : smatch bc m' b p.","proofString":"discriminate."},{"statement":"(b' : block) (ab : ablock) (m : mem) (b : block) (p n : Z) : forall m' : mem,\nstore_zeros m b p n = Some m' ->\nb' <> b -> bmatch bc m b' ab -> bmatch bc m' b' ab.","proofString":"functional induction (store_zeros m b p n); intros.\ninv H.\nauto.\neapply IHo; eauto.\neapply bmatch_inv; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\ndiscriminate."},{"statement":"(b' : block) (ab : ablock) (m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m' b' ab.","proofString":"inv H.\nauto."},{"statement":"(b' : block) (ab : ablock) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H0 : b' <> b) (H1 : bmatch bc m' b' ab) : bmatch bc m' b' ab.","proofString":"auto."},{"statement":"(b' : block) (ab : ablock) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nb' <> b -> bmatch bc m' b' ab -> bmatch bc m'1 b' ab) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m'0 b' ab.","proofString":"eapply IHo; eauto.\neapply bmatch_inv; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto."},{"statement":"(b' : block) (ab : ablock) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nb' <> b -> bmatch bc m' b' ab -> bmatch bc m'1 b' ab) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m' b' ab.","proofString":"eapply bmatch_inv; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto."},{"statement":"(b' : block) (ab : ablock) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nb' <> b -> bmatch bc m' b' ab -> bmatch bc m'1 b' ab) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : b' <> b) (H1 : bmatch bc m b' ab) : forall ofs n0 : Z,\nn0 >= 0 -> Mem.loadbytes m' b' ofs n0 = Mem.loadbytes m b' ofs n0.","proofString":"intros.\neapply Mem.loadbytes_store_other; eauto."},{"statement":"(b' : block) (ab : ablock) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nb' <> b -> bmatch bc m' b' ab -> bmatch bc m'1 b' ab) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : b' <> b) (H1 : bmatch bc m b' ab) (ofs n0 : Z) (H2 : n0 >= 0) : Mem.loadbytes m' b' ofs n0 = Mem.loadbytes m b' ofs n0.","proofString":"eapply Mem.loadbytes_store_other; eauto."},{"statement":"(b' : block) (ab : ablock) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (m' : mem) (H : None = Some m') (H0 : b' <> b) (H1 : bmatch bc m b' ab) : bmatch bc m' b' ab.","proofString":"discriminate."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (idg : ident * globdef fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (H1 : Genv.alloc_global ge m idg = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g idg) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g idg) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"destruct idg as [id1 [fd | gv]]; simpl in *.\ndestruct (Mem.alloc m 0 1) as [m1 b1] eqn:ALLOC.\nunfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninv H2.\nrewrite PTree.gss in H3.\ndiscriminate.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nset (sz := init_data_list_size (gvar_init gv)) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b1] eqn:ALLOC.\ndestruct (store_zeros m1 b1 0 sz) as [m2 | ] eqn:STZ; try discriminate.\ndestruct (Genv.store_init_data_list ge m2 b1 0 (gvar_init gv)) as [m3 | ] eqn:SIDL; try discriminate.\nunfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (H1 : (let (m1, b0) := Mem.alloc m 0 1 in Mem.drop_perm m1 b0 0 1 Nonempty) =\nSome m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g (id1, Gfun fd)) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gfun fd)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"destruct (Mem.alloc m 0 1) as [m1 b1] eqn:ALLOC.\nunfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninv H2.\nrewrite PTree.gss in H3.\ndiscriminate.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g (id1, Gfun fd)) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gfun fd)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"unfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninv H2.\nrewrite PTree.gss in H3.\ndiscriminate.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : (PTree.set id1 (Genv.genv_next g) (Genv.genv_symb g)) ! id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gfun fd)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"unfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninv H2.\nrewrite PTree.gss in H3.\ndiscriminate.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : (PTree.set id1 (Genv.genv_next g) (Genv.genv_symb g)) ! id = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gfun fd) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninv H2.\nrewrite PTree.gss in H3.\ndiscriminate.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : (if peq id id1 then Some (Genv.genv_next g) else (Genv.genv_symb g) ! id) =\nSome b) (H3 : match (PTree.set (Genv.genv_next g) (Gfun fd) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"destruct (peq id id1).\ninv H2.\nrewrite PTree.gss in H3.\ndiscriminate.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (e : id = id1) (H2 : Some (Genv.genv_next g) = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gfun fd) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"inv H2.\nrewrite PTree.gss in H3.\ndiscriminate."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (v : globvar unit) (H3 : match\n  (PTree.set (Genv.genv_next g) (Gfun fd) (Genv.genv_defs g))\n  ! (Genv.genv_next g)\nwith\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' (Genv.genv_next g)\n  (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"rewrite PTree.gss in H3.\ndiscriminate."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (v : globvar unit) (H3 : None = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' (Genv.genv_next g)\n  (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"discriminate."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gfun fd) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"assert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gfun fd) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"rewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"assert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"assert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"apply bmatch_inv with m.\neapply H0; eauto.\nintros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : bmatch bc m b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"eapply H0; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : forall ofs n0 : Z,\nn0 >= 0 -> Mem.loadbytes m' b ofs n0 = Mem.loadbytes m b ofs n0.","proofString":"intros.\ntransitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) (ofs n0 : Z) (H9 : n0 >= 0) : Mem.loadbytes m' b ofs n0 = Mem.loadbytes m b ofs n0.","proofString":"transitivity (Mem.loadbytes m1 b ofs n0).\neapply Mem.loadbytes_drop; eauto.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) (ofs n0 : Z) (H9 : n0 >= 0) : Mem.loadbytes m' b ofs n0 = Mem.loadbytes m1 b ofs n0.","proofString":"eapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (fd : fundef) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 1 = (m1, b1)) (H1 : Mem.drop_perm m1 b1 0 1 Nonempty = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) (ofs n0 : Z) (H9 : n0 >= 0) : Mem.loadbytes m1 b ofs n0 = Mem.loadbytes m b ofs n0.","proofString":"eapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (H1 : (let (m1, b0) := Mem.alloc m 0 (init_data_list_size (gvar_init gv)) in\n match store_zeros m1 b0 0 (init_data_list_size (gvar_init gv)) with\n | Some m2 =>\n     match Genv.store_init_data_list ge m2 b0 0 (gvar_init gv) with\n     | Some m3 =>\n         Mem.drop_perm m3 b0 0 (init_data_list_size (gvar_init gv))\n           (Genv.perm_globvar gv)\n     | None => None\n     end\n | None => None\n end) = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g (id1, Gvar gv)) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gvar gv)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"set (sz := init_data_list_size (gvar_init gv)) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b1] eqn:ALLOC.\ndestruct (store_zeros m1 b1 0 sz) as [m2 | ] eqn:STZ; try discriminate.\ndestruct (Genv.store_init_data_list ge m2 b1 0 (gvar_init gv)) as [m3 | ] eqn:SIDL; try discriminate.\nunfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (H1 : (let (m1, b0) := Mem.alloc m 0 sz in\n match store_zeros m1 b0 0 sz with\n | Some m2 =>\n     match Genv.store_init_data_list ge m2 b0 0 (gvar_init gv) with\n     | Some m3 => Mem.drop_perm m3 b0 0 sz (Genv.perm_globvar gv)\n     | None => None\n     end\n | None => None\n end) = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g (id1, Gvar gv)) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gvar gv)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"destruct (Mem.alloc m 0 sz) as [m1 b1] eqn:ALLOC.\ndestruct (store_zeros m1 b1 0 sz) as [m2 | ] eqn:STZ; try discriminate.\ndestruct (Genv.store_init_data_list ge m2 b1 0 (gvar_init gv)) as [m3 | ] eqn:SIDL; try discriminate.\nunfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (H1 : match store_zeros m1 b1 0 sz with\n| Some m2 =>\n    match Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) with\n    | Some m3 => Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv)\n    | None => None\n    end\n| None => None\nend = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g (id1, Gvar gv)) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gvar gv)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"destruct (store_zeros m1 b1 0 sz) as [m2 | ] eqn:STZ; try discriminate.\ndestruct (Genv.store_init_data_list ge m2 b1 0 (gvar_init gv)) as [m3 | ] eqn:SIDL; try discriminate.\nunfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (H1 : match Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) with\n| Some m3 => Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv)\n| None => None\nend = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g (id1, Gvar gv)) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gvar gv)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"destruct (Genv.store_init_data_list ge m2 b1 0 (gvar_init gv)) as [m3 | ] eqn:SIDL; try discriminate.\nunfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : Genv.find_symbol (Genv.add_global g (id1, Gvar gv)) id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gvar gv)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"unfold Genv.find_symbol in H2; simpl in H2.\nunfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : (PTree.set id1 (Genv.genv_next g) (Genv.genv_symb g)) ! id = Some b) (H3 : Genv.find_var_info (Genv.add_global g (id1, Gvar gv)) b = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"unfold Genv.find_var_info, Genv.find_def in H3; simpl in H3.\nrewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : (PTree.set id1 (Genv.genv_next g) (Genv.genv_symb g)) ! id = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gvar gv) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (H2 : (if peq id id1 then Some (Genv.genv_next g) else (Genv.genv_symb g) ! id) =\nSome b) (H3 : match (PTree.set (Genv.genv_next g) (Gvar gv) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"destruct (peq id id1).\ninjection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor.\nassert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (e : id = id1) (H2 : Some (Genv.genv_next g) = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gvar gv) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"injection H2; clear H2; intro EQ.\nrewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (e : id = id1) (H3 : match (PTree.set (Genv.genv_next g) (Gvar gv) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (EQ : Genv.genv_next g = b) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"rewrite EQ, PTree.gss in H3.\ninjection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (e : id = id1) (H3 : Some gv = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (EQ : Genv.genv_next g = b) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"injection H3; clear H3; intros EQ'; subst v.\nassert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (EQ : Genv.genv_next g = b) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init gv)).","proofString":"assert (b = b1).\nerewrite Mem.alloc_result by eauto.\ncongruence.\nclear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (EQ : Genv.genv_next g = b) : b = b1.","proofString":"erewrite Mem.alloc_result by eauto.\ncongruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (EQ : Genv.genv_next g = b) : b = Mem.nextblock m.","proofString":"congruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (EQ : Genv.genv_next g = b) (H2 : b = b1) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init gv)).","proofString":"clear EQ.\nsubst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (H2 : b = b1) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init gv)).","proofString":"subst b.\napply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) : bmatch bc m' b1 (store_init_data_list (ablock_init Pbot) 0 (gvar_init gv)).","proofString":"apply bmatch_inv with m3.\neapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence.\nintros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) : bmatch bc m3 b1 (store_init_data_list (ablock_init Pbot) 0 (gvar_init gv)).","proofString":"eapply store_init_data_list_sound; eauto.\napply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) : bmatch bc m2 b1 (ablock_init Pbot).","proofString":"apply ablock_init_sound.\neapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) : smatch bc m2 b1 Pbot.","proofString":"eapply store_zeros_same; eauto.\nsplit; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) : smatch bc m1 b1 Pbot.","proofString":"split; intros.\nexploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor.\nexploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (chunk : memory_chunk) (ofs : Z) (v : val) (H2 : Mem.load chunk m1 b1 ofs = Some v) : vmatch bc v (Ifptr Pbot).","proofString":"exploit Mem.load_alloc_same; eauto.\nintros EQ; subst v; constructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (chunk : memory_chunk) (ofs : Z) (v : val) (H2 : Mem.load chunk m1 b1 ofs = Some v) : v = Vundef -> vmatch bc v (Ifptr Pbot).","proofString":"intros EQ; subst v; constructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H2 : Mem.loadbytes m1 b1 ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc b' ofs' Pbot.","proofString":"exploit Mem.loadbytes_alloc_same; eauto with coqlib.\ncongruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H2 : Mem.loadbytes m1 b1 ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : Fragment (Vptr b' ofs') q i = Undef -> pmatch bc b' ofs' Pbot.","proofString":"congruence."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b1 ofs n = Mem.loadbytes m3 b1 ofs n.","proofString":"intros.\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (ofs n : Z) (H2 : n >= 0) : Mem.loadbytes m' b1 ofs n = Mem.loadbytes m3 b1 ofs n.","proofString":"eapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (ofs n : Z) (H2 : n >= 0) : b1 <> b1 \\/\nofs + n <= 0 \\/ sz <= ofs \\/ perm_order (Genv.perm_globvar gv) Readable.","proofString":"right; right; right.\nunfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (ofs n : Z) (H2 : n >= 0) : perm_order (Genv.perm_globvar gv) Readable.","proofString":"unfold Genv.perm_globvar.\nrewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (ofs n : Z) (H2 : n >= 0) : perm_order\n  (if gvar_volatile gv\n   then Nonempty\n   else if gvar_readonly gv then Readable else Writable) Readable.","proofString":"rewrite H4, H5.\nconstructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (e : id = id1) (H5 : gvar_readonly gv = true) (H4 : gvar_volatile gv = false) (ofs n : Z) (H2 : n >= 0) : perm_order Readable Readable.","proofString":"constructor."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gvar gv) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"assert (Plt b (Genv.genv_next g)) by (eapply Genv.genv_symb_range; eauto).\nrewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (PTree.set (Genv.genv_next g) (Gvar gv) (Genv.genv_defs g)) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"rewrite PTree.gso in H3 by (apply Plt_ne; auto).\nassert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"assert (Mem.valid_block m b) by (red; rewrite <- H; auto).\nassert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"assert (b <> b1) by (apply Mem.valid_not_valid_diff with m; eauto with mem).\napply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : bmatch bc m' b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"apply bmatch_inv with m3.\neapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto.\nintros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : bmatch bc m3 b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"eapply store_init_data_list_other; eauto.\neapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : bmatch bc m2 b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"eapply store_zeros_other; eauto.\napply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : bmatch bc m1 b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"apply bmatch_inv with m.\neapply H0; eauto.\nintros.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : bmatch bc m b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"eapply H0; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : forall ofs n0 : Z,\nn0 >= 0 -> Mem.loadbytes m1 b ofs n0 = Mem.loadbytes m b ofs n0.","proofString":"intros.\neapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) (ofs n0 : Z) (H9 : n0 >= 0) : Mem.loadbytes m1 b ofs n0 = Mem.loadbytes m b ofs n0.","proofString":"eapply Mem.loadbytes_alloc_unchanged; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) : forall ofs n0 : Z,\nn0 >= 0 -> Mem.loadbytes m' b ofs n0 = Mem.loadbytes m3 b ofs n0.","proofString":"intros.\neapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (id1 : ident) (gv : globvar unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (sz : Z) (m1 : Mem.mem') (b1 : block) (ALLOC : Mem.alloc m 0 sz = (m1, b1)) (m2 : mem) (STZ : store_zeros m1 b1 0 sz = Some m2) (m3 : mem) (SIDL : Genv.store_init_data_list ge m2 b1 0 (gvar_init gv) = Some m3) (H1 : Mem.drop_perm m3 b1 0 sz (Genv.perm_globvar gv) = Some m') (id : ident) (b : block) (v : globvar unit) (n : id <> id1) (H2 : (Genv.genv_symb g) ! id = Some b) (H3 : match (Genv.genv_defs g) ! b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v) (H4 : gvar_volatile v = false) (H5 : gvar_readonly v = true) (H6 : Plt b (Genv.genv_next g)) (H7 : Mem.valid_block m b) (H8 : b <> b1) (ofs n0 : Z) (H9 : n0 >= 0) : Mem.loadbytes m' b ofs n0 = Mem.loadbytes m3 b ofs n0.","proofString":"eapply Mem.loadbytes_drop; eauto."},{"statement":"(m : Mem.mem') (g : Genv.t fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (H1 : Some m = Some m') : initial_mem_match bc m' g.","proofString":"inv H1; auto."},{"statement":"(a : ident * globdef fundef unit) (gl : list (ident * globdef fundef unit)) (IHgl : forall (m0 : Mem.mem') (g0 : Genv.t fundef unit) (m'0 : mem),\nGenv.genv_next g0 = Mem.nextblock m0 ->\ninitial_mem_match bc m0 g0 ->\nGenv.alloc_globals ge m0 gl = Some m'0 ->\ninitial_mem_match bc m'0 (Genv.add_globals g0 gl)) (m : Mem.mem') (g : Genv.t fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (H1 : match Genv.alloc_global ge m a with\n| Some m'0 => Genv.alloc_globals ge m'0 gl\n| None => None\nend = Some m') : initial_mem_match bc m' (Genv.add_globals (Genv.add_global g a) gl).","proofString":"destruct (Genv.alloc_global ge m a) as [m1|] eqn:AG; try discriminate.\neapply IHgl; eauto.\nerewrite Genv.alloc_global_nextblock; eauto.\nsimpl.\ncongruence.\neapply alloc_global_match; eauto."},{"statement":"(a : ident * globdef fundef unit) (gl : list (ident * globdef fundef unit)) (IHgl : forall (m0 : Mem.mem') (g0 : Genv.t fundef unit) (m'0 : mem),\nGenv.genv_next g0 = Mem.nextblock m0 ->\ninitial_mem_match bc m0 g0 ->\nGenv.alloc_globals ge m0 gl = Some m'0 ->\ninitial_mem_match bc m'0 (Genv.add_globals g0 gl)) (m : Mem.mem') (g : Genv.t fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : mem) (AG : Genv.alloc_global ge m a = Some m1) (H1 : Genv.alloc_globals ge m1 gl = Some m') : initial_mem_match bc m' (Genv.add_globals (Genv.add_global g a) gl).","proofString":"eapply IHgl; eauto.\nerewrite Genv.alloc_global_nextblock; eauto.\nsimpl.\ncongruence.\neapply alloc_global_match; eauto."},{"statement":"(a : ident * globdef fundef unit) (gl : list (ident * globdef fundef unit)) (IHgl : forall (m0 : Mem.mem') (g0 : Genv.t fundef unit) (m'0 : mem),\nGenv.genv_next g0 = Mem.nextblock m0 ->\ninitial_mem_match bc m0 g0 ->\nGenv.alloc_globals ge m0 gl = Some m'0 ->\ninitial_mem_match bc m'0 (Genv.add_globals g0 gl)) (m : Mem.mem') (g : Genv.t fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : mem) (AG : Genv.alloc_global ge m a = Some m1) (H1 : Genv.alloc_globals ge m1 gl = Some m') : Genv.genv_next (Genv.add_global g a) = Mem.nextblock m1.","proofString":"erewrite Genv.alloc_global_nextblock; eauto.\nsimpl.\ncongruence."},{"statement":"(a : ident * globdef fundef unit) (gl : list (ident * globdef fundef unit)) (IHgl : forall (m0 : Mem.mem') (g0 : Genv.t fundef unit) (m'0 : mem),\nGenv.genv_next g0 = Mem.nextblock m0 ->\ninitial_mem_match bc m0 g0 ->\nGenv.alloc_globals ge m0 gl = Some m'0 ->\ninitial_mem_match bc m'0 (Genv.add_globals g0 gl)) (m : Mem.mem') (g : Genv.t fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : mem) (AG : Genv.alloc_global ge m a = Some m1) (H1 : Genv.alloc_globals ge m1 gl = Some m') : Genv.genv_next (Genv.add_global g a) = Pos.succ (Mem.nextblock m).","proofString":"simpl.\ncongruence."},{"statement":"(a : ident * globdef fundef unit) (gl : list (ident * globdef fundef unit)) (IHgl : forall (m0 : Mem.mem') (g0 : Genv.t fundef unit) (m'0 : mem),\nGenv.genv_next g0 = Mem.nextblock m0 ->\ninitial_mem_match bc m0 g0 ->\nGenv.alloc_globals ge m0 gl = Some m'0 ->\ninitial_mem_match bc m'0 (Genv.add_globals g0 gl)) (m : Mem.mem') (g : Genv.t fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : mem) (AG : Genv.alloc_global ge m a = Some m1) (H1 : Genv.alloc_globals ge m1 gl = Some m') : Pos.succ (Genv.genv_next g) = Pos.succ (Mem.nextblock m).","proofString":"congruence."},{"statement":"(a : ident * globdef fundef unit) (gl : list (ident * globdef fundef unit)) (IHgl : forall (m0 : Mem.mem') (g0 : Genv.t fundef unit) (m'0 : mem),\nGenv.genv_next g0 = Mem.nextblock m0 ->\ninitial_mem_match bc m0 g0 ->\nGenv.alloc_globals ge m0 gl = Some m'0 ->\ninitial_mem_match bc m'0 (Genv.add_globals g0 gl)) (m : Mem.mem') (g : Genv.t fundef unit) (m' : mem) (H : Genv.genv_next g = Mem.nextblock m) (H0 : initial_mem_match bc m g) (m1 : mem) (AG : Genv.alloc_global ge m a = Some m1) (H1 : Genv.alloc_globals ge m1 gl = Some m') : initial_mem_match bc m1 (Genv.add_global g a).","proofString":"eapply alloc_global_match; eauto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (idg : positive * globdef fundef unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (H0 : (alloc_global rm idg) ! id = Some ab) : exists v : globvar unit,\n  (PTree.set (fst idg) (snd idg) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"destruct idg as [id1 [f1 | v1]]; simpl in *.\nrewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq id id1); try discriminate.\nrewrite PTree.gso by auto.\napply H; auto.\ndestruct (gvar_readonly v1 && negb (gvar_volatile v1) && definitive_initializer (gvar_init v1)) eqn:RO.\nInvBooleans.\nrewrite negb_true_iff in H4.\nrewrite PTree.gsspec in *.\ndestruct (peq id id1).\ninv H0.\nexists v1; auto.\napply H; auto.\nrewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq id id1); try discriminate.\nrewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (f1 : fundef) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (H0 : (PTree.remove id1 rm) ! id = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gfun f1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"rewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq id id1); try discriminate.\nrewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (f1 : fundef) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (H0 : (if PTree.elt_eq id id1 then None else rm ! id) = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gfun f1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"destruct (PTree.elt_eq id id1); try discriminate.\nrewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (f1 : fundef) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (n : id <> id1) (H0 : rm ! id = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gfun f1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"rewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (f1 : fundef) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (n : id <> id1) (H0 : rm ! id = Some ab) : exists v : globvar unit,\n  dm ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"apply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (H0 : (if\n  gvar_readonly v1 && negb (gvar_volatile v1) &&\n  definitive_initializer (gvar_init v1)\n then\n  PTree.set id1 (store_init_data_list (ablock_init Pbot) 0 (gvar_init v1)) rm\n else PTree.remove id1 rm) ! id = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gvar v1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"destruct (gvar_readonly v1 && negb (gvar_volatile v1) && definitive_initializer (gvar_init v1)) eqn:RO.\nInvBooleans.\nrewrite negb_true_iff in H4.\nrewrite PTree.gsspec in *.\ndestruct (peq id id1).\ninv H0.\nexists v1; auto.\napply H; auto.\nrewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq id id1); try discriminate.\nrewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (RO : gvar_readonly v1 && negb (gvar_volatile v1) &&\ndefinitive_initializer (gvar_init v1) = true) (H0 : (PTree.set id1 (store_init_data_list (ablock_init Pbot) 0 (gvar_init v1)) rm)\n! id = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gvar v1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"InvBooleans.\nrewrite negb_true_iff in H4.\nrewrite PTree.gsspec in *.\ndestruct (peq id id1).\ninv H0.\nexists v1; auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (H0 : (PTree.set id1 (store_init_data_list (ablock_init Pbot) 0 (gvar_init v1)) rm)\n! id = Some ab) (H2 : definitive_initializer (gvar_init v1) = true) (H3 : gvar_readonly v1 = true) (H4 : negb (gvar_volatile v1) = true) : exists v : globvar unit,\n  (PTree.set id1 (Gvar v1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"rewrite negb_true_iff in H4.\nrewrite PTree.gsspec in *.\ndestruct (peq id id1).\ninv H0.\nexists v1; auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (H0 : (PTree.set id1 (store_init_data_list (ablock_init Pbot) 0 (gvar_init v1)) rm)\n! id = Some ab) (H2 : definitive_initializer (gvar_init v1) = true) (H3 : gvar_readonly v1 = true) (H4 : gvar_volatile v1 = false) : exists v : globvar unit,\n  (PTree.set id1 (Gvar v1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"rewrite PTree.gsspec in *.\ndestruct (peq id id1).\ninv H0.\nexists v1; auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (H0 : (if peq id id1\n then Some (store_init_data_list (ablock_init Pbot) 0 (gvar_init v1))\n else rm ! id) = Some ab) (H2 : definitive_initializer (gvar_init v1) = true) (H3 : gvar_readonly v1 = true) (H4 : gvar_volatile v1 = false) : exists v : globvar unit,\n  (if peq id id1 then Some (Gvar v1) else dm ! id) = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"destruct (peq id id1).\ninv H0.\nexists v1; auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (n : id <> id1) (H0 : rm ! id = Some ab) (H2 : definitive_initializer (gvar_init v1) = true) (H3 : gvar_readonly v1 = true) (H4 : gvar_volatile v1 = false) : exists v : globvar unit,\n  dm ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"apply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (RO : gvar_readonly v1 && negb (gvar_volatile v1) &&\ndefinitive_initializer (gvar_init v1) = false) (H0 : (PTree.remove id1 rm) ! id = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gvar v1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"rewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq id id1); try discriminate.\nrewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (RO : gvar_readonly v1 && negb (gvar_volatile v1) &&\ndefinitive_initializer (gvar_init v1) = false) (H0 : (if PTree.elt_eq id id1 then None else rm ! id) = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gvar v1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"destruct (PTree.elt_eq id id1); try discriminate.\nrewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (RO : gvar_readonly v1 && negb (gvar_volatile v1) &&\ndefinitive_initializer (gvar_init v1) = false) (n : id <> id1) (H0 : rm ! id = Some ab) : exists v : globvar unit,\n  (PTree.set id1 (Gvar v1) dm) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"rewrite PTree.gso by auto.\napply H; auto."},{"statement":"(dm : PTree.t (globdef fundef unit)) (rm : romem) (id1 : positive) (v1 : globvar unit) (H : romem_consistent dm rm) (id : positive) (ab : ablock) (RO : gvar_readonly v1 && negb (gvar_volatile v1) &&\ndefinitive_initializer (gvar_init v1) = false) (n : id <> id1) (H0 : rm ! id = Some ab) : exists v : globvar unit,\n  dm ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"apply H; auto."},{"statement":"forall (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (rm : romem),\nromem_consistent dm rm ->\nromem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l dm) (fold_left alloc_global l rm).","proofString":"induction l; intros; simpl; auto.\napply IHl.\napply alloc_global_consistent; auto."},{"statement":"(a : positive * globdef fundef unit) (l : list (positive * globdef fundef unit)) (IHl : forall (dm0 : PTree.t (globdef fundef unit)) (rm0 : romem),\nromem_consistent dm0 rm0 ->\nromem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l dm0) (fold_left alloc_global l rm0)) (dm : PTree.t (globdef fundef unit)) (rm : romem) (H : romem_consistent dm rm) : romem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l (PTree.set (fst a) (snd a) dm))\n  (fold_left alloc_global l (alloc_global rm a)).","proofString":"apply IHl.\napply alloc_global_consistent; auto."},{"statement":"(a : positive * globdef fundef unit) (l : list (positive * globdef fundef unit)) (IHl : forall (dm0 : PTree.t (globdef fundef unit)) (rm0 : romem),\nromem_consistent dm0 rm0 ->\nromem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l dm0) (fold_left alloc_global l rm0)) (dm : PTree.t (globdef fundef unit)) (rm : romem) (H : romem_consistent dm rm) : romem_consistent (PTree.set (fst a) (snd a) dm) (alloc_global rm a).","proofString":"apply alloc_global_consistent; auto."},{"statement":"(REC : forall (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (rm : romem),\nromem_consistent dm rm ->\nromem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l dm) (fold_left alloc_global l rm)) : forall cunit : AST.program fundef unit,\nromem_consistent (prog_defmap cunit) (romem_for cunit).","proofString":"intros.\napply REC.\nred; intros.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(REC : forall (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (rm : romem),\nromem_consistent dm rm ->\nromem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l dm) (fold_left alloc_global l rm)) (cunit : AST.program fundef unit) : romem_consistent (prog_defmap cunit) (romem_for cunit).","proofString":"apply REC.\nred; intros.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(REC : forall (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (rm : romem),\nromem_consistent dm rm ->\nromem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l dm) (fold_left alloc_global l rm)) (cunit : AST.program fundef unit) : romem_consistent (PTree.empty (globdef fundef unit)) (PTree.empty ablock).","proofString":"red; intros.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(REC : forall (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (rm : romem),\nromem_consistent dm rm ->\nromem_consistent\n  (fold_left\n     (fun (m : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) m) l dm) (fold_left alloc_global l rm)) (cunit : AST.program fundef unit) (id : positive) (ab : ablock) (H : (PTree.empty ablock) ! id = Some ab) : exists v : globvar unit,\n  (PTree.empty (globdef fundef unit)) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (ab : ablock) (H0 : (romem_for cunit) ! id = Some ab) : exists v : globvar unit,\n  (prog_defmap prog) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"exploit (romem_for_consistent cunit); eauto.\nintros (v & DM & RO & VO & DEFN & AB).\ndestruct (prog_defmap_linkorder _ _ _ _ H DM) as (gd & P & Q).\nassert (gd = Gvar v).\ninv Q.\ninv H2.\nsimpl in *.\nf_equal.\nf_equal.\ndestruct info1, info2; auto.\ninv H3; auto; discriminate.\nsubst gd.\nexists v; auto."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (ab : ablock) (H0 : (romem_for cunit) ! id = Some ab) : (exists v : globvar unit,\n   (prog_defmap cunit) ! id = Some (Gvar v) /\\\n   gvar_readonly v = true /\\\n   gvar_volatile v = false /\\\n   definitive_initializer (gvar_init v) = true /\\\n   ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) ->\nexists v : globvar unit,\n  (prog_defmap prog) ! id = Some (Gvar v) /\\\n  gvar_readonly v = true /\\\n  gvar_volatile v = false /\\\n  definitive_initializer (gvar_init v) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v).","proofString":"intros (v & DM & RO & VO & DEFN & AB).\ndestruct (prog_defmap_linkorder _ _ _ _ H DM) as (gd & P & Q).\nassert (gd = Gvar v).\ninv Q.\ninv H2.\nsimpl in *.\nf_equal.\nf_equal.\ndestruct info1, info2; auto.\ninv H3; auto; discriminate.\nsubst gd.\nexists v; auto."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (ab : ablock) (H0 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (DM : (prog_defmap cunit) ! id = Some (Gvar v)) (RO : gvar_readonly v = true) (VO : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (AB : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : exists v0 : globvar unit,\n  (prog_defmap prog) ! id = Some (Gvar v0) /\\\n  gvar_readonly v0 = true /\\\n  gvar_volatile v0 = false /\\\n  definitive_initializer (gvar_init v0) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v0).","proofString":"destruct (prog_defmap_linkorder _ _ _ _ H DM) as (gd & P & Q).\nassert (gd = Gvar v).\ninv Q.\ninv H2.\nsimpl in *.\nf_equal.\nf_equal.\ndestruct info1, info2; auto.\ninv H3; auto; discriminate.\nsubst gd.\nexists v; auto."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (ab : ablock) (H0 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (DM : (prog_defmap cunit) ! id = Some (Gvar v)) (RO : gvar_readonly v = true) (VO : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (AB : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (gd : globdef fundef unit) (P : (prog_defmap prog) ! id = Some gd) (Q : linkorder (Gvar v) gd) : exists v0 : globvar unit,\n  (prog_defmap prog) ! id = Some (Gvar v0) /\\\n  gvar_readonly v0 = true /\\\n  gvar_volatile v0 = false /\\\n  definitive_initializer (gvar_init v0) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v0).","proofString":"assert (gd = Gvar v).\ninv Q.\ninv H2.\nsimpl in *.\nf_equal.\nf_equal.\ndestruct info1, info2; auto.\ninv H3; auto; discriminate.\nsubst gd.\nexists v; auto."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (ab : ablock) (H0 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (DM : (prog_defmap cunit) ! id = Some (Gvar v)) (RO : gvar_readonly v = true) (VO : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (AB : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (gd : globdef fundef unit) (P : (prog_defmap prog) ! id = Some gd) (Q : linkorder (Gvar v) gd) : gd = Gvar v.","proofString":"inv Q.\ninv H2.\nsimpl in *.\nf_equal.\nf_equal.\ndestruct info1, info2; auto.\ninv H3; auto; discriminate."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (info1 : unit) (i1 : list init_data) (ro vo : bool) (DEFN : definitive_initializer i1 = true) (VO : vo = false) (RO : ro = true) (DM : (prog_defmap cunit) ! id =\nSome\n  (Gvar\n     {|\n       gvar_info := info1;\n       gvar_init := i1;\n       gvar_readonly := ro;\n       gvar_volatile := vo\n     |})) (H0 : (romem_for cunit) ! id = Some (store_init_data_list (ablock_init Pbot) 0 i1)) (info2 : unit) (i2 : list init_data) (P : (prog_defmap prog) ! id =\nSome\n  (Gvar\n     {|\n       gvar_info := info2;\n       gvar_init := i2;\n       gvar_readonly := ro;\n       gvar_volatile := vo\n     |})) (H1 : linkorder info1 info2) (H3 : linkorder i1 i2) : {|\n  gvar_info := info2;\n  gvar_init := i2;\n  gvar_readonly := ro;\n  gvar_volatile := vo\n|} =\n{|\n  gvar_info := info1;\n  gvar_init := i1;\n  gvar_readonly := ro;\n  gvar_volatile := vo\n|}.","proofString":"f_equal.\ndestruct info1, info2; auto.\ninv H3; auto; discriminate."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (info1 : unit) (i1 : list init_data) (ro vo : bool) (DEFN : definitive_initializer i1 = true) (VO : vo = false) (RO : ro = true) (DM : (prog_defmap cunit) ! id =\nSome\n  (Gvar\n     {|\n       gvar_info := info1;\n       gvar_init := i1;\n       gvar_readonly := ro;\n       gvar_volatile := vo\n     |})) (H0 : (romem_for cunit) ! id = Some (store_init_data_list (ablock_init Pbot) 0 i1)) (info2 : unit) (i2 : list init_data) (P : (prog_defmap prog) ! id =\nSome\n  (Gvar\n     {|\n       gvar_info := info2;\n       gvar_init := i2;\n       gvar_readonly := ro;\n       gvar_volatile := vo\n     |})) (H1 : linkorder info1 info2) (H3 : linkorder i1 i2) : info2 = info1.","proofString":"destruct info1, info2; auto."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (info1 : unit) (i1 : list init_data) (ro vo : bool) (DEFN : definitive_initializer i1 = true) (VO : vo = false) (RO : ro = true) (DM : (prog_defmap cunit) ! id =\nSome\n  (Gvar\n     {|\n       gvar_info := info1;\n       gvar_init := i1;\n       gvar_readonly := ro;\n       gvar_volatile := vo\n     |})) (H0 : (romem_for cunit) ! id = Some (store_init_data_list (ablock_init Pbot) 0 i1)) (info2 : unit) (i2 : list init_data) (P : (prog_defmap prog) ! id =\nSome\n  (Gvar\n     {|\n       gvar_info := info2;\n       gvar_init := i2;\n       gvar_readonly := ro;\n       gvar_volatile := vo\n     |})) (H1 : linkorder info1 info2) (H3 : linkorder i1 i2) : i2 = i1.","proofString":"inv H3; auto; discriminate."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (ab : ablock) (H0 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (DM : (prog_defmap cunit) ! id = Some (Gvar v)) (RO : gvar_readonly v = true) (VO : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (AB : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (gd : globdef fundef unit) (P : (prog_defmap prog) ! id = Some gd) (Q : linkorder (Gvar v) gd) (H1 : gd = Gvar v) : exists v0 : globvar unit,\n  (prog_defmap prog) ! id = Some (Gvar v0) /\\\n  gvar_readonly v0 = true /\\\n  gvar_volatile v0 = false /\\\n  definitive_initializer (gvar_init v0) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v0).","proofString":"subst gd.\nexists v; auto."},{"statement":"(cunit : program) (H : linkorder cunit prog) (id : positive) (ab : ablock) (H0 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (DM : (prog_defmap cunit) ! id = Some (Gvar v)) (RO : gvar_readonly v = true) (VO : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (AB : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (Q : linkorder (Gvar v) (Gvar v)) (P : (prog_defmap prog) ! id = Some (Gvar v)) : exists v0 : globvar unit,\n  (prog_defmap prog) ! id = Some (Gvar v0) /\\\n  gvar_readonly v0 = true /\\\n  gvar_volatile v0 = false /\\\n  definitive_initializer (gvar_init v0) = true /\\\n  ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v0).","proofString":"exists v; auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : exists bc : block_classification,\n  genv_match bc ge /\\\n  bc_below bc (Mem.nextblock m) /\\\n  bc_nostack bc /\\\n  (forall cunit : program,\n   linkorder cunit prog -> romatch bc m (romem_for cunit)) /\\\n  (forall b : block, Mem.valid_block m b -> bc b <> BCinvalid).","proofString":"exploit initial_block_classification; eauto.\nintros (bc & GE & BELOW & NOSTACK & INV & VALID).\nexists bc; splitall; auto.\nintros.\nassert (A: initial_mem_match bc m ge).\napply alloc_globals_match with (m := Mem.empty); auto.\nred.\nunfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate.\nassert (B: romem_consistent (prog_defmap prog) (romem_for cunit)) by (apply romem_for_consistent_2; auto).\nred; intros.\nexploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : (exists bc : block_classification,\n   genv_match bc ge /\\\n   bc_below bc (Mem.nextblock m) /\\\n   bc_nostack bc /\\\n   (forall (b : block) (id : ident),\n    bc b = BCglob id -> Genv.find_symbol ge id = Some b) /\\\n   (forall b : block, Mem.valid_block m b -> bc b <> BCinvalid)) ->\nexists bc : block_classification,\n  genv_match bc ge /\\\n  bc_below bc (Mem.nextblock m) /\\\n  bc_nostack bc /\\\n  (forall cunit : program,\n   linkorder cunit prog -> romatch bc m (romem_for cunit)) /\\\n  (forall b : block, Mem.valid_block m b -> bc b <> BCinvalid).","proofString":"intros (bc & GE & BELOW & NOSTACK & INV & VALID).\nexists bc; splitall; auto.\nintros.\nassert (A: initial_mem_match bc m ge).\napply alloc_globals_match with (m := Mem.empty); auto.\nred.\nunfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate.\nassert (B: romem_consistent (prog_defmap prog) (romem_for cunit)) by (apply romem_for_consistent_2; auto).\nred; intros.\nexploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) : exists bc0 : block_classification,\n  genv_match bc0 ge /\\\n  bc_below bc0 (Mem.nextblock m) /\\\n  bc_nostack bc0 /\\\n  (forall cunit : program,\n   linkorder cunit prog -> romatch bc0 m (romem_for cunit)) /\\\n  (forall b : block, Mem.valid_block m b -> bc0 b <> BCinvalid).","proofString":"exists bc; splitall; auto.\nintros.\nassert (A: initial_mem_match bc m ge).\napply alloc_globals_match with (m := Mem.empty); auto.\nred.\nunfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate.\nassert (B: romem_consistent (prog_defmap prog) (romem_for cunit)) by (apply romem_for_consistent_2; auto).\nred; intros.\nexploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) : forall cunit : program,\nlinkorder cunit prog -> romatch bc m (romem_for cunit).","proofString":"intros.\nassert (A: initial_mem_match bc m ge).\napply alloc_globals_match with (m := Mem.empty); auto.\nred.\nunfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate.\nassert (B: romem_consistent (prog_defmap prog) (romem_for cunit)) by (apply romem_for_consistent_2; auto).\nred; intros.\nexploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) : romatch bc m (romem_for cunit).","proofString":"assert (A: initial_mem_match bc m ge).\napply alloc_globals_match with (m := Mem.empty); auto.\nred.\nunfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate.\nassert (B: romem_consistent (prog_defmap prog) (romem_for cunit)) by (apply romem_for_consistent_2; auto).\nred; intros.\nexploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) : initial_mem_match bc m ge.","proofString":"apply alloc_globals_match with (m := Mem.empty); auto.\nred.\nunfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) : initial_mem_match bc Mem.empty\n  (Genv.empty_genv fundef unit (prog_public prog)).","proofString":"red.\nunfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) : forall (id : ident) (b : block) (v : globvar unit),\nGenv.find_symbol (Genv.empty_genv fundef unit (prog_public prog)) id = Some b ->\nGenv.find_var_info (Genv.empty_genv fundef unit (prog_public prog)) b =\nSome v ->\ngvar_volatile v = false ->\ngvar_readonly v = true ->\nbmatch bc Mem.empty b\n  (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"unfold Genv.find_symbol; simpl; intros.\nrewrite PTree.gempty in H1; discriminate."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (id : ident) (b : block) (v : globvar unit) (H1 : (PTree.empty block) ! id = Some b) (H2 : Genv.find_var_info (Genv.empty_genv fundef unit (prog_public prog)) b =\nSome v) (H3 : gvar_volatile v = false) (H4 : gvar_readonly v = true) : bmatch bc Mem.empty b\n  (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"rewrite PTree.gempty in H1; discriminate."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) : romatch bc m (romem_for cunit).","proofString":"assert (B: romem_consistent (prog_defmap prog) (romem_for cunit)) by (apply romem_for_consistent_2; auto).\nred; intros.\nexploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b : block) (id : ident),\nbc b = BCglob id -> Genv.find_symbol ge id = Some b) (VALID : forall b : block, Mem.valid_block m b -> bc b <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) : romatch bc m (romem_for cunit).","proofString":"red; intros.\nexploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"exploit B; eauto.\nintros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) : (exists v : globvar unit,\n   (prog_defmap prog) ! id = Some (Gvar v) /\\\n   gvar_readonly v = true /\\\n   gvar_volatile v = false /\\\n   definitive_initializer (gvar_init v) = true /\\\n   ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) ->\npge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"intros (v & DM & RO & NVOL & DEFN & EQ).\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (DM : (prog_defmap prog) ! id = Some (Gvar v)) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"rewrite Genv.find_def_symbol in DM.\ndestruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (DM : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv prog) b0 = Some (Gvar v)) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"destruct DM as (b1 & FS & FD).\nrewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (b1 : block) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b1) (FD : Genv.find_def (Genv.globalenv prog) b1 = Some (Gvar v)) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"rewrite <- Genv.find_var_info_iff in FD.\nassert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (b1 : block) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b1) (FD : Genv.find_var_info (Genv.globalenv prog) b1 = Some v) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"assert (b1 = b).\napply INV in H1.\nunfold ge in H1; congruence.\nsubst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (b1 : block) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b1) (FD : Genv.find_var_info (Genv.globalenv prog) b1 = Some v) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : b1 = b.","proofString":"apply INV in H1.\nunfold ge in H1; congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : Genv.find_symbol ge id = Some b) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (b1 : block) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b1) (FD : Genv.find_var_info (Genv.globalenv prog) b1 = Some v) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : b1 = b.","proofString":"unfold ge in H1; congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (b1 : block) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b1) (FD : Genv.find_var_info (Genv.globalenv prog) b1 = Some v) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (H3 : b1 = b) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"subst b1.\nsplit.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : pge Glob (ab_summary ab) /\\\nbmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"split.\nsubst ab.\napply store_init_data_list_summary.\nconstructor.\nsplit.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : pge Glob (ab_summary ab).","proofString":"subst ab.\napply store_init_data_list_summary.\nconstructor."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (H1 : bc b = BCglob id) (v : globvar unit) (H2 : (romem_for cunit) ! id =\nSome (store_init_data_list (ablock_init Pbot) 0 (gvar_init v))) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) : pge Glob\n  (ab_summary (store_init_data_list (ablock_init Pbot) 0 (gvar_init v))).","proofString":"apply store_init_data_list_summary.\nconstructor."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (H1 : bc b = BCglob id) (v : globvar unit) (H2 : (romem_for cunit) ! id =\nSome (store_init_data_list (ablock_init Pbot) 0 (gvar_init v))) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) : pge Glob (ab_summary (ablock_init Pbot)).","proofString":"constructor."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : bmatch bc m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","proofString":"split.\nsubst ab.\neapply A; eauto.\nexploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : bmatch bc m b ab.","proofString":"subst ab.\neapply A; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (H1 : bc b = BCglob id) (v : globvar unit) (H2 : (romem_for cunit) ! id =\nSome (store_init_data_list (ablock_init Pbot) 0 (gvar_init v))) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) : bmatch bc m b (store_init_data_list (ablock_init Pbot) 0 (gvar_init v)).","proofString":"eapply A; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : forall ofs : Z, ~ Mem.perm m b ofs Max Writable.","proofString":"exploit Genv.init_mem_characterization; eauto.\nintros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v) /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m b ofs k p ->\n 0 <= ofs < init_data_list_size (gvar_init v) /\\\n perm_order (Genv.perm_globvar v) p) /\\\n(gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv prog) m b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv prog) (gvar_init v))) ->\nforall ofs : Z, ~ Mem.perm m b ofs Max Writable.","proofString":"intros (P & Q & R).\nintros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (P : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p) (R : (gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv prog) m b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv prog) (gvar_init v)))) : forall ofs : Z, ~ Mem.perm m b ofs Max Writable.","proofString":"intros; red; intros.\nexploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (P : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p) (R : (gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv prog) m b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv prog) (gvar_init v)))) (ofs : Z) (H3 : Mem.perm m b ofs Max Writable) : False.","proofString":"exploit Q; eauto.\nintros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (P : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p) (R : (gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv prog) m b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv prog) (gvar_init v)))) (ofs : Z) (H3 : Mem.perm m b ofs Max Writable) : 0 <= ofs < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) Writable -> False.","proofString":"intros [U V].\nunfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (P : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p) (R : (gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv prog) m b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv prog) (gvar_init v)))) (ofs : Z) (H3 : Mem.perm m b ofs Max Writable) (U : 0 <= ofs < init_data_list_size (gvar_init v)) (V : perm_order (Genv.perm_globvar v) Writable) : False.","proofString":"unfold Genv.perm_globvar in V; rewrite RO, NVOL in V.\ninv V."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (bc : block_classification) (GE : genv_match bc ge) (BELOW : bc_below bc (Mem.nextblock m)) (NOSTACK : bc_nostack bc) (INV : forall (b0 : block) (id0 : ident),\nbc b0 = BCglob id0 -> Genv.find_symbol ge id0 = Some b0) (VALID : forall b0 : block, Mem.valid_block m b0 -> bc b0 <> BCinvalid) (cunit : program) (H0 : linkorder cunit prog) (A : initial_mem_match bc m ge) (B : romem_consistent (prog_defmap prog) (romem_for cunit)) (b : block) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : (romem_for cunit) ! id = Some ab) (v : globvar unit) (FD : Genv.find_var_info (Genv.globalenv prog) b = Some v) (FS : Genv.find_symbol (Genv.globalenv prog) id = Some b) (RO : gvar_readonly v = true) (NVOL : gvar_volatile v = false) (DEFN : definitive_initializer (gvar_init v) = true) (EQ : ab = store_init_data_list (ablock_init Pbot) 0 (gvar_init v)) (P : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p) (R : (gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv prog) m b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv prog) (gvar_init v)))) (ofs : Z) (H3 : Mem.perm m b ofs Max Writable) (U : 0 <= ofs < init_data_list_size (gvar_init v)) (V : perm_order Readable Writable) : False.","proofString":"inv V."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) : sound_state prog (Callstate nil f nil m0).","proofString":"exploit initial_mem_matches; eauto.\nintros (bc & GE & BELOW & NOSTACK & RM & VALID).\nconstructor; intros.\napply sound_call_state with bc.\nconstructor.\nsimpl; tauto.\napply RM; auto.\napply mmatch_inj_top with m0.\nreplace (inj_of_bc bc) with (Mem.flat_inj (Mem.nextblock m0)).\neapply Genv.initmem_inject; eauto.\nsymmetry; apply extensionality; unfold Mem.flat_inj; intros x.\ndestruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto.\nexact GE.\nexact NOSTACK."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) : (exists bc : block_classification,\n   genv_match bc (Genv.globalenv prog) /\\\n   bc_below bc (Mem.nextblock m0) /\\\n   bc_nostack bc /\\\n   (forall cunit : program,\n    linkorder cunit prog -> romatch bc m0 (romem_for cunit)) /\\\n   (forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid)) ->\nsound_state prog (Callstate nil f nil m0).","proofString":"intros (bc & GE & BELOW & NOSTACK & RM & VALID).\nconstructor; intros.\napply sound_call_state with bc.\nconstructor.\nsimpl; tauto.\napply RM; auto.\napply mmatch_inj_top with m0.\nreplace (inj_of_bc bc) with (Mem.flat_inj (Mem.nextblock m0)).\neapply Genv.initmem_inject; eauto.\nsymmetry; apply extensionality; unfold Mem.flat_inj; intros x.\ndestruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto.\nexact GE.\nexact NOSTACK."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit : program,\nlinkorder cunit prog -> romatch bc m0 (romem_for cunit)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) : sound_state prog (Callstate nil f nil m0).","proofString":"constructor; intros.\napply sound_call_state with bc.\nconstructor.\nsimpl; tauto.\napply RM; auto.\napply mmatch_inj_top with m0.\nreplace (inj_of_bc bc) with (Mem.flat_inj (Mem.nextblock m0)).\neapply Genv.initmem_inject; eauto.\nsymmetry; apply extensionality; unfold Mem.flat_inj; intros x.\ndestruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto.\nexact GE.\nexact NOSTACK."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : sound_state_base cunit (Genv.globalenv prog) (Callstate nil f nil m0).","proofString":"apply sound_call_state with bc.\nconstructor.\nsimpl; tauto.\napply RM; auto.\napply mmatch_inj_top with m0.\nreplace (inj_of_bc bc) with (Mem.flat_inj (Mem.nextblock m0)).\neapply Genv.initmem_inject; eauto.\nsymmetry; apply extensionality; unfold Mem.flat_inj; intros x.\ndestruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto.\nexact GE.\nexact NOSTACK."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : sound_stack cunit (Genv.globalenv prog) bc nil m0 (Mem.nextblock m0).","proofString":"constructor."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : forall v : val, In v nil -> vmatch bc v Vtop.","proofString":"simpl; tauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : romatch bc m0 (romem_for cunit).","proofString":"apply RM; auto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : mmatch bc m0 mtop.","proofString":"apply mmatch_inj_top with m0.\nreplace (inj_of_bc bc) with (Mem.flat_inj (Mem.nextblock m0)).\neapply Genv.initmem_inject; eauto.\nsymmetry; apply extensionality; unfold Mem.flat_inj; intros x.\ndestruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : Mem.inject (inj_of_bc bc) m0 m0.","proofString":"replace (inj_of_bc bc) with (Mem.flat_inj (Mem.nextblock m0)).\neapply Genv.initmem_inject; eauto.\nsymmetry; apply extensionality; unfold Mem.flat_inj; intros x.\ndestruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : Mem.inject (Mem.flat_inj (Mem.nextblock m0)) m0 m0.","proofString":"eapply Genv.initmem_inject; eauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : Mem.flat_inj (Mem.nextblock m0) = inj_of_bc bc.","proofString":"symmetry; apply extensionality; unfold Mem.flat_inj; intros x.\ndestruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) (x : block) : inj_of_bc bc x = (if plt x (Mem.nextblock m0) then Some (x, 0) else None).","proofString":"destruct (plt x (Mem.nextblock m0)).\napply inj_of_bc_valid; auto.\nunfold inj_of_bc.\nerewrite bc_below_invalid; eauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) (x : block) (p : Plt x (Mem.nextblock m0)) : inj_of_bc bc x = Some (x, 0).","proofString":"apply inj_of_bc_valid; auto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) (x : block) (n : ~ Plt x (Mem.nextblock m0)) : inj_of_bc bc x = None.","proofString":"unfold inj_of_bc.\nerewrite bc_below_invalid; eauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) (x : block) (n : ~ Plt x (Mem.nextblock m0)) : match bc x with\n| BCinvalid => None\n| _ => Some (x, 0)\nend = None.","proofString":"erewrite bc_below_invalid; eauto."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : genv_match bc (Genv.globalenv prog).","proofString":"exact GE."},{"statement":"(prog : program) (b : block) (f : fundef) (m0 : mem) (ge : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge b = Some f) (H2 : funsig f = signature_main) (bc : block_classification) (GE : genv_match bc (Genv.globalenv prog)) (BELOW : bc_below bc (Mem.nextblock m0)) (NOSTACK : bc_nostack bc) (RM : forall cunit0 : program,\nlinkorder cunit0 prog -> romatch bc m0 (romem_for cunit0)) (VALID : forall b0 : block, Mem.valid_block m0 b0 -> bc b0 <> BCinvalid) (cunit : program) (H3 : linkorder cunit prog) : bc_nostack bc.","proofString":"exact NOSTACK."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) : exists bc : block_classification,\n  vmatch bc e # r (avalue (analyze (romem_for cunit) f) # pc r) /\\\n  genv_match bc (Genv.globalenv prog) /\\ bc sp = BCstack.","proofString":"InvSoundState.\nexists bc; split; auto.\nrewrite AN.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : exists bc0 : block_classification,\n  vmatch bc0 e # r (avalue (analyze (romem_for cunit) f) # pc r) /\\\n  genv_match bc0 (Genv.globalenv prog) /\\ bc0 sp = BCstack.","proofString":"exists bc; split; auto.\nrewrite AN.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : vmatch bc e # r (avalue (analyze (romem_for cunit) f) # pc r).","proofString":"rewrite AN.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : vmatch bc e # r (avalue (VA.State ae am) r).","proofString":"apply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : e # r = Vptr b ofs) : exists bc : block_classification,\n  pmatch bc b ofs (aaddr (analyze (romem_for cunit) f) # pc r) /\\\n  genv_match bc (Genv.globalenv prog) /\\ bc sp = BCstack.","proofString":"InvSoundState.\nexists bc; split; auto.\nunfold aaddr; rewrite AN.\napply match_aptr_of_aval.\nrewrite <- H1.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : e # r = Vptr b ofs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : exists bc0 : block_classification,\n  pmatch bc0 b ofs (aaddr (analyze (romem_for cunit) f) # pc r) /\\\n  genv_match bc0 (Genv.globalenv prog) /\\ bc0 sp = BCstack.","proofString":"exists bc; split; auto.\nunfold aaddr; rewrite AN.\napply match_aptr_of_aval.\nrewrite <- H1.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : e # r = Vptr b ofs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : pmatch bc b ofs (aaddr (analyze (romem_for cunit) f) # pc r).","proofString":"unfold aaddr; rewrite AN.\napply match_aptr_of_aval.\nrewrite <- H1.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : e # r = Vptr b ofs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : pmatch bc b ofs (aptr_of_aval (AE.get r ae)).","proofString":"apply match_aptr_of_aval.\nrewrite <- H1.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : e # r = Vptr b ofs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : vmatch bc (Vptr b ofs) (AE.get r ae).","proofString":"rewrite <- H1.\napply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (r : positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : e # r = Vptr b ofs) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : vmatch bc e # r (AE.get r ae).","proofString":"apply EM."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (addr : addressing) (args : list positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_addressing (Genv.globalenv prog) (Vptr sp Ptrofs.zero) addr e ## args =\nSome (Vptr b ofs)) : exists bc : block_classification,\n  pmatch bc b ofs (aaddressing (analyze (romem_for cunit) f) # pc addr args) /\\\n  genv_match bc (Genv.globalenv prog) /\\ bc sp = BCstack.","proofString":"InvSoundState.\nexists bc; split; auto.\nunfold aaddressing.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (addr : addressing) (args : list positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_addressing (Genv.globalenv prog) (Vptr sp Ptrofs.zero) addr e ## args =\nSome (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : exists bc0 : block_classification,\n  pmatch bc0 b ofs (aaddressing (analyze (romem_for cunit) f) # pc addr args) /\\\n  genv_match bc0 (Genv.globalenv prog) /\\ bc0 sp = BCstack.","proofString":"exists bc; split; auto.\nunfold aaddressing.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (addr : addressing) (args : list positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_addressing (Genv.globalenv prog) (Vptr sp Ptrofs.zero) addr e ## args =\nSome (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : pmatch bc b ofs (aaddressing (analyze (romem_for cunit) f) # pc addr args).","proofString":"unfold aaddressing.\nrewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (addr : addressing) (args : list positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_addressing (Genv.globalenv prog) (Vptr sp Ptrofs.zero) addr e ## args =\nSome (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : pmatch bc b ofs\n  match (analyze (romem_for cunit) f) # pc with\n  | VA.Bot => Pbot\n  | VA.State ae0 _ =>\n      aptr_of_aval (eval_static_addressing addr (aregs ae0 args))\n  end.","proofString":"rewrite AN.\napply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (addr : addressing) (args : list positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_addressing (Genv.globalenv prog) (Vptr sp Ptrofs.zero) addr e ## args =\nSome (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : pmatch bc b ofs (aptr_of_aval (eval_static_addressing addr (aregs ae args))).","proofString":"apply match_aptr_of_aval.\neapply eval_static_addressing_sound; eauto with va."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (addr : addressing) (args : list positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_addressing (Genv.globalenv prog) (Vptr sp Ptrofs.zero) addr e ## args =\nSome (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : vmatch bc (Vptr b ofs) (eval_static_addressing addr (aregs ae args)).","proofString":"eapply eval_static_addressing_sound; eauto with va."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (m : mem) (rm : romem) (am : amem) (ge : genv) (sp : block) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a\n  (Vptr b ofs)) : pmatch bc b ofs (aaddr_arg (VA.State ae am) a).","proofString":"apply pmatch_ge with (aptr_of_aval (abuiltin_arg ae am rm a)).\nsimpl.\ndestruct a; try (apply pge_top); simpl; apply pge_refl.\napply match_aptr_of_aval.\neapply abuiltin_arg_sound; eauto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (m : mem) (rm : romem) (am : amem) (ge : genv) (sp : block) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a\n  (Vptr b ofs)) : pge (aaddr_arg (VA.State ae am) a) (aptr_of_aval (abuiltin_arg ae am rm a)).","proofString":"simpl.\ndestruct a; try (apply pge_top); simpl; apply pge_refl."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (m : mem) (rm : romem) (am : amem) (ge : genv) (sp : block) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a\n  (Vptr b ofs)) : pge\n  match a with\n  | BA r => aptr_of_aval (AE.get r ae)\n  | BA_addrstack ofs0 => Stk ofs0\n  | BA_addrglobal id ofs0 => Gl id ofs0\n  | _ => Ptop\n  end (aptr_of_aval (abuiltin_arg ae am rm a)).","proofString":"destruct a; try (apply pge_top); simpl; apply pge_refl."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (m : mem) (rm : romem) (am : amem) (ge : genv) (sp : block) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a\n  (Vptr b ofs)) : pmatch bc b ofs (aptr_of_aval (abuiltin_arg ae am rm a)).","proofString":"apply match_aptr_of_aval.\neapply abuiltin_arg_sound; eauto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (m : mem) (rm : romem) (am : amem) (ge : genv) (sp : block) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : ematch bc rs ae) (H0 : romatch bc m rm) (H1 : mmatch bc m am) (H2 : genv_match bc ge) (H3 : bc sp = BCstack) (H4 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a\n  (Vptr b ofs)) : vmatch bc (Vptr b ofs) (abuiltin_arg ae am rm a).","proofString":"eapply abuiltin_arg_sound; eauto."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_builtin_arg (Genv.globalenv prog) (fun r : positive => e # r)\n  (Vptr sp Ptrofs.zero) m a (Vptr b ofs)) : exists bc : block_classification,\n  pmatch bc b ofs (aaddr_arg (analyze (romem_for cunit) f) # pc a) /\\\n  genv_match bc (Genv.globalenv prog) /\\ bc sp = BCstack.","proofString":"InvSoundState.\nrewrite AN.\nexists bc; split; auto.\neapply aaddr_arg_sound_1; eauto."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_builtin_arg (Genv.globalenv prog) (fun r : positive => e # r)\n  (Vptr sp Ptrofs.zero) m a (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : exists bc0 : block_classification,\n  pmatch bc0 b ofs (aaddr_arg (analyze (romem_for cunit) f) # pc a) /\\\n  genv_match bc0 (Genv.globalenv prog) /\\ bc0 sp = BCstack.","proofString":"rewrite AN.\nexists bc; split; auto.\neapply aaddr_arg_sound_1; eauto."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_builtin_arg (Genv.globalenv prog) (fun r : positive => e # r)\n  (Vptr sp Ptrofs.zero) m a (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : exists bc0 : block_classification,\n  pmatch bc0 b ofs (aaddr_arg (VA.State ae am) a) /\\\n  genv_match bc0 (Genv.globalenv prog) /\\ bc0 sp = BCstack.","proofString":"exists bc; split; auto.\neapply aaddr_arg_sound_1; eauto."},{"statement":"(cunit prog : program) (s : list stackframe) (f : function) (sp : block) (pc : node) (e : regset) (m : mem) (a : builtin_arg positive) (b : block) (ofs : ptrofs) (H : sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m)) (H0 : linkorder cunit prog) (H1 : eval_builtin_arg (Genv.globalenv prog) (fun r : positive => e # r)\n  (Vptr sp Ptrofs.zero) m a (Vptr b ofs)) (ae : aenv) (am : amem) (bc : block_classification) (STK : sound_stack cunit (Genv.globalenv prog) bc s m sp) (AN : (analyze (romem_for cunit) f) # pc = VA.State ae am) (EM : ematch bc e ae) (RO : romatch bc m (romem_for cunit)) (MM : mmatch bc m am) (GE : genv_match bc (Genv.globalenv prog)) (SP : bc sp = BCstack) : pmatch bc b ofs (aaddr_arg (VA.State ae am) a).","proofString":"eapply aaddr_arg_sound_1; eauto."}]}