{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/MenhirLib/Interpreter_correct.v","fileSamples":[{"statement":"(A : Type) (symbols_to_pop : list symbol) (action : Grammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (word_stk : list token) (stk : stack) (res : A) (stk' : stack) (Hspec : pop_spec symbols_to_pop stk action stk' res) : word_has_stack_semantics word_stk stk ->\nexists\n  (word_stk' word_res : list token) (ptl : parse_tree_list symbols_to_pop\n                                             word_res),\n  word_stk' ++ word_res = word_stk /\\\n  word_has_stack_semantics word_stk' stk' /\\ ptl_sem ptl action = res.","proofString":"revert word_stk.\ninduction Hspec as [stk sem|symbols_to_pop st stk action sem stk' res Hspec IH];    intros word_stk Hword_stk.\nexists word_stk, [], Nil_ptl.\nrewrite -app_nil_end.\neauto.\ninversion Hword_stk.\nsubst_existT.\nedestruct IH as (word_stk' & word_res & ptl & ? & Hword_stk'' & ?); [eassumption|].\nsubst.\neexists word_stk', (word_res ++ _)%list, (Cons_ptl ptl _).\nsplit; [|split]=>//.\nrewrite app_assoc //."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (action : Grammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (stk : stack) (res : A) (stk' : stack) (Hspec : pop_spec symbols_to_pop stk action stk' res) : forall word_stk : list token,\nword_has_stack_semantics word_stk stk ->\nexists\n  (word_stk' word_res : list token) (ptl : parse_tree_list symbols_to_pop\n                                             word_res),\n  word_stk' ++ word_res = word_stk /\\\n  word_has_stack_semantics word_stk' stk' /\\ ptl_sem ptl action = res.","proofString":"induction Hspec as [stk sem|symbols_to_pop st stk action sem stk' res Hspec IH];    intros word_stk Hword_stk.\nexists word_stk, [], Nil_ptl.\nrewrite -app_nil_end.\neauto.\ninversion Hword_stk.\nsubst_existT.\nedestruct IH as (word_stk' & word_res & ptl & ? & Hword_stk'' & ?); [eassumption|].\nsubst.\neexists word_stk', (word_res ++ _)%list, (Cons_ptl ptl _).\nsplit; [|split]=>//.\nrewrite app_assoc //."},{"statement":"(A : Type) (stk : stack) (sem : Grammar.arrows_right A (map symbol_semantic_type [])) (word_stk : list token) (Hword_stk : word_has_stack_semantics word_stk stk) : exists (word_stk' word_res : list token) (ptl : parse_tree_list [] word_res),\n  word_stk' ++ word_res = word_stk /\\\n  word_has_stack_semantics word_stk' stk /\\ ptl_sem ptl sem = sem.","proofString":"exists word_stk, [], Nil_ptl.\nrewrite -app_nil_end.\neauto."},{"statement":"(A : Type) (stk : stack) (sem : Grammar.arrows_right A (map symbol_semantic_type [])) (word_stk : list token) (Hword_stk : word_has_stack_semantics word_stk stk) : word_stk ++ [] = word_stk /\\\nword_has_stack_semantics word_stk stk /\\ ptl_sem Nil_ptl sem = sem.","proofString":"rewrite -app_nil_end.\neauto."},{"statement":"(A : Type) (stk : stack) (sem : Grammar.arrows_right A (map symbol_semantic_type [])) (word_stk : list token) (Hword_stk : word_has_stack_semantics word_stk stk) : word_stk = word_stk /\\\nword_has_stack_semantics word_stk stk /\\ ptl_sem Nil_ptl sem = sem.","proofString":"eauto."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (st : noninitstate) (stk : stack) (action : noninitstate_type st ->\nGrammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (sem : noninitstate_type st) (stk' : stack) (res : A) (Hspec : pop_spec symbols_to_pop stk (action sem) stk' res) (IH : forall word_stk0 : list token,\nword_has_stack_semantics word_stk0 stk ->\nexists\n  (word_stk' word_res : list token) (ptl : parse_tree_list symbols_to_pop\n                                             word_res),\n  word_stk' ++ word_res = word_stk0 /\\\n  word_has_stack_semantics word_stk' stk' /\\ ptl_sem ptl (action sem) = res) (word_stk : list token) (Hword_stk : word_has_stack_semantics word_stk (existT noninitstate_type st sem :: stk)) : exists\n  (word_stk' word_res : list token) (ptl : parse_tree_list\n                                             (last_symb_of_non_init_state st\n                                              :: symbols_to_pop) word_res),\n  word_stk' ++ word_res = word_stk /\\\n  word_has_stack_semantics word_stk' stk' /\\ ptl_sem ptl action = res.","proofString":"inversion Hword_stk.\nsubst_existT.\nedestruct IH as (word_stk' & word_res & ptl & ? & Hword_stk'' & ?); [eassumption|].\nsubst.\neexists word_stk', (word_res ++ _)%list, (Cons_ptl ptl _).\nsplit; [|split]=>//.\nrewrite app_assoc //."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (st : noninitstate) (stk : stack) (action : noninitstate_type st ->\nGrammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (sem : noninitstate_type st) (stk' : stack) (res : A) (Hspec : pop_spec symbols_to_pop stk (action sem) stk' res) (IH : forall word_stk0 : list token,\nword_has_stack_semantics word_stk0 stk ->\nexists\n  (word_stk' word_res : list token) (ptl : parse_tree_list symbols_to_pop\n                                             word_res),\n  word_stk' ++ word_res = word_stk0 /\\\n  word_has_stack_semantics word_stk' stk' /\\ ptl_sem ptl (action sem) = res) (word_stk : list token) (Hword_stk : word_has_stack_semantics word_stk (existT noninitstate_type st sem :: stk)) (wordq : list token) (stackq : stack) (wordt : list token) (s : noninitstate) (H1 : word_has_stack_semantics wordq stk) (H0 : wordq ++ wordt = word_stk) (H : s = st) (pt0 : parse_tree (last_symb_of_non_init_state st) wordt) (H2 : existT (fun x : noninitstate => noninitstate_type x) st (pt_sem pt0) =\nexistT (fun x : noninitstate => noninitstate_type x) st sem) (H3 : stackq = stk) : exists\n  (word_stk' word_res : list token) (ptl : parse_tree_list\n                                             (last_symb_of_non_init_state st\n                                              :: symbols_to_pop) word_res),\n  word_stk' ++ word_res = wordq ++ wordt /\\\n  word_has_stack_semantics word_stk' stk' /\\ ptl_sem ptl action = res.","proofString":"subst_existT.\nedestruct IH as (word_stk' & word_res & ptl & ? & Hword_stk'' & ?); [eassumption|].\nsubst.\neexists word_stk', (word_res ++ _)%list, (Cons_ptl ptl _).\nsplit; [|split]=>//.\nrewrite app_assoc //."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (st : noninitstate) (stk : stack) (action : noninitstate_type st ->\nGrammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (stk' : stack) (res : A) (wordt : list token) (pt0 : parse_tree (last_symb_of_non_init_state st) wordt) (wordq : list token) (Hword_stk : word_has_stack_semantics (wordq ++ wordt)\n  (existT noninitstate_type st (pt_sem pt0) :: stk)) (IH : forall word_stk : list token,\nword_has_stack_semantics word_stk stk ->\nexists\n  (word_stk' word_res : list token) (ptl : parse_tree_list symbols_to_pop\n                                             word_res),\n  word_stk' ++ word_res = word_stk /\\\n  word_has_stack_semantics word_stk' stk' /\\\n  ptl_sem ptl (action (pt_sem pt0)) = res) (Hspec : pop_spec symbols_to_pop stk (action (pt_sem pt0)) stk' res) (H1 : word_has_stack_semantics wordq stk) : exists\n  (word_stk' word_res : list token) (ptl : parse_tree_list\n                                             (last_symb_of_non_init_state st\n                                              :: symbols_to_pop) word_res),\n  word_stk' ++ word_res = wordq ++ wordt /\\\n  word_has_stack_semantics word_stk' stk' /\\ ptl_sem ptl action = res.","proofString":"edestruct IH as (word_stk' & word_res & ptl & ? & Hword_stk'' & ?); [eassumption|].\nsubst.\neexists word_stk', (word_res ++ _)%list, (Cons_ptl ptl _).\nsplit; [|split]=>//.\nrewrite app_assoc //."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (st : noninitstate) (stk : stack) (action : noninitstate_type st ->\nGrammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (stk' : stack) (res : A) (wordt : list token) (pt0 : parse_tree (last_symb_of_non_init_state st) wordt) (wordq : list token) (Hword_stk : word_has_stack_semantics (wordq ++ wordt)\n  (existT noninitstate_type st (pt_sem pt0) :: stk)) (IH : forall word_stk : list token,\nword_has_stack_semantics word_stk stk ->\nexists\n  (word_stk'0 word_res0 : list token) (ptl0 : parse_tree_list symbols_to_pop\n                                                word_res0),\n  word_stk'0 ++ word_res0 = word_stk /\\\n  word_has_stack_semantics word_stk'0 stk' /\\\n  ptl_sem ptl0 (action (pt_sem pt0)) = res) (Hspec : pop_spec symbols_to_pop stk (action (pt_sem pt0)) stk' res) (H1 : word_has_stack_semantics wordq stk) (word_stk' word_res : list token) (ptl : parse_tree_list symbols_to_pop word_res) (H : word_stk' ++ word_res = wordq) (Hword_stk'' : word_has_stack_semantics word_stk' stk') (H0 : ptl_sem ptl (action (pt_sem pt0)) = res) : exists\n  (word_stk'0 word_res0 : list token) (ptl0 : parse_tree_list\n                                                (last_symb_of_non_init_state\n                                                 st :: symbols_to_pop)\n                                                word_res0),\n  word_stk'0 ++ word_res0 = wordq ++ wordt /\\\n  word_has_stack_semantics word_stk'0 stk' /\\ ptl_sem ptl0 action = res.","proofString":"subst.\neexists word_stk', (word_res ++ _)%list, (Cons_ptl ptl _).\nsplit; [|split]=>//.\nrewrite app_assoc //."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (st : noninitstate) (stk : stack) (action : noninitstate_type st ->\nGrammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (stk' : stack) (wordt : list token) (pt0 : parse_tree (last_symb_of_non_init_state st) wordt) (word_stk' word_res : list token) (Hword_stk : word_has_stack_semantics ((word_stk' ++ word_res) ++ wordt)\n  (existT noninitstate_type st (pt_sem pt0) :: stk)) (ptl : parse_tree_list symbols_to_pop word_res) (Hspec : pop_spec symbols_to_pop stk (action (pt_sem pt0)) stk'\n  (ptl_sem ptl (action (pt_sem pt0)))) (IH : forall word_stk : list token,\nword_has_stack_semantics word_stk stk ->\nexists\n  (word_stk'0 word_res0 : list token) (ptl0 : parse_tree_list symbols_to_pop\n                                                word_res0),\n  word_stk'0 ++ word_res0 = word_stk /\\\n  word_has_stack_semantics word_stk'0 stk' /\\\n  ptl_sem ptl0 (action (pt_sem pt0)) = ptl_sem ptl (action (pt_sem pt0))) (H1 : word_has_stack_semantics (word_stk' ++ word_res) stk) (Hword_stk'' : word_has_stack_semantics word_stk' stk') : exists\n  (word_stk'0 word_res0 : list token) (ptl0 : parse_tree_list\n                                                (last_symb_of_non_init_state\n                                                 st :: symbols_to_pop)\n                                                word_res0),\n  word_stk'0 ++ word_res0 = (word_stk' ++ word_res) ++ wordt /\\\n  word_has_stack_semantics word_stk'0 stk' /\\\n  ptl_sem ptl0 action = ptl_sem ptl (action (pt_sem pt0)).","proofString":"eexists word_stk', (word_res ++ _)%list, (Cons_ptl ptl _).\nsplit; [|split]=>//.\nrewrite app_assoc //."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (st : noninitstate) (stk : stack) (action : noninitstate_type st ->\nGrammar.arrows_right A (map symbol_semantic_type symbols_to_pop)) (stk' : stack) (wordt : list token) (pt0 : parse_tree (last_symb_of_non_init_state st) wordt) (word_stk' word_res : list token) (Hword_stk : word_has_stack_semantics ((word_stk' ++ word_res) ++ wordt)\n  (existT noninitstate_type st (pt_sem pt0) :: stk)) (ptl : parse_tree_list symbols_to_pop word_res) (Hspec : pop_spec symbols_to_pop stk (action (pt_sem pt0)) stk'\n  (ptl_sem ptl (action (pt_sem pt0)))) (IH : forall word_stk : list token,\nword_has_stack_semantics word_stk stk ->\nexists\n  (word_stk'0 word_res0 : list token) (ptl0 : parse_tree_list symbols_to_pop\n                                                word_res0),\n  word_stk'0 ++ word_res0 = word_stk /\\\n  word_has_stack_semantics word_stk'0 stk' /\\\n  ptl_sem ptl0 (action (pt_sem pt0)) = ptl_sem ptl (action (pt_sem pt0))) (H1 : word_has_stack_semantics (word_stk' ++ word_res) stk) (Hword_stk'' : word_has_stack_semantics word_stk' stk') : word_stk' ++ word_res ++ wordt = (word_stk' ++ word_res) ++ wordt.","proofString":"rewrite app_assoc //."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (word : list token) (buffer : Inter.buffer) (Hword_stk : word_has_stack_semantics word stk) : match reduce_step init stk prod buffer Hv Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      buffer = buffer_new /\\ pt_sem pt = sem\n| Progress_sr stk' buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics word stk'\nend.","proofString":"unfold reduce_step.\nmatch goal with  | |- context [pop_state_valid init ?stp stk ?x1 ?x2 ?x3 ?x4 ?x5] =>    generalize (pop_state_valid init stp stk x1 x2 x3 x4 x5)  end.\ndestruct pop as [stk' sem] eqn:Hpop=>/= Hv'.\napply pop_spec_ok in Hpop.\napply pop_spec_ptl with (word_stk := word) in Hpop=>//.\ndestruct Hpop as (word1 & word2 & ptl & <- & Hword1 & <-).\ngeneralize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')).\ndestruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (word : list token) (buffer : Inter.buffer) (Hword_stk : word_has_stack_semantics word stk) : match\n  (let\n   '(stk', sem) as ss :=\n    pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hv Hi)\n      (prod_action prod)\n    return\n      (thunkP\n         (ValidSafe.state_valid_after_pop (state_of_stack init (fst ss))\n            (prod_rhs_rev prod)\n            (ValidSafe.head_states_of_state (state_of_stack init stk))) ->\n       step_result init) in\n    fun\n      Hval' : thunkP\n                (ValidSafe.state_valid_after_pop\n                   (state_of_stack init (fst (stk', sem)))\n                   (prod_rhs_rev prod)\n                   (ValidSafe.head_states_of_state (state_of_stack init stk)))\n    =>\n    match\n      goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk' with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s =>\n        let\n          (state_new, e) as s0\n           return\n             (thunkP\n                (Some s0 = None ->\n                 match state_of_stack init stk' with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s0 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                      state_new e) = None ->\n                 match state_of_stack init stk' with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n                (last_symb_of_non_init_state state_new) e) :: stk') buffer\n    | None =>\n        fun\n          Hval : thunkP\n                   (None = None ->\n                    match state_of_stack init stk' with\n                    | Init i => prod_lhs prod = start_nt i\n                    | Ninit _ => False\n                    end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk' Hval) sem) buffer\n    end (fun _ : True => reduce_step_subproof1 init stk prod Hv stk' Hval'))\n    (fun _ : True =>\n     pop_state_valid init (prod_rhs_rev prod) stk\n       (reduce_step_subproof init stk prod Hv Hi)\n       (symbol_semantic_type (NT (prod_lhs prod))) \n       (prod_action prod)\n       (ValidSafe.head_states_of_state (state_of_stack init stk))\n       (reduce_step_subproof2 init stk Hi))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      buffer = buffer_new /\\ pt_sem pt = sem\n| Progress_sr stk' buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics word stk'\nend.","proofString":"match goal with  | |- context [pop_state_valid init ?stp stk ?x1 ?x2 ?x3 ?x4 ?x5] =>    generalize (pop_state_valid init stp stk x1 x2 x3 x4 x5)  end.\ndestruct pop as [stk' sem] eqn:Hpop=>/= Hv'.\napply pop_spec_ok in Hpop.\napply pop_spec_ptl with (word_stk := word) in Hpop=>//.\ndestruct Hpop as (word1 & word2 & ptl & <- & Hword1 & <-).\ngeneralize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')).\ndestruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (word : list token) (buffer : Inter.buffer) (Hword_stk : word_has_stack_semantics word stk) : forall\n  s : let stk' :=\n        fst\n          (pop (prod_rhs_rev prod) stk\n             (reduce_step_subproof init stk prod Hv Hi) \n             (prod_action prod)) in\n      ValidSafe.state_valid_after_pop (state_of_stack init stk')\n        (prod_rhs_rev prod)\n        (ValidSafe.head_states_of_state (state_of_stack init stk)),\nmatch\n  (let\n   '(stk', sem) as ss :=\n    pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hv Hi)\n      (prod_action prod)\n    return\n      (thunkP\n         (ValidSafe.state_valid_after_pop (state_of_stack init (fst ss))\n            (prod_rhs_rev prod)\n            (ValidSafe.head_states_of_state (state_of_stack init stk))) ->\n       step_result init) in\n    fun\n      Hval' : thunkP\n                (ValidSafe.state_valid_after_pop\n                   (state_of_stack init (fst (stk', sem)))\n                   (prod_rhs_rev prod)\n                   (ValidSafe.head_states_of_state (state_of_stack init stk)))\n    =>\n    match\n      goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk' with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s0 =>\n        let\n          (state_new, e) as s1\n           return\n             (thunkP\n                (Some s1 = None ->\n                 match state_of_stack init stk' with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s0 in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s1 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s1)\n                      state_new e) = None ->\n                 match state_of_stack init stk' with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n                (last_symb_of_non_init_state state_new) e) :: stk') buffer\n    | None =>\n        fun\n          Hval : thunkP\n                   (None = None ->\n                    match state_of_stack init stk' with\n                    | Init i => prod_lhs prod = start_nt i\n                    | Ninit _ => False\n                    end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk' Hval) sem) buffer\n    end (fun _ : True => reduce_step_subproof1 init stk prod Hv stk' Hval'))\n    (fun _ : True => s)\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      buffer = buffer_new /\\ pt_sem pt = sem\n| Progress_sr stk' buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics word stk'\nend.","proofString":"destruct pop as [stk' sem] eqn:Hpop=>/= Hv'.\napply pop_spec_ok in Hpop.\napply pop_spec_ptl with (word_stk := word) in Hpop=>//.\ndestruct Hpop as (word1 & word2 & ptl & <- & Hword1 & <-).\ngeneralize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')).\ndestruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (word : list token) (buffer : Inter.buffer) (Hword_stk : word_has_stack_semantics word stk) (stk' : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hpop : pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hv Hi)\n  (prod_action prod) = (stk', sem)) (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : match\n  match\n    goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n    return\n      (thunkP\n         (goto = None ->\n          match state_of_stack init stk' with\n          | Init i => prod_lhs prod = start_nt i\n          | Ninit _ => False\n          end) -> step_result init)\n  with\n  | Some s =>\n      let\n        (state_new, e) as s0\n         return\n           (thunkP\n              (Some s0 = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) -> step_result init) := s in\n      fun\n        _ : thunkP\n              (Some\n                 (exist\n                    (fun s0 : noninitstate =>\n                     NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                    state_new e) = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n              (last_symb_of_non_init_state state_new) e) :: stk') buffer\n  | None =>\n      fun\n        Hval : thunkP\n                 (None = None ->\n                  match state_of_stack init stk' with\n                  | Init i => prod_lhs prod = start_nt i\n                  | Ninit _ => False\n                  end) =>\n      Accept_sr\n        (cast symbol_semantic_type\n           (reduce_step_subproof0 init prod stk' Hval) sem) buffer\n  end\n    (fun _ : True =>\n     reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv'))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem0 buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      buffer = buffer_new /\\ pt_sem pt = sem0\n| Progress_sr stk'0 buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics word stk'0\nend.","proofString":"apply pop_spec_ok in Hpop.\napply pop_spec_ptl with (word_stk := word) in Hpop=>//.\ndestruct Hpop as (word1 & word2 & ptl & <- & Hword1 & <-).\ngeneralize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')).\ndestruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (word : list token) (buffer : Inter.buffer) (Hword_stk : word_has_stack_semantics word stk) (stk' : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hpop : pop_spec (prod_rhs_rev prod) stk (prod_action prod) stk' sem) (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : match\n  match\n    goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n    return\n      (thunkP\n         (goto = None ->\n          match state_of_stack init stk' with\n          | Init i => prod_lhs prod = start_nt i\n          | Ninit _ => False\n          end) -> step_result init)\n  with\n  | Some s =>\n      let\n        (state_new, e) as s0\n         return\n           (thunkP\n              (Some s0 = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) -> step_result init) := s in\n      fun\n        _ : thunkP\n              (Some\n                 (exist\n                    (fun s0 : noninitstate =>\n                     NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                    state_new e) = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n              (last_symb_of_non_init_state state_new) e) :: stk') buffer\n  | None =>\n      fun\n        Hval : thunkP\n                 (None = None ->\n                  match state_of_stack init stk' with\n                  | Init i => prod_lhs prod = start_nt i\n                  | Ninit _ => False\n                  end) =>\n      Accept_sr\n        (cast symbol_semantic_type\n           (reduce_step_subproof0 init prod stk' Hval) sem) buffer\n  end\n    (fun _ : True =>\n     reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv'))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem0 buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      buffer = buffer_new /\\ pt_sem pt = sem0\n| Progress_sr stk'0 buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics word stk'0\nend.","proofString":"apply pop_spec_ptl with (word_stk := word) in Hpop=>//.\ndestruct Hpop as (word1 & word2 & ptl & <- & Hword1 & <-).\ngeneralize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')).\ndestruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (word : list token) (buffer : Inter.buffer) (Hword_stk : word_has_stack_semantics word stk) (stk' : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hpop : exists\n  (word_stk' word_res : list token) (ptl : parse_tree_list\n                                             (prod_rhs_rev prod) word_res),\n  word_stk' ++ word_res = word /\\\n  word_has_stack_semantics word_stk' stk' /\\\n  ptl_sem ptl (prod_action prod) = sem) (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : match\n  match\n    goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n    return\n      (thunkP\n         (goto = None ->\n          match state_of_stack init stk' with\n          | Init i => prod_lhs prod = start_nt i\n          | Ninit _ => False\n          end) -> step_result init)\n  with\n  | Some s =>\n      let\n        (state_new, e) as s0\n         return\n           (thunkP\n              (Some s0 = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) -> step_result init) := s in\n      fun\n        _ : thunkP\n              (Some\n                 (exist\n                    (fun s0 : noninitstate =>\n                     NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                    state_new e) = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n              (last_symb_of_non_init_state state_new) e) :: stk') buffer\n  | None =>\n      fun\n        Hval : thunkP\n                 (None = None ->\n                  match state_of_stack init stk' with\n                  | Init i => prod_lhs prod = start_nt i\n                  | Ninit _ => False\n                  end) =>\n      Accept_sr\n        (cast symbol_semantic_type\n           (reduce_step_subproof0 init prod stk' Hval) sem) buffer\n  end\n    (fun _ : True =>\n     reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv'))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem0 buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      buffer = buffer_new /\\ pt_sem pt = sem0\n| Progress_sr stk'0 buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics word stk'0\nend.","proofString":"destruct Hpop as (word1 & word2 & ptl & <- & Hword1 & <-).\ngeneralize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')).\ndestruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : match\n  match\n    goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n    return\n      (thunkP\n         (goto = None ->\n          match state_of_stack init stk' with\n          | Init i => prod_lhs prod = start_nt i\n          | Ninit _ => False\n          end) -> step_result init)\n  with\n  | Some s =>\n      let\n        (state_new, e) as s0\n         return\n           (thunkP\n              (Some s0 = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) -> step_result init) := s in\n      fun\n        _ : thunkP\n              (Some\n                 (exist\n                    (fun s0 : noninitstate =>\n                     NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                    state_new e) = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n              (ptl_sem ptl (prod_action prod))\n              (last_symb_of_non_init_state state_new) e) :: stk') buffer\n  | None =>\n      fun\n        Hval : thunkP\n                 (None = None ->\n                  match state_of_stack init stk' with\n                  | Init i => prod_lhs prod = start_nt i\n                  | Ninit _ => False\n                  end) =>\n      Accept_sr\n        (cast symbol_semantic_type\n           (reduce_step_subproof0 init prod stk' Hval)\n           (ptl_sem ptl (prod_action prod))) buffer\n  end\n    (fun _ : True =>\n     reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv'))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) (word1 ++ word2),\n      buffer = buffer_new /\\ pt_sem pt = sem\n| Progress_sr stk'0 buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics (word1 ++ word2) stk'0\nend.","proofString":"generalize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')).\ndestruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : forall\n  y : goto_table (state_of_stack init stk') (prod_lhs prod) = None ->\n      match state_of_stack init stk' with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nmatch\n  match\n    goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n    return\n      (thunkP\n         (goto = None ->\n          match state_of_stack init stk' with\n          | Init i => prod_lhs prod = start_nt i\n          | Ninit _ => False\n          end) -> step_result init)\n  with\n  | Some s =>\n      let\n        (state_new, e) as s0\n         return\n           (thunkP\n              (Some s0 = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) -> step_result init) := s in\n      fun\n        _ : thunkP\n              (Some\n                 (exist\n                    (fun s0 : noninitstate =>\n                     NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                    state_new e) = None ->\n               match state_of_stack init stk' with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n              (ptl_sem ptl (prod_action prod))\n              (last_symb_of_non_init_state state_new) e) :: stk') buffer\n  | None =>\n      fun\n        Hval : thunkP\n                 (None = None ->\n                  match state_of_stack init stk' with\n                  | Init i => prod_lhs prod = start_nt i\n                  | Ninit _ => False\n                  end) =>\n      Accept_sr\n        (cast symbol_semantic_type\n           (reduce_step_subproof0 init prod stk' Hval)\n           (ptl_sem ptl (prod_action prod))) buffer\n  end (fun _ : True => y)\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) (word1 ++ word2),\n      buffer = buffer_new /\\ pt_sem pt = sem\n| Progress_sr stk'0 buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics (word1 ++ word2) stk'0\nend.","proofString":"destruct goto_table as [[st' EQ]|].\nintros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor.\nintros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (st' : noninitstate) (EQ : NT (prod_lhs prod) = last_symb_of_non_init_state st') : (Some\n   (exist\n      (fun s : noninitstate =>\n       NT (prod_lhs prod) = last_symb_of_non_init_state s) st' EQ) = None ->\n match state_of_stack init stk' with\n | Init i => prod_lhs prod = start_nt i\n | Ninit _ => False\n end) ->\nbuffer = buffer /\\\nword_has_stack_semantics (word1 ++ word2)\n  (existT noninitstate_type st'\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n        (ptl_sem ptl (prod_action prod)) (last_symb_of_non_init_state st') EQ)\n   :: stk').","proofString":"intros _.\nsplit=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (st' : noninitstate) (EQ : NT (prod_lhs prod) = last_symb_of_non_init_state st') : buffer = buffer /\\\nword_has_stack_semantics (word1 ++ word2)\n  (existT noninitstate_type st'\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n        (ptl_sem ptl (prod_action prod)) (last_symb_of_non_init_state st') EQ)\n   :: stk').","proofString":"split=>//.\nchange (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (st' : noninitstate) (EQ : NT (prod_lhs prod) = last_symb_of_non_init_state st') : word_has_stack_semantics (word1 ++ word2)\n  (existT noninitstate_type st'\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n        (ptl_sem ptl (prod_action prod)) (last_symb_of_non_init_state st') EQ)\n   :: stk').","proofString":"change (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (st' : noninitstate) (EQ : NT (prod_lhs prod) = last_symb_of_non_init_state st') : word_has_stack_semantics (word1 ++ word2)\n  (existT noninitstate_type st'\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n        (pt_sem (Non_terminal_pt prod ptl)) (last_symb_of_non_init_state st')\n        EQ) :: stk').","proofString":"generalize (Non_terminal_pt prod ptl).\nrewrite ->EQ.\nintros pt.\nby constructor."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (st' : noninitstate) (EQ : NT (prod_lhs prod) = last_symb_of_non_init_state st') : forall p : parse_tree (NT (prod_lhs prod)) word2,\nword_has_stack_semantics (word1 ++ word2)\n  (existT noninitstate_type st'\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type \n        (pt_sem p) (last_symb_of_non_init_state st') EQ) :: stk').","proofString":"rewrite ->EQ.\nintros pt.\nby constructor."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (st' : noninitstate) (EQ : NT (prod_lhs prod) = last_symb_of_non_init_state st') : forall p : parse_tree (last_symb_of_non_init_state st') word2,\nword_has_stack_semantics (word1 ++ word2)\n  (existT noninitstate_type st'\n     (eq_rect (last_symb_of_non_init_state st') symbol_semantic_type\n        (pt_sem p) (last_symb_of_non_init_state st') eq_refl) :: stk').","proofString":"intros pt.\nby constructor."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (st' : noninitstate) (EQ : NT (prod_lhs prod) = last_symb_of_non_init_state st') (pt : parse_tree (last_symb_of_non_init_state st') word2) : word_has_stack_semantics (word1 ++ word2)\n  (existT noninitstate_type st'\n     (eq_rect (last_symb_of_non_init_state st') symbol_semantic_type\n        (pt_sem pt) (last_symb_of_non_init_state st') eq_refl) :: stk').","proofString":"by constructor."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : forall\n  y : None = None ->\n      match state_of_stack init stk' with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nexists pt : parse_tree (NT (start_nt init)) (word1 ++ word2),\n  buffer = buffer /\\\n  pt_sem pt =\n  cast symbol_semantic_type\n    (reduce_step_subproof0 init prod stk' (fun _ : True => y))\n    (ptl_sem ptl (prod_action prod)).","proofString":"intros Hstk'.\ndestruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word1 word2 : list token) (Hword_stk : word_has_stack_semantics (word1 ++ word2) stk) (stk' : stack) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hword1 : word_has_stack_semantics word1 stk') (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init stk')\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (Hstk' : None = None ->\nmatch state_of_stack init stk' with\n| Init i => prod_lhs prod = start_nt i\n| Ninit _ => False\nend) : exists pt : parse_tree (NT (start_nt init)) (word1 ++ word2),\n  buffer = buffer /\\\n  pt_sem pt =\n  cast symbol_semantic_type\n    (reduce_step_subproof0 init prod stk' (fun _ : True => Hstk'))\n    (ptl_sem ptl (prod_action prod)).","proofString":"destruct Hword1; [|by destruct Hstk'].\ngeneralize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (prod : production) (Hv : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (buffer : Inter.buffer) (word2 : list token) (Hword_stk : word_has_stack_semantics ([] ++ word2) stk) (ptl : parse_tree_list (prod_rhs_rev prod) word2) (Hv' : ValidSafe.state_valid_after_pop (state_of_stack init []) \n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) (Hstk' : None = None ->\nmatch state_of_stack init [] with\n| Init i => prod_lhs prod = start_nt i\n| Ninit _ => False\nend) : exists pt : parse_tree (NT (start_nt init)) ([] ++ word2),\n  buffer = buffer /\\\n  pt_sem pt =\n  cast symbol_semantic_type\n    (reduce_step_subproof0 init prod [] (fun _ : True => Hstk'))\n    (ptl_sem ptl (prod_action prod)).","proofString":"generalize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')).\nsimpl in Hstk'.\nrewrite -Hstk' // => EQ.\nrewrite cast_eq.\nexists (Non_terminal_pt prod ptl).\nby split."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) : match step safe init stk buffer Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"unfold step.\ngeneralize (reduce_ok safe (state_of_stack init stk)).\ndestruct action_table as [prod|awt].\nintros Hv.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word buffer) in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto.\ndestruct buffer as [tok buffer]=>/=.\nmove=> /(_ (token_term tok)) Hv.\ndestruct (awt (token_term tok)) as [st EQ|prod|]=>//.\neexists _.\nsplit; [by apply app_buf_assoc with (l2 := [_])|].\nchange (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer))        in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) : match\n  match\n    action_table (state_of_stack init stk) as a\n    return\n      (thunkP\n         match a with\n         | Default_reduce_act prod =>\n             ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n         | Lookahead_act awt =>\n             forall t : terminal,\n             match awt t with\n             | Reduce_act p =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) p\n             | _ => True\n             end\n         end -> step_result init)\n  with\n  | Default_reduce_act prod =>\n      fun\n        Hv : thunkP\n               (ValidSafe.valid_for_reduce (state_of_stack init stk) prod) =>\n      reduce_step init stk prod buffer Hv Hi\n  | Lookahead_act awt =>\n      fun\n        Hv : thunkP\n               (forall t : terminal,\n                match awt t with\n                | Reduce_act p =>\n                    ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                | _ => True\n                end) =>\n      match\n        awt (token_term (buf_head buffer)) as a\n        return\n          (thunkP\n             match a with\n             | Reduce_act p =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) p\n             | _ => True\n             end -> step_result init)\n      with\n      | Shift_act state_new e =>\n          fun _ : thunkP True =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (T (token_term (buf_head buffer)))\n                  symbol_semantic_type (token_sem (buf_head buffer))\n                  (last_symb_of_non_init_state state_new) e) :: stk)\n            (buf_tail buffer)\n      | Reduce_act prod =>\n          fun\n            Hv0 : thunkP\n                    (ValidSafe.valid_for_reduce (state_of_stack init stk)\n                       prod) => reduce_step init stk prod buffer Hv0 Hi\n      | Fail_act =>\n          fun _ : thunkP True =>\n          Fail_sr_full (state_of_stack init stk) (buf_head buffer)\n      end (fun _ : True => Hv I (token_term (buf_head buffer)))\n  end (fun _ : True => reduce_ok safe (state_of_stack init stk))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"generalize (reduce_ok safe (state_of_stack init stk)).\ndestruct action_table as [prod|awt].\nintros Hv.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word buffer) in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto.\ndestruct buffer as [tok buffer]=>/=.\nmove=> /(_ (token_term tok)) Hv.\ndestruct (awt (token_term tok)) as [st EQ|prod|]=>//.\neexists _.\nsplit; [by apply app_buf_assoc with (l2 := [_])|].\nchange (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer))        in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch\n  match\n    action_table (state_of_stack init stk) as a\n    return\n      (thunkP\n         match a with\n         | Default_reduce_act prod =>\n             ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n         | Lookahead_act awt =>\n             forall t : terminal,\n             match awt t with\n             | Reduce_act p =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) p\n             | _ => True\n             end\n         end -> step_result init)\n  with\n  | Default_reduce_act prod =>\n      fun\n        Hv : thunkP\n               (ValidSafe.valid_for_reduce (state_of_stack init stk) prod) =>\n      reduce_step init stk prod buffer Hv Hi\n  | Lookahead_act awt =>\n      fun\n        Hv : thunkP\n               (forall t : terminal,\n                match awt t with\n                | Reduce_act p =>\n                    ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                | _ => True\n                end) =>\n      match\n        awt (token_term (buf_head buffer)) as a\n        return\n          (thunkP\n             match a with\n             | Reduce_act p =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) p\n             | _ => True\n             end -> step_result init)\n      with\n      | Shift_act state_new e =>\n          fun _ : thunkP True =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (T (token_term (buf_head buffer)))\n                  symbol_semantic_type (token_sem (buf_head buffer))\n                  (last_symb_of_non_init_state state_new) e) :: stk)\n            (buf_tail buffer)\n      | Reduce_act prod =>\n          fun\n            Hv0 : thunkP\n                    (ValidSafe.valid_for_reduce (state_of_stack init stk)\n                       prod) => reduce_step init stk prod buffer Hv0 Hi\n      | Fail_act =>\n          fun _ : thunkP True =>\n          Fail_sr_full (state_of_stack init stk) (buf_head buffer)\n      end (fun _ : True => Hv I (token_term (buf_head buffer)))\n  end (fun _ : True => y)\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"destruct action_table as [prod|awt].\nintros Hv.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word buffer) in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto.\ndestruct buffer as [tok buffer]=>/=.\nmove=> /(_ (token_term tok)) Hv.\ndestruct (awt (token_term tok)) as [st EQ|prod|]=>//.\neexists _.\nsplit; [by apply app_buf_assoc with (l2 := [_])|].\nchange (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer))        in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (prod : production) : forall y : ValidSafe.valid_for_reduce (state_of_stack init stk) prod,\nmatch reduce_step init stk prod buffer (fun _ : True => y) Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"intros Hv.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word buffer) in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) : match reduce_step init stk prod buffer (fun _ : True => Hv) Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"apply (reduce_step_invariant stk prod (fun _ => Hv) Hi word buffer) in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) (Hword_stk : match reduce_step init stk prod buffer (fun _ : True => Hv) Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      buffer = buffer_new /\\ pt_sem pt = sem\n| Progress_sr stk' buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics word stk'\nend) : match reduce_step init stk prod buffer (fun _ : True => Hv) Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"destruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) (s : symbol_semantic_type (NT (start_nt init))) (b : Inter.buffer) (Hword_stk : exists pt : parse_tree (NT (start_nt init)) word, buffer = b /\\ pt_sem pt = s) : exists\n  (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n  (word ++ buffer)%buf = (word_new ++ b)%buf /\\ pt_sem pt = s.","proofString":"destruct Hword_stk as (pt & <- & <-); eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) (s : stack) (b : Inter.buffer) (Hword_stk : buffer = b /\\ word_has_stack_semantics word s) : exists word_new : list token,\n  (word ++ buffer)%buf = (word_new ++ b)%buf /\\\n  word_has_stack_semantics word_new s.","proofString":"destruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) : forall\n  y : forall t : terminal,\n      match awt t with\n      | Reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | _ => True\n      end,\nmatch\n  match\n    awt (token_term (buf_head buffer)) as a\n    return\n      (thunkP\n         match a with\n         | Reduce_act p =>\n             ValidSafe.valid_for_reduce (state_of_stack init stk) p\n         | _ => True\n         end -> step_result init)\n  with\n  | Shift_act state_new e =>\n      fun _ : thunkP True =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (T (token_term (buf_head buffer))) symbol_semantic_type\n              (token_sem (buf_head buffer))\n              (last_symb_of_non_init_state state_new) e) :: stk)\n        (buf_tail buffer)\n  | Reduce_act prod =>\n      fun\n        Hv : thunkP\n               (ValidSafe.valid_for_reduce (state_of_stack init stk) prod) =>\n      reduce_step init stk prod buffer Hv Hi\n  | Fail_act =>\n      fun _ : thunkP True =>\n      Fail_sr_full (state_of_stack init stk) (buf_head buffer)\n  end (fun _ : True => y (token_term (buf_head buffer)))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"destruct buffer as [tok buffer]=>/=.\nmove=> /(_ (token_term tok)) Hv.\ndestruct (awt (token_term tok)) as [st EQ|prod|]=>//.\neexists _.\nsplit; [by apply app_buf_assoc with (l2 := [_])|].\nchange (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer))        in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) : forall\n  y : forall t : terminal,\n      match awt t with\n      | Reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | _ => True\n      end,\nmatch\n  match\n    awt (token_term tok) as a\n    return\n      (thunkP\n         match a with\n         | Reduce_act p =>\n             ValidSafe.valid_for_reduce (state_of_stack init stk) p\n         | _ => True\n         end -> step_result init)\n  with\n  | Shift_act state_new e =>\n      fun _ : thunkP True =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (T (token_term tok)) symbol_semantic_type \n              (token_sem tok) (last_symb_of_non_init_state state_new) e)\n         :: stk) buffer\n  | Reduce_act prod =>\n      fun\n        Hv : thunkP\n               (ValidSafe.valid_for_reduce (state_of_stack init stk) prod) =>\n      reduce_step init stk prod (tok :: buffer) Hv Hi\n  | Fail_act =>\n      fun _ : thunkP True => Fail_sr_full (state_of_stack init stk) tok\n  end (fun _ : True => y (token_term tok))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"move=> /(_ (token_term tok)) Hv.\ndestruct (awt (token_term tok)) as [st EQ|prod|]=>//.\neexists _.\nsplit; [by apply app_buf_assoc with (l2 := [_])|].\nchange (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer))        in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (Hv : match awt (token_term tok) with\n| Reduce_act p => ValidSafe.valid_for_reduce (state_of_stack init stk) p\n| _ => True\nend) : match\n  match\n    awt (token_term tok) as a\n    return\n      (thunkP\n         match a with\n         | Reduce_act p =>\n             ValidSafe.valid_for_reduce (state_of_stack init stk) p\n         | _ => True\n         end -> step_result init)\n  with\n  | Shift_act state_new e =>\n      fun _ : thunkP True =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (T (token_term tok)) symbol_semantic_type \n              (token_sem tok) (last_symb_of_non_init_state state_new) e)\n         :: stk) buffer\n  | Reduce_act prod =>\n      fun\n        Hv0 : thunkP\n                (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n      => reduce_step init stk prod (tok :: buffer) Hv0 Hi\n  | Fail_act =>\n      fun _ : thunkP True => Fail_sr_full (state_of_stack init stk) tok\n  end (fun _ : True => Hv)\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"destruct (awt (token_term tok)) as [st EQ|prod|]=>//.\neexists _.\nsplit; [by apply app_buf_assoc with (l2 := [_])|].\nchange (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor.\napply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer))        in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (st : noninitstate) (EQ : T (token_term tok) = last_symb_of_non_init_state st) (Hv : True) : exists word_new : list token,\n  (word ++ tok :: buffer)%buf = (word_new ++ buffer)%buf /\\\n  word_has_stack_semantics word_new\n    (existT noninitstate_type st\n       (eq_rect (T (token_term tok)) symbol_semantic_type \n          (token_sem tok) (last_symb_of_non_init_state st) EQ) :: stk).","proofString":"eexists _.\nsplit; [by apply app_buf_assoc with (l2 := [_])|].\nchange (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (st : noninitstate) (EQ : T (token_term tok) = last_symb_of_non_init_state st) (Hv : True) : word_has_stack_semantics (word ++ [tok])\n  (existT noninitstate_type st\n     (eq_rect (T (token_term tok)) symbol_semantic_type \n        (token_sem tok) (last_symb_of_non_init_state st) EQ) :: stk).","proofString":"change (token_sem tok) with (pt_sem (Terminal_pt tok)).\ngeneralize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (st : noninitstate) (EQ : T (token_term tok) = last_symb_of_non_init_state st) (Hv : True) : word_has_stack_semantics (word ++ [tok])\n  (existT noninitstate_type st\n     (eq_rect (T (token_term tok)) symbol_semantic_type\n        (pt_sem (Terminal_pt tok)) (last_symb_of_non_init_state st) EQ)\n   :: stk).","proofString":"generalize (Terminal_pt tok).\ngeneralize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (st : noninitstate) (EQ : T (token_term tok) = last_symb_of_non_init_state st) (Hv : True) : forall p : parse_tree (T (token_term tok)) [tok],\nword_has_stack_semantics (word ++ [tok])\n  (existT noninitstate_type st\n     (eq_rect (T (token_term tok)) symbol_semantic_type \n        (pt_sem p) (last_symb_of_non_init_state st) EQ) :: stk).","proofString":"generalize [tok].\nrewrite -> EQ=>word' pt /=.\nby constructor."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (st : noninitstate) (EQ : T (token_term tok) = last_symb_of_non_init_state st) (Hv : True) : forall (l : list token) (p : parse_tree (T (token_term tok)) l),\nword_has_stack_semantics (word ++ l)\n  (existT noninitstate_type st\n     (eq_rect (T (token_term tok)) symbol_semantic_type \n        (pt_sem p) (last_symb_of_non_init_state st) EQ) :: stk).","proofString":"rewrite -> EQ=>word' pt /=.\nby constructor."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (st : noninitstate) (EQ : T (token_term tok) = last_symb_of_non_init_state st) (Hv : True) (word' : list token) (pt : parse_tree (last_symb_of_non_init_state st) word') : word_has_stack_semantics (word ++ word')\n  (existT noninitstate_type st (pt_sem pt) :: stk).","proofString":"by constructor."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (Hword_stk : word_has_stack_semantics word stk) (awt : forall term : terminal, lookahead_action term) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) : match reduce_step init stk prod (tok :: buffer) (fun _ : True => Hv) Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"apply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer))        in Hword_stk.\ndestruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) (Hword_stk : match reduce_step init stk prod (tok :: buffer) (fun _ : True => Hv) Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word,\n      (tok :: buffer)%buf = buffer_new /\\ pt_sem pt = sem\n| Progress_sr stk' buffer_new =>\n    (tok :: buffer)%buf = buffer_new /\\ word_has_stack_semantics word stk'\nend) (awt : forall term : terminal, lookahead_action term) : match reduce_step init stk prod (tok :: buffer) (fun _ : True => Hv) Hi with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ tok :: buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"destruct reduce_step=>//.\ndestruct Hword_stk as (pt & <- & <-); eauto.\ndestruct Hword_stk as [<- ?]; eauto."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) (s : symbol_semantic_type (NT (start_nt init))) (b : Inter.buffer) (Hword_stk : exists pt : parse_tree (NT (start_nt init)) word,\n  (tok :: buffer)%buf = b /\\ pt_sem pt = s) (awt : forall term : terminal, lookahead_action term) : exists\n  (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n  (word ++ tok :: buffer)%buf = (word_new ++ b)%buf /\\ pt_sem pt = s.","proofString":"destruct Hword_stk as (pt & <- & <-); eauto."},{"statement":"(stk : stack) (word : list token) (tok : token) (buffer : Inter.buffer) (safe : ValidSafe.safe) (Hi : thunkP (stack_invariant init stk)) (prod : production) (Hv : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) (s : stack) (b : Inter.buffer) (Hword_stk : (tok :: buffer)%buf = b /\\ word_has_stack_semantics word s) (awt : forall term : terminal, lookahead_action term) : exists word_new : list token,\n  (word ++ tok :: buffer)%buf = (word_new ++ b)%buf /\\\n  word_has_stack_semantics word_new s.","proofString":"destruct Hword_stk as [<- ?]; eauto."},{"statement":"(safe : ValidSafe.safe) (log_n_steps : nat) : forall (stk : stack) (word : list token) (buffer0 : buffer)\n  (Hi : thunkP (stack_invariant init stk)),\nword_has_stack_semantics word stk ->\nmatch proj1_sig (parse_fix safe init stk buffer0 log_n_steps Hi) with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"induction log_n_steps as [|log_n_steps IH]=>/= stk word buffer Hi Hstk;    [by apply step_invariant|].\nassert (IH1 := IH stk word buffer Hi Hstk).\ndestruct parse_fix as [[] Hi']=>/=; try by apply IH1.\ndestruct IH1 as (word' & -> & Hstk')=>//.\nby apply IH."},{"statement":"(safe : ValidSafe.safe) (log_n_steps : nat) (IH : forall (stk0 : stack) (word0 : list token) (buffer0 : Inter.buffer)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nword_has_stack_semantics word0 stk0 ->\nmatch proj1_sig (parse_fix safe init stk0 buffer0 log_n_steps Hi0) with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word0 ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\\n      pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word0 ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend) (stk : stack) (word : list token) (buffer : Inter.buffer) (Hi : thunkP (stack_invariant init stk)) (Hstk : word_has_stack_semantics word stk) : match\n  proj1_sig\n    (let (x, Hi') := parse_fix safe init stk buffer log_n_steps Hi in\n     match\n       x as x0\n       return\n         ((forall (stk' : stack) (buffer' : Inter.buffer),\n           x0 = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n          {sr : step_result init\n          | forall (stk' : stack) (buffer' : Inter.buffer),\n            sr = Progress_sr stk' buffer' -> stack_invariant init stk'})\n     with\n     | Fail_sr_full s t =>\n         fun\n           Hi'0 : forall (stk' : stack) (buffer' : Inter.buffer),\n                  Fail_sr_full s t = Progress_sr stk' buffer' ->\n                  stack_invariant init stk' =>\n         exist\n           (fun sr : step_result init =>\n            forall (stk' : stack) (buffer' : Inter.buffer),\n            sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n           (Fail_sr_full s t) Hi'0\n     | Accept_sr s b =>\n         fun\n           Hi'0 : forall (stk' : stack) (buffer' : Inter.buffer),\n                  Accept_sr s b = Progress_sr stk' buffer' ->\n                  stack_invariant init stk' =>\n         exist\n           (fun sr : step_result init =>\n            forall (stk' : stack) (buffer' : Inter.buffer),\n            sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n           (Accept_sr s b) Hi'0\n     | Progress_sr stk0 buffer0 =>\n         fun\n           Hi'0 : forall (stk' : stack) (buffer' : Inter.buffer),\n                  Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                  stack_invariant init stk' =>\n         parse_fix safe init stk0 buffer0 log_n_steps\n           (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n     end Hi')\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"assert (IH1 := IH stk word buffer Hi Hstk).\ndestruct parse_fix as [[] Hi']=>/=; try by apply IH1.\ndestruct IH1 as (word' & -> & Hstk')=>//.\nby apply IH."},{"statement":"(safe : ValidSafe.safe) (log_n_steps : nat) (IH : forall (stk0 : stack) (word0 : list token) (buffer0 : Inter.buffer)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nword_has_stack_semantics word0 stk0 ->\nmatch proj1_sig (parse_fix safe init stk0 buffer0 log_n_steps Hi0) with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word0 ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\\n      pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word0 ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend) (stk : stack) (word : list token) (buffer : Inter.buffer) (Hi : thunkP (stack_invariant init stk)) (Hstk : word_has_stack_semantics word stk) (IH1 : match proj1_sig (parse_fix safe init stk buffer log_n_steps Hi) with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend) : match\n  proj1_sig\n    (let (x, Hi') := parse_fix safe init stk buffer log_n_steps Hi in\n     match\n       x as x0\n       return\n         ((forall (stk' : stack) (buffer' : Inter.buffer),\n           x0 = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n          {sr : step_result init\n          | forall (stk' : stack) (buffer' : Inter.buffer),\n            sr = Progress_sr stk' buffer' -> stack_invariant init stk'})\n     with\n     | Fail_sr_full s t =>\n         fun\n           Hi'0 : forall (stk' : stack) (buffer' : Inter.buffer),\n                  Fail_sr_full s t = Progress_sr stk' buffer' ->\n                  stack_invariant init stk' =>\n         exist\n           (fun sr : step_result init =>\n            forall (stk' : stack) (buffer' : Inter.buffer),\n            sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n           (Fail_sr_full s t) Hi'0\n     | Accept_sr s b =>\n         fun\n           Hi'0 : forall (stk' : stack) (buffer' : Inter.buffer),\n                  Accept_sr s b = Progress_sr stk' buffer' ->\n                  stack_invariant init stk' =>\n         exist\n           (fun sr : step_result init =>\n            forall (stk' : stack) (buffer' : Inter.buffer),\n            sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n           (Accept_sr s b) Hi'0\n     | Progress_sr stk0 buffer0 =>\n         fun\n           Hi'0 : forall (stk' : stack) (buffer' : Inter.buffer),\n                  Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                  stack_invariant init stk' =>\n         parse_fix safe init stk0 buffer0 log_n_steps\n           (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n     end Hi')\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"destruct parse_fix as [[] Hi']=>/=; try by apply IH1.\ndestruct IH1 as (word' & -> & Hstk')=>//.\nby apply IH."},{"statement":"(safe : ValidSafe.safe) (log_n_steps : nat) (IH : forall (stk0 : stack) (word0 : list token) (buffer0 : Inter.buffer)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nword_has_stack_semantics word0 stk0 ->\nmatch proj1_sig (parse_fix safe init stk0 buffer0 log_n_steps Hi0) with\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word0 ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\\n      pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word0 ++ buffer0)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend) (stk : stack) (word : list token) (buffer : Inter.buffer) (Hi : thunkP (stack_invariant init stk)) (Hstk : word_has_stack_semantics word stk) (s : stack) (b : Inter.buffer) (Hi' : forall (stk' : stack) (buffer' : Inter.buffer),\nProgress_sr s b = Progress_sr stk' buffer' -> stack_invariant init stk') (IH1 : match\n  proj1_sig\n    (exist\n       (fun sr : step_result init =>\n        forall (stk' : stack) (buffer' : Inter.buffer),\n        sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n       (Progress_sr s b) Hi')\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend) : match\n  proj1_sig\n    (parse_fix safe init s b log_n_steps (fun _ : True => Hi' s b eq_refl))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      (word ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend.","proofString":"destruct IH1 as (word' & -> & Hstk')=>//.\nby apply IH."},{"statement":"(safe : ValidSafe.safe) (buffer : Inter.buffer) (log_n_steps : nat) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] buffer log_n_steps (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Parsed_pr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      buffer = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| _ => True\nend.","proofString":"assert (Hparse := parse_fix_invariant [] [] buffer safe log_n_steps                                        (parse_subproof init)).\ndestruct proj1_sig=>//.\napply Hparse.\nconstructor."},{"statement":"(safe : ValidSafe.safe) (buffer : Inter.buffer) (log_n_steps : nat) (Hparse : word_has_stack_semantics [] [] ->\nmatch\n  proj1_sig (parse_fix safe init [] buffer log_n_steps (parse_subproof init))\nwith\n| Fail_sr_full _ _ => True\n| Accept_sr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      ([] ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| Progress_sr stk_new buffer_new =>\n    exists word_new : list token,\n      ([] ++ buffer)%buf = (word_new ++ buffer_new)%buf /\\\n      word_has_stack_semantics word_new stk_new\nend) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] buffer log_n_steps (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Parsed_pr sem buffer_new =>\n    exists\n      (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n      buffer = (word_new ++ buffer_new)%buf /\\ pt_sem pt = sem\n| _ => True\nend.","proofString":"destruct proj1_sig=>//.\napply Hparse.\nconstructor."},{"statement":"(safe : ValidSafe.safe) (buffer : Inter.buffer) (log_n_steps : nat) (s : symbol_semantic_type (NT (start_nt init))) (b : Inter.buffer) (Hparse : word_has_stack_semantics [] [] ->\nexists\n  (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n  ([] ++ buffer)%buf = (word_new ++ b)%buf /\\ pt_sem pt = s) : exists\n  (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n  buffer = (word_new ++ b)%buf /\\ pt_sem pt = s.","proofString":"apply Hparse.\nconstructor."},{"statement":"(safe : ValidSafe.safe) (buffer : Inter.buffer) (log_n_steps : nat) (s : symbol_semantic_type (NT (start_nt init))) (b : Inter.buffer) (Hparse : word_has_stack_semantics [] [] ->\nexists\n  (word_new : list token) (pt : parse_tree (NT (start_nt init)) word_new),\n  ([] ++ buffer)%buf = (word_new ++ b)%buf /\\ pt_sem pt = s) : word_has_stack_semantics [] [].","proofString":"constructor."}]}