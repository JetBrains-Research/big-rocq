[{"statement":"Lemma next_helper C a \n  (IC : is_init ∩₁ E ⊆₁ C)\n  (CE : C ⊆₁ E)\n  (CC : C ⊆₁ dom_cond sb C)\n  (NEXT: next C a) :\n  ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘ ≡ ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘.","proof":"split.\n- unfolder; ins; desc; splits; eauto; eexists; splits; eauto; subst.\nassert (~ is_init a) as NA.\n{\nintros H; apply NEXT, IC.\nsplit; auto.\napply NEXT.\n}\nassert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8.\n- rewrite sb_tid_init'.\nunfold same_tid; unfolder; ins; desf; splits; eauto.\napply NEXT; basic_solver 10.\napply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf.\n"},{"statement":"Lemma next_helper' a T\n      (TCOH : tls_coherent G T)\n      (ICOH : iord_coherent G sc T)\n  (NEXT: next (covered T) a) :\n  ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗covered T⦘ ≡ ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘.","proof":"apply next_helper; auto using init_covered, coveredE.\napply dom_rel_to_cond.\neapply dom_sb_covered; eauto.\n"},{"statement":"Lemma next_n_init T e\n        (NEXT : next (covered T) e)\n        (TCOH: tls_coherent G T):\n    ~ Init e.","proof":"intros HH.\napply NEXT.\neapply init_covered; eauto.\nsplit; auto.\napply NEXT.\n"},{"statement":"Lemma issuable_next_w T \n    (TCOH: tls_coherent G T)\n    (ICOH: iord_coherent G sc T):\n    W ∩₁ next (covered T) ⊆₁ issuable G sc T.","proof":"unfold issuable, next.\napply set_subset_inter_r; split.\n{\nbasic_solver 10.\n}\nrewrite !set_interA.\narewrite (dom_cond sb (covered T) ∩₁ set_compl (covered T) ⊆₁ dom_cond sb (covered T)).\n{\nbasic_solver 10.\n}\nrewrite !dom_cond_alt.\nrewrite <- !set_bunion_inter_compat_l.\napply set_subset_bunion_l.\nins.\nrewrite <- !set_bunion_inter_compat_r.\nrewrite set_collect_bunion.\napply set_subset_bunion_r with (a := mkTL ta_issue x).\n2: {\nunfolder.\nins.\ndesc.\neexists.\nsplits; vauto.\n}\nfilter_iord_seq.\nrewrite <- id_inter, set_inter_absorb_l; [| basic_solver].\nrewrite inclusion_restr.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\n{\nassert (T ∩₁ action ↓₁ eq ta_cover ⊆₁ T) as <-; [basic_solver| ].\napply dom_rel_collect_event2; [basic_solver| ].\nrewrite <- COND.\nrewrite fwbob_in_sb.\nbasic_solver.\n}\nassert (T ∩₁ action ↓₁ eq ta_issue ⊆₁ T) as <-; [basic_solver| ].\napply dom_rel_collect_event2; [basic_solver| ].\nrewrite event_collect_eq.\nrewrite ct_end, !seqA.\narewrite (ar ∪ rf ⨾ ppo ∩ same_loc ⊆ (ar ∪ sb)^? ⨾ ar) at 2.\n{\napply inclusion_union_l; [basic_solver|].\nrewrite rfi_union_rfe.\nrewrite rfe_in_ar, ppo_in_ar.\narewrite (rfi ⊆ sb).\nbasic_solver 10.\n}\narewrite (ar ⨾ ⦗W⦘ ⊆ sb).\n{\nunfold imm_s.ar.\nrewrite !seq_union_l.\nrewrite (ar_int_in_sb WF).\nrewrite wf_scD with (sc:=sc); [|by apply IMMCON].\nrewrite (wf_rfeD WF).\ntype_solver.\n}\napply dom_rel_helper_in in COND.\nrewrite COND.\narewrite ((ar ∪ sb)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T ∪₁ issued T⦘ ⨾ (ar ∪ sb)^? ⨾ ⦗covered T⦘).\n2: {\netransitivity.\n2: apply ar_rf_ppo_loc_rt_CI_in_I; eauto.\n{\nbasic_solver 20.\n}\napply IMMCON.\n}\napply dom_rel_helper_in.\nrewrite crE, !seq_union_l, !dom_union, seq_id_l.\nunionL; [basic_solver| |].\n2: {\nrewrite dom_sb_covered; basic_solver.\n}\napply ar_C_in_CI; eauto.\napply IMMCON.\n"}]