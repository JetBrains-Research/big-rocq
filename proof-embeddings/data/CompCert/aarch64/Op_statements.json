{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/Op.v","fileSamples":[{"statement":"(x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) : {{| a32_amount := x; a32_range := Px |} =\n {| a32_amount := y; a32_range := Py |}} +\n{{| a32_amount := x; a32_range := Px |} <>\n {| a32_amount := y; a32_range := Py |}}.","proofString":"destruct (Int.eq_dec x y).\nsubst y.\nassert (Px = Py) by (apply proof_irr).\nsubst Py.\nleft; auto.\nright; congruence."},{"statement":"(x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (e : x = y) : {{| a32_amount := x; a32_range := Px |} =\n {| a32_amount := y; a32_range := Py |}} +\n{{| a32_amount := x; a32_range := Px |} <>\n {| a32_amount := y; a32_range := Py |}}.","proofString":"subst y.\nassert (Px = Py) by (apply proof_irr).\nsubst Py.\nleft; auto."},{"statement":"(x : int) (Px Py : Int.ltu x Int.iwordsize = true) : {{| a32_amount := x; a32_range := Px |} =\n {| a32_amount := x; a32_range := Py |}} +\n{{| a32_amount := x; a32_range := Px |} <>\n {| a32_amount := x; a32_range := Py |}}.","proofString":"assert (Px = Py) by (apply proof_irr).\nsubst Py.\nleft; auto."},{"statement":"(x : int) (Px Py : Int.ltu x Int.iwordsize = true) (H : Px = Py) : {{| a32_amount := x; a32_range := Px |} =\n {| a32_amount := x; a32_range := Py |}} +\n{{| a32_amount := x; a32_range := Px |} <>\n {| a32_amount := x; a32_range := Py |}}.","proofString":"subst Py.\nleft; auto."},{"statement":"(x : int) (Px : Int.ltu x Int.iwordsize = true) : {{| a32_amount := x; a32_range := Px |} =\n {| a32_amount := x; a32_range := Px |}} +\n{{| a32_amount := x; a32_range := Px |} <>\n {| a32_amount := x; a32_range := Px |}}.","proofString":"left; auto."},{"statement":"(x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (n : x <> y) : {{| a32_amount := x; a32_range := Px |} =\n {| a32_amount := y; a32_range := Py |}} +\n{{| a32_amount := x; a32_range := Px |} <>\n {| a32_amount := y; a32_range := Py |}}.","proofString":"right; congruence."},{"statement":"(x : int) (Px : Int.ltu x Int64.iwordsize' = true) (y : int) (Py : Int.ltu y Int64.iwordsize' = true) : {{| a64_amount := x; a64_range := Px |} =\n {| a64_amount := y; a64_range := Py |}} +\n{{| a64_amount := x; a64_range := Px |} <>\n {| a64_amount := y; a64_range := Py |}}.","proofString":"destruct (Int.eq_dec x y).\nsubst y.\nassert (Px = Py) by (apply proof_irr).\nsubst Py.\nleft; auto.\nright; congruence."},{"statement":"(x : int) (Px : Int.ltu x Int64.iwordsize' = true) (y : int) (Py : Int.ltu y Int64.iwordsize' = true) (e : x = y) : {{| a64_amount := x; a64_range := Px |} =\n {| a64_amount := y; a64_range := Py |}} +\n{{| a64_amount := x; a64_range := Px |} <>\n {| a64_amount := y; a64_range := Py |}}.","proofString":"subst y.\nassert (Px = Py) by (apply proof_irr).\nsubst Py.\nleft; auto."},{"statement":"(x : int) (Px Py : Int.ltu x Int64.iwordsize' = true) : {{| a64_amount := x; a64_range := Px |} =\n {| a64_amount := x; a64_range := Py |}} +\n{{| a64_amount := x; a64_range := Px |} <>\n {| a64_amount := x; a64_range := Py |}}.","proofString":"assert (Px = Py) by (apply proof_irr).\nsubst Py.\nleft; auto."},{"statement":"(x : int) (Px Py : Int.ltu x Int64.iwordsize' = true) (H : Px = Py) : {{| a64_amount := x; a64_range := Px |} =\n {| a64_amount := x; a64_range := Py |}} +\n{{| a64_amount := x; a64_range := Px |} <>\n {| a64_amount := x; a64_range := Py |}}.","proofString":"subst Py.\nleft; auto."},{"statement":"(x : int) (Px : Int.ltu x Int64.iwordsize' = true) : {{| a64_amount := x; a64_range := Px |} =\n {| a64_amount := x; a64_range := Px |}} +\n{{| a64_amount := x; a64_range := Px |} <>\n {| a64_amount := x; a64_range := Px |}}.","proofString":"left; auto."},{"statement":"(x : int) (Px : Int.ltu x Int64.iwordsize' = true) (y : int) (Py : Int.ltu y Int64.iwordsize' = true) (n : x <> y) : {{| a64_amount := x; a64_range := Px |} =\n {| a64_amount := y; a64_range := Py |}} +\n{{| a64_amount := x; a64_range := Px |} <>\n {| a64_amount := y; a64_range := Py |}}.","proofString":"right; congruence."},{"statement":"(x y : condition) (H : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"generalize Int.eq_dec Int64.eq_dec eq_shift eq_amount32 eq_amount64; intro.\ndecide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) ->\n(forall x0 y0 : shift, {x0 = y0} + {x0 <> y0}) ->\n(forall x0 y0 : amount32, {x0 = y0} + {x0 <> y0}) ->\n(forall x0 y0 : amount64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(x y : addressing) (H : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H2 : forall x0 y0 : extension, {x0 = y0} + {x0 <> y0}) (H3 : forall x0 y0 : amount64, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(x y : operation) : {x = y} + {x <> y}.","proofString":"generalize Int.eq_dec Int64.eq_dec Ptrofs.eq_dec Float.eq_dec Float32.eq_dec             zeq ident_eq eq_shift eq_extension eq_amount32 eq_amount64             typ_eq eq_condition;   decide equality."},{"statement":"(F : Type) (V : Type) (genv : Genv.t F V) (sp : val) (ofs : ptrofs) : eval_addressing genv sp (Ainstack ofs) nil = Some (Val.offset_ptr sp ofs).","proofString":"reflexivity."},{"statement":"(v1 v2 : val) : Val.has_type (Val.add v1 v2) Tint.","proofString":"unfold Val.has_type, Val.add.\ndestruct v1, v2; simpl; auto."},{"statement":"(v1 v2 : val) : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend.","proofString":"destruct v1, v2; simpl; auto."},{"statement":"(v1 v2 : val) : Val.has_type (Val.sub v1 v2) Tint.","proofString":"unfold Val.has_type, Val.add.\ndestruct v1, v2; simpl; auto."},{"statement":"(v1 v2 : val) : match Val.sub v1 v2 with\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend.","proofString":"destruct v1, v2; simpl; auto."},{"statement":"(v1 v2 : val) : Val.has_type (Val.addl v1 v2) Tlong.","proofString":"unfold Val.has_type, Val.addl.\ndestruct v1, v2; simpl; auto."},{"statement":"(v1 v2 : val) : match\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend.","proofString":"destruct v1, v2; simpl; auto."},{"statement":"(v1 v2 : val) : Val.has_type (Val.subl v1 v2) Tlong.","proofString":"unfold Val.has_type, Val.addl.\ndestruct v1, v2; simpl; auto.\ndestruct (eq_block b b0); auto."},{"statement":"(v1 v2 : val) : match Val.subl v1 v2 with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend.","proofString":"destruct v1, v2; simpl; auto.\ndestruct (eq_block b b0); auto."},{"statement":"(b : block) (i : ptrofs) (b0 : block) (i0 : ptrofs) : match\n  (if eq_block b b0\n   then Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))\n   else Vundef)\nwith\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend.","proofString":"destruct (eq_block b b0); auto."},{"statement":"(sp v : val) (m : mem) (H : Omove <> Omove) : Val.has_type v Tint.","proofString":"congruence."},{"statement":"(n : int) (sp : val) (m : mem) (H : Ointconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(n : int64) (sp : val) (m : mem) (H : Olongconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(n : float) (sp : val) (m : mem) (H : Ofloatconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(n : float32) (sp : val) (m : mem) (H : Osingleconst n <> Omove) : True.","proofString":"exact I."},{"statement":"(v0 v1 sp : val) (m : mem) (H : Oadd <> Omove) : Val.has_type (Val.add v0 v1) Tint.","proofString":"apply type_add."},{"statement":"(s : shift) (a : amount32) (v0 v1 sp : val) (m : mem) (H : Oaddshift s a <> Omove) : Val.has_type (Val.add v0 (eval_shift s v1 a)) Tint.","proofString":"apply type_add."},{"statement":"(n : int) (v0 sp : val) (m : mem) (H : Oaddimm n <> Omove) : Val.has_type (Val.add v0 (Vint n)) Tint.","proofString":"apply type_add."},{"statement":"(v0 v1 sp : val) (m : mem) (H : Osub <> Omove) : Val.has_type (Val.sub v0 v1) Tint.","proofString":"apply type_sub."},{"statement":"(s : shift) (a : amount32) (v0 v1 sp : val) (m : mem) (H : Osubshift s a <> Omove) : Val.has_type (Val.sub v0 (eval_shift s v1 a)) Tint.","proofString":"apply type_sub."},{"statement":"(v0 v1 v2 sp : val) (m : mem) (H : Omuladd <> Omove) : Val.has_type (Val.add v0 (Val.mul v1 v2)) Tint.","proofString":"apply type_add."},{"statement":"(v0 v1 v2 sp : val) (m : mem) (H : Omulsub <> Omove) : Val.has_type (Val.sub v0 (Val.mul v1 v2)) Tint.","proofString":"apply type_sub."},{"statement":"(v0 v1 sp : val) (m : mem) (H : Oaddl <> Omove) : Val.has_type (Val.addl v0 v1) Tlong.","proofString":"apply type_addl."},{"statement":"(s : shift) (a : amount64) (v0 v1 sp : val) (m : mem) (H : Oaddlshift s a <> Omove) : Val.has_type (Val.addl v0 (eval_shiftl s v1 a)) Tlong.","proofString":"apply type_addl."},{"statement":"(x : extension) (a : amount64) (v0 v1 sp : val) (m : mem) (H : Oaddlext x a <> Omove) : Val.has_type (Val.addl v0 (eval_extend x v1 a)) Tlong.","proofString":"apply type_addl."},{"statement":"(n : int64) (v0 sp : val) (m : mem) (H : Oaddlimm n <> Omove) : Val.has_type (Val.addl v0 (Vlong n)) Tlong.","proofString":"apply type_addl."},{"statement":"(v0 v1 sp : val) (m : mem) (H : Osubl <> Omove) : Val.has_type (Val.subl v0 v1) Tlong.","proofString":"apply type_subl."},{"statement":"(s : shift) (a : amount64) (v0 v1 sp : val) (m : mem) (H : Osublshift s a <> Omove) : Val.has_type (Val.subl v0 (eval_shiftl s v1 a)) Tlong.","proofString":"apply type_subl."},{"statement":"(x : extension) (a : amount64) (v0 v1 sp : val) (m : mem) (H : Osublext x a <> Omove) : Val.has_type (Val.subl v0 (eval_extend x v1 a)) Tlong.","proofString":"apply type_subl."},{"statement":"(v0 v1 v2 sp : val) (m : mem) (H : Omulladd <> Omove) : Val.has_type (Val.addl v0 (Val.mull v1 v2)) Tlong.","proofString":"apply type_addl."},{"statement":"(v0 v1 v2 sp : val) (m : mem) (H : Omullsub <> Omove) : Val.has_type (Val.subl v0 (Val.mull v1 v2)) Tlong.","proofString":"apply type_subl."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel cond ty <> Omove) : Val.has_type (Val.select (eval_condition cond vl m) v0 v1 ty) ty.","proofString":"unfold Val.select.\ndestruct (eval_condition cond vl m).\napply Val.normalize_type.\nexact I."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel cond ty <> Omove) : Val.has_type\n  match eval_condition cond vl m with\n  | Some b => Val.normalize (if b then v0 else v1) ty\n  | None => Vundef\n  end ty.","proofString":"destruct (eval_condition cond vl m).\napply Val.normalize_type.\nexact I."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel cond ty <> Omove) (b : bool) : Val.has_type (Val.normalize (if b then v0 else v1) ty) ty.","proofString":"apply Val.normalize_type."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (vl : list val) (sp : val) (m : mem) (H : Osel cond ty <> Omove) : Val.has_type Vundef ty.","proofString":"exact I."},{"statement":"(n : int) : (if zlt (Int.unsigned (Int.zero_ext l n)) (Int.unsigned N)\n then true\n else false) = true.","proofString":"apply zlt_true.\nrewrite N_eq.\napply (Int.zero_ext_range l n).\nassumption."},{"statement":"(n : int) : Int.unsigned (Int.zero_ext l n) < Int.unsigned N.","proofString":"rewrite N_eq.\napply (Int.zero_ext_range l n).\nassumption."},{"statement":"(n : int) : Int.unsigned (Int.zero_ext l n) < two_p l.","proofString":"apply (Int.zero_ext_range l n).\nassumption."},{"statement":"(n : int) : 0 <= l < Int.zwordsize.","proofString":"assumption."},{"statement":"(n : int) (H : Int.ltu n N = true) : Int.zero_ext l n = n.","proofString":"transitivity (Int.repr (Int.unsigned (Int.zero_ext l n))).\nsymmetry; apply Int.repr_unsigned.\ntransitivity (Int.repr (Int.unsigned n)).\nf_equal.\nrewrite Int.zero_ext_mod.\napply Int.ltu_inv in H.\nrewrite N_eq in H.\napply Z.mod_small.\nassumption.\nassumption.\napply Int.repr_unsigned."},{"statement":"(n : int) (H : Int.ltu n N = true) : Int.zero_ext l n = Int.repr (Int.unsigned (Int.zero_ext l n)).","proofString":"symmetry; apply Int.repr_unsigned."},{"statement":"(n : int) (H : Int.ltu n N = true) : Int.repr (Int.unsigned (Int.zero_ext l n)) = n.","proofString":"transitivity (Int.repr (Int.unsigned n)).\nf_equal.\nrewrite Int.zero_ext_mod.\napply Int.ltu_inv in H.\nrewrite N_eq in H.\napply Z.mod_small.\nassumption.\nassumption.\napply Int.repr_unsigned."},{"statement":"(n : int) (H : Int.ltu n N = true) : Int.repr (Int.unsigned (Int.zero_ext l n)) = Int.repr (Int.unsigned n).","proofString":"f_equal.\nrewrite Int.zero_ext_mod.\napply Int.ltu_inv in H.\nrewrite N_eq in H.\napply Z.mod_small.\nassumption.\nassumption."},{"statement":"(n : int) (H : Int.ltu n N = true) : Int.unsigned (Int.zero_ext l n) = Int.unsigned n.","proofString":"rewrite Int.zero_ext_mod.\napply Int.ltu_inv in H.\nrewrite N_eq in H.\napply Z.mod_small.\nassumption.\nassumption."},{"statement":"(n : int) (H : Int.ltu n N = true) : Int.unsigned n mod two_p l = Int.unsigned n.","proofString":"apply Int.ltu_inv in H.\nrewrite N_eq in H.\napply Z.mod_small.\nassumption."},{"statement":"(n : int) (H : 0 <= Int.unsigned n < Int.unsigned N) : Int.unsigned n mod two_p l = Int.unsigned n.","proofString":"rewrite N_eq in H.\napply Z.mod_small.\nassumption."},{"statement":"(n : int) (H : 0 <= Int.unsigned n < two_p l) : Int.unsigned n mod two_p l = Int.unsigned n.","proofString":"apply Z.mod_small.\nassumption."},{"statement":"(n : int) (H : 0 <= Int.unsigned n < two_p l) : 0 <= Int.unsigned n < two_p l.","proofString":"assumption."},{"statement":"(n : int) (H : Int.ltu n N = true) : 0 <= l < Int.zwordsize.","proofString":"assumption."},{"statement":"(n : int) (H : Int.ltu n N = true) : Int.repr (Int.unsigned n) = n.","proofString":"apply Int.repr_unsigned."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : 0 <= 5 < 32.","proofString":"lia."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : Int.unsigned Int.iwordsize = two_p 5.","proofString":"reflexivity."},{"statement":"(n : int) (H : Int.ltu n Int64.iwordsize' = true) : 0 <= 6 < 32.","proofString":"lia."},{"statement":"(n : int) (H : Int.ltu n Int64.iwordsize' = true) : Int.unsigned Int64.iwordsize' = two_p 6.","proofString":"reflexivity."},{"statement":"(A : Type) (op : operation) (args : list A) (a : A) : is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil.","proofString":"unfold is_move_operation; destruct op;  try (intros; discriminate).\ndestruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (args : list A) (a : A) : match args with\n| nil => None\n| arg :: nil => Some arg\n| arg :: _ :: _ => None\nend = Some a -> Omove = Omove /\\ args = a :: nil.","proofString":"destruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a : A) : None = Some a -> Omove = Omove /\\ nil = a :: nil.","proofString":"intros; discriminate."},{"statement":"(A : Type) (a0 : A) (args : list A) (a : A) : match args with\n| nil => Some a0\n| _ :: _ => None\nend = Some a -> Omove = Omove /\\ a0 :: args = a :: nil.","proofString":"destruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a0 a : A) : Some a0 = Some a -> Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intros.\nintuition congruence."},{"statement":"(A : Type) (a0 a : A) (H : Some a0 = Some a) : Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intuition congruence."},{"statement":"(A : Type) (a0 a1 : A) (args : list A) (a : A) : None = Some a -> Omove = Omove /\\ a0 :: a1 :: args = a :: nil.","proofString":"intros; discriminate."},{"statement":"(cond : condition) (vl : list val) (m : mem) : eval_condition (negate_condition cond) vl m =\noption_map negb (eval_condition cond vl m).","proofString":"destruct cond; simpl.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply (Val.negate_cmp_bool Ceq).\nrepeat (destruct vl; auto).\napply (Val.negate_cmp_bool Cne).\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\napply (Val.negate_cmpl_bool Ceq).\nrepeat (destruct vl; auto).\napply (Val.negate_cmpl_bool Cne).\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0) as [[]|]; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v (Vfloat Float.zero)) as [[]|]; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0) as [[]|]; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v (Vsingle Float32.zero)) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmp_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmp_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmp_bool c v v0).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v v0).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (n : int) (v : val) (m : mem) : Val.cmp_bool (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmp_bool c v (Vint n)).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (n : int) (v : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (Vint n)).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (s : shift) (a : amount32) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmp_bool (negate_comparison c) v1 (eval_shift s v2 a)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 (eval_shift s v2 a)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (s : shift) (a : amount32) (v v0 : val) (m : mem) : Val.cmp_bool (negate_comparison c) v (eval_shift s v0 a) =\noption_map negb (Val.cmp_bool c v (eval_shift s v0 a)).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (s : shift) (a : amount32) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1\n      (eval_shift s v2 a)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil =>\n      Val.cmpu_bool (Mem.valid_pointer m) c v1 (eval_shift s v2 a)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (s : shift) (a : amount32) (v v0 : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v\n  (eval_shift s v0 a) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (eval_shift s v0 a)).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool Cne (Val.and v1 (Vint n)) (Vint Int.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool Ceq (Val.and v1 (Vint n)) (Vint Int.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply (Val.negate_cmp_bool Ceq)."},{"statement":"(n : int) (v : val) (m : mem) : Val.cmp_bool Cne (Val.and v (Vint n)) (Vint Int.zero) =\noption_map negb (Val.cmp_bool Ceq (Val.and v (Vint n)) (Vint Int.zero)).","proofString":"apply (Val.negate_cmp_bool Ceq)."},{"statement":"(n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool Ceq (Val.and v1 (Vint n)) (Vint Int.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool Cne (Val.and v1 (Vint n)) (Vint Int.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply (Val.negate_cmp_bool Cne)."},{"statement":"(n : int) (v : val) (m : mem) : Val.cmp_bool Ceq (Val.and v (Vint n)) (Vint Int.zero) =\noption_map negb (Val.cmp_bool Cne (Val.and v (Vint n)) (Vint Int.zero)).","proofString":"apply (Val.negate_cmp_bool Cne)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpl_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpl_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmpl_bool c v v0).","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v v0).","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpl_bool (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpl_bool c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (n : int64) (v : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmpl_bool c v (Vlong n)).","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (n : int64) (v : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v (Vlong n)).","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (s : shift) (a : amount64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpl_bool (negate_comparison c) v1 (eval_shiftl s v2 a)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpl_bool c v1 (eval_shiftl s v2 a)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (s : shift) (a : amount64) (v v0 : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v (eval_shiftl s v0 a) =\noption_map negb (Val.cmpl_bool c v (eval_shiftl s v0 a)).","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (s : shift) (a : amount64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1\n      (eval_shiftl s v2 a)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil =>\n      Val.cmplu_bool (Mem.valid_pointer m) c v1 (eval_shiftl s v2 a)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (s : shift) (a : amount64) (v v0 : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v\n  (eval_shiftl s v0 a) =\noption_map negb\n  (Val.cmplu_bool (Mem.valid_pointer m) c v (eval_shiftl s v0 a)).","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpl_bool Cne (Val.andl v1 (Vlong n)) (Vlong Int64.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpl_bool Ceq (Val.andl v1 (Vlong n)) (Vlong Int64.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply (Val.negate_cmpl_bool Ceq)."},{"statement":"(n : int64) (v : val) (m : mem) : Val.cmpl_bool Cne (Val.andl v (Vlong n)) (Vlong Int64.zero) =\noption_map negb (Val.cmpl_bool Ceq (Val.andl v (Vlong n)) (Vlong Int64.zero)).","proofString":"apply (Val.negate_cmpl_bool Ceq)."},{"statement":"(n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpl_bool Ceq (Val.andl v1 (Vlong n)) (Vlong Int64.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpl_bool Cne (Val.andl v1 (Vlong n)) (Vlong Int64.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply (Val.negate_cmpl_bool Cne)."},{"statement":"(n : int64) (v : val) (m : mem) : Val.cmpl_bool Ceq (Val.andl v (Vlong n)) (Vlong Int64.zero) =\noption_map negb (Val.cmpl_bool Cne (Val.andl v (Vlong n)) (Vlong Int64.zero)).","proofString":"apply (Val.negate_cmpl_bool Cne)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpf_bool c v v0 =\noption_map negb (option_map negb (Val.cmpf_bool c v v0)).","proofString":"destruct (Val.cmpf_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => option_map negb (Val.cmpf_bool c v1 (Vfloat Float.zero))\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpf_bool c v1 (Vfloat Float.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpf_bool c v1 (Vfloat Float.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => option_map negb (Val.cmpf_bool c v1 (Vfloat Float.zero))\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v (Vfloat Float.zero)) as [[]|]; auto."},{"statement":"(c : comparison) (v : val) (m : mem) : Val.cmpf_bool c v (Vfloat Float.zero) =\noption_map negb (option_map negb (Val.cmpf_bool c v (Vfloat Float.zero))).","proofString":"destruct (Val.cmpf_bool c v (Vfloat Float.zero)) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpfs_bool c v v0 =\noption_map negb (option_map negb (Val.cmpfs_bool c v v0)).","proofString":"destruct (Val.cmpfs_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => option_map negb (Val.cmpfs_bool c v1 (Vsingle Float32.zero))\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpfs_bool c v1 (Vsingle Float32.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpfs_bool c v1 (Vsingle Float32.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => option_map negb (Val.cmpfs_bool c v1 (Vsingle Float32.zero))\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v (Vsingle Float32.zero)) as [[]|]; auto."},{"statement":"(c : comparison) (v : val) (m : mem) : Val.cmpfs_bool c v (Vsingle Float32.zero) =\noption_map negb (option_map negb (Val.cmpfs_bool c v (Vsingle Float32.zero))).","proofString":"destruct (Val.cmpfs_bool c v (Vsingle Float32.zero)) as [[]|]; auto."},{"statement":"(delta : Z) (addr : addressing) : type_of_addressing (shift_stack_addressing delta addr) =\ntype_of_addressing addr.","proofString":"destruct addr; auto."},{"statement":"(delta : Z) (op : operation) : type_of_operation (shift_stack_operation delta op) = type_of_operation op.","proofString":"destruct op; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : eval_addressing ge (Vptr sp Ptrofs.zero) (shift_stack_addressing delta addr)\n  vl = eval_addressing ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"destruct addr; simpl; auto.\ndestruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (vl : list val) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta))))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs))\n| _ :: _ => None\nend.","proofString":"destruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (delta : Z) : Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta)))) =\nSome (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs)).","proofString":"rewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (op : operation) (vl : list val) (m : mem) (delta : Z) : eval_operation ge (Vptr sp Ptrofs.zero) (shift_stack_operation delta op) vl m =\neval_operation ge (Vptr sp (Ptrofs.repr delta)) op vl m.","proofString":"destruct op; simpl; auto.\ndestruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (vl : list val) (m : mem) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta))))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs))\n| _ :: _ => None\nend.","proofString":"destruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (m : mem) (delta : Z) : Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta)))) =\nSome (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs)).","proofString":"rewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) : eval_addressing ge sp addr' args = Some (Val.add v (Vint (Int.repr delta))).","proofString":"discriminate."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (op : operation) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory op = false) : eval_operation ge sp op args m1 = eval_operation ge sp op args m2.","proofString":"destruct op; auto.\nsimpl.\nrewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto.\nsimpl.\ndestruct args; auto.\ndestruct args; auto.\nrewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Ocmp cond) = false) : eval_operation ge sp (Ocmp cond) args m1 =\neval_operation ge sp (Ocmp cond) args m2.","proofString":"simpl.\nrewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Ocmp cond) = false) : Some (Val.of_optbool (eval_condition cond args m1)) =\nSome (Val.of_optbool (eval_condition cond args m2)).","proofString":"rewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Ocmp cond) = false) : Some (Val.of_optbool (eval_condition cond args m2)) =\nSome (Val.of_optbool (eval_condition cond args m2)).","proofString":"auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (ty : typ) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Osel cond ty) = false) : eval_operation ge sp (Osel cond ty) args m1 =\neval_operation ge sp (Osel cond ty) args m2.","proofString":"simpl.\ndestruct args; auto.\ndestruct args; auto.\nrewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (ty : typ) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Osel cond ty) = false) : match args with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: vl => Some (Val.select (eval_condition cond vl m1) v1 v2 ty)\nend =\nmatch args with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: vl => Some (Val.select (eval_condition cond vl m2) v1 v2 ty)\nend.","proofString":"destruct args; auto.\ndestruct args; auto.\nrewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (ty : typ) (v : val) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Osel cond ty) = false) : match args with\n| nil => None\n| v2 :: vl => Some (Val.select (eval_condition cond vl m1) v v2 ty)\nend =\nmatch args with\n| nil => None\n| v2 :: vl => Some (Val.select (eval_condition cond vl m2) v v2 ty)\nend.","proofString":"destruct args; auto.\nrewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (ty : typ) (v v0 : val) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Osel cond ty) = false) : Some (Val.select (eval_condition cond args m1) v v0 ty) =\nSome (Val.select (eval_condition cond args m2) v v0 ty).","proofString":"rewrite (cond_depends_on_memory_correct cond args m1 m2 H).\nauto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (ty : typ) (v v0 : val) (args : list val) (m1 m2 : mem) (H : op_depends_on_memory (Osel cond ty) = false) : Some (Val.select (eval_condition cond args m2) v v0 ty) =\nSome (Val.select (eval_condition cond args m2) v v0 ty).","proofString":"auto."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.","proofString":"unfold eval_addressing; destruct addr; auto.\ndestruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) (vl : list val) : match vl with\n| nil => Some (Genv.symbol_address ge2 id ofs)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 id ofs)\n| _ :: _ => None\nend.","proofString":"destruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) : Some (Genv.symbol_address ge2 id ofs) = Some (Genv.symbol_address ge1 id ofs).","proofString":"unfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) : Some\n  match Genv.find_symbol ge2 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end =\nSome\n  match Genv.find_symbol ge1 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"rewrite agree_on_symbols; auto."},{"statement":"(sp : val) (op : operation) (vl : list val) (m : mem) : eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.","proofString":"unfold eval_operation; destruct op; auto.\ndestruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) (vl : list val) (m : mem) : match vl with\n| nil => Some (Genv.symbol_address ge2 id ofs)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 id ofs)\n| _ :: _ => None\nend.","proofString":"destruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) (m : mem) : Some (Genv.symbol_address ge2 id ofs) = Some (Genv.symbol_address ge1 id ofs).","proofString":"unfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) (m : mem) : Some\n  match Genv.find_symbol ge2 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end =\nSome\n  match Genv.find_symbol ge1 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"rewrite agree_on_symbols; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (H : Val.inject_list f vl1 vl2) (H0 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"destruct cond; simpl in H0; FuncInv; InvInject; simpl; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\neauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\ninv H3; simpl in H0; inv H0; auto.\neauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\nrevert H0.\ngeneralize (eval_shift_inject s a H2); intros J; inv H3; inv J; simpl; congruence.\neauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies, eval_shift_inject.\ninv H3; inv H0; auto.\ninv H3; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\neauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies.\ninv H3; simpl in H0; inv H0; auto.\neauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies.\nrevert H0.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H3; inv J; simpl; congruence.\neauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies, eval_shiftl_inject.\ninv H3; inv H0; auto.\ninv H3; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmp_bool c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmp_bool c v' (Vint n) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpu_bool (Mem.valid_pointer m2) c v' (Vint n) = Some b.","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (s : shift) (a : amount32) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v (eval_shift s v0 a) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v' (eval_shift s v'0 a) = Some b.","proofString":"revert H0.\ngeneralize (eval_shift_inject s a H2); intros J; inv H3; inv J; simpl; congruence."},{"statement":"(c : comparison) (s : shift) (a : amount32) (v v0 : val) (b : bool) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v (eval_shift s v0 a) = Some b ->\nVal.cmp_bool c v' (eval_shift s v'0 a) = Some b.","proofString":"generalize (eval_shift_inject s a H2); intros J; inv H3; inv J; simpl; congruence."},{"statement":"(c : comparison) (s : shift) (a : amount32) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (eval_shift s v0 a) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpu_bool (Mem.valid_pointer m2) c v' (eval_shift s v'0 a) = Some b.","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies, eval_shift_inject."},{"statement":"(n : int) (v : val) (b : bool) (H0 : Val.cmp_bool Ceq (Val.and v (Vint n)) (Vint Int.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmp_bool Ceq (Val.and v' (Vint n)) (Vint Int.zero) = Some b.","proofString":"inv H3; inv H0; auto."},{"statement":"(n : int) (v : val) (b : bool) (H0 : Val.cmp_bool Cne (Val.and v (Vint n)) (Vint Int.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmp_bool Cne (Val.and v' (Vint n)) (Vint Int.zero) = Some b.","proofString":"inv H3; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpl_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpl_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmplu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","proofString":"eauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmpl_bool c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpl_bool c v' (Vlong n) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmplu_bool (Mem.valid_pointer m2) c v' (Vlong n) = Some b.","proofString":"eauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (s : shift) (a : amount64) (v v0 : val) (b : bool) (H0 : Val.cmpl_bool c v (eval_shiftl s v0 a) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpl_bool c v' (eval_shiftl s v'0 a) = Some b.","proofString":"revert H0.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H3; inv J; simpl; congruence."},{"statement":"(c : comparison) (s : shift) (a : amount64) (v v0 : val) (b : bool) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpl_bool c v (eval_shiftl s v0 a) = Some b ->\nVal.cmpl_bool c v' (eval_shiftl s v'0 a) = Some b.","proofString":"generalize (eval_shiftl_inject s a H2); intros J; inv H3; inv J; simpl; congruence."},{"statement":"(c : comparison) (s : shift) (a : amount64) (v v0 : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v (eval_shiftl s v0 a) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmplu_bool (Mem.valid_pointer m2) c v' (eval_shiftl s v'0 a) = Some b.","proofString":"eauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies, eval_shiftl_inject."},{"statement":"(n : int64) (v : val) (b : bool) (H0 : Val.cmpl_bool Ceq (Val.andl v (Vlong n)) (Vlong Int64.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpl_bool Ceq (Val.andl v' (Vlong n)) (Vlong Int64.zero) = Some b.","proofString":"inv H3; inv H0; auto."},{"statement":"(n : int64) (v : val) (b : bool) (H0 : Val.cmpl_bool Cne (Val.andl v (Vlong n)) (Vlong Int64.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpl_bool Cne (Val.andl v' (Vlong n)) (Vlong Int64.zero) = Some b.","proofString":"inv H3; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpf_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpf_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpf_bool c v' v'0) = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : Val.cmpf_bool c v (Vfloat Float.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpf_bool c v' (Vfloat Float.zero) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v (Vfloat Float.zero)) = Some b) (v' : val) (H3 : Val.inject f v v') : option_map negb (Val.cmpf_bool c v' (Vfloat Float.zero)) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpfs_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpfs_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpfs_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpfs_bool c v' v'0) = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : Val.cmpfs_bool c v (Vsingle Float32.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpfs_bool c v' (Vsingle Float32.zero) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : option_map negb (Val.cmpfs_bool c v (Vsingle Float32.zero)) = Some b) (v' : val) (H3 : Val.inject f v v') : option_map negb (Val.cmpfs_bool c v' (Vsingle Float32.zero)) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(op : operation) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H1 : eval_operation ge1 sp1 op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation ge2 sp2 op vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct op; simpl in H1; simpl; FuncInv; InvInject; TrivialExists.\napply GL; simpl; auto.\napply Val.offset_ptr_inject; auto.\napply eval_shift_inject; auto.\napply Val.add_inject; auto.\napply Val.add_inject; auto using eval_shift_inject.\napply Val.add_inject; auto.\ninv H4; simpl; auto.\ngeneralize (eval_shift_inject s a H4); intros J; inv J; simpl; auto.\napply Val.sub_inject; auto.\napply Val.sub_inject; auto using eval_shift_inject.\ninv H4; inv H2; simpl; auto.\napply Val.add_inject; auto.\ninv H2; inv H3; simpl; auto.\napply Val.sub_inject; auto.\ninv H2; inv H3; simpl; auto.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ngeneralize (eval_shift_inject s a H4); intros J; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto; rewrite a32_range; auto.\ninv H4; simpl; auto; rewrite a32_range; auto.\ninv H4; simpl; auto; rewrite a32_range; simpl; auto.\ninv H4; simpl; auto; rewrite a32_range; simpl; auto.\napply eval_shiftl_inject; auto.\napply eval_extend_inject; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\napply Val.addl_inject; auto.\napply Val.addl_inject; auto using eval_shiftl_inject.\napply Val.addl_inject; auto using eval_extend_inject.\napply Val.addl_inject; auto.\ninv H4; simpl; auto.\ngeneralize (eval_shiftl_inject s a H4); intros J; inv J; simpl; auto.\napply Val.subl_inject; auto.\napply Val.subl_inject; auto using eval_shiftl_inject.\napply Val.subl_inject; auto using eval_extend_inject.\ninv H4; inv H2; simpl; auto.\napply Val.addl_inject; auto.\ninv H2; inv H3; simpl; auto.\napply Val.subl_inject; auto.\ninv H2; inv H3; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ngeneralize (eval_shiftl_inject s a H4); intros J; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ngeneralize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto; rewrite a64_range; auto.\ninv H4; simpl; auto; rewrite a64_range; auto.\ninv H4; simpl; auto; rewrite a64_range; simpl; auto.\ninv H4; simpl; auto; rewrite a64_range; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\nsubst v1.\ndestruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor.\napply Val.select_inject; auto.\ndestruct (eval_condition cond vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(id : ident) (ofs : ptrofs) (sp1 sp2 : val) (GL : forall (id0 : ident) (ofs0 : ptrofs),\nIn id0 (globals_operation (Oaddrsymbol id ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id0 ofs0)\n  (Genv.symbol_address ge2 id0 ofs0)) (H : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs).","proofString":"apply GL; simpl; auto."},{"statement":"(ofs : ptrofs) (sp1 sp2 : val) (GL : forall (id : ident) (ofs0 : ptrofs),\nIn id (globals_operation (Oaddrstack ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs0)\n  (Genv.symbol_address ge2 id ofs0)) (H : Val.inject f sp1 sp2) : Val.inject f (Val.offset_ptr sp1 ofs) (Val.offset_ptr sp2 ofs).","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (eval_shift s v a) (eval_shift s v' a).","proofString":"apply eval_shift_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oadd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.add v v0) (Val.add v' v'0).","proofString":"apply Val.add_inject; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.add v (eval_shift s v0 a))\n  (Val.add v' (eval_shift s v'0 a)).","proofString":"apply Val.add_inject; auto using eval_shift_inject."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.add v (Vint n)) (Val.add v' (Vint n)).","proofString":"apply Val.add_inject; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oneg) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.neg v) (Val.neg v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Onegshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.neg (eval_shift s v a)) (Val.neg (eval_shift s v' a)).","proofString":"generalize (eval_shift_inject s a H4); intros J; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub v v0) (Val.sub v' v'0).","proofString":"apply Val.sub_inject; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osubshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub v (eval_shift s v0 a))\n  (Val.sub v' (eval_shift s v'0 a)).","proofString":"apply Val.sub_inject; auto using eval_shift_inject."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omul) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mul v v0) (Val.mul v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omuladd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.add v (Val.mul v0 v2)) (Val.add v' (Val.mul v'0 v'1)).","proofString":"apply Val.add_inject; auto.\ninv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omuladd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.mul v0 v2) (Val.mul v'0 v'1).","proofString":"inv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulsub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.sub v (Val.mul v0 v2)) (Val.sub v' (Val.mul v'0 v'1)).","proofString":"apply Val.sub_inject; auto.\ninv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulsub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.mul v0 v2) (Val.mul v'0 v'1).","proofString":"inv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divs v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divs v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val, Val.divs (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divs i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divs i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val, Val.divu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oand) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v v0) (Val.and v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v (eval_shift s v0 a))\n  (Val.and v' (eval_shift s v'0 a)).","proofString":"generalize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.and v (Vint n)) (Val.and v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v v0) (Val.or v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v (eval_shift s v0 a)) (Val.or v' (eval_shift s v'0 a)).","proofString":"generalize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.or v (Vint n)) (Val.or v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v v0) (Val.xor v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v (eval_shift s v0 a))\n  (Val.xor v' (eval_shift s v'0 a)).","proofString":"generalize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xor v (Vint n)) (Val.xor v' (Vint n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onot) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notint v) (Val.notint v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Onotshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notint (eval_shift s v a)) (Val.notint (eval_shift s v' a)).","proofString":"generalize (eval_shift_inject s a H4); intros J; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Obic) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v (Val.notint v0)) (Val.and v' (Val.notint v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Obicshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v (Val.notint (eval_shift s v0 a)))\n  (Val.and v' (Val.notint (eval_shift s v'0 a))).","proofString":"generalize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oorn) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v (Val.notint v0)) (Val.or v' (Val.notint v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oornshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v (Val.notint (eval_shift s v0 a)))\n  (Val.or v' (Val.notint (eval_shift s v'0 a))).","proofString":"generalize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oeqv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v (Val.notint v0)) (Val.xor v' (Val.notint v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount32) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oeqvshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v (Val.notint (eval_shift s v0 a)))\n  (Val.xor v' (Val.notint (eval_shift s v'0 a))).","proofString":"generalize (eval_shift_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shl v v0) (Val.shl v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shr v v0) (Val.shr v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shru v v0) (Val.shru v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrx v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrx v' (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1) : exists v2 : val, Val.shrx (Vint i) (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vint (Int.shrx i n)) = Some v2 /\\\n  Val.inject f (Vint (Int.shrx i n)) v2.","proofString":"TrivialExists."},{"statement":"(s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ozext s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.zero_ext s v) (Val.zero_ext s v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osext s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext s v) (Val.sign_ext s v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : Z) (a : amount32) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlzext s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shl (Val.zero_ext s v) (Vint a))\n  (Val.shl (Val.zero_ext s v') (Vint a)).","proofString":"inv H4; simpl; auto; rewrite a32_range; auto."},{"statement":"(s : Z) (a : amount32) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlsext s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shl (Val.sign_ext s v) (Vint a))\n  (Val.shl (Val.sign_ext s v') (Vint a)).","proofString":"inv H4; simpl; auto; rewrite a32_range; auto."},{"statement":"(a : amount32) (s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ozextshr a s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.zero_ext s (Val.shru v (Vint a)))\n  (Val.zero_ext s (Val.shru v' (Vint a))).","proofString":"inv H4; simpl; auto; rewrite a32_range; simpl; auto."},{"statement":"(a : amount32) (s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osextshr a s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext s (Val.shr v (Vint a)))\n  (Val.sign_ext s (Val.shr v' (Vint a))).","proofString":"inv H4; simpl; auto; rewrite a32_range; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshiftl s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (eval_shiftl s v a) (eval_shiftl s v' a).","proofString":"apply eval_shiftl_inject; auto."},{"statement":"(x : extension) (a : amount64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oextend x a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (eval_extend x v a) (eval_extend x v' a).","proofString":"apply eval_extend_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omakelong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.longofwords v v0) (Val.longofwords v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olowlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.loword v) (Val.loword v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ohighlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.hiword v) (Val.hiword v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addl v v0) (Val.addl v' v'0).","proofString":"apply Val.addl_inject; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddlshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addl v (eval_shiftl s v0 a))\n  (Val.addl v' (eval_shiftl s v'0 a)).","proofString":"apply Val.addl_inject; auto using eval_shiftl_inject."},{"statement":"(x : extension) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddlext x a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addl v (eval_extend x v0 a))\n  (Val.addl v' (eval_extend x v'0 a)).","proofString":"apply Val.addl_inject; auto using eval_extend_inject."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.addl v (Vlong n)) (Val.addl v' (Vlong n)).","proofString":"apply Val.addl_inject; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negl v) (Val.negl v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oneglshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negl (eval_shiftl s v a)) (Val.negl (eval_shiftl s v' a)).","proofString":"generalize (eval_shiftl_inject s a H4); intros J; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subl v v0) (Val.subl v' v'0).","proofString":"apply Val.subl_inject; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osublshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subl v (eval_shiftl s v0 a))\n  (Val.subl v' (eval_shiftl s v'0 a)).","proofString":"apply Val.subl_inject; auto using eval_shiftl_inject."},{"statement":"(x : extension) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osublext x a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subl v (eval_extend x v0 a))\n  (Val.subl v' (eval_extend x v'0 a)).","proofString":"apply Val.subl_inject; auto using eval_extend_inject."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omull) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mull v v0) (Val.mull v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulladd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.addl v (Val.mull v0 v2)) (Val.addl v' (Val.mull v'0 v'1)).","proofString":"apply Val.addl_inject; auto.\ninv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulladd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.mull v0 v2) (Val.mull v'0 v'1).","proofString":"inv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullsub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.subl v (Val.mull v0 v2)) (Val.subl v' (Val.mull v'0 v'1)).","proofString":"apply Val.subl_inject; auto.\ninv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullsub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.mull v0 v2) (Val.mull v'0 v'1).","proofString":"inv H2; inv H3; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mullhs v v0) (Val.mullhs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mullhu v v0) (Val.mullhu v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divls v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divls v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1) : exists v2 : val,\n  Val.divls (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.divs i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divs i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divlu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divlu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1) : exists v2 : val,\n  Val.divlu (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1) : exists v2 : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.divu i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oandl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.andl v v0) (Val.andl v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandlshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.andl v (eval_shiftl s v0 a))\n  (Val.andl v' (eval_shiftl s v'0 a)).","proofString":"generalize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.andl v (Vlong n)) (Val.andl v' (Vlong n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.orl v v0) (Val.orl v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorlshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.orl v (eval_shiftl s v0 a))\n  (Val.orl v' (eval_shiftl s v'0 a)).","proofString":"generalize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.orl v (Vlong n)) (Val.orl v' (Vlong n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xorl v v0) (Val.xorl v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorlshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xorl v (eval_shiftl s v0 a))\n  (Val.xorl v' (eval_shiftl s v'0 a)).","proofString":"generalize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xorl v (Vlong n)) (Val.xorl v' (Vlong n)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onotl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notl v) (Val.notl v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Onotlshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notl (eval_shiftl s v a)) (Val.notl (eval_shiftl s v' a)).","proofString":"generalize (eval_shiftl_inject s a H4); intros J; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Obicl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.andl v (Val.notl v0)) (Val.andl v' (Val.notl v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Obiclshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.andl v (Val.notl (eval_shiftl s v0 a)))\n  (Val.andl v' (Val.notl (eval_shiftl s v'0 a))).","proofString":"generalize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oornl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.orl v (Val.notl v0)) (Val.orl v' (Val.notl v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oornlshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.orl v (Val.notl (eval_shiftl s v0 a)))\n  (Val.orl v' (Val.notl (eval_shiftl s v'0 a))).","proofString":"generalize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oeqvl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xorl v (Val.notl v0)) (Val.xorl v' (Val.notl v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (a : amount64) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oeqvlshift s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xorl v (Val.notl (eval_shiftl s v0 a)))\n  (Val.xorl v' (Val.notl (eval_shiftl s v'0 a))).","proofString":"generalize (eval_shiftl_inject s a H2); intros J; inv H4; inv J; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shll v v0) (Val.shll v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shrl v v0) (Val.shrl v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shrlu v v0) (Val.shrlu v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrxl v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrxl v' (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1) : exists v2 : val, Val.shrxl (Vlong i) (Vint n) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vlong (Int64.shrx' i n)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.shrx' i n)) v2.","proofString":"TrivialExists."},{"statement":"(s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ozextl s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.zero_ext_l s v) (Val.zero_ext_l s v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osextl s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext_l s v) (Val.sign_ext_l s v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : Z) (a : amount64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllzext s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shll (Val.zero_ext_l s v) (Vint a))\n  (Val.shll (Val.zero_ext_l s v') (Vint a)).","proofString":"inv H4; simpl; auto; rewrite a64_range; auto."},{"statement":"(s : Z) (a : amount64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllsext s a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shll (Val.sign_ext_l s v) (Vint a))\n  (Val.shll (Val.sign_ext_l s v') (Vint a)).","proofString":"inv H4; simpl; auto; rewrite a64_range; auto."},{"statement":"(a : amount64) (s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ozextshrl a s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.zero_ext_l s (Val.shrlu v (Vint a)))\n  (Val.zero_ext_l s (Val.shrlu v' (Vint a))).","proofString":"inv H4; simpl; auto; rewrite a64_range; simpl; auto."},{"statement":"(a : amount64) (s : Z) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osextshrl a s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext_l s (Val.shrl v (Vint a)))\n  (Val.sign_ext_l s (Val.shrl v' (Vint a))).","proofString":"inv H4; simpl; auto; rewrite a64_range; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negf v) (Val.negf v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absf v) (Val.absf v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addf v v0) (Val.addf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subf v v0) (Val.subf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulf v v0) (Val.mulf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divf v v0) (Val.divf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negfs v) (Val.negfs v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absfs v) (Val.absfs v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addfs v v0) (Val.addfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subfs v v0) (Val.subfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulfs v v0) (Val.mulfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divfs v v0) (Val.divfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.singleoffloat v) (Val.singleoffloat v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.floatofsingle v) (Val.floatofsingle v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val, Val.intoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intuoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1) : exists v2 : val, Val.intuoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float.to_intu f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatofint v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.floatofint (Vint i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vfloat (Float.of_int i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofintu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatofintu v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.floatofintu (Vint i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_intu i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vfloat (Float.of_intu i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_intu i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val, Val.intofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float32.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intuofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1) : exists v2 : val,\n  Val.intuofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float32.to_intu f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleofint v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.singleofint (Vint i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vsingle (Float32.of_int i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofintu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleofintu v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.singleofintu (Vint i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vsingle (Float32.of_intu i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1) : exists v2 : val, Val.longoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float.to_long f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longuoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longuoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_longu f0) = Some v1) : exists v2 : val, Val.longuoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_longu f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float.to_longu f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatoflong v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatoflong v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.floatoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vfloat (Float.of_long i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatoflongu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatoflongu v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.floatoflongu (Vlong i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_longu i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vfloat (Float.of_longu i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_longu i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1) : exists v2 : val,\n  Val.longofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float32.to_long f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longuofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longuofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_longu f0) = Some v1) : exists v2 : val,\n  Val.longuofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_longu f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float32.to_longu f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleoflong v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleoflong v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.singleoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vsingle (Float32.of_long i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleoflongu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleoflongu v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.singleoflongu (Vlong i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) v2.","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vsingle (Float32.of_longu i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) v2.","proofString":"TrivialExists."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H2 : Val.of_optbool (eval_condition cond vl1 m1) = v1) : Val.inject f v1 (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"subst v1.\ndestruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) : Val.inject f (Val.of_optbool (eval_condition cond vl1 m1))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"destruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) : Val.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"exploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b ->\nVal.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"intros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) (EQ : eval_condition cond vl2 m2 = Some b) : Val.inject f (Val.of_optbool (Some b)) (Val.of_optbool (Some b)).","proofString":"destruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (Heqo : eval_condition cond vl1 m1 = None) : Val.inject f (Val.of_optbool None)\n  (Val.of_optbool (eval_condition cond vl2 m2)).","proofString":"simpl; constructor."},{"statement":"(cond : condition) (ty : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel cond ty)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) : Val.inject f (Val.select (eval_condition cond vl1 m1) v v0 ty)\n  (Val.select (eval_condition cond vl'0 m2) v' v'0 ty).","proofString":"apply Val.select_inject; auto.\ndestruct (eval_condition cond vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(cond : condition) (ty : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel cond ty)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) : eval_condition cond vl1 m1 = None \\/\neval_condition cond vl1 m1 = eval_condition cond vl'0 m2.","proofString":"destruct (eval_condition cond vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(cond : condition) (ty : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel cond ty)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) : Some b = None \\/ Some b = eval_condition cond vl'0 m2.","proofString":"right; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : eval_addressing ge1 sp1 addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct addr; simpl in H2; simpl; FuncInv; InvInject; TrivialExists.\napply Val.addl_inject; auto.\napply Val.addl_inject; auto.\napply Val.addl_inject; auto.\ninv H3; simpl; auto; rewrite a64_range; auto.\napply Val.addl_inject; auto using eval_extend_inject.\napply H; simpl; auto.\napply Val.offset_ptr_inject; auto."},{"statement":"(ofs : int64) (sp1 v sp2 : val) (H : forall (id : ident) (ofs0 : ptrofs),\nIn id (globals_addressing (Aindexed ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs0)\n  (Genv.symbol_address ge2 id ofs0)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') : Val.inject f (Val.addl v (Vlong ofs)) (Val.addl v' (Vlong ofs)).","proofString":"apply Val.addl_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing Aindexed2) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : Val.inject f (Val.addl v v0) (Val.addl v' v'0).","proofString":"apply Val.addl_inject; auto."},{"statement":"(a : amount64) (sp1 v v0 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed2shift a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : Val.inject f (Val.addl v (Val.shll v0 (Vint a)))\n  (Val.addl v' (Val.shll v'0 (Vint a))).","proofString":"apply Val.addl_inject; auto.\ninv H3; simpl; auto; rewrite a64_range; auto."},{"statement":"(a : amount64) (sp1 v v0 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed2shift a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : Val.inject f (Val.shll v0 (Vint a)) (Val.shll v'0 (Vint a)).","proofString":"inv H3; simpl; auto; rewrite a64_range; auto."},{"statement":"(x : extension) (a : amount64) (sp1 v v0 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed2ext x a)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : Val.inject f (Val.addl v (eval_extend x v0 a))\n  (Val.addl v' (eval_extend x v'0 a)).","proofString":"apply Val.addl_inject; auto using eval_extend_inject."},{"statement":"(id : ident) (ofs : ptrofs) (sp1 sp2 : val) (H : forall (id0 : ident) (ofs0 : ptrofs),\nIn id0 (globals_addressing (Aglobal id ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id0 ofs0)\n  (Genv.symbol_address ge2 id0 ofs0)) (H0 : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs).","proofString":"apply H; simpl; auto."},{"statement":"(ofs : ptrofs) (sp1 sp2 : val) (H : forall (id : ident) (ofs0 : ptrofs),\nIn id (globals_addressing (Ainstack ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs0)\n  (Genv.symbol_address ge2 id ofs0)) (H0 : Val.inject f sp1 sp2) : Val.inject f (Val.offset_ptr sp1 ofs) (Val.offset_ptr sp2 ofs).","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) =\ntrue.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) = true.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 : mem) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"inv H.\nrewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr 0) <=\nPtrofs.max_unsigned.","proofString":"rewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned.","proofString":"apply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : b1 <> b2) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true) (H2 : Some (b1, 0) = Some (b1', delta1)) (H3 : Some (b2, 0) = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"inv H2; inv H3.\nauto."},{"statement":"(m1 : mem) (ofs1 ofs2 : ptrofs) (b1' b2' : block) (H0 : Mem.valid_pointer m1 b1' (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2' (Ptrofs.unsigned ofs2) = true) (H : b1' <> b2') : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr 0)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr 0)).","proofString":"auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"eapply eval_condition_inj with (f := fun b => Some(b, 0)) (m1 := m1).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nrewrite <- val_inject_list_lessdef.\neauto.\nauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"apply val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (H2 : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_operation genv sp op vl2 m2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.lessdef_list vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"rewrite <- val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (H1 : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_addressing genv sp addr vl2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"exploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : f b = Some (b, 0) -> Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"intros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"eapply eval_condition_inj with (f := f) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl2 = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_addressing.\neapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 (Ptrofs.repr delta)) addr vl2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros.\napply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) (id : ident) (ofs : ptrofs) (H1 : In id (globals_addressing addr)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"apply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op)\n    vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_operation.\nsimpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"simpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros.\napply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) (id : ident) (ofs : ptrofs) (H2 : In id (globals_operation op)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"apply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."}]}