{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Core/Raux.v","fileSamples":[{"statement":"(x y : R) (H : (x <= y)%R) : (0 <= y - x)%R.","conclusion":"(0 <= y - x)%R","hypotheses":"(x y : R) (H : (x <= y)%R)","proofString":"apply Rge_le.\napply Rge_minus.\nnow apply Rle_ge."},{"statement":"(x y : R) (H : (x <= y)%R) : (y - x >= 0)%R.","conclusion":"(y - x >= 0)%R","hypotheses":"(x y : R) (H : (x <= y)%R)","proofString":"apply Rge_minus.\nnow apply Rle_ge."},{"statement":"(x y : R) (H : (x <= y)%R) : (y >= x)%R.","conclusion":"(y >= x)%R","hypotheses":"(x y : R) (H : (x <= y)%R)","proofString":"now apply Rle_ge."},{"statement":"(x y : R) (H : Rabs x = Rabs y) : x = y \\/ x = (- y)%R.","conclusion":"x = y \\/ x = (- y)%R","hypotheses":"(x y : R) (H : Rabs x = Rabs y)","proofString":"unfold Rabs in H.\ndestruct (Rcase_abs x) as [_|_].\nassert (H' := f_equal Ropp H).\nrewrite Ropp_involutive in H'.\nrewrite H'.\ndestruct (Rcase_abs y) as [_|_].\nleft.\napply Ropp_involutive.\nnow right.\nrewrite H.\nnow destruct (Rcase_abs y) as [_|_] ; [right|left]."},{"statement":"(x y : R) (H : (if Rcase_abs x then (- x)%R else x) = (if Rcase_abs y then (- y)%R else y)) : x = y \\/ x = (- y)%R.","conclusion":"x = y \\/ x = (- y)%R","hypotheses":"(x y : R) (H : (if Rcase_abs x then (- x)%R else x) = (if Rcase_abs y then (- y)%R else y))","proofString":"destruct (Rcase_abs x) as [_|_].\nassert (H' := f_equal Ropp H).\nrewrite Ropp_involutive in H'.\nrewrite H'.\ndestruct (Rcase_abs y) as [_|_].\nleft.\napply Ropp_involutive.\nnow right.\nrewrite H.\nnow destruct (Rcase_abs y) as [_|_] ; [right|left]."},{"statement":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y)) : x = y \\/ x = (- y)%R.","conclusion":"x = y \\/ x = (- y)%R","hypotheses":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y))","proofString":"assert (H' := f_equal Ropp H).\nrewrite Ropp_involutive in H'.\nrewrite H'.\ndestruct (Rcase_abs y) as [_|_].\nleft.\napply Ropp_involutive.\nnow right."},{"statement":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y)) (H' : (- - x)%R = (- (if Rcase_abs y then - y else y))%R) : x = y \\/ x = (- y)%R.","conclusion":"x = y \\/ x = (- y)%R","hypotheses":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y)) (H' : (- - x)%R = (- (if Rcase_abs y then - y else y))%R)","proofString":"rewrite Ropp_involutive in H'.\nrewrite H'.\ndestruct (Rcase_abs y) as [_|_].\nleft.\napply Ropp_involutive.\nnow right."},{"statement":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y)) (H' : x = (- (if Rcase_abs y then - y else y))%R) : x = y \\/ x = (- y)%R.","conclusion":"x = y \\/ x = (- y)%R","hypotheses":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y)) (H' : x = (- (if Rcase_abs y then - y else y))%R)","proofString":"rewrite H'.\ndestruct (Rcase_abs y) as [_|_].\nleft.\napply Ropp_involutive.\nnow right."},{"statement":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y)) (H' : x = (- (if Rcase_abs y then - y else y))%R) : (- (if Rcase_abs y then - y else y))%R = y \\/\n(- (if Rcase_abs y then - y else y))%R = (- y)%R.","conclusion":"(- (if Rcase_abs y then - y else y))%R = y \\/\n(- (if Rcase_abs y then - y else y))%R = (- y)%R","hypotheses":"(x y : R) (H : (- x)%R = (if Rcase_abs y then (- y)%R else y)) (H' : x = (- (if Rcase_abs y then - y else y))%R)","proofString":"destruct (Rcase_abs y) as [_|_].\nleft.\napply Ropp_involutive.\nnow right."},{"statement":"(x y : R) (H : (- x)%R = (- y)%R) (H' : x = (- - y)%R) : (- - y)%R = y \\/ (- - y)%R = (- y)%R.","conclusion":"(- - y)%R = y \\/ (- - y)%R = (- y)%R","hypotheses":"(x y : R) (H : (- x)%R = (- y)%R) (H' : x = (- - y)%R)","proofString":"left.\napply Ropp_involutive."},{"statement":"(x y : R) (H : (- x)%R = (- y)%R) (H' : x = (- - y)%R) : (- - y)%R = y.","conclusion":"(- - y)%R = y","hypotheses":"(x y : R) (H : (- x)%R = (- y)%R) (H' : x = (- - y)%R)","proofString":"apply Ropp_involutive."},{"statement":"(x y : R) (H : (- x)%R = y) (H' : x = (- y)%R) : (- y)%R = y \\/ (- y)%R = (- y)%R.","conclusion":"(- y)%R = y \\/ (- y)%R = (- y)%R","hypotheses":"(x y : R) (H : (- x)%R = y) (H' : x = (- y)%R)","proofString":"now right."},{"statement":"(x y : R) (H : x = (if Rcase_abs y then (- y)%R else y)) : x = y \\/ x = (- y)%R.","conclusion":"x = y \\/ x = (- y)%R","hypotheses":"(x y : R) (H : x = (if Rcase_abs y then (- y)%R else y))","proofString":"rewrite H.\nnow destruct (Rcase_abs y) as [_|_] ; [right|left]."},{"statement":"(x y : R) (H : x = (if Rcase_abs y then (- y)%R else y)) : (if Rcase_abs y then (- y)%R else y) = y \\/\n(if Rcase_abs y then (- y)%R else y) = (- y)%R.","conclusion":"(if Rcase_abs y then (- y)%R else y) = y \\/\n(if Rcase_abs y then (- y)%R else y) = (- y)%R","hypotheses":"(x y : R) (H : x = (if Rcase_abs y then (- y)%R else y))","proofString":"now destruct (Rcase_abs y) as [_|_] ; [right|left]."},{"statement":"(x y : R) (Hx : (0 <= y)%R) (Hy : (y <= 2 * x)%R) : (Rabs (x - y) <= x)%R.","conclusion":"(Rabs (x - y) <= x)%R","hypotheses":"(x y : R) (Hx : (0 <= y)%R) (Hy : (y <= 2 * x)%R)","proofString":"apply Rabs_le.\nlra."},{"statement":"(x y : R) (Hx : (0 <= y)%R) (Hy : (y <= 2 * x)%R) : (- x <= x - y <= x)%R.","conclusion":"(- x <= x - y <= x)%R","hypotheses":"(x y : R) (Hx : (0 <= y)%R) (Hy : (y <= 2 * x)%R)","proofString":"lra."},{"statement":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R) : (r1 * r3 < r2 * r4)%R.","conclusion":"(r1 * r3 < r2 * r4)%R","hypotheses":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R)","proofString":"apply Rle_lt_trans with (r1 * r4)%R.\napply Rmult_le_compat_l.\nexact Pr1.\nnow apply Rlt_le.\napply Rmult_lt_compat_r.\nnow apply Rle_lt_trans with r3.\nexact H12."},{"statement":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R) : (r1 * r3 <= r1 * r4)%R.","conclusion":"(r1 * r3 <= r1 * r4)%R","hypotheses":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R)","proofString":"apply Rmult_le_compat_l.\nexact Pr1.\nnow apply Rlt_le."},{"statement":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R) : (0 <= r1)%R.","conclusion":"(0 <= r1)%R","hypotheses":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R)","proofString":"exact Pr1."},{"statement":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R) : (r3 <= r4)%R.","conclusion":"(r3 <= r4)%R","hypotheses":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R)","proofString":"now apply Rlt_le."},{"statement":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R) : (r1 * r4 < r2 * r4)%R.","conclusion":"(r1 * r4 < r2 * r4)%R","hypotheses":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R)","proofString":"apply Rmult_lt_compat_r.\nnow apply Rle_lt_trans with r3.\nexact H12."},{"statement":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R) : (0 < r4)%R.","conclusion":"(0 < r4)%R","hypotheses":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R)","proofString":"now apply Rle_lt_trans with r3."},{"statement":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R) : (r1 < r2)%R.","conclusion":"(r1 < r2)%R","hypotheses":"(r1 r2 r3 r4 : R) (Pr1 : (0 <= r1)%R) (Pr3 : (0 <= r3)%R) (H12 : (r1 < r2)%R) (H34 : (r3 < r4)%R)","proofString":"exact H12."},{"statement":"(r1 r2 r3 : R) (H1 : (r2 * r1)%R <> (r3 * r1)%R) (H2 : r2 = r3) : False.","conclusion":"False","hypotheses":"(r1 r2 r3 : R) (H1 : (r2 * r1)%R <> (r3 * r1)%R) (H2 : r2 = r3)","proofString":"apply H1; rewrite H2; ring."},{"statement":"(r1 r2 r3 : R) (H : r1 <> 0%R) (H1 : r2 <> r3) (H2 : (r2 * r1)%R = (r3 * r1)%R) : False.","conclusion":"False","hypotheses":"(r1 r2 r3 : R) (H : r1 <> 0%R) (H1 : r2 <> r3) (H2 : (r2 * r1)%R = (r3 * r1)%R)","proofString":"now apply H1, Rmult_eq_reg_r with r1."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) : (Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r).","conclusion":"(Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r)","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R)","proofString":"unfold Rmin.\ndestruct (Rle_dec r1 r2) as [H1|H1] ;  destruct (Rle_dec (r1 * r) (r2 * r)) as [H2|H2] ;  try easy.\napply (f_equal (fun x => Rmult x r)).\napply Rle_antisym.\nexact H1.\napply Rmult_le_reg_r with (1 := Hr).\napply Rlt_le.\nnow apply Rnot_le_lt.\napply Rle_antisym.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply Rlt_le.\nnow apply Rnot_le_lt.\nexact H2."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) : ((if Rle_dec r1 r2 then r1 else r2) * r)%R =\n(if Rle_dec (r1 * r) (r2 * r) then (r1 * r)%R else (r2 * r)%R).","conclusion":"((if Rle_dec r1 r2 then r1 else r2) * r)%R =\n(if Rle_dec (r1 * r) (r2 * r) then (r1 * r)%R else (r2 * r)%R)","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R)","proofString":"destruct (Rle_dec r1 r2) as [H1|H1] ;  destruct (Rle_dec (r1 * r) (r2 * r)) as [H2|H2] ;  try easy.\napply (f_equal (fun x => Rmult x r)).\napply Rle_antisym.\nexact H1.\napply Rmult_le_reg_r with (1 := Hr).\napply Rlt_le.\nnow apply Rnot_le_lt.\napply Rle_antisym.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply Rlt_le.\nnow apply Rnot_le_lt.\nexact H2."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R) : (r1 * r)%R = (r2 * r)%R.","conclusion":"(r1 * r)%R = (r2 * r)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R)","proofString":"apply (f_equal (fun x => Rmult x r)).\napply Rle_antisym.\nexact H1.\napply Rmult_le_reg_r with (1 := Hr).\napply Rlt_le.\nnow apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R) : r1 = r2.","conclusion":"r1 = r2","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R)","proofString":"apply Rle_antisym.\nexact H1.\napply Rmult_le_reg_r with (1 := Hr).\napply Rlt_le.\nnow apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R) : (r1 <= r2)%R.","conclusion":"(r1 <= r2)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R)","proofString":"exact H1."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R) : (r2 <= r1)%R.","conclusion":"(r2 <= r1)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R)","proofString":"apply Rmult_le_reg_r with (1 := Hr).\napply Rlt_le.\nnow apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R) : (r2 * r <= r1 * r)%R.","conclusion":"(r2 * r <= r1 * r)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R)","proofString":"apply Rlt_le.\nnow apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R) : (r2 * r < r1 * r)%R.","conclusion":"(r2 * r < r1 * r)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : (r1 <= r2)%R) (H2 : ~ (r1 * r <= r2 * r)%R)","proofString":"now apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R) : (r2 * r)%R = (r1 * r)%R.","conclusion":"(r2 * r)%R = (r1 * r)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R)","proofString":"apply Rle_antisym.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\napply Rlt_le.\nnow apply Rnot_le_lt.\nexact H2."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R) : (r2 * r <= r1 * r)%R.","conclusion":"(r2 * r <= r1 * r)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R)","proofString":"apply Rmult_le_compat_r.\nnow apply Rlt_le.\napply Rlt_le.\nnow apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R) : (0 <= r)%R.","conclusion":"(0 <= r)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R)","proofString":"now apply Rlt_le."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R) : (r2 <= r1)%R.","conclusion":"(r2 <= r1)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R)","proofString":"apply Rlt_le.\nnow apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R) : (r2 < r1)%R.","conclusion":"(r2 < r1)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R)","proofString":"now apply Rnot_le_lt."},{"statement":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R) : (r1 * r <= r2 * r)%R.","conclusion":"(r1 * r <= r2 * r)%R","hypotheses":"(r r1 r2 : R) (Hr : (0 < r)%R) (H1 : ~ (r1 <= r2)%R) (H2 : (r1 * r <= r2 * r)%R)","proofString":"exact H2."},{"statement":"(r r1 r2 : R) (Hr : 0%R = r) : (Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r).","conclusion":"(Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r)","hypotheses":"(r r1 r2 : R) (Hr : 0%R = r)","proofString":"rewrite <- Hr.\nrewrite 3!Rmult_0_r.\nunfold Rmin.\ndestruct (Rle_dec 0 0) as [H0|H0].\neasy.\nelim H0.\napply Rle_refl."},{"statement":"(r r1 r2 : R) (Hr : 0%R = r) : (Rmin r1 r2 * 0)%R = Rmin (r1 * 0) (r2 * 0).","conclusion":"(Rmin r1 r2 * 0)%R = Rmin (r1 * 0) (r2 * 0)","hypotheses":"(r r1 r2 : R) (Hr : 0%R = r)","proofString":"rewrite 3!Rmult_0_r.\nunfold Rmin.\ndestruct (Rle_dec 0 0) as [H0|H0].\neasy.\nelim H0.\napply Rle_refl."},{"statement":"(r r1 r2 : R) (Hr : 0%R = r) : 0%R = Rmin 0 0.","conclusion":"0%R = Rmin 0 0","hypotheses":"(r r1 r2 : R) (Hr : 0%R = r)","proofString":"unfold Rmin.\ndestruct (Rle_dec 0 0) as [H0|H0].\neasy.\nelim H0.\napply Rle_refl."},{"statement":"(r r1 r2 : R) (Hr : 0%R = r) : 0%R = (if Rle_dec 0 0 then 0%R else 0%R).","conclusion":"0%R = (if Rle_dec 0 0 then 0%R else 0%R)","hypotheses":"(r r1 r2 : R) (Hr : 0%R = r)","proofString":"destruct (Rle_dec 0 0) as [H0|H0].\neasy.\nelim H0.\napply Rle_refl."},{"statement":"(r r1 r2 : R) (Hr : 0%R = r) (H0 : (0 <= 0)%R) : 0%R = 0%R.","conclusion":"0%R = 0%R","hypotheses":"(r r1 r2 : R) (Hr : 0%R = r) (H0 : (0 <= 0)%R)","proofString":"easy."},{"statement":"(r r1 r2 : R) (Hr : 0%R = r) (H0 : ~ (0 <= 0)%R) : 0%R = 0%R.","conclusion":"0%R = 0%R","hypotheses":"(r r1 r2 : R) (Hr : 0%R = r) (H0 : ~ (0 <= 0)%R)","proofString":"elim H0.\napply Rle_refl."},{"statement":"(r r1 r2 : R) (Hr : 0%R = r) (H0 : ~ (0 <= 0)%R) : (0 <= 0)%R.","conclusion":"(0 <= 0)%R","hypotheses":"(r r1 r2 : R) (Hr : 0%R = r) (H0 : ~ (0 <= 0)%R)","proofString":"apply Rle_refl."},{"statement":"(r r1 r2 : R) (Hr : (0 <= r)%R) : (r * Rmin r1 r2)%R = Rmin (r * r1) (r * r2).","conclusion":"(r * Rmin r1 r2)%R = Rmin (r * r1) (r * r2)","hypotheses":"(r r1 r2 : R) (Hr : (0 <= r)%R)","proofString":"rewrite 3!(Rmult_comm r).\nnow apply Rmult_min_distr_r."},{"statement":"(r r1 r2 : R) (Hr : (0 <= r)%R) : (Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r).","conclusion":"(Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r)","hypotheses":"(r r1 r2 : R) (Hr : (0 <= r)%R)","proofString":"now apply Rmult_min_distr_r."},{"statement":"(x y : R) : Rmin (- x) (- y) = (- Rmax x y)%R.","conclusion":"Rmin (- x) (- y) = (- Rmax x y)%R","hypotheses":"(x y : R)","proofString":"apply Rmax_case_strong; intros H.\nrewrite Rmin_left; trivial.\nnow apply Ropp_le_contravar.\nrewrite Rmin_right; trivial.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (y <= x)%R) : Rmin (- x) (- y) = (- x)%R.","conclusion":"Rmin (- x) (- y) = (- x)%R","hypotheses":"(x y : R) (H : (y <= x)%R)","proofString":"rewrite Rmin_left; trivial.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (y <= x)%R) : (- x <= - y)%R.","conclusion":"(- x <= - y)%R","hypotheses":"(x y : R) (H : (y <= x)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (x <= y)%R) : Rmin (- x) (- y) = (- y)%R.","conclusion":"Rmin (- x) (- y) = (- y)%R","hypotheses":"(x y : R) (H : (x <= y)%R)","proofString":"rewrite Rmin_right; trivial.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (x <= y)%R) : (- y <= - x)%R.","conclusion":"(- y <= - x)%R","hypotheses":"(x y : R) (H : (x <= y)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(x y : R) : Rmax (- x) (- y) = (- Rmin x y)%R.","conclusion":"Rmax (- x) (- y) = (- Rmin x y)%R","hypotheses":"(x y : R)","proofString":"apply Rmin_case_strong; intros H.\nrewrite Rmax_left; trivial.\nnow apply Ropp_le_contravar.\nrewrite Rmax_right; trivial.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (x <= y)%R) : Rmax (- x) (- y) = (- x)%R.","conclusion":"Rmax (- x) (- y) = (- x)%R","hypotheses":"(x y : R) (H : (x <= y)%R)","proofString":"rewrite Rmax_left; trivial.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (x <= y)%R) : (- y <= - x)%R.","conclusion":"(- y <= - x)%R","hypotheses":"(x y : R) (H : (x <= y)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (y <= x)%R) : Rmax (- x) (- y) = (- y)%R.","conclusion":"Rmax (- x) (- y) = (- y)%R","hypotheses":"(x y : R) (H : (y <= x)%R)","proofString":"rewrite Rmax_right; trivial.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (y <= x)%R) : (- x <= - y)%R.","conclusion":"(- x <= - y)%R","hypotheses":"(x y : R) (H : (y <= x)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(x y : R) (H : (x < y)%R) : (exp x <= exp y)%R.","conclusion":"(exp x <= exp y)%R","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"apply Rlt_le.\nnow apply exp_increasing."},{"statement":"(x y : R) (H : (x < y)%R) : (exp x < exp y)%R.","conclusion":"(exp x < exp y)%R","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"now apply exp_increasing."},{"statement":"(x y : R) (H : x = y) : (exp x <= exp y)%R.","conclusion":"(exp x <= exp y)%R","hypotheses":"(x y : R) (H : x = y)","proofString":"rewrite H.\napply Rle_refl."},{"statement":"(x y : R) (H : x = y) : (exp y <= exp y)%R.","conclusion":"(exp y <= exp y)%R","hypotheses":"(x y : R) (H : x = y)","proofString":"apply Rle_refl."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R) : (/ y < / x)%R.","conclusion":"(/ y < / x)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R)","proofString":"apply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nexact Hx.\nnow apply Rlt_trans with x.\nexact Hxy."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R) : (0 < x * y)%R.","conclusion":"(0 < x * y)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R)","proofString":"apply Rmult_lt_0_compat.\nexact Hx.\nnow apply Rlt_trans with x."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R) : (0 < x)%R.","conclusion":"(0 < x)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R)","proofString":"exact Hx."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R) : (0 < y)%R.","conclusion":"(0 < y)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R)","proofString":"now apply Rlt_trans with x."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x < y)%R)","proofString":"exact Hxy."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (/ y <= / x)%R.","conclusion":"(/ y <= / x)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"apply Rle_Rinv.\nexact Hx.\nnow apply Rlt_le_trans with x.\nexact Hxy."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (0 < x)%R.","conclusion":"(0 < x)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"exact Hx."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (0 < y)%R.","conclusion":"(0 < y)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"now apply Rlt_le_trans with x."},{"statement":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (x <= y)%R.","conclusion":"(x <= y)%R","hypotheses":"(x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"exact Hxy."},{"statement":"(x : R) : (0 <= sqrt x)%R.","conclusion":"(0 <= sqrt x)%R","hypotheses":"(x : R)","proofString":"unfold sqrt.\ndestruct (Rcase_abs x) as [_|H].\napply Rle_refl.\napply Rsqrt_positivity."},{"statement":"(x : R) : (0 <=\n match Rcase_abs x with\n | left _ => 0\n | right a => Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 a |}\n end)%R.","conclusion":"(0 <=\n match Rcase_abs x with\n | left _ => 0\n | right a => Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 a |}\n end)%R","hypotheses":"(x : R)","proofString":"destruct (Rcase_abs x) as [_|H].\napply Rle_refl.\napply Rsqrt_positivity."},{"statement":"(x : R) : (0 <= 0)%R.","conclusion":"(0 <= 0)%R","hypotheses":"(x : R)","proofString":"apply Rle_refl."},{"statement":"(x : R) (H : (x >= 0)%R) : (0 <= Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 H |})%R.","conclusion":"(0 <= Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 H |})%R","hypotheses":"(x : R) (H : (x >= 0)%R)","proofString":"apply Rsqrt_positivity."},{"statement":"(x : R) (Npx : (x <= 0)%R) : sqrt x = 0%R.","conclusion":"sqrt x = 0%R","hypotheses":"(x : R) (Npx : (x <= 0)%R)","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx.\nexact sqrt_0.\nunfold sqrt.\ndestruct Rcase_abs.\nreflexivity.\nexfalso.\nnow apply Nzx, Rle_antisym; [|apply Rge_le]."},{"statement":"(x : R) (Npx : (x <= 0)%R) (Zx : x = 0%R) : sqrt x = 0%R.","conclusion":"sqrt x = 0%R","hypotheses":"(x : R) (Npx : (x <= 0)%R) (Zx : x = 0%R)","proofString":"rewrite Zx.\nexact sqrt_0."},{"statement":"(x : R) (Npx : (x <= 0)%R) (Zx : x = 0%R) : sqrt 0 = 0%R.","conclusion":"sqrt 0 = 0%R","hypotheses":"(x : R) (Npx : (x <= 0)%R) (Zx : x = 0%R)","proofString":"exact sqrt_0."},{"statement":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) : sqrt x = 0%R.","conclusion":"sqrt x = 0%R","hypotheses":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R)","proofString":"unfold sqrt.\ndestruct Rcase_abs.\nreflexivity.\nexfalso.\nnow apply Nzx, Rle_antisym; [|apply Rge_le]."},{"statement":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) : match Rcase_abs x with\n| left _ => 0%R\n| right a => Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 a |}\nend = 0%R.","conclusion":"match Rcase_abs x with\n| left _ => 0%R\n| right a => Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 a |}\nend = 0%R","hypotheses":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R)","proofString":"destruct Rcase_abs.\nreflexivity.\nexfalso.\nnow apply Nzx, Rle_antisym; [|apply Rge_le]."},{"statement":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) (r : (x < 0)%R) : 0%R = 0%R.","conclusion":"0%R = 0%R","hypotheses":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) (r : (x < 0)%R)","proofString":"reflexivity."},{"statement":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) (r : (x >= 0)%R) : Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 r |} = 0%R.","conclusion":"Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 r |} = 0%R","hypotheses":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) (r : (x >= 0)%R)","proofString":"exfalso.\nnow apply Nzx, Rle_antisym; [|apply Rge_le]."},{"statement":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) (r : (x >= 0)%R) : False.","conclusion":"False","hypotheses":"(x : R) (Npx : (x <= 0)%R) (Nzx : x <> 0%R) (r : (x >= 0)%R)","proofString":"now apply Nzx, Rle_antisym; [|apply Rge_le]."},{"statement":"(x y : R) (H : (x² <= y²)%R) : (x <= Rabs y)%R.","conclusion":"(x <= Rabs y)%R","hypotheses":"(x y : R) (H : (x² <= y²)%R)","proofString":"apply (Rle_trans _ (Rabs x)); [apply Rle_abs|apply (Rsqr_le_abs_0 _ _ H)]."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (- y <= x <= y)%R.","conclusion":"(- y <= x <= y)%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"split.\napply Rle_trans with (- Rabs x)%R.\nnow apply Ropp_le_contravar.\napply Ropp_le_cancel.\nrewrite Ropp_involutive, <- Rabs_Ropp.\napply RRle_abs.\napply Rle_trans with (2 := Hxy).\napply RRle_abs."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (- y <= x)%R.","conclusion":"(- y <= x)%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"apply Rle_trans with (- Rabs x)%R.\nnow apply Ropp_le_contravar.\napply Ropp_le_cancel.\nrewrite Ropp_involutive, <- Rabs_Ropp.\napply RRle_abs."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (- y <= - Rabs x)%R.","conclusion":"(- y <= - Rabs x)%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (- Rabs x <= x)%R.","conclusion":"(- Rabs x <= x)%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"apply Ropp_le_cancel.\nrewrite Ropp_involutive, <- Rabs_Ropp.\napply RRle_abs."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (- x <= - - Rabs x)%R.","conclusion":"(- x <= - - Rabs x)%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"rewrite Ropp_involutive, <- Rabs_Ropp.\napply RRle_abs."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (- x <= Rabs (- x))%R.","conclusion":"(- x <= Rabs (- x))%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"apply RRle_abs."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (x <= y)%R.","conclusion":"(x <= y)%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"apply Rle_trans with (2 := Hxy).\napply RRle_abs."},{"statement":"(x y : R) (Hxy : (Rabs x <= y)%R) : (x <= Rabs x)%R.","conclusion":"(x <= Rabs x)%R","hypotheses":"(x y : R) (Hxy : (Rabs x <= y)%R)","proofString":"apply RRle_abs."},{"statement":"(x y : R) (Hyx : (y <= - x)%R) : (x <= Rabs y)%R.","conclusion":"(x <= Rabs y)%R","hypotheses":"(x y : R) (Hyx : (y <= - x)%R)","proofString":"apply Rle_trans with (-y)%R.\napply Ropp_le_cancel.\nnow rewrite Ropp_involutive.\nrewrite <- Rabs_Ropp.\napply RRle_abs."},{"statement":"(x y : R) (Hyx : (y <= - x)%R) : (x <= - y)%R.","conclusion":"(x <= - y)%R","hypotheses":"(x y : R) (Hyx : (y <= - x)%R)","proofString":"apply Ropp_le_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x y : R) (Hyx : (y <= - x)%R) : (- - y <= - x)%R.","conclusion":"(- - y <= - x)%R","hypotheses":"(x y : R) (Hyx : (y <= - x)%R)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x y : R) (Hyx : (y <= - x)%R) : (- y <= Rabs y)%R.","conclusion":"(- y <= Rabs y)%R","hypotheses":"(x y : R) (Hyx : (y <= - x)%R)","proofString":"rewrite <- Rabs_Ropp.\napply RRle_abs."},{"statement":"(x y : R) (Hyx : (y <= - x)%R) : (- y <= Rabs (- y))%R.","conclusion":"(- y <= Rabs (- y))%R","hypotheses":"(x y : R) (Hyx : (y <= - x)%R)","proofString":"apply RRle_abs."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (x <= Rabs y)%R.","conclusion":"(x <= Rabs y)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply Rle_trans with (1 := Hxy).\napply RRle_abs."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (y <= Rabs y)%R.","conclusion":"(y <= Rabs y)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply RRle_abs."},{"statement":"(x y : R) : (x <= Rabs y)%R -> (y <= - x)%R \\/ (x <= y)%R.","conclusion":"(x <= Rabs y)%R -> (y <= - x)%R \\/ (x <= y)%R","hypotheses":"(x y : R)","proofString":"unfold Rabs.\ncase Rcase_abs ; intros Hy Hxy.\nleft.\napply Ropp_le_cancel.\nnow rewrite Ropp_involutive.\nnow right."},{"statement":"(x y : R) : (x <= (if Rcase_abs y then - y else y))%R -> (y <= - x)%R \\/ (x <= y)%R.","conclusion":"(x <= (if Rcase_abs y then - y else y))%R -> (y <= - x)%R \\/ (x <= y)%R","hypotheses":"(x y : R)","proofString":"case Rcase_abs ; intros Hy Hxy.\nleft.\napply Ropp_le_cancel.\nnow rewrite Ropp_involutive.\nnow right."},{"statement":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x <= - y)%R) : (y <= - x)%R \\/ (x <= y)%R.","conclusion":"(y <= - x)%R \\/ (x <= y)%R","hypotheses":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x <= - y)%R)","proofString":"left.\napply Ropp_le_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x <= - y)%R) : (y <= - x)%R.","conclusion":"(y <= - x)%R","hypotheses":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x <= - y)%R)","proofString":"apply Ropp_le_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x <= - y)%R) : (- - x <= - y)%R.","conclusion":"(- - x <= - y)%R","hypotheses":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x <= - y)%R)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x y : R) (Hy : (y >= 0)%R) (Hxy : (x <= y)%R) : (y <= - x)%R \\/ (x <= y)%R.","conclusion":"(y <= - x)%R \\/ (x <= y)%R","hypotheses":"(x y : R) (Hy : (y >= 0)%R) (Hxy : (x <= y)%R)","proofString":"now right."},{"statement":"(x y : R) (Hyx : (- y < x)%R) (Hxy : (x < y)%R) : (Rabs x < y)%R.","conclusion":"(Rabs x < y)%R","hypotheses":"(x y : R) (Hyx : (- y < x)%R) (Hxy : (x < y)%R)","proofString":"now apply Rabs_def1."},{"statement":"(x y : R) (H : (Rabs x < y)%R) : (- y < x < y)%R.","conclusion":"(- y < x < y)%R","hypotheses":"(x y : R) (H : (Rabs x < y)%R)","proofString":"now split ; eapply Rabs_def2."},{"statement":"(x y : R) (Hyx : (y < - x)%R) : (x < Rabs y)%R.","conclusion":"(x < Rabs y)%R","hypotheses":"(x y : R) (Hyx : (y < - x)%R)","proofString":"rewrite <- Rabs_Ropp.\napply Rlt_le_trans with (Ropp y).\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\napply RRle_abs."},{"statement":"(x y : R) (Hyx : (y < - x)%R) : (x < Rabs (- y))%R.","conclusion":"(x < Rabs (- y))%R","hypotheses":"(x y : R) (Hyx : (y < - x)%R)","proofString":"apply Rlt_le_trans with (Ropp y).\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\napply RRle_abs."},{"statement":"(x y : R) (Hyx : (y < - x)%R) : (x < - y)%R.","conclusion":"(x < - y)%R","hypotheses":"(x y : R) (Hyx : (y < - x)%R)","proofString":"apply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x y : R) (Hyx : (y < - x)%R) : (- - y < - x)%R.","conclusion":"(- - y < - x)%R","hypotheses":"(x y : R) (Hyx : (y < - x)%R)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x y : R) (Hyx : (y < - x)%R) : (- y <= Rabs (- y))%R.","conclusion":"(- y <= Rabs (- y))%R","hypotheses":"(x y : R) (Hyx : (y < - x)%R)","proofString":"apply RRle_abs."},{"statement":"(x y : R) (Hxy : (x < y)%R) : (x < Rabs y)%R.","conclusion":"(x < Rabs y)%R","hypotheses":"(x y : R) (Hxy : (x < y)%R)","proofString":"apply Rlt_le_trans with (1 := Hxy).\napply RRle_abs."},{"statement":"(x y : R) (Hxy : (x < y)%R) : (y <= Rabs y)%R.","conclusion":"(y <= Rabs y)%R","hypotheses":"(x y : R) (Hxy : (x < y)%R)","proofString":"apply RRle_abs."},{"statement":"(x y : R) : (x < Rabs y)%R -> (y < - x)%R \\/ (x < y)%R.","conclusion":"(x < Rabs y)%R -> (y < - x)%R \\/ (x < y)%R","hypotheses":"(x y : R)","proofString":"unfold Rabs.\ncase Rcase_abs ; intros Hy Hxy.\nleft.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nnow right."},{"statement":"(x y : R) : (x < (if Rcase_abs y then - y else y))%R -> (y < - x)%R \\/ (x < y)%R.","conclusion":"(x < (if Rcase_abs y then - y else y))%R -> (y < - x)%R \\/ (x < y)%R","hypotheses":"(x y : R)","proofString":"case Rcase_abs ; intros Hy Hxy.\nleft.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive.\nnow right."},{"statement":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x < - y)%R) : (y < - x)%R \\/ (x < y)%R.","conclusion":"(y < - x)%R \\/ (x < y)%R","hypotheses":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x < - y)%R)","proofString":"left.\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x < - y)%R) : (y < - x)%R.","conclusion":"(y < - x)%R","hypotheses":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x < - y)%R)","proofString":"apply Ropp_lt_cancel.\nnow rewrite Ropp_involutive."},{"statement":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x < - y)%R) : (- - x < - y)%R.","conclusion":"(- - x < - y)%R","hypotheses":"(x y : R) (Hy : (y < 0)%R) (Hxy : (x < - y)%R)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x y : R) (Hy : (y >= 0)%R) (Hxy : (x < y)%R) : (y < - x)%R \\/ (x < y)%R.","conclusion":"(y < - x)%R \\/ (x < y)%R","hypotheses":"(x y : R) (Hy : (y >= 0)%R) (Hxy : (x < y)%R)","proofString":"now right."},{"statement":"(m n p : Z) (H1 : (m <= n)%Z) (H2 : (n < p)%Z) : (IZR m <= IZR n < IZR p)%R.","conclusion":"(IZR m <= IZR n < IZR p)%R","hypotheses":"(m n p : Z) (H1 : (m <= n)%Z) (H2 : (n < p)%Z)","proofString":"split.\nnow apply IZR_le.\nnow apply IZR_lt."},{"statement":"(m n p : Z) (H1 : (m <= n)%Z) (H2 : (n < p)%Z) : (IZR m <= IZR n)%R.","conclusion":"(IZR m <= IZR n)%R","hypotheses":"(m n p : Z) (H1 : (m <= n)%Z) (H2 : (n < p)%Z)","proofString":"now apply IZR_le."},{"statement":"(m n p : Z) (H1 : (m <= n)%Z) (H2 : (n < p)%Z) : (IZR n < IZR p)%R.","conclusion":"(IZR n < IZR p)%R","hypotheses":"(m n p : Z) (H1 : (m <= n)%Z) (H2 : (n < p)%Z)","proofString":"now apply IZR_lt."},{"statement":"(m n p : Z) (H1 : (IZR m <= IZR n)%R) (H2 : (IZR n < IZR p)%R) : (m <= n < p)%Z.","conclusion":"(m <= n < p)%Z","hypotheses":"(m n p : Z) (H1 : (IZR m <= IZR n)%R) (H2 : (IZR n < IZR p)%R)","proofString":"split.\nnow apply le_IZR.\nnow apply lt_IZR."},{"statement":"(m n p : Z) (H1 : (IZR m <= IZR n)%R) (H2 : (IZR n < IZR p)%R) : (m <= n)%Z.","conclusion":"(m <= n)%Z","hypotheses":"(m n p : Z) (H1 : (IZR m <= IZR n)%R) (H2 : (IZR n < IZR p)%R)","proofString":"now apply le_IZR."},{"statement":"(m n p : Z) (H1 : (IZR m <= IZR n)%R) (H2 : (IZR n < IZR p)%R) : (n < p)%Z.","conclusion":"(n < p)%Z","hypotheses":"(m n p : Z) (H1 : (IZR m <= IZR n)%R) (H2 : (IZR n < IZR p)%R)","proofString":"now apply lt_IZR."},{"statement":"(m n : Z) (H : IZR m <> IZR n) (H' : m = n) : False.","conclusion":"False","hypotheses":"(m n : Z) (H : IZR m <> IZR n) (H' : m = n)","proofString":"apply H.\nnow apply f_equal."},{"statement":"(m n : Z) (H : IZR m <> IZR n) (H' : m = n) : IZR m = IZR n.","conclusion":"IZR m = IZR n","hypotheses":"(m n : Z) (H : IZR m <> IZR n) (H' : m = n)","proofString":"now apply f_equal."},{"statement":"(x y : R) : Rcompare_prop x y (Rcompare x y).","conclusion":"Rcompare_prop x y (Rcompare x y)","hypotheses":"(x y : R)","proofString":"unfold Rcompare.\nnow destruct (total_order_T x y) as [[H|H]|H] ; constructor."},{"statement":"(x y : R) : Rcompare_prop x y\n  match total_order_T x y with\n  | inleft (left _) => Lt\n  | inleft (right _) => Eq\n  | inright _ => Gt\n  end.","conclusion":"Rcompare_prop x y\n  match total_order_T x y with\n  | inleft (left _) => Lt\n  | inleft (right _) => Eq\n  | inright _ => Gt\n  end","hypotheses":"(x y : R)","proofString":"now destruct (total_order_T x y) as [[H|H]|H] ; constructor."},{"statement":"(x y : R) (H : (x < y)%R) : Rcompare x y = Lt.","conclusion":"Rcompare x y = Lt","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"case Rcompare_spec ; intro H'.\neasy.\nrewrite H' in H.\nelim (Rlt_irrefl _ H).\nelim (Rlt_irrefl x).\nnow apply Rlt_trans with y."},{"statement":"(x y : R) (H H' : (x < y)%R) : Lt = Lt.","conclusion":"Lt = Lt","hypotheses":"(x y : R) (H H' : (x < y)%R)","proofString":"easy."},{"statement":"(x y : R) (H : (x < y)%R) (H' : x = y) : Eq = Lt.","conclusion":"Eq = Lt","hypotheses":"(x y : R) (H : (x < y)%R) (H' : x = y)","proofString":"rewrite H' in H.\nelim (Rlt_irrefl _ H)."},{"statement":"(x y : R) (H : (y < y)%R) (H' : x = y) : Eq = Lt.","conclusion":"Eq = Lt","hypotheses":"(x y : R) (H : (y < y)%R) (H' : x = y)","proofString":"elim (Rlt_irrefl _ H)."},{"statement":"(x y : R) (H : (x < y)%R) (H' : (y < x)%R) : Gt = Lt.","conclusion":"Gt = Lt","hypotheses":"(x y : R) (H : (x < y)%R) (H' : (y < x)%R)","proofString":"elim (Rlt_irrefl x).\nnow apply Rlt_trans with y."},{"statement":"(x y : R) (H : (x < y)%R) (H' : (y < x)%R) : (x < x)%R.","conclusion":"(x < x)%R","hypotheses":"(x y : R) (H : (x < y)%R) (H' : (y < x)%R)","proofString":"now apply Rlt_trans with y."},{"statement":"(x y : R) : Rcompare x y = Lt -> (x < y)%R.","conclusion":"Rcompare x y = Lt -> (x < y)%R","hypotheses":"(x y : R)","proofString":"now case Rcompare_spec."},{"statement":"(x y : R) (H1 : (y <= x)%R) (H2 : Rcompare x y = Lt) : False.","conclusion":"False","hypotheses":"(x y : R) (H1 : (y <= x)%R) (H2 : Rcompare x y = Lt)","proofString":"apply Rle_not_lt with (1 := H1).\nnow apply Rcompare_Lt_inv."},{"statement":"(x y : R) (H1 : (y <= x)%R) (H2 : Rcompare x y = Lt) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (H1 : (y <= x)%R) (H2 : Rcompare x y = Lt)","proofString":"now apply Rcompare_Lt_inv."},{"statement":"(x y : R) (H : Rcompare x y <> Lt) : (y <= x)%R.","conclusion":"(y <= x)%R","hypotheses":"(x y : R) (H : Rcompare x y <> Lt)","proofString":"apply Rnot_lt_le.\ncontradict H.\nnow apply Rcompare_Lt."},{"statement":"(x y : R) (H : Rcompare x y <> Lt) : ~ (x < y)%R.","conclusion":"~ (x < y)%R","hypotheses":"(x y : R) (H : Rcompare x y <> Lt)","proofString":"contradict H.\nnow apply Rcompare_Lt."},{"statement":"(x y : R) (H : (x < y)%R) : Rcompare x y = Lt.","conclusion":"Rcompare x y = Lt","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"now apply Rcompare_Lt."},{"statement":"(x y : R) (H : x = y) : Rcompare x y = Eq.","conclusion":"Rcompare x y = Eq","hypotheses":"(x y : R) (H : x = y)","proofString":"rewrite H.\nnow case Rcompare_spec ; intro H' ; try elim (Rlt_irrefl _ H')."},{"statement":"(x y : R) (H : x = y) : Rcompare y y = Eq.","conclusion":"Rcompare y y = Eq","hypotheses":"(x y : R) (H : x = y)","proofString":"now case Rcompare_spec ; intro H' ; try elim (Rlt_irrefl _ H')."},{"statement":"(x y : R) : Rcompare x y = Eq -> x = y.","conclusion":"Rcompare x y = Eq -> x = y","hypotheses":"(x y : R)","proofString":"now case Rcompare_spec."},{"statement":"(x y : R) (H : (y < x)%R) : Rcompare x y = Gt.","conclusion":"Rcompare x y = Gt","hypotheses":"(x y : R) (H : (y < x)%R)","proofString":"case Rcompare_spec ; intro H'.\nelim (Rlt_irrefl x).\nnow apply Rlt_trans with y.\nrewrite H' in H.\nelim (Rlt_irrefl _ H).\neasy."},{"statement":"(x y : R) (H : (y < x)%R) (H' : (x < y)%R) : Lt = Gt.","conclusion":"Lt = Gt","hypotheses":"(x y : R) (H : (y < x)%R) (H' : (x < y)%R)","proofString":"elim (Rlt_irrefl x).\nnow apply Rlt_trans with y."},{"statement":"(x y : R) (H : (y < x)%R) (H' : (x < y)%R) : (x < x)%R.","conclusion":"(x < x)%R","hypotheses":"(x y : R) (H : (y < x)%R) (H' : (x < y)%R)","proofString":"now apply Rlt_trans with y."},{"statement":"(x y : R) (H : (y < x)%R) (H' : x = y) : Eq = Gt.","conclusion":"Eq = Gt","hypotheses":"(x y : R) (H : (y < x)%R) (H' : x = y)","proofString":"rewrite H' in H.\nelim (Rlt_irrefl _ H)."},{"statement":"(x y : R) (H : (y < y)%R) (H' : x = y) : Eq = Gt.","conclusion":"Eq = Gt","hypotheses":"(x y : R) (H : (y < y)%R) (H' : x = y)","proofString":"elim (Rlt_irrefl _ H)."},{"statement":"(x y : R) (H H' : (y < x)%R) : Gt = Gt.","conclusion":"Gt = Gt","hypotheses":"(x y : R) (H H' : (y < x)%R)","proofString":"easy."},{"statement":"(x y : R) : Rcompare x y = Gt -> (y < x)%R.","conclusion":"Rcompare x y = Gt -> (y < x)%R","hypotheses":"(x y : R)","proofString":"now case Rcompare_spec."},{"statement":"(x y : R) (H1 : (x <= y)%R) (H2 : Rcompare x y = Gt) : False.","conclusion":"False","hypotheses":"(x y : R) (H1 : (x <= y)%R) (H2 : Rcompare x y = Gt)","proofString":"apply Rle_not_lt with (1 := H1).\nnow apply Rcompare_Gt_inv."},{"statement":"(x y : R) (H1 : (x <= y)%R) (H2 : Rcompare x y = Gt) : (y < x)%R.","conclusion":"(y < x)%R","hypotheses":"(x y : R) (H1 : (x <= y)%R) (H2 : Rcompare x y = Gt)","proofString":"now apply Rcompare_Gt_inv."},{"statement":"(x y : R) (H : Rcompare x y <> Gt) : (x <= y)%R.","conclusion":"(x <= y)%R","hypotheses":"(x y : R) (H : Rcompare x y <> Gt)","proofString":"apply Rnot_lt_le.\ncontradict H.\nnow apply Rcompare_Gt."},{"statement":"(x y : R) (H : Rcompare x y <> Gt) : ~ (y < x)%R.","conclusion":"~ (y < x)%R","hypotheses":"(x y : R) (H : Rcompare x y <> Gt)","proofString":"contradict H.\nnow apply Rcompare_Gt."},{"statement":"(x y : R) (H : (y < x)%R) : Rcompare x y = Gt.","conclusion":"Rcompare x y = Gt","hypotheses":"(x y : R) (H : (y < x)%R)","proofString":"now apply Rcompare_Gt."},{"statement":"(x y : Z) : Rcompare (IZR x) (IZR y) = (x ?= y)%Z.","conclusion":"Rcompare (IZR x) (IZR y) = (x ?= y)%Z","hypotheses":"(x y : Z)","proofString":"case Rcompare_spec ; intros H ; apply sym_eq.\napply Zcompare_Lt.\nnow apply lt_IZR.\napply Zcompare_Eq.\nnow apply eq_IZR.\napply Zcompare_Gt.\nnow apply lt_IZR."},{"statement":"(x y : Z) (H : (IZR x < IZR y)%R) : (x ?= y)%Z = Lt.","conclusion":"(x ?= y)%Z = Lt","hypotheses":"(x y : Z) (H : (IZR x < IZR y)%R)","proofString":"apply Zcompare_Lt.\nnow apply lt_IZR."},{"statement":"(x y : Z) (H : (IZR x < IZR y)%R) : (x < y)%Z.","conclusion":"(x < y)%Z","hypotheses":"(x y : Z) (H : (IZR x < IZR y)%R)","proofString":"now apply lt_IZR."},{"statement":"(x y : Z) (H : IZR x = IZR y) : (x ?= y)%Z = Eq.","conclusion":"(x ?= y)%Z = Eq","hypotheses":"(x y : Z) (H : IZR x = IZR y)","proofString":"apply Zcompare_Eq.\nnow apply eq_IZR."},{"statement":"(x y : Z) (H : IZR x = IZR y) : x = y.","conclusion":"x = y","hypotheses":"(x y : Z) (H : IZR x = IZR y)","proofString":"now apply eq_IZR."},{"statement":"(x y : Z) (H : (IZR y < IZR x)%R) : (x ?= y)%Z = Gt.","conclusion":"(x ?= y)%Z = Gt","hypotheses":"(x y : Z) (H : (IZR y < IZR x)%R)","proofString":"apply Zcompare_Gt.\nnow apply lt_IZR."},{"statement":"(x y : Z) (H : (IZR y < IZR x)%R) : (y < x)%Z.","conclusion":"(y < x)%Z","hypotheses":"(x y : Z) (H : (IZR y < IZR x)%R)","proofString":"now apply lt_IZR."},{"statement":"(x y : R) : Rcompare x y = CompOpp (Rcompare y x).","conclusion":"Rcompare x y = CompOpp (Rcompare y x)","hypotheses":"(x y : R)","proofString":"destruct (Rcompare_spec y x) as [H|H|H].\nnow apply Rcompare_Gt.\nnow apply Rcompare_Eq.\nnow apply Rcompare_Lt."},{"statement":"(x y : R) (H : (y < x)%R) : Rcompare x y = CompOpp Lt.","conclusion":"Rcompare x y = CompOpp Lt","hypotheses":"(x y : R) (H : (y < x)%R)","proofString":"now apply Rcompare_Gt."},{"statement":"(x y : R) (H : y = x) : Rcompare x y = CompOpp Eq.","conclusion":"Rcompare x y = CompOpp Eq","hypotheses":"(x y : R) (H : y = x)","proofString":"now apply Rcompare_Eq."},{"statement":"(x y : R) (H : (x < y)%R) : Rcompare x y = CompOpp Gt.","conclusion":"Rcompare x y = CompOpp Gt","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"now apply Rcompare_Lt."},{"statement":"(x y : R) : Rcompare (- x) (- y) = Rcompare y x.","conclusion":"Rcompare (- x) (- y) = Rcompare y x","hypotheses":"(x y : R)","proofString":"destruct (Rcompare_spec y x);  destruct (Rcompare_spec (- x) (- y));  try reflexivity; exfalso; lra."},{"statement":"(z x y : R) : Rcompare (x + z) (y + z) = Rcompare x y.","conclusion":"Rcompare (x + z) (y + z) = Rcompare x y","hypotheses":"(z x y : R)","proofString":"destruct (Rcompare_spec x y) as [H|H|H].\napply Rcompare_Lt.\nnow apply Rplus_lt_compat_r.\napply Rcompare_Eq.\nnow rewrite H.\napply Rcompare_Gt.\nnow apply Rplus_lt_compat_r."},{"statement":"(z x y : R) (H : (x < y)%R) : Rcompare (x + z) (y + z) = Lt.","conclusion":"Rcompare (x + z) (y + z) = Lt","hypotheses":"(z x y : R) (H : (x < y)%R)","proofString":"apply Rcompare_Lt.\nnow apply Rplus_lt_compat_r."},{"statement":"(z x y : R) (H : (x < y)%R) : (x + z < y + z)%R.","conclusion":"(x + z < y + z)%R","hypotheses":"(z x y : R) (H : (x < y)%R)","proofString":"now apply Rplus_lt_compat_r."},{"statement":"(z x y : R) (H : x = y) : Rcompare (x + z) (y + z) = Eq.","conclusion":"Rcompare (x + z) (y + z) = Eq","hypotheses":"(z x y : R) (H : x = y)","proofString":"apply Rcompare_Eq.\nnow rewrite H."},{"statement":"(z x y : R) (H : x = y) : (x + z)%R = (y + z)%R.","conclusion":"(x + z)%R = (y + z)%R","hypotheses":"(z x y : R) (H : x = y)","proofString":"now rewrite H."},{"statement":"(z x y : R) (H : (y < x)%R) : Rcompare (x + z) (y + z) = Gt.","conclusion":"Rcompare (x + z) (y + z) = Gt","hypotheses":"(z x y : R) (H : (y < x)%R)","proofString":"apply Rcompare_Gt.\nnow apply Rplus_lt_compat_r."},{"statement":"(z x y : R) (H : (y < x)%R) : (y + z < x + z)%R.","conclusion":"(y + z < x + z)%R","hypotheses":"(z x y : R) (H : (y < x)%R)","proofString":"now apply Rplus_lt_compat_r."},{"statement":"(z x y : R) : Rcompare (z + x) (z + y) = Rcompare x y.","conclusion":"Rcompare (z + x) (z + y) = Rcompare x y","hypotheses":"(z x y : R)","proofString":"rewrite 2!(Rplus_comm z).\napply Rcompare_plus_r."},{"statement":"(z x y : R) : Rcompare (x + z) (y + z) = Rcompare x y.","conclusion":"Rcompare (x + z) (y + z) = Rcompare x y","hypotheses":"(z x y : R)","proofString":"apply Rcompare_plus_r."},{"statement":"(z x y : R) (Hz : (0 < z)%R) : Rcompare (x * z) (y * z) = Rcompare x y.","conclusion":"Rcompare (x * z) (y * z) = Rcompare x y","hypotheses":"(z x y : R) (Hz : (0 < z)%R)","proofString":"destruct (Rcompare_spec x y) as [H|H|H].\napply Rcompare_Lt.\nnow apply Rmult_lt_compat_r.\napply Rcompare_Eq.\nnow rewrite H.\napply Rcompare_Gt.\nnow apply Rmult_lt_compat_r."},{"statement":"(z x y : R) (Hz : (0 < z)%R) (H : (x < y)%R) : Rcompare (x * z) (y * z) = Lt.","conclusion":"Rcompare (x * z) (y * z) = Lt","hypotheses":"(z x y : R) (Hz : (0 < z)%R) (H : (x < y)%R)","proofString":"apply Rcompare_Lt.\nnow apply Rmult_lt_compat_r."},{"statement":"(z x y : R) (Hz : (0 < z)%R) (H : (x < y)%R) : (x * z < y * z)%R.","conclusion":"(x * z < y * z)%R","hypotheses":"(z x y : R) (Hz : (0 < z)%R) (H : (x < y)%R)","proofString":"now apply Rmult_lt_compat_r."},{"statement":"(z x y : R) (Hz : (0 < z)%R) (H : x = y) : Rcompare (x * z) (y * z) = Eq.","conclusion":"Rcompare (x * z) (y * z) = Eq","hypotheses":"(z x y : R) (Hz : (0 < z)%R) (H : x = y)","proofString":"apply Rcompare_Eq.\nnow rewrite H."},{"statement":"(z x y : R) (Hz : (0 < z)%R) (H : x = y) : (x * z)%R = (y * z)%R.","conclusion":"(x * z)%R = (y * z)%R","hypotheses":"(z x y : R) (Hz : (0 < z)%R) (H : x = y)","proofString":"now rewrite H."},{"statement":"(z x y : R) (Hz : (0 < z)%R) (H : (y < x)%R) : Rcompare (x * z) (y * z) = Gt.","conclusion":"Rcompare (x * z) (y * z) = Gt","hypotheses":"(z x y : R) (Hz : (0 < z)%R) (H : (y < x)%R)","proofString":"apply Rcompare_Gt.\nnow apply Rmult_lt_compat_r."},{"statement":"(z x y : R) (Hz : (0 < z)%R) (H : (y < x)%R) : (y * z < x * z)%R.","conclusion":"(y * z < x * z)%R","hypotheses":"(z x y : R) (Hz : (0 < z)%R) (H : (y < x)%R)","proofString":"now apply Rmult_lt_compat_r."},{"statement":"(z x y : R) : (0 < z)%R -> Rcompare (z * x) (z * y) = Rcompare x y.","conclusion":"(0 < z)%R -> Rcompare (z * x) (z * y) = Rcompare x y","hypotheses":"(z x y : R)","proofString":"rewrite 2!(Rmult_comm z).\napply Rcompare_mult_r."},{"statement":"(z x y : R) : (0 < z)%R -> Rcompare (x * z) (y * z) = Rcompare x y.","conclusion":"(0 < z)%R -> Rcompare (x * z) (y * z) = Rcompare x y","hypotheses":"(z x y : R)","proofString":"apply Rcompare_mult_r."},{"statement":"(x d u : R) : Rcompare (x - d) (u - x) = Rcompare x ((d + u) / 2).","conclusion":"Rcompare (x - d) (u - x) = Rcompare x ((d + u) / 2)","hypotheses":"(x d u : R)","proofString":"rewrite <- (Rcompare_plus_r (- x / 2 - d / 2) x).\nrewrite <- (Rcompare_mult_r (/2) (x - d)).\nfield_simplify (x + (- x / 2 - d / 2))%R.\nnow field_simplify ((d + u) / 2 + (- x / 2 - d / 2))%R.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x d u : R) : Rcompare (x - d) (u - x) =\nRcompare (x + (- x / 2 - d / 2)) ((d + u) / 2 + (- x / 2 - d / 2)).","conclusion":"Rcompare (x - d) (u - x) =\nRcompare (x + (- x / 2 - d / 2)) ((d + u) / 2 + (- x / 2 - d / 2))","hypotheses":"(x d u : R)","proofString":"rewrite <- (Rcompare_mult_r (/2) (x - d)).\nfield_simplify (x + (- x / 2 - d / 2))%R.\nnow field_simplify ((d + u) / 2 + (- x / 2 - d / 2))%R.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x d u : R) : Rcompare ((x - d) * / 2) ((u - x) * / 2) =\nRcompare (x + (- x / 2 - d / 2)) ((d + u) / 2 + (- x / 2 - d / 2)).","conclusion":"Rcompare ((x - d) * / 2) ((u - x) * / 2) =\nRcompare (x + (- x / 2 - d / 2)) ((d + u) / 2 + (- x / 2 - d / 2))","hypotheses":"(x d u : R)","proofString":"field_simplify (x + (- x / 2 - d / 2))%R.\nnow field_simplify ((d + u) / 2 + (- x / 2 - d / 2))%R."},{"statement":"(x d u : R) : Rcompare ((x - d) * / 2) ((u - x) * / 2) =\nRcompare ((x - d) / 2) ((d + u) / 2 + (- x / 2 - d / 2)).","conclusion":"Rcompare ((x - d) * / 2) ((u - x) * / 2) =\nRcompare ((x - d) / 2) ((d + u) / 2 + (- x / 2 - d / 2))","hypotheses":"(x d u : R)","proofString":"now field_simplify ((d + u) / 2 + (- x / 2 - d / 2))%R."},{"statement":"(x d u : R) : (0 < / 2)%R.","conclusion":"(0 < / 2)%R","hypotheses":"(x d u : R)","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x d u : R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(x d u : R)","proofString":"now apply IZR_lt."},{"statement":"(x y : R) : Rcompare (x / 2) y = Rcompare x (2 * y).","conclusion":"Rcompare (x / 2) y = Rcompare x (2 * y)","hypotheses":"(x y : R)","proofString":"rewrite <- (Rcompare_mult_r 2%R).\nunfold Rdiv.\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r.\nnow rewrite Rmult_comm.\nnow apply IZR_neq.\nnow apply IZR_lt."},{"statement":"(x y : R) : Rcompare (x / 2 * 2) (y * 2) = Rcompare x (2 * y).","conclusion":"Rcompare (x / 2 * 2) (y * 2) = Rcompare x (2 * y)","hypotheses":"(x y : R)","proofString":"unfold Rdiv.\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r.\nnow rewrite Rmult_comm.\nnow apply IZR_neq."},{"statement":"(x y : R) : Rcompare (x * / 2 * 2) (y * 2) = Rcompare x (2 * y).","conclusion":"Rcompare (x * / 2 * 2) (y * 2) = Rcompare x (2 * y)","hypotheses":"(x y : R)","proofString":"rewrite Rmult_assoc, Rinv_l, Rmult_1_r.\nnow rewrite Rmult_comm.\nnow apply IZR_neq."},{"statement":"(x y : R) : Rcompare x (y * 2) = Rcompare x (2 * y).","conclusion":"Rcompare x (y * 2) = Rcompare x (2 * y)","hypotheses":"(x y : R)","proofString":"now rewrite Rmult_comm."},{"statement":"(x y : R) : 2%R <> 0%R.","conclusion":"2%R <> 0%R","hypotheses":"(x y : R)","proofString":"now apply IZR_neq."},{"statement":"(x y : R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(x y : R)","proofString":"now apply IZR_lt."},{"statement":"(x y : R) : Rcompare x (y / 2) = Rcompare (2 * x) y.","conclusion":"Rcompare x (y / 2) = Rcompare (2 * x) y","hypotheses":"(x y : R)","proofString":"rewrite <- (Rcompare_mult_r 2%R).\nunfold Rdiv.\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r.\nnow rewrite Rmult_comm.\nnow apply IZR_neq.\nnow apply IZR_lt."},{"statement":"(x y : R) : Rcompare (x * 2) (y / 2 * 2) = Rcompare (2 * x) y.","conclusion":"Rcompare (x * 2) (y / 2 * 2) = Rcompare (2 * x) y","hypotheses":"(x y : R)","proofString":"unfold Rdiv.\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r.\nnow rewrite Rmult_comm.\nnow apply IZR_neq."},{"statement":"(x y : R) : Rcompare (x * 2) (y * / 2 * 2) = Rcompare (2 * x) y.","conclusion":"Rcompare (x * 2) (y * / 2 * 2) = Rcompare (2 * x) y","hypotheses":"(x y : R)","proofString":"rewrite Rmult_assoc, Rinv_l, Rmult_1_r.\nnow rewrite Rmult_comm.\nnow apply IZR_neq."},{"statement":"(x y : R) : Rcompare (x * 2) y = Rcompare (2 * x) y.","conclusion":"Rcompare (x * 2) y = Rcompare (2 * x) y","hypotheses":"(x y : R)","proofString":"now rewrite Rmult_comm."},{"statement":"(x y : R) : 2%R <> 0%R.","conclusion":"2%R <> 0%R","hypotheses":"(x y : R)","proofString":"now apply IZR_neq."},{"statement":"(x y : R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(x y : R)","proofString":"now apply IZR_lt."},{"statement":"(x y : R) : Rcompare (x * x) (y * y) = Rcompare (Rabs x) (Rabs y).","conclusion":"Rcompare (x * x) (y * y) = Rcompare (Rabs x) (Rabs y)","hypotheses":"(x y : R)","proofString":"destruct (Rcompare_spec (Rabs x) (Rabs y)) as [H|H|H].\napply Rcompare_Lt.\nnow apply Rsqr_lt_abs_1.\nchange (Rcompare (Rsqr x) (Rsqr y) = Eq).\nrewrite Rsqr_abs, H, (Rsqr_abs y).\nnow apply Rcompare_Eq.\napply Rcompare_Gt.\nnow apply Rsqr_lt_abs_1."},{"statement":"(x y : R) (H : (Rabs x < Rabs y)%R) : Rcompare (x * x) (y * y) = Lt.","conclusion":"Rcompare (x * x) (y * y) = Lt","hypotheses":"(x y : R) (H : (Rabs x < Rabs y)%R)","proofString":"apply Rcompare_Lt.\nnow apply Rsqr_lt_abs_1."},{"statement":"(x y : R) (H : (Rabs x < Rabs y)%R) : (x * x < y * y)%R.","conclusion":"(x * x < y * y)%R","hypotheses":"(x y : R) (H : (Rabs x < Rabs y)%R)","proofString":"now apply Rsqr_lt_abs_1."},{"statement":"(x y : R) (H : Rabs x = Rabs y) : Rcompare (x * x) (y * y) = Eq.","conclusion":"Rcompare (x * x) (y * y) = Eq","hypotheses":"(x y : R) (H : Rabs x = Rabs y)","proofString":"change (Rcompare (Rsqr x) (Rsqr y) = Eq).\nrewrite Rsqr_abs, H, (Rsqr_abs y).\nnow apply Rcompare_Eq."},{"statement":"(x y : R) (H : Rabs x = Rabs y) : Rcompare x² y² = Eq.","conclusion":"Rcompare x² y² = Eq","hypotheses":"(x y : R) (H : Rabs x = Rabs y)","proofString":"rewrite Rsqr_abs, H, (Rsqr_abs y).\nnow apply Rcompare_Eq."},{"statement":"(x y : R) (H : Rabs x = Rabs y) : Rcompare (Rabs y)² (Rabs y)² = Eq.","conclusion":"Rcompare (Rabs y)² (Rabs y)² = Eq","hypotheses":"(x y : R) (H : Rabs x = Rabs y)","proofString":"now apply Rcompare_Eq."},{"statement":"(x y : R) (H : (Rabs y < Rabs x)%R) : Rcompare (x * x) (y * y) = Gt.","conclusion":"Rcompare (x * x) (y * y) = Gt","hypotheses":"(x y : R) (H : (Rabs y < Rabs x)%R)","proofString":"apply Rcompare_Gt.\nnow apply Rsqr_lt_abs_1."},{"statement":"(x y : R) (H : (Rabs y < Rabs x)%R) : (y * y < x * x)%R.","conclusion":"(y * y < x * x)%R","hypotheses":"(x y : R) (H : (Rabs y < Rabs x)%R)","proofString":"now apply Rsqr_lt_abs_1."},{"statement":"(x y : R) : Rmin x y = match Rcompare x y with\n           | Gt => y\n           | _ => x\n           end.","conclusion":"Rmin x y = match Rcompare x y with\n           | Gt => y\n           | _ => x\n           end","hypotheses":"(x y : R)","proofString":"unfold Rmin.\ndestruct (Rle_dec x y) as [[Hx|Hx]|Hx].\nnow rewrite Rcompare_Lt.\nnow rewrite Rcompare_Eq.\nrewrite Rcompare_Gt.\neasy.\nnow apply Rnot_le_lt."},{"statement":"(x y : R) : (if Rle_dec x y then x else y) =\nmatch Rcompare x y with\n| Gt => y\n| _ => x\nend.","conclusion":"(if Rle_dec x y then x else y) =\nmatch Rcompare x y with\n| Gt => y\n| _ => x\nend","hypotheses":"(x y : R)","proofString":"destruct (Rle_dec x y) as [[Hx|Hx]|Hx].\nnow rewrite Rcompare_Lt.\nnow rewrite Rcompare_Eq.\nrewrite Rcompare_Gt.\neasy.\nnow apply Rnot_le_lt."},{"statement":"(x y : R) (Hx : (x < y)%R) : x = match Rcompare x y with\n    | Gt => y\n    | _ => x\n    end.","conclusion":"x = match Rcompare x y with\n    | Gt => y\n    | _ => x\n    end","hypotheses":"(x y : R) (Hx : (x < y)%R)","proofString":"now rewrite Rcompare_Lt."},{"statement":"(x y : R) (Hx : x = y) : x = match Rcompare x y with\n    | Gt => y\n    | _ => x\n    end.","conclusion":"x = match Rcompare x y with\n    | Gt => y\n    | _ => x\n    end","hypotheses":"(x y : R) (Hx : x = y)","proofString":"now rewrite Rcompare_Eq."},{"statement":"(x y : R) (Hx : ~ (x <= y)%R) : y = match Rcompare x y with\n    | Gt => y\n    | _ => x\n    end.","conclusion":"y = match Rcompare x y with\n    | Gt => y\n    | _ => x\n    end","hypotheses":"(x y : R) (Hx : ~ (x <= y)%R)","proofString":"rewrite Rcompare_Gt.\neasy.\nnow apply Rnot_le_lt."},{"statement":"(x y : R) (Hx : ~ (x <= y)%R) : y = y.","conclusion":"y = y","hypotheses":"(x y : R) (Hx : ~ (x <= y)%R)","proofString":"easy."},{"statement":"(x y : R) (Hx : ~ (x <= y)%R) : (y < x)%R.","conclusion":"(y < x)%R","hypotheses":"(x y : R) (Hx : ~ (x <= y)%R)","proofString":"now apply Rnot_le_lt."},{"statement":"(x y : R) : Rle_bool_prop x y (Rle_bool x y).","conclusion":"Rle_bool_prop x y (Rle_bool x y)","hypotheses":"(x y : R)","proofString":"unfold Rle_bool.\ncase Rcompare_spec ; constructor.\nnow apply Rlt_le.\nrewrite H.\napply Rle_refl.\nexact H."},{"statement":"(x y : R) : Rle_bool_prop x y match Rcompare x y with\n                  | Gt => false\n                  | _ => true\n                  end.","conclusion":"Rle_bool_prop x y match Rcompare x y with\n                  | Gt => false\n                  | _ => true\n                  end","hypotheses":"(x y : R)","proofString":"case Rcompare_spec ; constructor.\nnow apply Rlt_le.\nrewrite H.\napply Rle_refl.\nexact H."},{"statement":"(x y : R) (H : (x < y)%R) : (x <= y)%R.","conclusion":"(x <= y)%R","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"now apply Rlt_le."},{"statement":"(x y : R) (H : x = y) : (x <= y)%R.","conclusion":"(x <= y)%R","hypotheses":"(x y : R) (H : x = y)","proofString":"rewrite H.\napply Rle_refl."},{"statement":"(x y : R) (H : x = y) : (y <= y)%R.","conclusion":"(y <= y)%R","hypotheses":"(x y : R) (H : x = y)","proofString":"apply Rle_refl."},{"statement":"(x y : R) (H : (y < x)%R) : (y < x)%R.","conclusion":"(y < x)%R","hypotheses":"(x y : R) (H : (y < x)%R)","proofString":"exact H."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : Rle_bool x y = true.","conclusion":"Rle_bool x y = true","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"case Rle_bool_spec ; intros H.\napply refl_equal.\nelim (Rlt_irrefl x).\nnow apply Rle_lt_trans with y."},{"statement":"(x y : R) (Hxy H : (x <= y)%R) : true = true.","conclusion":"true = true","hypotheses":"(x y : R) (Hxy H : (x <= y)%R)","proofString":"apply refl_equal."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (H : (y < x)%R) : false = true.","conclusion":"false = true","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (H : (y < x)%R)","proofString":"elim (Rlt_irrefl x).\nnow apply Rle_lt_trans with y."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (H : (y < x)%R) : (x < x)%R.","conclusion":"(x < x)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (H : (y < x)%R)","proofString":"now apply Rle_lt_trans with y."},{"statement":"(x y : R) (Hxy : (y < x)%R) : Rle_bool x y = false.","conclusion":"Rle_bool x y = false","hypotheses":"(x y : R) (Hxy : (y < x)%R)","proofString":"case Rle_bool_spec ; intros H.\nelim (Rlt_irrefl x).\nnow apply Rle_lt_trans with y.\napply refl_equal."},{"statement":"(x y : R) (Hxy : (y < x)%R) (H : (x <= y)%R) : true = false.","conclusion":"true = false","hypotheses":"(x y : R) (Hxy : (y < x)%R) (H : (x <= y)%R)","proofString":"elim (Rlt_irrefl x).\nnow apply Rle_lt_trans with y."},{"statement":"(x y : R) (Hxy : (y < x)%R) (H : (x <= y)%R) : (x < x)%R.","conclusion":"(x < x)%R","hypotheses":"(x y : R) (Hxy : (y < x)%R) (H : (x <= y)%R)","proofString":"now apply Rle_lt_trans with y."},{"statement":"(x y : R) (Hxy H : (y < x)%R) : false = false.","conclusion":"false = false","hypotheses":"(x y : R) (Hxy H : (y < x)%R)","proofString":"apply refl_equal."},{"statement":"(x y : R) : Rlt_bool_prop x y (Rlt_bool x y).","conclusion":"Rlt_bool_prop x y (Rlt_bool x y)","hypotheses":"(x y : R)","proofString":"unfold Rlt_bool.\ncase Rcompare_spec ; constructor.\nexact H.\nrewrite H.\napply Rle_refl.\nnow apply Rlt_le."},{"statement":"(x y : R) : Rlt_bool_prop x y match Rcompare x y with\n                  | Lt => true\n                  | _ => false\n                  end.","conclusion":"Rlt_bool_prop x y match Rcompare x y with\n                  | Lt => true\n                  | _ => false\n                  end","hypotheses":"(x y : R)","proofString":"case Rcompare_spec ; constructor.\nexact H.\nrewrite H.\napply Rle_refl.\nnow apply Rlt_le."},{"statement":"(x y : R) (H : (x < y)%R) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"exact H."},{"statement":"(x y : R) (H : x = y) : (y <= x)%R.","conclusion":"(y <= x)%R","hypotheses":"(x y : R) (H : x = y)","proofString":"rewrite H.\napply Rle_refl."},{"statement":"(x y : R) (H : x = y) : (y <= y)%R.","conclusion":"(y <= y)%R","hypotheses":"(x y : R) (H : x = y)","proofString":"apply Rle_refl."},{"statement":"(x y : R) (H : (y < x)%R) : (y <= x)%R.","conclusion":"(y <= x)%R","hypotheses":"(x y : R) (H : (y < x)%R)","proofString":"now apply Rlt_le."},{"statement":"(x y : R) : negb (Rle_bool x y) = Rlt_bool y x.","conclusion":"negb (Rle_bool x y) = Rlt_bool y x","hypotheses":"(x y : R)","proofString":"unfold Rlt_bool, Rle_bool.\nrewrite Rcompare_sym.\nnow case Rcompare."},{"statement":"(x y : R) : negb match Rcompare x y with\n     | Gt => false\n     | _ => true\n     end = match Rcompare y x with\n           | Lt => true\n           | _ => false\n           end.","conclusion":"negb match Rcompare x y with\n     | Gt => false\n     | _ => true\n     end = match Rcompare y x with\n           | Lt => true\n           | _ => false\n           end","hypotheses":"(x y : R)","proofString":"rewrite Rcompare_sym.\nnow case Rcompare."},{"statement":"(x y : R) : negb match CompOpp (Rcompare y x) with\n     | Gt => false\n     | _ => true\n     end = match Rcompare y x with\n           | Lt => true\n           | _ => false\n           end.","conclusion":"negb match CompOpp (Rcompare y x) with\n     | Gt => false\n     | _ => true\n     end = match Rcompare y x with\n           | Lt => true\n           | _ => false\n           end","hypotheses":"(x y : R)","proofString":"now case Rcompare."},{"statement":"(x y : R) : negb (Rlt_bool x y) = Rle_bool y x.","conclusion":"negb (Rlt_bool x y) = Rle_bool y x","hypotheses":"(x y : R)","proofString":"unfold Rlt_bool, Rle_bool.\nrewrite Rcompare_sym.\nnow case Rcompare."},{"statement":"(x y : R) : negb match Rcompare x y with\n     | Lt => true\n     | _ => false\n     end = match Rcompare y x with\n           | Gt => false\n           | _ => true\n           end.","conclusion":"negb match Rcompare x y with\n     | Lt => true\n     | _ => false\n     end = match Rcompare y x with\n           | Gt => false\n           | _ => true\n           end","hypotheses":"(x y : R)","proofString":"rewrite Rcompare_sym.\nnow case Rcompare."},{"statement":"(x y : R) : negb match CompOpp (Rcompare y x) with\n     | Lt => true\n     | _ => false\n     end = match Rcompare y x with\n           | Gt => false\n           | _ => true\n           end.","conclusion":"negb match CompOpp (Rcompare y x) with\n     | Lt => true\n     | _ => false\n     end = match Rcompare y x with\n           | Gt => false\n           | _ => true\n           end","hypotheses":"(x y : R)","proofString":"now case Rcompare."},{"statement":"(x y : R) (Hxy : (x < y)%R) : Rlt_bool x y = true.","conclusion":"Rlt_bool x y = true","hypotheses":"(x y : R) (Hxy : (x < y)%R)","proofString":"rewrite <- negb_Rlt_bool.\nnow rewrite Rle_bool_false."},{"statement":"(x y : R) (Hxy : (x < y)%R) : negb (Rle_bool y x) = true.","conclusion":"negb (Rle_bool y x) = true","hypotheses":"(x y : R) (Hxy : (x < y)%R)","proofString":"now rewrite Rle_bool_false."},{"statement":"(x y : R) (Hxy : (y <= x)%R) : Rlt_bool x y = false.","conclusion":"Rlt_bool x y = false","hypotheses":"(x y : R) (Hxy : (y <= x)%R)","proofString":"rewrite <- negb_Rlt_bool.\nnow rewrite Rle_bool_true."},{"statement":"(x y : R) (Hxy : (y <= x)%R) : negb (Rle_bool y x) = false.","conclusion":"negb (Rle_bool y x) = false","hypotheses":"(x y : R) (Hxy : (y <= x)%R)","proofString":"now rewrite Rle_bool_true."},{"statement":"(x y : R) : Rlt_bool (- x) (- y) = Rlt_bool y x.","conclusion":"Rlt_bool (- x) (- y) = Rlt_bool y x","hypotheses":"(x y : R)","proofString":"now unfold Rlt_bool; rewrite Rcompare_opp."},{"statement":"(x y : R) : Req_bool_prop x y (Req_bool x y).","conclusion":"Req_bool_prop x y (Req_bool x y)","hypotheses":"(x y : R)","proofString":"unfold Req_bool.\ncase Rcompare_spec ; constructor.\nnow apply Rlt_not_eq.\neasy.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) : Req_bool_prop x y match Rcompare x y with\n                  | Eq => true\n                  | _ => false\n                  end.","conclusion":"Req_bool_prop x y match Rcompare x y with\n                  | Eq => true\n                  | _ => false\n                  end","hypotheses":"(x y : R)","proofString":"case Rcompare_spec ; constructor.\nnow apply Rlt_not_eq.\neasy.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (H : (x < y)%R) : x <> y.","conclusion":"x <> y","hypotheses":"(x y : R) (H : (x < y)%R)","proofString":"now apply Rlt_not_eq."},{"statement":"(x y : R) (H : x = y) : x = y.","conclusion":"x = y","hypotheses":"(x y : R) (H : x = y)","proofString":"easy."},{"statement":"(x y : R) (H : (y < x)%R) : x <> y.","conclusion":"x <> y","hypotheses":"(x y : R) (H : (y < x)%R)","proofString":"now apply Rgt_not_eq."},{"statement":"(x y : R) (Hxy : x = y) : Req_bool x y = true.","conclusion":"Req_bool x y = true","hypotheses":"(x y : R) (Hxy : x = y)","proofString":"case Req_bool_spec ; intros H.\napply refl_equal.\ncontradict H.\nexact Hxy."},{"statement":"(x y : R) (Hxy H : x = y) : true = true.","conclusion":"true = true","hypotheses":"(x y : R) (Hxy H : x = y)","proofString":"apply refl_equal."},{"statement":"(x y : R) (Hxy : x = y) (H : x <> y) : false = true.","conclusion":"false = true","hypotheses":"(x y : R) (Hxy : x = y) (H : x <> y)","proofString":"contradict H.\nexact Hxy."},{"statement":"(x y : R) (Hxy : x = y) : x = y.","conclusion":"x = y","hypotheses":"(x y : R) (Hxy : x = y)","proofString":"exact Hxy."},{"statement":"(x y : R) (Hxy : x <> y) : Req_bool x y = false.","conclusion":"Req_bool x y = false","hypotheses":"(x y : R) (Hxy : x <> y)","proofString":"case Req_bool_spec ; intros H.\ncontradict Hxy.\nexact H.\napply refl_equal."},{"statement":"(x y : R) (Hxy : x <> y) (H : x = y) : true = false.","conclusion":"true = false","hypotheses":"(x y : R) (Hxy : x <> y) (H : x = y)","proofString":"contradict Hxy.\nexact H."},{"statement":"(x y : R) (H : x = y) : x = y.","conclusion":"x = y","hypotheses":"(x y : R) (H : x = y)","proofString":"exact H."},{"statement":"(x y : R) (Hxy H : x <> y) : false = false.","conclusion":"false = false","hypotheses":"(x y : R) (Hxy H : x <> y)","proofString":"apply refl_equal."},{"statement":"(x : R) : (IZR (Zfloor x) <= x)%R.","conclusion":"(IZR (Zfloor x) <= x)%R","hypotheses":"(x : R)","proofString":"unfold Zfloor.\nrewrite minus_IZR.\nsimpl.\napply Rplus_le_reg_r with (1 - x)%R.\nring_simplify.\nexact (proj2 (archimed x))."},{"statement":"(x : R) : (IZR (up x - 1) <= x)%R.","conclusion":"(IZR (up x - 1) <= x)%R","hypotheses":"(x : R)","proofString":"rewrite minus_IZR.\nsimpl.\napply Rplus_le_reg_r with (1 - x)%R.\nring_simplify.\nexact (proj2 (archimed x))."},{"statement":"(x : R) : (IZR (up x) - 1 <= x)%R.","conclusion":"(IZR (up x) - 1 <= x)%R","hypotheses":"(x : R)","proofString":"simpl.\napply Rplus_le_reg_r with (1 - x)%R.\nring_simplify.\nexact (proj2 (archimed x))."},{"statement":"(x : R) : (IZR (up x) - 1 <= x)%R.","conclusion":"(IZR (up x) - 1 <= x)%R","hypotheses":"(x : R)","proofString":"apply Rplus_le_reg_r with (1 - x)%R.\nring_simplify.\nexact (proj2 (archimed x))."},{"statement":"(x : R) : (IZR (up x) - 1 + (1 - x) <= x + (1 - x))%R.","conclusion":"(IZR (up x) - 1 + (1 - x) <= x + (1 - x))%R","hypotheses":"(x : R)","proofString":"ring_simplify.\nexact (proj2 (archimed x))."},{"statement":"(x : R) : (IZR (up x) - x <= 1)%R.","conclusion":"(IZR (up x) - x <= 1)%R","hypotheses":"(x : R)","proofString":"exact (proj2 (archimed x))."},{"statement":"(x : R) : (x < IZR (Zfloor x) + 1)%R.","conclusion":"(x < IZR (Zfloor x) + 1)%R","hypotheses":"(x : R)","proofString":"unfold Zfloor.\nrewrite minus_IZR.\nunfold Rminus.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_l, Rplus_0_r.\nexact (proj1 (archimed x))."},{"statement":"(x : R) : (x < IZR (up x - 1) + 1)%R.","conclusion":"(x < IZR (up x - 1) + 1)%R","hypotheses":"(x : R)","proofString":"rewrite minus_IZR.\nunfold Rminus.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_l, Rplus_0_r.\nexact (proj1 (archimed x))."},{"statement":"(x : R) : (x < IZR (up x) - 1 + 1)%R.","conclusion":"(x < IZR (up x) - 1 + 1)%R","hypotheses":"(x : R)","proofString":"unfold Rminus.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_l, Rplus_0_r.\nexact (proj1 (archimed x))."},{"statement":"(x : R) : (x < IZR (up x) + - (1) + 1)%R.","conclusion":"(x < IZR (up x) + - (1) + 1)%R","hypotheses":"(x : R)","proofString":"rewrite Rplus_assoc.\nrewrite Rplus_opp_l, Rplus_0_r.\nexact (proj1 (archimed x))."},{"statement":"(x : R) : (x < IZR (up x) + (- (1) + 1))%R.","conclusion":"(x < IZR (up x) + (- (1) + 1))%R","hypotheses":"(x : R)","proofString":"rewrite Rplus_opp_l, Rplus_0_r.\nexact (proj1 (archimed x))."},{"statement":"(x : R) : (x < IZR (up x))%R.","conclusion":"(x < IZR (up x))%R","hypotheses":"(x : R)","proofString":"exact (proj1 (archimed x))."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R) : (n <= Zfloor x)%Z.","conclusion":"(n <= Zfloor x)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R)","proofString":"apply Zlt_succ_le.\napply lt_IZR.\napply Rle_lt_trans with (1 := Hnx).\nunfold Z.succ.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R) : (n < Z.succ (Zfloor x))%Z.","conclusion":"(n < Z.succ (Zfloor x))%Z","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R)","proofString":"apply lt_IZR.\napply Rle_lt_trans with (1 := Hnx).\nunfold Z.succ.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R) : (IZR n < IZR (Z.succ (Zfloor x)))%R.","conclusion":"(IZR n < IZR (Z.succ (Zfloor x)))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R)","proofString":"apply Rle_lt_trans with (1 := Hnx).\nunfold Z.succ.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R) : (x < IZR (Z.succ (Zfloor x)))%R.","conclusion":"(x < IZR (Z.succ (Zfloor x)))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R)","proofString":"unfold Z.succ.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R) : (x < IZR (Zfloor x + 1))%R.","conclusion":"(x < IZR (Zfloor x + 1))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R)","proofString":"rewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R) : (x < IZR (Zfloor x) + 1)%R.","conclusion":"(x < IZR (Zfloor x) + 1)%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x)%R)","proofString":"apply Zfloor_ub."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R) : Zfloor x = n.","conclusion":"Zfloor x = n","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R)","proofString":"apply Zle_antisym.\napply Zlt_succ_le.\napply lt_IZR.\napply Rle_lt_trans with (2 := proj2 Hnx).\napply Zfloor_lb.\nnow apply Zfloor_lub."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R) : (Zfloor x <= n)%Z.","conclusion":"(Zfloor x <= n)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R)","proofString":"apply Zlt_succ_le.\napply lt_IZR.\napply Rle_lt_trans with (2 := proj2 Hnx).\napply Zfloor_lb."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R) : (Zfloor x < Z.succ n)%Z.","conclusion":"(Zfloor x < Z.succ n)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R)","proofString":"apply lt_IZR.\napply Rle_lt_trans with (2 := proj2 Hnx).\napply Zfloor_lb."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R) : (IZR (Zfloor x) < IZR (Z.succ n))%R.","conclusion":"(IZR (Zfloor x) < IZR (Z.succ n))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R)","proofString":"apply Rle_lt_trans with (2 := proj2 Hnx).\napply Zfloor_lb."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R) : (IZR (Zfloor x) <= x)%R.","conclusion":"(IZR (Zfloor x) <= x)%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R)","proofString":"apply Zfloor_lb."},{"statement":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R) : (n <= Zfloor x)%Z.","conclusion":"(n <= Zfloor x)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (IZR n <= x < IZR (n + 1))%R)","proofString":"now apply Zfloor_lub."},{"statement":"(n : Z) : Zfloor (IZR n) = n.","conclusion":"Zfloor (IZR n) = n","hypotheses":"(n : Z)","proofString":"apply Zfloor_imp.\nsplit.\napply Rle_refl.\napply IZR_lt.\napply Zlt_succ."},{"statement":"(n : Z) : (IZR n <= IZR n < IZR (n + 1))%R.","conclusion":"(IZR n <= IZR n < IZR (n + 1))%R","hypotheses":"(n : Z)","proofString":"split.\napply Rle_refl.\napply IZR_lt.\napply Zlt_succ."},{"statement":"(n : Z) : (IZR n <= IZR n)%R.","conclusion":"(IZR n <= IZR n)%R","hypotheses":"(n : Z)","proofString":"apply Rle_refl."},{"statement":"(n : Z) : (IZR n < IZR (n + 1))%R.","conclusion":"(IZR n < IZR (n + 1))%R","hypotheses":"(n : Z)","proofString":"apply IZR_lt.\napply Zlt_succ."},{"statement":"(n : Z) : (n < n + 1)%Z.","conclusion":"(n < n + 1)%Z","hypotheses":"(n : Z)","proofString":"apply Zlt_succ."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (Zfloor x <= Zfloor y)%Z.","conclusion":"(Zfloor x <= Zfloor y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply Zfloor_lub.\napply Rle_trans with (2 := Hxy).\napply Zfloor_lb."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (IZR (Zfloor x) <= y)%R.","conclusion":"(IZR (Zfloor x) <= y)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply Rle_trans with (2 := Hxy).\napply Zfloor_lb."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (IZR (Zfloor x) <= x)%R.","conclusion":"(IZR (Zfloor x) <= x)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply Zfloor_lb."},{"statement":"(x : R) : (x <= IZR (Zceil x))%R.","conclusion":"(x <= IZR (Zceil x))%R","hypotheses":"(x : R)","proofString":"unfold Zceil.\nrewrite opp_IZR.\napply Ropp_le_cancel.\nrewrite Ropp_involutive.\napply Zfloor_lb."},{"statement":"(x : R) : (x <= IZR (- Zfloor (- x)))%R.","conclusion":"(x <= IZR (- Zfloor (- x)))%R","hypotheses":"(x : R)","proofString":"rewrite opp_IZR.\napply Ropp_le_cancel.\nrewrite Ropp_involutive.\napply Zfloor_lb."},{"statement":"(x : R) : (x <= - IZR (Zfloor (- x)))%R.","conclusion":"(x <= - IZR (Zfloor (- x)))%R","hypotheses":"(x : R)","proofString":"apply Ropp_le_cancel.\nrewrite Ropp_involutive.\napply Zfloor_lb."},{"statement":"(x : R) : (- - IZR (Zfloor (- x)) <= - x)%R.","conclusion":"(- - IZR (Zfloor (- x)) <= - x)%R","hypotheses":"(x : R)","proofString":"rewrite Ropp_involutive.\napply Zfloor_lb."},{"statement":"(x : R) : (IZR (Zfloor (- x)) <= - x)%R.","conclusion":"(IZR (Zfloor (- x)) <= - x)%R","hypotheses":"(x : R)","proofString":"apply Zfloor_lb."},{"statement":"(x : R) : (IZR (Zceil x) < x + 1)%R.","conclusion":"(IZR (Zceil x) < x + 1)%R","hypotheses":"(x : R)","proofString":"unfold Zceil.\nrewrite opp_IZR.\nrewrite <-(Ropp_involutive (x + 1)), Ropp_plus_distr.\napply Ropp_lt_contravar, (Rplus_lt_reg_r 1); ring_simplify.\napply Zfloor_ub."},{"statement":"(x : R) : (IZR (- Zfloor (- x)) < x + 1)%R.","conclusion":"(IZR (- Zfloor (- x)) < x + 1)%R","hypotheses":"(x : R)","proofString":"rewrite opp_IZR.\nrewrite <-(Ropp_involutive (x + 1)), Ropp_plus_distr.\napply Ropp_lt_contravar, (Rplus_lt_reg_r 1); ring_simplify.\napply Zfloor_ub."},{"statement":"(x : R) : (- IZR (Zfloor (- x)) < x + 1)%R.","conclusion":"(- IZR (Zfloor (- x)) < x + 1)%R","hypotheses":"(x : R)","proofString":"rewrite <-(Ropp_involutive (x + 1)), Ropp_plus_distr.\napply Ropp_lt_contravar, (Rplus_lt_reg_r 1); ring_simplify.\napply Zfloor_ub."},{"statement":"(x : R) : (- IZR (Zfloor (- x)) < - (- x + - (1)))%R.","conclusion":"(- IZR (Zfloor (- x)) < - (- x + - (1)))%R","hypotheses":"(x : R)","proofString":"apply Ropp_lt_contravar, (Rplus_lt_reg_r 1); ring_simplify.\napply Zfloor_ub."},{"statement":"(x : R) : (- x < IZR (Zfloor (- x)) + 1)%R.","conclusion":"(- x < IZR (Zfloor (- x)) + 1)%R","hypotheses":"(x : R)","proofString":"apply Zfloor_ub."},{"statement":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R) : (Zceil x <= n)%Z.","conclusion":"(Zceil x <= n)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R)","proofString":"unfold Zceil.\napply Zopp_le_cancel.\nrewrite Z.opp_involutive.\napply Zfloor_lub.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R) : (- Zfloor (- x) <= n)%Z.","conclusion":"(- Zfloor (- x) <= n)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R)","proofString":"apply Zopp_le_cancel.\nrewrite Z.opp_involutive.\napply Zfloor_lub.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R) : (- n <= - - Zfloor (- x))%Z.","conclusion":"(- n <= - - Zfloor (- x))%Z","hypotheses":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R)","proofString":"rewrite Z.opp_involutive.\napply Zfloor_lub.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R) : (- n <= Zfloor (- x))%Z.","conclusion":"(- n <= Zfloor (- x))%Z","hypotheses":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R)","proofString":"apply Zfloor_lub.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R) : (IZR (- n) <= - x)%R.","conclusion":"(IZR (- n) <= - x)%R","hypotheses":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R)","proofString":"rewrite opp_IZR.\nnow apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R) : (- IZR n <= - x)%R.","conclusion":"(- IZR n <= - x)%R","hypotheses":"(n : Z) (x : R) (Hnx : (x <= IZR n)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : Zceil x = n.","conclusion":"Zceil x = n","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"unfold Zceil.\nrewrite <- (Z.opp_involutive n).\napply f_equal.\napply Zfloor_imp.\nsplit.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar.\nrewrite <- (Z.opp_involutive 1).\nrewrite <- Zopp_plus_distr.\nrewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (- Zfloor (- x))%Z = n.","conclusion":"(- Zfloor (- x))%Z = n","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"rewrite <- (Z.opp_involutive n).\napply f_equal.\napply Zfloor_imp.\nsplit.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar.\nrewrite <- (Z.opp_involutive 1).\nrewrite <- Zopp_plus_distr.\nrewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (- Zfloor (- x))%Z = (- - n)%Z.","conclusion":"(- Zfloor (- x))%Z = (- - n)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"apply f_equal.\napply Zfloor_imp.\nsplit.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar.\nrewrite <- (Z.opp_involutive 1).\nrewrite <- Zopp_plus_distr.\nrewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : Zfloor (- x) = (- n)%Z.","conclusion":"Zfloor (- x) = (- n)%Z","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"apply Zfloor_imp.\nsplit.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar.\nrewrite <- (Z.opp_involutive 1).\nrewrite <- Zopp_plus_distr.\nrewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (IZR (- n) <= - x < IZR (- n + 1))%R.","conclusion":"(IZR (- n) <= - x < IZR (- n + 1))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"split.\nrewrite opp_IZR.\nnow apply Ropp_le_contravar.\nrewrite <- (Z.opp_involutive 1).\nrewrite <- Zopp_plus_distr.\nrewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (IZR (- n) <= - x)%R.","conclusion":"(IZR (- n) <= - x)%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"rewrite opp_IZR.\nnow apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (- IZR n <= - x)%R.","conclusion":"(- IZR n <= - x)%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (- x < IZR (- n + 1))%R.","conclusion":"(- x < IZR (- n + 1))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"rewrite <- (Z.opp_involutive 1).\nrewrite <- Zopp_plus_distr.\nrewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (- x < IZR (- n + - - (1)))%R.","conclusion":"(- x < IZR (- n + - - (1)))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"rewrite <- Zopp_plus_distr.\nrewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (- x < IZR (- (n + - (1))))%R.","conclusion":"(- x < IZR (- (n + - (1))))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"rewrite opp_IZR.\nnow apply Ropp_lt_contravar."},{"statement":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R) : (- x < - IZR (n + - (1)))%R.","conclusion":"(- x < - IZR (n + - (1)))%R","hypotheses":"(n : Z) (x : R) (Hnx : (IZR (n - 1) < x <= IZR n)%R)","proofString":"now apply Ropp_lt_contravar."},{"statement":"(n : Z) : Zceil (IZR n) = n.","conclusion":"Zceil (IZR n) = n","hypotheses":"(n : Z)","proofString":"unfold Zceil.\nrewrite <- opp_IZR, Zfloor_IZR.\napply Z.opp_involutive."},{"statement":"(n : Z) : (- Zfloor (- IZR n))%Z = n.","conclusion":"(- Zfloor (- IZR n))%Z = n","hypotheses":"(n : Z)","proofString":"rewrite <- opp_IZR, Zfloor_IZR.\napply Z.opp_involutive."},{"statement":"(n : Z) : (- - n)%Z = n.","conclusion":"(- - n)%Z = n","hypotheses":"(n : Z)","proofString":"apply Z.opp_involutive."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (Zceil x <= Zceil y)%Z.","conclusion":"(Zceil x <= Zceil y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply Zceil_glb.\napply Rle_trans with (1 := Hxy).\napply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (x <= IZR (Zceil y))%R.","conclusion":"(x <= IZR (Zceil y))%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply Rle_trans with (1 := Hxy).\napply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (y <= IZR (Zceil y))%R.","conclusion":"(y <= IZR (Zceil y))%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"apply Zceil_ub."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : Zceil x = (Zfloor x + 1)%Z.","conclusion":"Zceil x = (Zfloor x + 1)%Z","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"apply Zceil_imp.\nsplit.\nring_simplify (Zfloor x + 1 - 1)%Z.\napply Rnot_le_lt.\nintros H.\napply Hx.\napply Rle_antisym.\napply Zfloor_lb.\nexact H.\napply Rlt_le.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : (IZR (Zfloor x + 1 - 1) < x <= IZR (Zfloor x + 1))%R.","conclusion":"(IZR (Zfloor x + 1 - 1) < x <= IZR (Zfloor x + 1))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"split.\nring_simplify (Zfloor x + 1 - 1)%Z.\napply Rnot_le_lt.\nintros H.\napply Hx.\napply Rle_antisym.\napply Zfloor_lb.\nexact H.\napply Rlt_le.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : (IZR (Zfloor x + 1 - 1) < x)%R.","conclusion":"(IZR (Zfloor x + 1 - 1) < x)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"ring_simplify (Zfloor x + 1 - 1)%Z.\napply Rnot_le_lt.\nintros H.\napply Hx.\napply Rle_antisym.\napply Zfloor_lb.\nexact H."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : (IZR (Zfloor x) < x)%R.","conclusion":"(IZR (Zfloor x) < x)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"apply Rnot_le_lt.\nintros H.\napply Hx.\napply Rle_antisym.\napply Zfloor_lb.\nexact H."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : ~ (x <= IZR (Zfloor x))%R.","conclusion":"~ (x <= IZR (Zfloor x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"intros H.\napply Hx.\napply Rle_antisym.\napply Zfloor_lb.\nexact H."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R) : False.","conclusion":"False","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R)","proofString":"apply Hx.\napply Rle_antisym.\napply Zfloor_lb.\nexact H."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R) : IZR (Zfloor x) = x.","conclusion":"IZR (Zfloor x) = x","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R)","proofString":"apply Rle_antisym.\napply Zfloor_lb.\nexact H."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R) : (IZR (Zfloor x) <= x)%R.","conclusion":"(IZR (Zfloor x) <= x)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R)","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R) : (x <= IZR (Zfloor x))%R.","conclusion":"(x <= IZR (Zfloor x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H : (x <= IZR (Zfloor x))%R)","proofString":"exact H."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : (x <= IZR (Zfloor x + 1))%R.","conclusion":"(x <= IZR (Zfloor x + 1))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"apply Rlt_le.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : (x < IZR (Zfloor x + 1))%R.","conclusion":"(x < IZR (Zfloor x + 1))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"rewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : (x < IZR (Zfloor x) + 1)%R.","conclusion":"(x < IZR (Zfloor x) + 1)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"apply Zfloor_ub."},{"statement":"(n : Z) : Ztrunc (IZR n) = n.","conclusion":"Ztrunc (IZR n) = n","hypotheses":"(n : Z)","proofString":"unfold Ztrunc.\ncase Rlt_bool_spec ; intro H.\napply Zceil_IZR.\napply Zfloor_IZR."},{"statement":"(n : Z) : (if Rlt_bool (IZR n) 0 then Zceil (IZR n) else Zfloor (IZR n)) = n.","conclusion":"(if Rlt_bool (IZR n) 0 then Zceil (IZR n) else Zfloor (IZR n)) = n","hypotheses":"(n : Z)","proofString":"case Rlt_bool_spec ; intro H.\napply Zceil_IZR.\napply Zfloor_IZR."},{"statement":"(n : Z) (H : (IZR n < 0)%R) : Zceil (IZR n) = n.","conclusion":"Zceil (IZR n) = n","hypotheses":"(n : Z) (H : (IZR n < 0)%R)","proofString":"apply Zceil_IZR."},{"statement":"(n : Z) (H : (0 <= IZR n)%R) : Zfloor (IZR n) = n.","conclusion":"Zfloor (IZR n) = n","hypotheses":"(n : Z) (H : (0 <= IZR n)%R)","proofString":"apply Zfloor_IZR."},{"statement":"(x : R) (Hx : (0 <= x)%R) : Ztrunc x = Zfloor x.","conclusion":"Ztrunc x = Zfloor x","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"unfold Ztrunc.\ncase Rlt_bool_spec ; intro H.\nelim Rlt_irrefl with x.\nnow apply Rlt_le_trans with R0.\napply refl_equal."},{"statement":"(x : R) (Hx : (0 <= x)%R) : (if Rlt_bool x 0 then Zceil x else Zfloor x) = Zfloor x.","conclusion":"(if Rlt_bool x 0 then Zceil x else Zfloor x) = Zfloor x","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"case Rlt_bool_spec ; intro H.\nelim Rlt_irrefl with x.\nnow apply Rlt_le_trans with R0.\napply refl_equal."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R) : Zceil x = Zfloor x.","conclusion":"Zceil x = Zfloor x","hypotheses":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R)","proofString":"elim Rlt_irrefl with x.\nnow apply Rlt_le_trans with R0."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R) : (x < x)%R.","conclusion":"(x < x)%R","hypotheses":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R)","proofString":"now apply Rlt_le_trans with R0."},{"statement":"(x : R) (Hx H : (0 <= x)%R) : Zfloor x = Zfloor x.","conclusion":"Zfloor x = Zfloor x","hypotheses":"(x : R) (Hx H : (0 <= x)%R)","proofString":"apply refl_equal."},{"statement":"(x : R) (Hx : (x <= 0)%R) : Ztrunc x = Zceil x.","conclusion":"Ztrunc x = Zceil x","hypotheses":"(x : R) (Hx : (x <= 0)%R)","proofString":"unfold Ztrunc.\ncase Rlt_bool_spec ; intro H.\napply refl_equal.\nrewrite (Rle_antisym _ _ Hx H).\nrewrite Zceil_IZR.\napply Zfloor_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) : (if Rlt_bool x 0 then Zceil x else Zfloor x) = Zceil x.","conclusion":"(if Rlt_bool x 0 then Zceil x else Zfloor x) = Zceil x","hypotheses":"(x : R) (Hx : (x <= 0)%R)","proofString":"case Rlt_bool_spec ; intro H.\napply refl_equal.\nrewrite (Rle_antisym _ _ Hx H).\nrewrite Zceil_IZR.\napply Zfloor_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (x < 0)%R) : Zceil x = Zceil x.","conclusion":"Zceil x = Zceil x","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (x < 0)%R)","proofString":"apply refl_equal."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R) : Zfloor x = Zceil x.","conclusion":"Zfloor x = Zceil x","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R)","proofString":"rewrite (Rle_antisym _ _ Hx H).\nrewrite Zceil_IZR.\napply Zfloor_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R) : Zfloor 0 = Zceil 0.","conclusion":"Zfloor 0 = Zceil 0","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R)","proofString":"rewrite Zceil_IZR.\napply Zfloor_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R) : Zfloor 0 = 0%Z.","conclusion":"Zfloor 0 = 0%Z","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R)","proofString":"apply Zfloor_IZR."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (Ztrunc x <= Ztrunc y)%Z.","conclusion":"(Ztrunc x <= Ztrunc y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"unfold Ztrunc at 1.\ncase Rlt_bool_spec ; intro Hx.\nunfold Ztrunc.\ncase Rlt_bool_spec ; intro Hy.\nnow apply Zceil_le.\napply Z.le_trans with 0%Z.\napply Zceil_glb.\nnow apply Rlt_le.\nnow apply Zfloor_lub.\nrewrite Ztrunc_floor.\nnow apply Zfloor_le.\nnow apply Rle_trans with x."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : ((if Rlt_bool x 0 then Zceil x else Zfloor x) <= Ztrunc y)%Z.","conclusion":"((if Rlt_bool x 0 then Zceil x else Zfloor x) <= Ztrunc y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"case Rlt_bool_spec ; intro Hx.\nunfold Ztrunc.\ncase Rlt_bool_spec ; intro Hy.\nnow apply Zceil_le.\napply Z.le_trans with 0%Z.\napply Zceil_glb.\nnow apply Rlt_le.\nnow apply Zfloor_lub.\nrewrite Ztrunc_floor.\nnow apply Zfloor_le.\nnow apply Rle_trans with x."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) : (Zceil x <= Ztrunc y)%Z.","conclusion":"(Zceil x <= Ztrunc y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R)","proofString":"unfold Ztrunc.\ncase Rlt_bool_spec ; intro Hy.\nnow apply Zceil_le.\napply Z.le_trans with 0%Z.\napply Zceil_glb.\nnow apply Rlt_le.\nnow apply Zfloor_lub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) : (Zceil x <= (if Rlt_bool y 0 then Zceil y else Zfloor y))%Z.","conclusion":"(Zceil x <= (if Rlt_bool y 0 then Zceil y else Zfloor y))%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R)","proofString":"case Rlt_bool_spec ; intro Hy.\nnow apply Zceil_le.\napply Z.le_trans with 0%Z.\napply Zceil_glb.\nnow apply Rlt_le.\nnow apply Zfloor_lub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (y < 0)%R) : (Zceil x <= Zceil y)%Z.","conclusion":"(Zceil x <= Zceil y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (y < 0)%R)","proofString":"now apply Zceil_le."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (Zceil x <= Zfloor y)%Z.","conclusion":"(Zceil x <= Zfloor y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Z.le_trans with 0%Z.\napply Zceil_glb.\nnow apply Rlt_le.\nnow apply Zfloor_lub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (Zceil x <= 0)%Z.","conclusion":"(Zceil x <= 0)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Zceil_glb.\nnow apply Rlt_le."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (x <= 0)%R.","conclusion":"(x <= 0)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"now apply Rlt_le."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (0 <= Zfloor y)%Z.","conclusion":"(0 <= Zfloor y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"now apply Zfloor_lub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R) : (Zfloor x <= Ztrunc y)%Z.","conclusion":"(Zfloor x <= Ztrunc y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R)","proofString":"rewrite Ztrunc_floor.\nnow apply Zfloor_le.\nnow apply Rle_trans with x."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R) : (Zfloor x <= Zfloor y)%Z.","conclusion":"(Zfloor x <= Zfloor y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R)","proofString":"now apply Zfloor_le."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R) : (0 <= y)%R.","conclusion":"(0 <= y)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R)","proofString":"now apply Rle_trans with x."},{"statement":"(x : R) : Ztrunc (- x) = (- Ztrunc x)%Z.","conclusion":"Ztrunc (- x) = (- Ztrunc x)%Z","hypotheses":"(x : R)","proofString":"unfold Ztrunc at 2.\ncase Rlt_bool_spec ; intros Hx.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Z.opp_involutive.\nrewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le.\nrewrite Ztrunc_ceil.\nunfold Zceil.\nnow rewrite Ropp_involutive.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) : Ztrunc (- x) = (- (if Rlt_bool x 0 then Zceil x else Zfloor x))%Z.","conclusion":"Ztrunc (- x) = (- (if Rlt_bool x 0 then Zceil x else Zfloor x))%Z","hypotheses":"(x : R)","proofString":"case Rlt_bool_spec ; intros Hx.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Z.opp_involutive.\nrewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le.\nrewrite Ztrunc_ceil.\nunfold Zceil.\nnow rewrite Ropp_involutive.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) (Hx : (x < 0)%R) : Ztrunc (- x) = (- Zceil x)%Z.","conclusion":"Ztrunc (- x) = (- Zceil x)%Z","hypotheses":"(x : R) (Hx : (x < 0)%R)","proofString":"rewrite Ztrunc_floor.\napply sym_eq.\napply Z.opp_involutive.\nrewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(x : R) (Hx : (x < 0)%R) : Zfloor (- x) = (- Zceil x)%Z.","conclusion":"Zfloor (- x) = (- Zceil x)%Z","hypotheses":"(x : R) (Hx : (x < 0)%R)","proofString":"apply sym_eq.\napply Z.opp_involutive."},{"statement":"(x : R) (Hx : (x < 0)%R) : (- Zceil x)%Z = Zfloor (- x).","conclusion":"(- Zceil x)%Z = Zfloor (- x)","hypotheses":"(x : R) (Hx : (x < 0)%R)","proofString":"apply Z.opp_involutive."},{"statement":"(x : R) (Hx : (x < 0)%R) : (0 <= - x)%R.","conclusion":"(0 <= - x)%R","hypotheses":"(x : R) (Hx : (x < 0)%R)","proofString":"rewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(x : R) (Hx : (x < 0)%R) : (- 0 <= - x)%R.","conclusion":"(- 0 <= - x)%R","hypotheses":"(x : R) (Hx : (x < 0)%R)","proofString":"apply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(x : R) (Hx : (x < 0)%R) : (x <= 0)%R.","conclusion":"(x <= 0)%R","hypotheses":"(x : R) (Hx : (x < 0)%R)","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Hx : (0 <= x)%R) : Ztrunc (- x) = (- Zfloor x)%Z.","conclusion":"Ztrunc (- x) = (- Zfloor x)%Z","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"rewrite Ztrunc_ceil.\nunfold Zceil.\nnow rewrite Ropp_involutive.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) (Hx : (0 <= x)%R) : Zceil (- x) = (- Zfloor x)%Z.","conclusion":"Zceil (- x) = (- Zfloor x)%Z","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"unfold Zceil.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (Hx : (0 <= x)%R) : (- Zfloor (- - x))%Z = (- Zfloor x)%Z.","conclusion":"(- Zfloor (- - x))%Z = (- Zfloor x)%Z","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x : R) (Hx : (0 <= x)%R) : (- x <= 0)%R.","conclusion":"(- x <= 0)%R","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"rewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) (Hx : (0 <= x)%R) : (- x <= - 0)%R.","conclusion":"(- x <= - 0)%R","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(n : Z) : Zaway (IZR n) = n.","conclusion":"Zaway (IZR n) = n","hypotheses":"(n : Z)","proofString":"unfold Zaway.\ncase Rlt_bool_spec ; intro H.\napply Zfloor_IZR.\napply Zceil_IZR."},{"statement":"(n : Z) : (if Rlt_bool (IZR n) 0 then Zfloor (IZR n) else Zceil (IZR n)) = n.","conclusion":"(if Rlt_bool (IZR n) 0 then Zfloor (IZR n) else Zceil (IZR n)) = n","hypotheses":"(n : Z)","proofString":"case Rlt_bool_spec ; intro H.\napply Zfloor_IZR.\napply Zceil_IZR."},{"statement":"(n : Z) (H : (IZR n < 0)%R) : Zfloor (IZR n) = n.","conclusion":"Zfloor (IZR n) = n","hypotheses":"(n : Z) (H : (IZR n < 0)%R)","proofString":"apply Zfloor_IZR."},{"statement":"(n : Z) (H : (0 <= IZR n)%R) : Zceil (IZR n) = n.","conclusion":"Zceil (IZR n) = n","hypotheses":"(n : Z) (H : (0 <= IZR n)%R)","proofString":"apply Zceil_IZR."},{"statement":"(x : R) (Hx : (0 <= x)%R) : Zaway x = Zceil x.","conclusion":"Zaway x = Zceil x","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"unfold Zaway.\ncase Rlt_bool_spec ; intro H.\nelim Rlt_irrefl with x.\nnow apply Rlt_le_trans with R0.\napply refl_equal."},{"statement":"(x : R) (Hx : (0 <= x)%R) : (if Rlt_bool x 0 then Zfloor x else Zceil x) = Zceil x.","conclusion":"(if Rlt_bool x 0 then Zfloor x else Zceil x) = Zceil x","hypotheses":"(x : R) (Hx : (0 <= x)%R)","proofString":"case Rlt_bool_spec ; intro H.\nelim Rlt_irrefl with x.\nnow apply Rlt_le_trans with R0.\napply refl_equal."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R) : Zfloor x = Zceil x.","conclusion":"Zfloor x = Zceil x","hypotheses":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R)","proofString":"elim Rlt_irrefl with x.\nnow apply Rlt_le_trans with R0."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R) : (x < x)%R.","conclusion":"(x < x)%R","hypotheses":"(x : R) (Hx : (0 <= x)%R) (H : (x < 0)%R)","proofString":"now apply Rlt_le_trans with R0."},{"statement":"(x : R) (Hx H : (0 <= x)%R) : Zceil x = Zceil x.","conclusion":"Zceil x = Zceil x","hypotheses":"(x : R) (Hx H : (0 <= x)%R)","proofString":"apply refl_equal."},{"statement":"(x : R) (Hx : (x <= 0)%R) : Zaway x = Zfloor x.","conclusion":"Zaway x = Zfloor x","hypotheses":"(x : R) (Hx : (x <= 0)%R)","proofString":"unfold Zaway.\ncase Rlt_bool_spec ; intro H.\napply refl_equal.\nrewrite (Rle_antisym _ _ Hx H).\nrewrite Zfloor_IZR.\napply Zceil_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) : (if Rlt_bool x 0 then Zfloor x else Zceil x) = Zfloor x.","conclusion":"(if Rlt_bool x 0 then Zfloor x else Zceil x) = Zfloor x","hypotheses":"(x : R) (Hx : (x <= 0)%R)","proofString":"case Rlt_bool_spec ; intro H.\napply refl_equal.\nrewrite (Rle_antisym _ _ Hx H).\nrewrite Zfloor_IZR.\napply Zceil_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (x < 0)%R) : Zfloor x = Zfloor x.","conclusion":"Zfloor x = Zfloor x","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (x < 0)%R)","proofString":"apply refl_equal."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R) : Zceil x = Zfloor x.","conclusion":"Zceil x = Zfloor x","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R)","proofString":"rewrite (Rle_antisym _ _ Hx H).\nrewrite Zfloor_IZR.\napply Zceil_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R) : Zceil 0 = Zfloor 0.","conclusion":"Zceil 0 = Zfloor 0","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R)","proofString":"rewrite Zfloor_IZR.\napply Zceil_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R) : Zceil 0 = 0%Z.","conclusion":"Zceil 0 = 0%Z","hypotheses":"(x : R) (Hx : (x <= 0)%R) (H : (0 <= x)%R)","proofString":"apply Zceil_IZR."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : (Zaway x <= Zaway y)%Z.","conclusion":"(Zaway x <= Zaway y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"unfold Zaway at 1.\ncase Rlt_bool_spec ; intro Hx.\nunfold Zaway.\ncase Rlt_bool_spec ; intro Hy.\nnow apply Zfloor_le.\napply le_IZR.\napply Rle_trans with 0%R.\napply Rlt_le.\napply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb.\napply Rle_trans with (1 := Hy).\napply Zceil_ub.\nrewrite Zaway_ceil.\nnow apply Zceil_le.\nnow apply Rle_trans with x."},{"statement":"(x y : R) (Hxy : (x <= y)%R) : ((if Rlt_bool x 0 then Zfloor x else Zceil x) <= Zaway y)%Z.","conclusion":"((if Rlt_bool x 0 then Zfloor x else Zceil x) <= Zaway y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R)","proofString":"case Rlt_bool_spec ; intro Hx.\nunfold Zaway.\ncase Rlt_bool_spec ; intro Hy.\nnow apply Zfloor_le.\napply le_IZR.\napply Rle_trans with 0%R.\napply Rlt_le.\napply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb.\napply Rle_trans with (1 := Hy).\napply Zceil_ub.\nrewrite Zaway_ceil.\nnow apply Zceil_le.\nnow apply Rle_trans with x."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) : (Zfloor x <= Zaway y)%Z.","conclusion":"(Zfloor x <= Zaway y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R)","proofString":"unfold Zaway.\ncase Rlt_bool_spec ; intro Hy.\nnow apply Zfloor_le.\napply le_IZR.\napply Rle_trans with 0%R.\napply Rlt_le.\napply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb.\napply Rle_trans with (1 := Hy).\napply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) : (Zfloor x <= (if Rlt_bool y 0 then Zfloor y else Zceil y))%Z.","conclusion":"(Zfloor x <= (if Rlt_bool y 0 then Zfloor y else Zceil y))%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R)","proofString":"case Rlt_bool_spec ; intro Hy.\nnow apply Zfloor_le.\napply le_IZR.\napply Rle_trans with 0%R.\napply Rlt_le.\napply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb.\napply Rle_trans with (1 := Hy).\napply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (y < 0)%R) : (Zfloor x <= Zfloor y)%Z.","conclusion":"(Zfloor x <= Zfloor y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (y < 0)%R)","proofString":"now apply Zfloor_le."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (Zfloor x <= Zceil y)%Z.","conclusion":"(Zfloor x <= Zceil y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply le_IZR.\napply Rle_trans with 0%R.\napply Rlt_le.\napply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb.\napply Rle_trans with (1 := Hy).\napply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (IZR (Zfloor x) <= IZR (Zceil y))%R.","conclusion":"(IZR (Zfloor x) <= IZR (Zceil y))%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Rle_trans with 0%R.\napply Rlt_le.\napply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb.\napply Rle_trans with (1 := Hy).\napply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (IZR (Zfloor x) <= 0)%R.","conclusion":"(IZR (Zfloor x) <= 0)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Rlt_le.\napply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (IZR (Zfloor x) < 0)%R.","conclusion":"(IZR (Zfloor x) < 0)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Rle_lt_trans with (2 := Hx).\napply Zfloor_lb."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (IZR (Zfloor x) <= x)%R.","conclusion":"(IZR (Zfloor x) <= x)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Zfloor_lb."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (0 <= IZR (Zceil y))%R.","conclusion":"(0 <= IZR (Zceil y))%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Rle_trans with (1 := Hy).\napply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R) : (y <= IZR (Zceil y))%R.","conclusion":"(y <= IZR (Zceil y))%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (x < 0)%R) (Hy : (0 <= y)%R)","proofString":"apply Zceil_ub."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R) : (Zceil x <= Zaway y)%Z.","conclusion":"(Zceil x <= Zaway y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R)","proofString":"rewrite Zaway_ceil.\nnow apply Zceil_le.\nnow apply Rle_trans with x."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R) : (Zceil x <= Zceil y)%Z.","conclusion":"(Zceil x <= Zceil y)%Z","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R)","proofString":"now apply Zceil_le."},{"statement":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R) : (0 <= y)%R.","conclusion":"(0 <= y)%R","hypotheses":"(x y : R) (Hxy : (x <= y)%R) (Hx : (0 <= x)%R)","proofString":"now apply Rle_trans with x."},{"statement":"(x : R) : Zaway (- x) = (- Zaway x)%Z.","conclusion":"Zaway (- x) = (- Zaway x)%Z","hypotheses":"(x : R)","proofString":"unfold Zaway at 2.\ncase Rlt_bool_spec ; intro H.\nrewrite Zaway_ceil.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Rlt_le.\nnow apply Ropp_0_gt_lt_contravar.\nrewrite Zaway_floor.\napply sym_eq.\napply Z.opp_involutive.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) : Zaway (- x) = (- (if Rlt_bool x 0 then Zfloor x else Zceil x))%Z.","conclusion":"Zaway (- x) = (- (if Rlt_bool x 0 then Zfloor x else Zceil x))%Z","hypotheses":"(x : R)","proofString":"case Rlt_bool_spec ; intro H.\nrewrite Zaway_ceil.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Rlt_le.\nnow apply Ropp_0_gt_lt_contravar.\nrewrite Zaway_floor.\napply sym_eq.\napply Z.opp_involutive.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) (H : (x < 0)%R) : Zaway (- x) = (- Zfloor x)%Z.","conclusion":"Zaway (- x) = (- Zfloor x)%Z","hypotheses":"(x : R) (H : (x < 0)%R)","proofString":"rewrite Zaway_ceil.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Rlt_le.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (H : (x < 0)%R) : Zceil (- x) = (- Zfloor x)%Z.","conclusion":"Zceil (- x) = (- Zfloor x)%Z","hypotheses":"(x : R) (H : (x < 0)%R)","proofString":"unfold Zceil.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) (H : (x < 0)%R) : (- Zfloor (- - x))%Z = (- Zfloor x)%Z.","conclusion":"(- Zfloor (- - x))%Z = (- Zfloor x)%Z","hypotheses":"(x : R) (H : (x < 0)%R)","proofString":"now rewrite Ropp_involutive."},{"statement":"(x : R) (H : (x < 0)%R) : (0 <= - x)%R.","conclusion":"(0 <= - x)%R","hypotheses":"(x : R) (H : (x < 0)%R)","proofString":"apply Rlt_le.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (H : (x < 0)%R) : (0 < - x)%R.","conclusion":"(0 < - x)%R","hypotheses":"(x : R) (H : (x < 0)%R)","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (H : (0 <= x)%R) : Zaway (- x) = (- Zceil x)%Z.","conclusion":"Zaway (- x) = (- Zceil x)%Z","hypotheses":"(x : R) (H : (0 <= x)%R)","proofString":"rewrite Zaway_floor.\napply sym_eq.\napply Z.opp_involutive.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) (H : (0 <= x)%R) : Zfloor (- x) = (- Zceil x)%Z.","conclusion":"Zfloor (- x) = (- Zceil x)%Z","hypotheses":"(x : R) (H : (0 <= x)%R)","proofString":"apply sym_eq.\napply Z.opp_involutive."},{"statement":"(x : R) (H : (0 <= x)%R) : (- Zceil x)%Z = Zfloor (- x).","conclusion":"(- Zceil x)%Z = Zfloor (- x)","hypotheses":"(x : R) (H : (0 <= x)%R)","proofString":"apply Z.opp_involutive."},{"statement":"(x : R) (H : (0 <= x)%R) : (- x <= 0)%R.","conclusion":"(- x <= 0)%R","hypotheses":"(x : R) (H : (0 <= x)%R)","proofString":"rewrite <- Ropp_0.\nnow apply Ropp_le_contravar."},{"statement":"(x : R) (H : (0 <= x)%R) : (- x <= - 0)%R.","conclusion":"(- x <= - 0)%R","hypotheses":"(x : R) (H : (0 <= x)%R)","proofString":"now apply Ropp_le_contravar."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : Rcompare (x - IZR (Zfloor x)) (/ 2) =\nRcompare (x - IZR (Zfloor x)) (IZR (Zceil x) - x).","conclusion":"Rcompare (x - IZR (Zfloor x)) (/ 2) =\nRcompare (x - IZR (Zfloor x)) (IZR (Zceil x) - x)","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"rewrite Zceil_floor_neq with (1 := Hx).\nrewrite plus_IZR.\ndestruct (Rcompare_spec (x - IZR (Zfloor x)) (/ 2)) as [H1|H1|H1] ; apply sym_eq.\napply Rcompare_Lt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt.\napply Rcompare_Eq.\nreplace (IZR (Zfloor x) + 1 - x)%R with (1 - (x - IZR (Zfloor x)))%R by ring.\nrewrite H1.\nfield.\napply Rcompare_Gt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : Rcompare (x - IZR (Zfloor x)) (/ 2) =\nRcompare (x - IZR (Zfloor x)) (IZR (Zfloor x + 1) - x).","conclusion":"Rcompare (x - IZR (Zfloor x)) (/ 2) =\nRcompare (x - IZR (Zfloor x)) (IZR (Zfloor x + 1) - x)","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"rewrite plus_IZR.\ndestruct (Rcompare_spec (x - IZR (Zfloor x)) (/ 2)) as [H1|H1|H1] ; apply sym_eq.\napply Rcompare_Lt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt.\napply Rcompare_Eq.\nreplace (IZR (Zfloor x) + 1 - x)%R with (1 - (x - IZR (Zfloor x)))%R by ring.\nrewrite H1.\nfield.\napply Rcompare_Gt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : Rcompare (x - IZR (Zfloor x)) (/ 2) =\nRcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x).","conclusion":"Rcompare (x - IZR (Zfloor x)) (/ 2) =\nRcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x)","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"destruct (Rcompare_spec (x - IZR (Zfloor x)) (/ 2)) as [H1|H1|H1] ; apply sym_eq.\napply Rcompare_Lt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt.\napply Rcompare_Eq.\nreplace (IZR (Zfloor x) + 1 - x)%R with (1 - (x - IZR (Zfloor x)))%R by ring.\nrewrite H1.\nfield.\napply Rcompare_Gt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R) : Rcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x) = Lt.","conclusion":"Rcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x) = Lt","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R)","proofString":"apply Rcompare_Lt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R) : (x - IZR (Zfloor x) < IZR (Zfloor x) + 1 - x)%R.","conclusion":"(x - IZR (Zfloor x) < IZR (Zfloor x) + 1 - x)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R)","proofString":"apply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R) : (x - IZR (Zfloor x) + (x - IZR (Zfloor x)) <\n x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R.","conclusion":"(x - IZR (Zfloor x) + (x - IZR (Zfloor x)) <\n x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R)","proofString":"replace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R) : ((x - IZR (Zfloor x)) * 2 < x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R.","conclusion":"((x - IZR (Zfloor x)) * 2 < x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R)","proofString":"replace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R) : ((x - IZR (Zfloor x)) * 2 < / 2 * 2)%R.","conclusion":"((x - IZR (Zfloor x)) * 2 < / 2 * 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R)","proofString":"apply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x) < / 2)%R)","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R) : Rcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x) = Eq.","conclusion":"Rcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x) = Eq","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R)","proofString":"apply Rcompare_Eq.\nreplace (IZR (Zfloor x) + 1 - x)%R with (1 - (x - IZR (Zfloor x)))%R by ring.\nrewrite H1.\nfield."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R) : (x - IZR (Zfloor x))%R = (IZR (Zfloor x) + 1 - x)%R.","conclusion":"(x - IZR (Zfloor x))%R = (IZR (Zfloor x) + 1 - x)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R)","proofString":"replace (IZR (Zfloor x) + 1 - x)%R with (1 - (x - IZR (Zfloor x)))%R by ring.\nrewrite H1.\nfield."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R) : (x - IZR (Zfloor x))%R = (1 - (x - IZR (Zfloor x)))%R.","conclusion":"(x - IZR (Zfloor x))%R = (1 - (x - IZR (Zfloor x)))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R)","proofString":"rewrite H1.\nfield."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R) : (/ 2)%R = (1 - / 2)%R.","conclusion":"(/ 2)%R = (1 - / 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (x - IZR (Zfloor x))%R = (/ 2)%R)","proofString":"field."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R) : Rcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x) = Gt.","conclusion":"Rcompare (x - IZR (Zfloor x)) (IZR (Zfloor x) + 1 - x) = Gt","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R)","proofString":"apply Rcompare_Gt.\napply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R) : (IZR (Zfloor x) + 1 - x < x - IZR (Zfloor x))%R.","conclusion":"(IZR (Zfloor x) + 1 - x < x - IZR (Zfloor x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R)","proofString":"apply Rplus_lt_reg_l with (x - IZR (Zfloor x))%R.\nreplace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R) : (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x) <\n x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R.","conclusion":"(x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x) <\n x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R)","proofString":"replace (x - IZR (Zfloor x) + (x - IZR (Zfloor x)))%R with ((x - IZR (Zfloor x)) * 2)%R by ring.\nreplace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R) : (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x) < (x - IZR (Zfloor x)) * 2)%R.","conclusion":"(x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x) < (x - IZR (Zfloor x)) * 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R)","proofString":"replace (x - IZR (Zfloor x) + (IZR (Zfloor x) + 1 - x))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R) : (/ 2 * 2 < (x - IZR (Zfloor x)) * 2)%R.","conclusion":"(/ 2 * 2 < (x - IZR (Zfloor x)) * 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R)","proofString":"apply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < x - IZR (Zfloor x))%R)","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : Rcompare (IZR (Zceil x) - x) (/ 2) =\nRcompare (IZR (Zceil x) - x) (x - IZR (Zfloor x)).","conclusion":"Rcompare (IZR (Zceil x) - x) (/ 2) =\nRcompare (IZR (Zceil x) - x) (x - IZR (Zfloor x))","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"rewrite Zceil_floor_neq with (1 := Hx).\nrewrite plus_IZR.\ndestruct (Rcompare_spec (IZR (Zfloor x) + 1 - x) (/ 2)) as [H1|H1|H1] ; apply sym_eq.\napply Rcompare_Lt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt.\napply Rcompare_Eq.\nreplace (x - IZR (Zfloor x))%R with (1 - (IZR (Zfloor x) + 1 - x))%R by ring.\nrewrite H1.\nfield.\napply Rcompare_Gt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : Rcompare (IZR (Zfloor x + 1) - x) (/ 2) =\nRcompare (IZR (Zfloor x + 1) - x) (x - IZR (Zfloor x)).","conclusion":"Rcompare (IZR (Zfloor x + 1) - x) (/ 2) =\nRcompare (IZR (Zfloor x + 1) - x) (x - IZR (Zfloor x))","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"rewrite plus_IZR.\ndestruct (Rcompare_spec (IZR (Zfloor x) + 1 - x) (/ 2)) as [H1|H1|H1] ; apply sym_eq.\napply Rcompare_Lt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt.\napply Rcompare_Eq.\nreplace (x - IZR (Zfloor x))%R with (1 - (IZR (Zfloor x) + 1 - x))%R by ring.\nrewrite H1.\nfield.\napply Rcompare_Gt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) : Rcompare (IZR (Zfloor x) + 1 - x) (/ 2) =\nRcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x)).","conclusion":"Rcompare (IZR (Zfloor x) + 1 - x) (/ 2) =\nRcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x))","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x)","proofString":"destruct (Rcompare_spec (IZR (Zfloor x) + 1 - x) (/ 2)) as [H1|H1|H1] ; apply sym_eq.\napply Rcompare_Lt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt.\napply Rcompare_Eq.\nreplace (x - IZR (Zfloor x))%R with (1 - (IZR (Zfloor x) + 1 - x))%R by ring.\nrewrite H1.\nfield.\napply Rcompare_Gt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R) : Rcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x)) = Lt.","conclusion":"Rcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x)) = Lt","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R)","proofString":"apply Rcompare_Lt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R) : (IZR (Zfloor x) + 1 - x < x - IZR (Zfloor x))%R.","conclusion":"(IZR (Zfloor x) + 1 - x < x - IZR (Zfloor x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R)","proofString":"apply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R) : (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x) <\n IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R.","conclusion":"(IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x) <\n IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R)","proofString":"replace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R) : ((IZR (Zfloor x) + 1 - x) * 2 < IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R.","conclusion":"((IZR (Zfloor x) + 1 - x) * 2 < IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R)","proofString":"replace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R) : ((IZR (Zfloor x) + 1 - x) * 2 < / 2 * 2)%R.","conclusion":"((IZR (Zfloor x) + 1 - x) * 2 < / 2 * 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R)","proofString":"apply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x < / 2)%R)","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R) : Rcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x)) = Eq.","conclusion":"Rcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x)) = Eq","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R)","proofString":"apply Rcompare_Eq.\nreplace (x - IZR (Zfloor x))%R with (1 - (IZR (Zfloor x) + 1 - x))%R by ring.\nrewrite H1.\nfield."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R) : (IZR (Zfloor x) + 1 - x)%R = (x - IZR (Zfloor x))%R.","conclusion":"(IZR (Zfloor x) + 1 - x)%R = (x - IZR (Zfloor x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R)","proofString":"replace (x - IZR (Zfloor x))%R with (1 - (IZR (Zfloor x) + 1 - x))%R by ring.\nrewrite H1.\nfield."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R) : (IZR (Zfloor x) + 1 - x)%R = (1 - (IZR (Zfloor x) + 1 - x))%R.","conclusion":"(IZR (Zfloor x) + 1 - x)%R = (1 - (IZR (Zfloor x) + 1 - x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R)","proofString":"rewrite H1.\nfield."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R) : (/ 2)%R = (1 - / 2)%R.","conclusion":"(/ 2)%R = (1 - / 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (IZR (Zfloor x) + 1 - x)%R = (/ 2)%R)","proofString":"field."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R) : Rcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x)) = Gt.","conclusion":"Rcompare (IZR (Zfloor x) + 1 - x) (x - IZR (Zfloor x)) = Gt","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R)","proofString":"apply Rcompare_Gt.\napply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R) : (x - IZR (Zfloor x) < IZR (Zfloor x) + 1 - x)%R.","conclusion":"(x - IZR (Zfloor x) < IZR (Zfloor x) + 1 - x)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R)","proofString":"apply Rplus_lt_reg_l with (IZR (Zfloor x) + 1 - x)%R.\nreplace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R) : (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)) <\n IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R.","conclusion":"(IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)) <\n IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R)","proofString":"replace (IZR (Zfloor x) + 1 - x + (IZR (Zfloor x) + 1 - x))%R with ((IZR (Zfloor x) + 1 - x) * 2)%R by ring.\nreplace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R) : (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)) < (IZR (Zfloor x) + 1 - x) * 2)%R.","conclusion":"(IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)) < (IZR (Zfloor x) + 1 - x) * 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R)","proofString":"replace (IZR (Zfloor x) + 1 - x + (x - IZR (Zfloor x)))%R with (/2 * 2)%R by field.\napply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R) : (/ 2 * 2 < (IZR (Zfloor x) + 1 - x) * 2)%R.","conclusion":"(/ 2 * 2 < (IZR (Zfloor x) + 1 - x) * 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R)","proofString":"apply Rmult_lt_compat_r with (2 := H1).\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(x : R) (Hx : IZR (Zfloor x) <> x) (H1 : (/ 2 < IZR (Zfloor x) + 1 - x)%R)","proofString":"now apply IZR_lt."},{"statement":"(x y : Z) (Zy : y <> 0%Z) : Zfloor (IZR x / IZR y) = (x / y)%Z.","conclusion":"Zfloor (IZR x / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z)","proofString":"generalize (Z.div_mod x y Zy).\nintros Hx.\nrewrite Hx at 1.\nassert (Zy': IZR y <> 0%R).\ncontradict Zy.\nnow apply eq_IZR.\nunfold Rdiv.\nrewrite plus_IZR, Rmult_plus_distr_r, mult_IZR.\nreplace (IZR y * IZR (x / y) * / IZR y)%R with (IZR (x / y)) by now field.\napply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) : x = (y * (x / y) + x mod y)%Z -> Zfloor (IZR x / IZR y) = (x / y)%Z.","conclusion":"x = (y * (x / y) + x mod y)%Z -> Zfloor (IZR x / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z)","proofString":"intros Hx.\nrewrite Hx at 1.\nassert (Zy': IZR y <> 0%R).\ncontradict Zy.\nnow apply eq_IZR.\nunfold Rdiv.\nrewrite plus_IZR, Rmult_plus_distr_r, mult_IZR.\nreplace (IZR y * IZR (x / y) * / IZR y)%R with (IZR (x / y)) by now field.\napply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) : Zfloor (IZR x / IZR y) = (x / y)%Z.","conclusion":"Zfloor (IZR x / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z)","proofString":"rewrite Hx at 1.\nassert (Zy': IZR y <> 0%R).\ncontradict Zy.\nnow apply eq_IZR.\nunfold Rdiv.\nrewrite plus_IZR, Rmult_plus_distr_r, mult_IZR.\nreplace (IZR y * IZR (x / y) * / IZR y)%R with (IZR (x / y)) by now field.\napply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) : Zfloor (IZR (y * (x / y) + x mod y) / IZR y) = (x / y)%Z.","conclusion":"Zfloor (IZR (y * (x / y) + x mod y) / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z)","proofString":"assert (Zy': IZR y <> 0%R).\ncontradict Zy.\nnow apply eq_IZR.\nunfold Rdiv.\nrewrite plus_IZR, Rmult_plus_distr_r, mult_IZR.\nreplace (IZR y * IZR (x / y) * / IZR y)%R with (IZR (x / y)) by now field.\napply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) : IZR y <> 0%R.","conclusion":"IZR y <> 0%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z)","proofString":"contradict Zy.\nnow apply eq_IZR."},{"statement":"(x y : Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy : IZR y = 0%R) : y = 0%Z.","conclusion":"y = 0%Z","hypotheses":"(x y : Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy : IZR y = 0%R)","proofString":"now apply eq_IZR."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : Zfloor (IZR (y * (x / y) + x mod y) / IZR y) = (x / y)%Z.","conclusion":"Zfloor (IZR (y * (x / y) + x mod y) / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"unfold Rdiv.\nrewrite plus_IZR, Rmult_plus_distr_r, mult_IZR.\nreplace (IZR y * IZR (x / y) * / IZR y)%R with (IZR (x / y)) by now field.\napply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : Zfloor (IZR (y * (x / y) + x mod y) * / IZR y) = (x / y)%Z.","conclusion":"Zfloor (IZR (y * (x / y) + x mod y) * / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"rewrite plus_IZR, Rmult_plus_distr_r, mult_IZR.\nreplace (IZR y * IZR (x / y) * / IZR y)%R with (IZR (x / y)) by now field.\napply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : Zfloor (IZR y * IZR (x / y) * / IZR y + IZR (x mod y) * / IZR y) = (x / y)%Z.","conclusion":"Zfloor (IZR y * IZR (x / y) * / IZR y + IZR (x mod y) * / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"replace (IZR y * IZR (x / y) * / IZR y)%R with (IZR (x / y)) by now field.\napply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : Zfloor (IZR (x / y) + IZR (x mod y) * / IZR y) = (x / y)%Z.","conclusion":"Zfloor (IZR (x / y) + IZR (x mod y) * / IZR y) = (x / y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"apply Zfloor_imp.\nrewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : (IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y + 1))%R.","conclusion":"(IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y + 1))%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"rewrite plus_IZR.\nassert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : (IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y) + 1)%R.","conclusion":"(IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y) + 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"assert (0 <= IZR (x mod y) * / IZR y < 1)%R.\nassert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia.\nsplit.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : (0 <= IZR (x mod y) * / IZR y < 1)%R.","conclusion":"(0 <= IZR (x mod y) * / IZR y < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"assert (forall x' y', (0 < y')%Z -> 0 <= IZR (x' mod y') * / IZR y' < 1)%R.\nclear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt.\ndestruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R.","conclusion":"forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R)","proofString":"clear.\nintros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt."},{"statement":"forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R.","conclusion":"forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R","hypotheses":"","proofString":"intros x y Hy.\nsplit.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 <= IZR (x mod y) * / IZR y < 1)%R.","conclusion":"(0 <= IZR (x mod y) * / IZR y < 1)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"split.\napply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 <= IZR (x mod y) * / IZR y)%R.","conclusion":"(0 <= IZR (x mod y) * / IZR y)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"apply Rmult_le_pos.\napply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 <= IZR (x mod y))%R.","conclusion":"(0 <= IZR (x mod y))%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"apply IZR_le.\nrefine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 <= x mod y)%Z.","conclusion":"(0 <= x mod y)%Z","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"refine (proj1 (Z_mod_lt _ _ _)).\nnow apply Z.lt_gt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (y > 0)%Z.","conclusion":"(y > 0)%Z","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"now apply Z.lt_gt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 <= / IZR y)%R.","conclusion":"(0 <= / IZR y)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"apply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 < / IZR y)%R.","conclusion":"(0 < / IZR y)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 < IZR y)%R.","conclusion":"(0 < IZR y)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"now apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (IZR (x mod y) * / IZR y < 1)%R.","conclusion":"(IZR (x mod y) * / IZR y < 1)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"apply Rmult_lt_reg_r with (IZR y).\nnow apply IZR_lt.\nrewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (0 < IZR y)%R.","conclusion":"(0 < IZR y)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"now apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (IZR (x mod y) * / IZR y * IZR y < 1 * IZR y)%R.","conclusion":"(IZR (x mod y) * / IZR y * IZR y < 1 * IZR y)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"rewrite Rmult_1_l, Rmult_assoc, Rinv_l, Rmult_1_r.\napply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt.\napply Rgt_not_eq.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (IZR (x mod y) < IZR y)%R.","conclusion":"(IZR (x mod y) < IZR y)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"apply IZR_lt.\neapply Z_mod_lt.\nnow apply Z.lt_gt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (x mod y < y)%Z.","conclusion":"(x mod y < y)%Z","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"eapply Z_mod_lt.\nnow apply Z.lt_gt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (y > 0)%Z.","conclusion":"(y > 0)%Z","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"now apply Z.lt_gt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : IZR y <> 0%R.","conclusion":"IZR y <> 0%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"apply Rgt_not_eq.\nnow apply IZR_lt."},{"statement":"(x y : Z) (Hy : (0 < y)%Z) : (IZR y > 0)%R.","conclusion":"(IZR y > 0)%R","hypotheses":"(x y : Z) (Hy : (0 < y)%Z)","proofString":"now apply IZR_lt."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) : (0 <= IZR (x mod y) * / IZR y < 1)%R.","conclusion":"(0 <= IZR (x mod y) * / IZR y < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R)","proofString":"destruct (Z_lt_le_dec y 0) as [Hy|Hy].\nrewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia.\napply H.\nclear -Zy Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z) : (0 <= IZR (x mod y) * / IZR y < 1)%R.","conclusion":"(0 <= IZR (x mod y) * / IZR y < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z)","proofString":"rewrite <- Rmult_opp_opp.\nrewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z) : (0 <= - IZR (x mod y) * - / IZR y < 1)%R.","conclusion":"(0 <= - IZR (x mod y) * - / IZR y < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z)","proofString":"rewrite Ropp_inv_permute with (1 := Zy').\nrewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z) : (0 <= - IZR (x mod y) * / - IZR y < 1)%R.","conclusion":"(0 <= - IZR (x mod y) * / - IZR y < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z)","proofString":"rewrite <- 2!opp_IZR.\nrewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z) : (0 <= IZR (- (x mod y)) * / IZR (- y) < 1)%R.","conclusion":"(0 <= IZR (- (x mod y)) * / IZR (- y) < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z)","proofString":"rewrite <- Zmod_opp_opp.\napply H.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z) : (0 <= IZR (- x mod - y) * / IZR (- y) < 1)%R.","conclusion":"(0 <= IZR (- x mod - y) * / IZR (- y) < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z)","proofString":"apply H.\nclear -Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z) : (0 < - y)%Z.","conclusion":"(0 < - y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (y < 0)%Z)","proofString":"clear -Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (0 <= y)%Z) : (0 <= IZR (x mod y) * / IZR y < 1)%R.","conclusion":"(0 <= IZR (x mod y) * / IZR y < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (0 <= y)%Z)","proofString":"apply H.\nclear -Zy Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (0 <= y)%Z) : (0 < y)%Z.","conclusion":"(0 < y)%Z","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : forall x' y' : Z, (0 < y')%Z -> (0 <= IZR (x' mod y') * / IZR y' < 1)%R) (Hy : (0 <= y)%Z)","proofString":"clear -Zy Hy ; lia."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R) : (IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y) + 1)%R.","conclusion":"(IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y) + 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R)","proofString":"split.\npattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\napply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R) : (IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y)%R.","conclusion":"(IZR (x / y) <= IZR (x / y) + IZR (x mod y) * / IZR y)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R)","proofString":"pattern (IZR (x / y)) at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R) : (IZR (x / y) + 0 <= IZR (x / y) + IZR (x mod y) * / IZR y)%R.","conclusion":"(IZR (x / y) + 0 <= IZR (x / y) + IZR (x mod y) * / IZR y)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R)","proofString":"apply Rplus_le_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R) : (0 <= IZR (x mod y) * / IZR y)%R.","conclusion":"(0 <= IZR (x mod y) * / IZR y)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R)","proofString":"apply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R) : (IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y) + 1)%R.","conclusion":"(IZR (x / y) + IZR (x mod y) * / IZR y < IZR (x / y) + 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R)","proofString":"apply Rplus_lt_compat_l.\napply H."},{"statement":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R) : (IZR (x mod y) * / IZR y < 1)%R.","conclusion":"(IZR (x mod y) * / IZR y < 1)%R","hypotheses":"(x y : Z) (Zy : y <> 0%Z) (Hx : x = (y * (x / y) + x mod y)%Z) (Zy' : IZR y <> 0%R) (H : (0 <= IZR (x mod y) * / IZR y < 1)%R)","proofString":"apply H."},{"statement":"(p : positive) : Ztrunc (0 / IZR (Z.pos p)) = (0 ÷ Z.pos p)%Z.","conclusion":"Ztrunc (0 / IZR (Z.pos p)) = (0 ÷ Z.pos p)%Z","hypotheses":"(p : positive)","proofString":"rewrite Z.quot_0_l; [| easy].\nunfold Rdiv.\nrewrite Rmult_0_l.\nrewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Ztrunc (0 / IZR (Z.pos p)) = 0%Z.","conclusion":"Ztrunc (0 / IZR (Z.pos p)) = 0%Z","hypotheses":"(p : positive)","proofString":"unfold Rdiv.\nrewrite Rmult_0_l.\nrewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Ztrunc (0 * / IZR (Z.pos p)) = 0%Z.","conclusion":"Ztrunc (0 * / IZR (Z.pos p)) = 0%Z","hypotheses":"(p : positive)","proofString":"rewrite Rmult_0_l.\nrewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Ztrunc 0 = 0%Z.","conclusion":"Ztrunc 0 = 0%Z","hypotheses":"(p : positive)","proofString":"rewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Zfloor 0 = 0%Z.","conclusion":"Zfloor 0 = 0%Z","hypotheses":"(p : positive)","proofString":"now rewrite Zfloor_IZR."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) = (Z.pos p0 ÷ Z.pos p)%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) = (Z.pos p0 ÷ Z.pos p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) = (Z.pos p0 / Z.pos p)%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) = (Z.pos p0 / Z.pos p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite <-Zfloor_div; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p)).","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p))","hypotheses":"(p0 p : positive)","proofString":"unfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : (if Rlt_bool (IZR (Z.pos p0) / IZR (Z.pos p)) 0\n then Zceil (IZR (Z.pos p0) / IZR (Z.pos p))\n else Zfloor (IZR (Z.pos p0) / IZR (Z.pos p))) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p)).","conclusion":"(if Rlt_bool (IZR (Z.pos p0) / IZR (Z.pos p)) 0\n then Zceil (IZR (Z.pos p0) / IZR (Z.pos p))\n else Zfloor (IZR (Z.pos p0) / IZR (Z.pos p))) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p))","hypotheses":"(p0 p : positive)","proofString":"rewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : (0 <= IZR (Z.pos p0) / IZR (Z.pos p))%R.","conclusion":"(0 <= IZR (Z.pos p0) / IZR (Z.pos p))%R","hypotheses":"(p0 p : positive)","proofString":"apply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.neg p0) / IZR (Z.pos p)) = (Z.neg p0 ÷ Z.pos p)%Z.","conclusion":"Ztrunc (IZR (Z.neg p0) / IZR (Z.pos p)) = (Z.neg p0 ÷ Z.pos p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite <-Pos2Z.opp_pos.\nrewrite Z.quot_opp_l; [| easy].\nrewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div.\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) = (- Z.pos p0 ÷ Z.pos p)%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) = (- Z.pos p0 ÷ Z.pos p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_opp_l; [| easy].\nrewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div.\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) = (- (Z.pos p0 ÷ Z.pos p))%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) = (- (Z.pos p0 ÷ Z.pos p))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div.\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) = (- (Z.pos p0 / Z.pos p))%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) = (- (Z.pos p0 / Z.pos p))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div.\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Ropp_Ropp_IZR.\nrewrite Ropp_div.\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (- IZR (Z.pos p0) / IZR (Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (- IZR (Z.pos p0) / IZR (Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Ropp_div.\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"unfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : (if Rlt_bool (- (IZR (Z.pos p0) / IZR (Z.pos p))) 0\n then Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p)))\n else Zfloor (- (IZR (Z.pos p0) / IZR (Z.pos p)))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"(if Rlt_bool (- (IZR (Z.pos p0) / IZR (Z.pos p))) 0\n then Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p)))\n else Zfloor (- (IZR (Z.pos p0) / IZR (Z.pos p)))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"unfold Zceil.\nnow rewrite Ropp_involutive."},{"statement":"(p0 p : positive) : (- Zfloor (- - (IZR (Z.pos p0) / IZR (Z.pos p))))%Z =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"(- Zfloor (- - (IZR (Z.pos p0) / IZR (Z.pos p))))%Z =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"now rewrite Ropp_involutive."},{"statement":"(p0 p : positive) : (- (IZR (Z.pos p0) / IZR (Z.pos p)) < 0)%R.","conclusion":"(- (IZR (Z.pos p0) / IZR (Z.pos p)) < 0)%R","hypotheses":"(p0 p : positive)","proofString":"apply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : (IZR (Z.pos p0) / IZR (Z.pos p) > 0)%R.","conclusion":"(IZR (Z.pos p0) / IZR (Z.pos p) > 0)%R","hypotheses":"(p0 p : positive)","proofString":"apply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p : positive) : Ztrunc (0 / IZR (Z.neg p)) = (0 ÷ Z.neg p)%Z.","conclusion":"Ztrunc (0 / IZR (Z.neg p)) = (0 ÷ Z.neg p)%Z","hypotheses":"(p : positive)","proofString":"rewrite Z.quot_0_l; [| easy].\nunfold Rdiv.\nrewrite Rmult_0_l.\nrewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Ztrunc (0 / IZR (Z.neg p)) = 0%Z.","conclusion":"Ztrunc (0 / IZR (Z.neg p)) = 0%Z","hypotheses":"(p : positive)","proofString":"unfold Rdiv.\nrewrite Rmult_0_l.\nrewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Ztrunc (0 * / IZR (Z.neg p)) = 0%Z.","conclusion":"Ztrunc (0 * / IZR (Z.neg p)) = 0%Z","hypotheses":"(p : positive)","proofString":"rewrite Rmult_0_l.\nrewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Ztrunc 0 = 0%Z.","conclusion":"Ztrunc 0 = 0%Z","hypotheses":"(p : positive)","proofString":"rewrite Ztrunc_floor; [| apply Rle_refl].\nnow rewrite Zfloor_IZR."},{"statement":"(p : positive) : Zfloor 0 = 0%Z.","conclusion":"Zfloor 0 = 0%Z","hypotheses":"(p : positive)","proofString":"now rewrite Zfloor_IZR."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (Z.neg p)) = (Z.pos p0 ÷ Z.neg p)%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (Z.neg p)) = (Z.pos p0 ÷ Z.neg p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite <-Pos2Z.opp_pos.\nrewrite Z.quot_opp_r; [| easy].\nrewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div_den; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) = (Z.pos p0 ÷ - Z.pos p)%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) = (Z.pos p0 ÷ - Z.pos p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_opp_r; [| easy].\nrewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div_den; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) = (- (Z.pos p0 ÷ Z.pos p))%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) = (- (Z.pos p0 ÷ Z.pos p))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div_den; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) = (- (Z.pos p0 / Z.pos p))%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) = (- (Z.pos p0 / Z.pos p))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite <-Zfloor_div; [| easy].\nrewrite Ropp_Ropp_IZR.\nrewrite Ropp_div_den; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (- Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Ropp_Ropp_IZR.\nrewrite Ropp_div_den; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / - IZR (Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (IZR (Z.pos p0) / - IZR (Z.pos p)) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Ropp_div_den; [| easy].\nunfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"unfold Ztrunc.\nrewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : (if Rlt_bool (- (IZR (Z.pos p0) / IZR (Z.pos p))) 0\n then Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p)))\n else Zfloor (- (IZR (Z.pos p0) / IZR (Z.pos p)))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"(if Rlt_bool (- (IZR (Z.pos p0) / IZR (Z.pos p))) 0\n then Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p)))\n else Zfloor (- (IZR (Z.pos p0) / IZR (Z.pos p)))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Rlt_bool_true.\nunfold Zceil.\nnow rewrite Ropp_involutive.\napply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Zceil (- (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"unfold Zceil.\nnow rewrite Ropp_involutive."},{"statement":"(p0 p : positive) : (- Zfloor (- - (IZR (Z.pos p0) / IZR (Z.pos p))))%Z =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"(- Zfloor (- - (IZR (Z.pos p0) / IZR (Z.pos p))))%Z =\n(- Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"now rewrite Ropp_involutive."},{"statement":"(p0 p : positive) : (- (IZR (Z.pos p0) / IZR (Z.pos p)) < 0)%R.","conclusion":"(- (IZR (Z.pos p0) / IZR (Z.pos p)) < 0)%R","hypotheses":"(p0 p : positive)","proofString":"apply Ropp_lt_gt_0_contravar.\napply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : (IZR (Z.pos p0) / IZR (Z.pos p) > 0)%R.","conclusion":"(IZR (Z.pos p0) / IZR (Z.pos p) > 0)%R","hypotheses":"(p0 p : positive)","proofString":"apply Rdiv_lt_0_compat; now apply IZR_lt."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.neg p0) / IZR (Z.neg p)) = (Z.neg p0 ÷ Z.neg p)%Z.","conclusion":"Ztrunc (IZR (Z.neg p0) / IZR (Z.neg p)) = (Z.neg p0 ÷ Z.neg p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite <-2Pos2Z.opp_pos.\nrewrite Z.quot_opp_l; [| easy].\nrewrite Z.quot_opp_r; [| easy].\nrewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite 2Ropp_Ropp_IZR.\nrewrite Ropp_div.\nrewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- Z.pos p0 ÷ - Z.pos p)%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- Z.pos p0 ÷ - Z.pos p)%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_opp_l; [| easy].\nrewrite Z.quot_opp_r; [| easy].\nrewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite 2Ropp_Ropp_IZR.\nrewrite Ropp_div.\nrewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- (Z.pos p0 ÷ - Z.pos p))%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- (Z.pos p0 ÷ - Z.pos p))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_opp_r; [| easy].\nrewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite 2Ropp_Ropp_IZR.\nrewrite Ropp_div.\nrewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- - (Z.pos p0 ÷ Z.pos p))%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- - (Z.pos p0 ÷ Z.pos p))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.quot_div_nonneg; [| easy | easy].\nrewrite <-Zfloor_div; [| easy].\nrewrite 2Ropp_Ropp_IZR.\nrewrite Ropp_div.\nrewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- - (Z.pos p0 / Z.pos p))%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) = (- - (Z.pos p0 / Z.pos p))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite <-Zfloor_div; [| easy].\nrewrite 2Ropp_Ropp_IZR.\nrewrite Ropp_div.\nrewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (IZR (- Z.pos p0) / IZR (- Z.pos p)) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite 2Ropp_Ropp_IZR.\nrewrite Ropp_div.\nrewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (- IZR (Z.pos p0) / - IZR (Z.pos p)) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (- IZR (Z.pos p0) / - IZR (Z.pos p)) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Ropp_div.\nrewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (- (IZR (Z.pos p0) / - IZR (Z.pos p))) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (- (IZR (Z.pos p0) / - IZR (Z.pos p))) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Ropp_div_den; [| easy].\nrewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (- - (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z.","conclusion":"Ztrunc (- - (IZR (Z.pos p0) / IZR (Z.pos p))) =\n(- - Zfloor (IZR (Z.pos p0) / IZR (Z.pos p)))%Z","hypotheses":"(p0 p : positive)","proofString":"rewrite Z.opp_involutive.\nrewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (- - (IZR (Z.pos p0) / IZR (Z.pos p))) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p)).","conclusion":"Ztrunc (- - (IZR (Z.pos p0) / IZR (Z.pos p))) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p))","hypotheses":"(p0 p : positive)","proofString":"rewrite Ropp_involutive.\nunfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p)).","conclusion":"Ztrunc (IZR (Z.pos p0) / IZR (Z.pos p)) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p))","hypotheses":"(p0 p : positive)","proofString":"unfold Ztrunc.\nrewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : (if Rlt_bool (IZR (Z.pos p0) / IZR (Z.pos p)) 0\n then Zceil (IZR (Z.pos p0) / IZR (Z.pos p))\n else Zfloor (IZR (Z.pos p0) / IZR (Z.pos p))) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p)).","conclusion":"(if Rlt_bool (IZR (Z.pos p0) / IZR (Z.pos p)) 0\n then Zceil (IZR (Z.pos p0) / IZR (Z.pos p))\n else Zfloor (IZR (Z.pos p0) / IZR (Z.pos p))) =\nZfloor (IZR (Z.pos p0) / IZR (Z.pos p))","hypotheses":"(p0 p : positive)","proofString":"rewrite Rlt_bool_false; [reflexivity |].\napply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(p0 p : positive) : (0 <= IZR (Z.pos p0) / IZR (Z.pos p))%R.","conclusion":"(0 <= IZR (Z.pos p0) / IZR (Z.pos p))%R","hypotheses":"(p0 p : positive)","proofString":"apply Rle_mult_inv_pos; [now apply IZR_le | now apply IZR_lt]."},{"statement":"(v : Z) (Hr : (2 <=? v)%Z = true) : (0 < IZR {| radix_val := v; radix_prop := Hr |})%R.","conclusion":"(0 < IZR {| radix_val := v; radix_prop := Hr |})%R","hypotheses":"(v : Z) (Hr : (2 <=? v)%Z = true)","proofString":"simpl.\napply IZR_lt.\napply Z.lt_le_trans with 2%Z.\neasy.\nnow apply Zle_bool_imp_le."},{"statement":"(v : Z) (Hr : (2 <=? v)%Z = true) : (0 < IZR v)%R.","conclusion":"(0 < IZR v)%R","hypotheses":"(v : Z) (Hr : (2 <=? v)%Z = true)","proofString":"apply IZR_lt.\napply Z.lt_le_trans with 2%Z.\neasy.\nnow apply Zle_bool_imp_le."},{"statement":"(v : Z) (Hr : (2 <=? v)%Z = true) : (0 < v)%Z.","conclusion":"(0 < v)%Z","hypotheses":"(v : Z) (Hr : (2 <=? v)%Z = true)","proofString":"apply Z.lt_le_trans with 2%Z.\neasy.\nnow apply Zle_bool_imp_le."},{"statement":"(v : Z) (Hr : (2 <=? v)%Z = true) : (0 < 2)%Z.","conclusion":"(0 < 2)%Z","hypotheses":"(v : Z) (Hr : (2 <=? v)%Z = true)","proofString":"easy."},{"statement":"(v : Z) (Hr : (2 <=? v)%Z = true) : (2 <= v)%Z.","conclusion":"(2 <= v)%Z","hypotheses":"(v : Z) (Hr : (2 <=? v)%Z = true)","proofString":"now apply Zle_bool_imp_le."},{"statement":"(n : Z) (m : positive) : IZR (Z.pow_pos n m) = powerRZ (IZR n) (Z.pos m).","conclusion":"IZR (Z.pow_pos n m) = powerRZ (IZR n) (Z.pos m)","hypotheses":"(n : Z) (m : positive)","proofString":"rewrite Zpower_pos_nat.\nsimpl.\ninduction (nat_of_P m).\napply refl_equal.\nunfold Zpower_nat.\nsimpl.\nrewrite mult_IZR.\napply Rmult_eq_compat_l.\nexact IHn0."},{"statement":"(n : Z) (m : positive) : IZR (Zpower_nat n (Pos.to_nat m)) = powerRZ (IZR n) (Z.pos m).","conclusion":"IZR (Zpower_nat n (Pos.to_nat m)) = powerRZ (IZR n) (Z.pos m)","hypotheses":"(n : Z) (m : positive)","proofString":"simpl.\ninduction (nat_of_P m).\napply refl_equal.\nunfold Zpower_nat.\nsimpl.\nrewrite mult_IZR.\napply Rmult_eq_compat_l.\nexact IHn0."},{"statement":"(n : Z) (m : positive) : IZR (Zpower_nat n (Pos.to_nat m)) = (IZR n ^ Pos.to_nat m)%R.","conclusion":"IZR (Zpower_nat n (Pos.to_nat m)) = (IZR n ^ Pos.to_nat m)%R","hypotheses":"(n : Z) (m : positive)","proofString":"induction (nat_of_P m).\napply refl_equal.\nunfold Zpower_nat.\nsimpl.\nrewrite mult_IZR.\napply Rmult_eq_compat_l.\nexact IHn0."},{"statement":"(n : Z) (m : positive) : IZR (Zpower_nat n 0) = (IZR n ^ 0)%R.","conclusion":"IZR (Zpower_nat n 0) = (IZR n ^ 0)%R","hypotheses":"(n : Z) (m : positive)","proofString":"apply refl_equal."},{"statement":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R) : IZR (Zpower_nat n (S n0)) = (IZR n ^ S n0)%R.","conclusion":"IZR (Zpower_nat n (S n0)) = (IZR n ^ S n0)%R","hypotheses":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R)","proofString":"unfold Zpower_nat.\nsimpl.\nrewrite mult_IZR.\napply Rmult_eq_compat_l.\nexact IHn0."},{"statement":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R) : IZR (nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) (S n0)) =\n(IZR n ^ S n0)%R.","conclusion":"IZR (nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) (S n0)) =\n(IZR n ^ S n0)%R","hypotheses":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R)","proofString":"simpl.\nrewrite mult_IZR.\napply Rmult_eq_compat_l.\nexact IHn0."},{"statement":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R) : IZR (n * nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) n0) =\n(IZR n * IZR n ^ n0)%R.","conclusion":"IZR (n * nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) n0) =\n(IZR n * IZR n ^ n0)%R","hypotheses":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R)","proofString":"rewrite mult_IZR.\napply Rmult_eq_compat_l.\nexact IHn0."},{"statement":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R) : (IZR n * IZR (nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) n0))%R =\n(IZR n * IZR n ^ n0)%R.","conclusion":"(IZR n * IZR (nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) n0))%R =\n(IZR n * IZR n ^ n0)%R","hypotheses":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R)","proofString":"apply Rmult_eq_compat_l.\nexact IHn0."},{"statement":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R) : IZR (nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) n0) =\n(IZR n ^ n0)%R.","conclusion":"IZR (nat_rect (fun _ : nat => Z) 1%Z (fun _ : nat => Z.mul n) n0) =\n(IZR n ^ n0)%R","hypotheses":"(n : Z) (m : positive) (n0 : nat) (IHn0 : IZR (Zpower_nat n n0) = (IZR n ^ n0)%R)","proofString":"exact IHn0."},{"statement":"1%R = powerRZ (IZR r) 0.","conclusion":"1%R = powerRZ (IZR r) 0","hypotheses":"","proofString":"reflexivity."},{"statement":"(p : positive) : IZR (Z.pow_pos r p) = powerRZ (IZR r) (Z.pos p).","conclusion":"IZR (Z.pow_pos r p) = powerRZ (IZR r) (Z.pos p)","hypotheses":"(p : positive)","proofString":"now rewrite IZR_Zpower_pos."},{"statement":"(p : positive) : (/ IZR (Z.pow_pos r p))%R = powerRZ (IZR r) (Z.neg p).","conclusion":"(/ IZR (Z.pow_pos r p))%R = powerRZ (IZR r) (Z.neg p)","hypotheses":"(p : positive)","proofString":"now rewrite IZR_Zpower_pos."},{"statement":"(e : Z) : (0 <= bpow e)%R.","conclusion":"(0 <= bpow e)%R","hypotheses":"(e : Z)","proofString":"rewrite bpow_powerRZ.\napply powerRZ_le.\napply radix_pos."},{"statement":"(e : Z) : (0 <= powerRZ (IZR r) e)%R.","conclusion":"(0 <= powerRZ (IZR r) e)%R","hypotheses":"(e : Z)","proofString":"apply powerRZ_le.\napply radix_pos."},{"statement":"(e : Z) : (0 < IZR r)%R.","conclusion":"(0 < IZR r)%R","hypotheses":"(e : Z)","proofString":"apply radix_pos."},{"statement":"(e : Z) : (0 < bpow e)%R.","conclusion":"(0 < bpow e)%R","hypotheses":"(e : Z)","proofString":"rewrite bpow_powerRZ.\napply powerRZ_lt.\napply radix_pos."},{"statement":"(e : Z) : (0 < powerRZ (IZR r) e)%R.","conclusion":"(0 < powerRZ (IZR r) e)%R","hypotheses":"(e : Z)","proofString":"apply powerRZ_lt.\napply radix_pos."},{"statement":"(e : Z) : (0 < IZR r)%R.","conclusion":"(0 < IZR r)%R","hypotheses":"(e : Z)","proofString":"apply radix_pos."},{"statement":"(e1 e2 : Z) : bpow (e1 + e2) = (bpow e1 * bpow e2)%R.","conclusion":"bpow (e1 + e2) = (bpow e1 * bpow e2)%R","hypotheses":"(e1 e2 : Z)","proofString":"repeat rewrite bpow_powerRZ.\napply powerRZ_add.\napply Rgt_not_eq.\napply radix_pos."},{"statement":"(e1 e2 : Z) : powerRZ (IZR r) (e1 + e2) = (powerRZ (IZR r) e1 * powerRZ (IZR r) e2)%R.","conclusion":"powerRZ (IZR r) (e1 + e2) = (powerRZ (IZR r) e1 * powerRZ (IZR r) e2)%R","hypotheses":"(e1 e2 : Z)","proofString":"apply powerRZ_add.\napply Rgt_not_eq.\napply radix_pos."},{"statement":"(e1 e2 : Z) : IZR r <> 0%R.","conclusion":"IZR r <> 0%R","hypotheses":"(e1 e2 : Z)","proofString":"apply Rgt_not_eq.\napply radix_pos."},{"statement":"(e1 e2 : Z) : (IZR r > 0)%R.","conclusion":"(IZR r > 0)%R","hypotheses":"(e1 e2 : Z)","proofString":"apply radix_pos."},{"statement":"IZR (Pos.iter (Z.mul r) 1%Z 1) = IZR r.","conclusion":"IZR (Pos.iter (Z.mul r) 1%Z 1) = IZR r","hypotheses":"","proofString":"simpl.\nnow rewrite Zmult_1_r."},{"statement":"IZR (r * 1) = IZR r.","conclusion":"IZR (r * 1) = IZR r","hypotheses":"","proofString":"now rewrite Zmult_1_r."},{"statement":"(e : Z) : bpow (e + 1) = (IZR r * bpow e)%R.","conclusion":"bpow (e + 1) = (IZR r * bpow e)%R","hypotheses":"(e : Z)","proofString":"rewrite <- bpow_1.\nrewrite <- bpow_plus.\nnow rewrite Zplus_comm."},{"statement":"(e : Z) : bpow (e + 1) = (bpow 1 * bpow e)%R.","conclusion":"bpow (e + 1) = (bpow 1 * bpow e)%R","hypotheses":"(e : Z)","proofString":"rewrite <- bpow_plus.\nnow rewrite Zplus_comm."},{"statement":"(e : Z) : bpow (e + 1) = bpow (1 + e).","conclusion":"bpow (e + 1) = bpow (1 + e)","hypotheses":"(e : Z)","proofString":"now rewrite Zplus_comm."},{"statement":"bpow (- 0) = (/ bpow 0)%R.","conclusion":"bpow (- 0) = (/ bpow 0)%R","hypotheses":"","proofString":"apply eq_sym, Rinv_1."},{"statement":"(p : positive) : bpow (- Z.pos p) = (/ bpow (Z.pos p))%R.","conclusion":"bpow (- Z.pos p) = (/ bpow (Z.pos p))%R","hypotheses":"(p : positive)","proofString":"now change (-Zpos p)%Z with (Zneg p)."},{"statement":"(p : positive) : bpow (- Z.neg p) = (/ bpow (Z.neg p))%R.","conclusion":"bpow (- Z.neg p) = (/ bpow (Z.neg p))%R","hypotheses":"(p : positive)","proofString":"change (-Zneg p)%Z with (Zpos p).\nsimpl; rewrite Rinv_involutive; trivial.\napply Rgt_not_eq.\napply (bpow_gt_0 (Zpos p))."},{"statement":"(p : positive) : bpow (Z.pos p) = (/ bpow (Z.neg p))%R.","conclusion":"bpow (Z.pos p) = (/ bpow (Z.neg p))%R","hypotheses":"(p : positive)","proofString":"simpl; rewrite Rinv_involutive; trivial.\napply Rgt_not_eq.\napply (bpow_gt_0 (Zpos p))."},{"statement":"(p : positive) : IZR (Z.pow_pos r p) <> 0%R.","conclusion":"IZR (Z.pow_pos r p) <> 0%R","hypotheses":"(p : positive)","proofString":"apply Rgt_not_eq.\napply (bpow_gt_0 (Zpos p))."},{"statement":"(p : positive) : (IZR (Z.pow_pos r p) > 0)%R.","conclusion":"(IZR (Z.pow_pos r p) > 0)%R","hypotheses":"(p : positive)","proofString":"apply (bpow_gt_0 (Zpos p))."},{"statement":"IZR (Zpower_nat r 0) = bpow (Z.of_nat 0).","conclusion":"IZR (Zpower_nat r 0) = bpow (Z.of_nat 0)","hypotheses":"","proofString":"split."},{"statement":"(e : nat) : IZR (Zpower_nat r (S e)) = bpow (Z.of_nat (S e)).","conclusion":"IZR (Zpower_nat r (S e)) = bpow (Z.of_nat (S e))","hypotheses":"(e : nat)","proofString":"rewrite <- nat_of_P_o_P_of_succ_nat_eq_succ.\nrewrite <- Zpower_pos_nat.\nnow rewrite <- Zpos_eq_Z_of_nat_o_nat_of_P."},{"statement":"(e : nat) : IZR (Zpower_nat r (Pos.to_nat (Pos.of_succ_nat e))) =\nbpow (Z.of_nat (Pos.to_nat (Pos.of_succ_nat e))).","conclusion":"IZR (Zpower_nat r (Pos.to_nat (Pos.of_succ_nat e))) =\nbpow (Z.of_nat (Pos.to_nat (Pos.of_succ_nat e)))","hypotheses":"(e : nat)","proofString":"rewrite <- Zpower_pos_nat.\nnow rewrite <- Zpos_eq_Z_of_nat_o_nat_of_P."},{"statement":"(e : nat) : IZR (Z.pow_pos r (Pos.of_succ_nat e)) =\nbpow (Z.of_nat (Pos.to_nat (Pos.of_succ_nat e))).","conclusion":"IZR (Z.pow_pos r (Pos.of_succ_nat e)) =\nbpow (Z.of_nat (Pos.to_nat (Pos.of_succ_nat e)))","hypotheses":"(e : nat)","proofString":"now rewrite <- Zpos_eq_Z_of_nat_o_nat_of_P."},{"statement":"(H : (0 <= 0)%Z) : IZR (r ^ 0) = bpow 0.","conclusion":"IZR (r ^ 0) = bpow 0","hypotheses":"(H : (0 <= 0)%Z)","proofString":"split."},{"statement":"(e : positive) (H : (0 <= Z.pos e)%Z) : IZR (r ^ Z.pos e) = bpow (Z.pos e).","conclusion":"IZR (r ^ Z.pos e) = bpow (Z.pos e)","hypotheses":"(e : positive) (H : (0 <= Z.pos e)%Z)","proofString":"split."},{"statement":"(e : positive) (H : (0 <= Z.neg e)%Z) : IZR (r ^ Z.neg e) = bpow (Z.neg e).","conclusion":"IZR (r ^ Z.neg e) = bpow (Z.neg e)","hypotheses":"(e : positive) (H : (0 <= Z.neg e)%Z)","proofString":"now elim H."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) : (bpow e1 < bpow e2)%R.","conclusion":"(bpow e1 < bpow e2)%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z)","proofString":"replace e2 with (e1 + (e2 - e1))%Z by ring.\nrewrite <- (Rmult_1_r (bpow e1)).\nrewrite bpow_plus.\napply Rmult_lt_compat_l.\napply bpow_gt_0.\nassert (0 < e2 - e1)%Z by lia.\ndestruct (e2 - e1)%Z ; try discriminate H0.\nclear.\nrewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) : (bpow e1 < bpow (e1 + (e2 - e1)))%R.","conclusion":"(bpow e1 < bpow (e1 + (e2 - e1)))%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z)","proofString":"rewrite <- (Rmult_1_r (bpow e1)).\nrewrite bpow_plus.\napply Rmult_lt_compat_l.\napply bpow_gt_0.\nassert (0 < e2 - e1)%Z by lia.\ndestruct (e2 - e1)%Z ; try discriminate H0.\nclear.\nrewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) : (bpow e1 * 1 < bpow (e1 + (e2 - e1)))%R.","conclusion":"(bpow e1 * 1 < bpow (e1 + (e2 - e1)))%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z)","proofString":"rewrite bpow_plus.\napply Rmult_lt_compat_l.\napply bpow_gt_0.\nassert (0 < e2 - e1)%Z by lia.\ndestruct (e2 - e1)%Z ; try discriminate H0.\nclear.\nrewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) : (bpow e1 * 1 < bpow e1 * bpow (e2 - e1))%R.","conclusion":"(bpow e1 * 1 < bpow e1 * bpow (e2 - e1))%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z)","proofString":"apply Rmult_lt_compat_l.\napply bpow_gt_0.\nassert (0 < e2 - e1)%Z by lia.\ndestruct (e2 - e1)%Z ; try discriminate H0.\nclear.\nrewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) : (0 < bpow e1)%R.","conclusion":"(0 < bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z)","proofString":"apply bpow_gt_0."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) : (1 < bpow (e2 - e1))%R.","conclusion":"(1 < bpow (e2 - e1))%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z)","proofString":"assert (0 < e2 - e1)%Z by lia.\ndestruct (e2 - e1)%Z ; try discriminate H0.\nclear.\nrewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) (H0 : (0 < e2 - e1)%Z) : (1 < bpow (e2 - e1))%R.","conclusion":"(1 < bpow (e2 - e1))%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z) (H0 : (0 < e2 - e1)%Z)","proofString":"destruct (e2 - e1)%Z ; try discriminate H0.\nclear.\nrewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(e1 e2 : Z) (H : (e1 < e2)%Z) (p : positive) (H0 : (0 < Z.pos p)%Z) : (1 < bpow (Z.pos p))%R.","conclusion":"(1 < bpow (Z.pos p))%R","hypotheses":"(e1 e2 : Z) (H : (e1 < e2)%Z) (p : positive) (H0 : (0 < Z.pos p)%Z)","proofString":"clear.\nrewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(p : positive) : (1 < bpow (Z.pos p))%R.","conclusion":"(1 < bpow (Z.pos p))%R","hypotheses":"(p : positive)","proofString":"rewrite <- IZR_Zpower by easy.\napply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(p : positive) : (1 < IZR (r ^ Z.pos p))%R.","conclusion":"(1 < IZR (r ^ Z.pos p))%R","hypotheses":"(p : positive)","proofString":"apply IZR_lt.\nnow apply Zpower_gt_1."},{"statement":"(p : positive) : (1 < r ^ Z.pos p)%Z.","conclusion":"(1 < r ^ Z.pos p)%Z","hypotheses":"(p : positive)","proofString":"now apply Zpower_gt_1."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) : (e1 < e2)%Z.","conclusion":"(e1 < e2)%Z","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R)","proofString":"apply Z.gt_lt.\napply Znot_le_gt.\nintros H'.\napply Rlt_not_le with (1 := H).\ndestruct (Zle_lt_or_eq _ _ H').\napply Rlt_le.\nnow apply bpow_lt.\nrewrite H0.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) : (e2 > e1)%Z.","conclusion":"(e2 > e1)%Z","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R)","proofString":"apply Znot_le_gt.\nintros H'.\napply Rlt_not_le with (1 := H).\ndestruct (Zle_lt_or_eq _ _ H').\napply Rlt_le.\nnow apply bpow_lt.\nrewrite H0.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) : ~ (e2 <= e1)%Z.","conclusion":"~ (e2 <= e1)%Z","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R)","proofString":"intros H'.\napply Rlt_not_le with (1 := H).\ndestruct (Zle_lt_or_eq _ _ H').\napply Rlt_le.\nnow apply bpow_lt.\nrewrite H0.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) : False.","conclusion":"False","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z)","proofString":"apply Rlt_not_le with (1 := H).\ndestruct (Zle_lt_or_eq _ _ H').\napply Rlt_le.\nnow apply bpow_lt.\nrewrite H0.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) : (bpow e2 <= bpow e1)%R.","conclusion":"(bpow e2 <= bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z)","proofString":"destruct (Zle_lt_or_eq _ _ H').\napply Rlt_le.\nnow apply bpow_lt.\nrewrite H0.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : (e2 < e1)%Z) : (bpow e2 <= bpow e1)%R.","conclusion":"(bpow e2 <= bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : (e2 < e1)%Z)","proofString":"apply Rlt_le.\nnow apply bpow_lt."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : (e2 < e1)%Z) : (bpow e2 < bpow e1)%R.","conclusion":"(bpow e2 < bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : (e2 < e1)%Z)","proofString":"now apply bpow_lt."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : e2 = e1) : (bpow e2 <= bpow e1)%R.","conclusion":"(bpow e2 <= bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : e2 = e1)","proofString":"rewrite H0.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : e2 = e1) : (bpow e1 <= bpow e1)%R.","conclusion":"(bpow e1 <= bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (bpow e1 < bpow e2)%R) (H' : (e2 <= e1)%Z) (H0 : e2 = e1)","proofString":"apply Rle_refl."},{"statement":"(e1 e2 : Z) (H : (e1 <= e2)%Z) : (bpow e1 <= bpow e2)%R.","conclusion":"(bpow e1 <= bpow e2)%R","hypotheses":"(e1 e2 : Z) (H : (e1 <= e2)%Z)","proofString":"apply Rnot_lt_le.\nintros H'.\napply Zle_not_gt with (1 := H).\napply Z.lt_gt.\nnow apply lt_bpow."},{"statement":"(e1 e2 : Z) (H : (e1 <= e2)%Z) : ~ (bpow e2 < bpow e1)%R.","conclusion":"~ (bpow e2 < bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (e1 <= e2)%Z)","proofString":"intros H'.\napply Zle_not_gt with (1 := H).\napply Z.lt_gt.\nnow apply lt_bpow."},{"statement":"(e1 e2 : Z) (H : (e1 <= e2)%Z) (H' : (bpow e2 < bpow e1)%R) : False.","conclusion":"False","hypotheses":"(e1 e2 : Z) (H : (e1 <= e2)%Z) (H' : (bpow e2 < bpow e1)%R)","proofString":"apply Zle_not_gt with (1 := H).\napply Z.lt_gt.\nnow apply lt_bpow."},{"statement":"(e1 e2 : Z) (H : (e1 <= e2)%Z) (H' : (bpow e2 < bpow e1)%R) : (e1 > e2)%Z.","conclusion":"(e1 > e2)%Z","hypotheses":"(e1 e2 : Z) (H : (e1 <= e2)%Z) (H' : (bpow e2 < bpow e1)%R)","proofString":"apply Z.lt_gt.\nnow apply lt_bpow."},{"statement":"(e1 e2 : Z) (H : (e1 <= e2)%Z) (H' : (bpow e2 < bpow e1)%R) : (e2 < e1)%Z.","conclusion":"(e2 < e1)%Z","hypotheses":"(e1 e2 : Z) (H : (e1 <= e2)%Z) (H' : (bpow e2 < bpow e1)%R)","proofString":"now apply lt_bpow."},{"statement":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) : (e1 <= e2)%Z.","conclusion":"(e1 <= e2)%Z","hypotheses":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R)","proofString":"apply Znot_gt_le.\nintros H'.\napply Rle_not_lt with (1 := H).\napply bpow_lt.\nnow apply Z.gt_lt."},{"statement":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) : ~ (e1 > e2)%Z.","conclusion":"~ (e1 > e2)%Z","hypotheses":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R)","proofString":"intros H'.\napply Rle_not_lt with (1 := H).\napply bpow_lt.\nnow apply Z.gt_lt."},{"statement":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) (H' : (e1 > e2)%Z) : False.","conclusion":"False","hypotheses":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) (H' : (e1 > e2)%Z)","proofString":"apply Rle_not_lt with (1 := H).\napply bpow_lt.\nnow apply Z.gt_lt."},{"statement":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) (H' : (e1 > e2)%Z) : (bpow e2 < bpow e1)%R.","conclusion":"(bpow e2 < bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) (H' : (e1 > e2)%Z)","proofString":"apply bpow_lt.\nnow apply Z.gt_lt."},{"statement":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) (H' : (e1 > e2)%Z) : (e2 < e1)%Z.","conclusion":"(e2 < e1)%Z","hypotheses":"(e1 e2 : Z) (H : (bpow e1 <= bpow e2)%R) (H' : (e1 > e2)%Z)","proofString":"now apply Z.gt_lt."},{"statement":"(e1 e2 : Z) (H : bpow e1 = bpow e2) : e1 = e2.","conclusion":"e1 = e2","hypotheses":"(e1 e2 : Z) (H : bpow e1 = bpow e2)","proofString":"apply Zle_antisym.\napply le_bpow.\nnow apply Req_le.\napply le_bpow.\nnow apply Req_le."},{"statement":"(e1 e2 : Z) (H : bpow e1 = bpow e2) : (e1 <= e2)%Z.","conclusion":"(e1 <= e2)%Z","hypotheses":"(e1 e2 : Z) (H : bpow e1 = bpow e2)","proofString":"apply le_bpow.\nnow apply Req_le."},{"statement":"(e1 e2 : Z) (H : bpow e1 = bpow e2) : (bpow e1 <= bpow e2)%R.","conclusion":"(bpow e1 <= bpow e2)%R","hypotheses":"(e1 e2 : Z) (H : bpow e1 = bpow e2)","proofString":"now apply Req_le."},{"statement":"(e1 e2 : Z) (H : bpow e1 = bpow e2) : (e2 <= e1)%Z.","conclusion":"(e2 <= e1)%Z","hypotheses":"(e1 e2 : Z) (H : bpow e1 = bpow e2)","proofString":"apply le_bpow.\nnow apply Req_le."},{"statement":"(e1 e2 : Z) (H : bpow e1 = bpow e2) : (bpow e2 <= bpow e1)%R.","conclusion":"(bpow e2 <= bpow e1)%R","hypotheses":"(e1 e2 : Z) (H : bpow e1 = bpow e2)","proofString":"now apply Req_le."},{"statement":"forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r)).","conclusion":"forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r))","hypotheses":"","proofString":"intros e.\nunfold bpow.\nrewrite Zpower_pos_nat.\nrewrite <- positive_nat_Z.\nrewrite <- INR_IZR_INZ.\ninduction (nat_of_P e).\nrewrite Rmult_0_l.\nnow rewrite exp_0.\nrewrite Zpower_nat_S.\nrewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) : bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r)).","conclusion":"bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r))","hypotheses":"(e : positive)","proofString":"unfold bpow.\nrewrite Zpower_pos_nat.\nrewrite <- positive_nat_Z.\nrewrite <- INR_IZR_INZ.\ninduction (nat_of_P e).\nrewrite Rmult_0_l.\nnow rewrite exp_0.\nrewrite Zpower_nat_S.\nrewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) : IZR (Z.pow_pos r e) = exp (IZR (Z.pos e) * ln (IZR r)).","conclusion":"IZR (Z.pow_pos r e) = exp (IZR (Z.pos e) * ln (IZR r))","hypotheses":"(e : positive)","proofString":"rewrite Zpower_pos_nat.\nrewrite <- positive_nat_Z.\nrewrite <- INR_IZR_INZ.\ninduction (nat_of_P e).\nrewrite Rmult_0_l.\nnow rewrite exp_0.\nrewrite Zpower_nat_S.\nrewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) : IZR (Zpower_nat r (Pos.to_nat e)) = exp (IZR (Z.pos e) * ln (IZR r)).","conclusion":"IZR (Zpower_nat r (Pos.to_nat e)) = exp (IZR (Z.pos e) * ln (IZR r))","hypotheses":"(e : positive)","proofString":"rewrite <- positive_nat_Z.\nrewrite <- INR_IZR_INZ.\ninduction (nat_of_P e).\nrewrite Rmult_0_l.\nnow rewrite exp_0.\nrewrite Zpower_nat_S.\nrewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) : IZR (Zpower_nat r (Pos.to_nat e)) =\nexp (IZR (Z.of_nat (Pos.to_nat e)) * ln (IZR r)).","conclusion":"IZR (Zpower_nat r (Pos.to_nat e)) =\nexp (IZR (Z.of_nat (Pos.to_nat e)) * ln (IZR r))","hypotheses":"(e : positive)","proofString":"rewrite <- INR_IZR_INZ.\ninduction (nat_of_P e).\nrewrite Rmult_0_l.\nnow rewrite exp_0.\nrewrite Zpower_nat_S.\nrewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) : IZR (Zpower_nat r (Pos.to_nat e)) = exp (INR (Pos.to_nat e) * ln (IZR r)).","conclusion":"IZR (Zpower_nat r (Pos.to_nat e)) = exp (INR (Pos.to_nat e) * ln (IZR r))","hypotheses":"(e : positive)","proofString":"induction (nat_of_P e).\nrewrite Rmult_0_l.\nnow rewrite exp_0.\nrewrite Zpower_nat_S.\nrewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) : IZR (Zpower_nat r 0) = exp (INR 0 * ln (IZR r)).","conclusion":"IZR (Zpower_nat r 0) = exp (INR 0 * ln (IZR r))","hypotheses":"(e : positive)","proofString":"rewrite Rmult_0_l.\nnow rewrite exp_0."},{"statement":"(e : positive) : IZR (Zpower_nat r 0) = exp 0.","conclusion":"IZR (Zpower_nat r 0) = exp 0","hypotheses":"(e : positive)","proofString":"now rewrite exp_0."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (Zpower_nat r (S n)) = exp (INR (S n) * ln (IZR r)).","conclusion":"IZR (Zpower_nat r (S n)) = exp (INR (S n) * ln (IZR r))","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite Zpower_nat_S.\nrewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) = exp (INR (S n) * ln (IZR r)).","conclusion":"IZR (r * Zpower_nat r n) = exp (INR (S n) * ln (IZR r))","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite S_INR.\nrewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) = exp ((INR n + 1) * ln (IZR r)).","conclusion":"IZR (r * Zpower_nat r n) = exp ((INR n + 1) * ln (IZR r))","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite Rmult_plus_distr_r.\nrewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) = exp (INR n * ln (IZR r) + 1 * ln (IZR r)).","conclusion":"IZR (r * Zpower_nat r n) = exp (INR n * ln (IZR r) + 1 * ln (IZR r))","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite exp_plus.\nrewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) =\n(exp (INR n * ln (IZR r)) * exp (1 * ln (IZR r)))%R.","conclusion":"IZR (r * Zpower_nat r n) =\n(exp (INR n * ln (IZR r)) * exp (1 * ln (IZR r)))%R","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite Rmult_1_l.\nrewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) = (exp (INR n * ln (IZR r)) * exp (ln (IZR r)))%R.","conclusion":"IZR (r * Zpower_nat r n) = (exp (INR n * ln (IZR r)) * exp (ln (IZR r)))%R","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite exp_ln.\nrewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm.\napply radix_pos."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) = (exp (INR n * ln (IZR r)) * IZR r)%R.","conclusion":"IZR (r * Zpower_nat r n) = (exp (INR n * ln (IZR r)) * IZR r)%R","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite <- IHn.\nrewrite <- mult_IZR.\nnow rewrite Zmult_comm."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) = (IZR (Zpower_nat r n) * IZR r)%R.","conclusion":"IZR (r * Zpower_nat r n) = (IZR (Zpower_nat r n) * IZR r)%R","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"rewrite <- mult_IZR.\nnow rewrite Zmult_comm."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : IZR (r * Zpower_nat r n) = IZR (Zpower_nat r n * r).","conclusion":"IZR (r * Zpower_nat r n) = IZR (Zpower_nat r n * r)","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"now rewrite Zmult_comm."},{"statement":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r))) : (0 < IZR r)%R.","conclusion":"(0 < IZR r)%R","hypotheses":"(e : positive) (n : nat) (IHn : IZR (Zpower_nat r n) = exp (INR n * ln (IZR r)))","proofString":"apply radix_pos."},{"statement":"(H : forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r))) : forall e : Z, bpow e = exp (IZR e * ln (IZR r)).","conclusion":"forall e : Z, bpow e = exp (IZR e * ln (IZR r))","hypotheses":"(H : forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r)))","proofString":"intros [|e|e].\nrewrite Rmult_0_l.\nnow rewrite exp_0.\napply H.\nunfold bpow.\nchange (IZR (Zpower_pos r e)) with (bpow (Zpos e)).\nrewrite H.\nrewrite <- exp_Ropp.\nrewrite <- Ropp_mult_distr_l_reverse.\nnow rewrite <- opp_IZR."},{"statement":"(H : forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r))) : bpow 0 = exp (0 * ln (IZR r)).","conclusion":"bpow 0 = exp (0 * ln (IZR r))","hypotheses":"(H : forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r)))","proofString":"rewrite Rmult_0_l.\nnow rewrite exp_0."},{"statement":"(H : forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r))) : bpow 0 = exp 0.","conclusion":"bpow 0 = exp 0","hypotheses":"(H : forall e : positive, bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r)))","proofString":"now rewrite exp_0."},{"statement":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive) : bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r)).","conclusion":"bpow (Z.pos e) = exp (IZR (Z.pos e) * ln (IZR r))","hypotheses":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive)","proofString":"apply H."},{"statement":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive) : bpow (Z.neg e) = exp (IZR (Z.neg e) * ln (IZR r)).","conclusion":"bpow (Z.neg e) = exp (IZR (Z.neg e) * ln (IZR r))","hypotheses":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive)","proofString":"unfold bpow.\nchange (IZR (Zpower_pos r e)) with (bpow (Zpos e)).\nrewrite H.\nrewrite <- exp_Ropp.\nrewrite <- Ropp_mult_distr_l_reverse.\nnow rewrite <- opp_IZR."},{"statement":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive) : (/ IZR (Z.pow_pos r e))%R = exp (IZR (Z.neg e) * ln (IZR r)).","conclusion":"(/ IZR (Z.pow_pos r e))%R = exp (IZR (Z.neg e) * ln (IZR r))","hypotheses":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive)","proofString":"change (IZR (Zpower_pos r e)) with (bpow (Zpos e)).\nrewrite H.\nrewrite <- exp_Ropp.\nrewrite <- Ropp_mult_distr_l_reverse.\nnow rewrite <- opp_IZR."},{"statement":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive) : (/ bpow (Z.pos e))%R = exp (IZR (Z.neg e) * ln (IZR r)).","conclusion":"(/ bpow (Z.pos e))%R = exp (IZR (Z.neg e) * ln (IZR r))","hypotheses":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive)","proofString":"rewrite H.\nrewrite <- exp_Ropp.\nrewrite <- Ropp_mult_distr_l_reverse.\nnow rewrite <- opp_IZR."},{"statement":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive) : (/ exp (IZR (Z.pos e) * ln (IZR r)))%R = exp (IZR (Z.neg e) * ln (IZR r)).","conclusion":"(/ exp (IZR (Z.pos e) * ln (IZR r)))%R = exp (IZR (Z.neg e) * ln (IZR r))","hypotheses":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive)","proofString":"rewrite <- exp_Ropp.\nrewrite <- Ropp_mult_distr_l_reverse.\nnow rewrite <- opp_IZR."},{"statement":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive) : exp (- (IZR (Z.pos e) * ln (IZR r))) = exp (IZR (Z.neg e) * ln (IZR r)).","conclusion":"exp (- (IZR (Z.pos e) * ln (IZR r))) = exp (IZR (Z.neg e) * ln (IZR r))","hypotheses":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive)","proofString":"rewrite <- Ropp_mult_distr_l_reverse.\nnow rewrite <- opp_IZR."},{"statement":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive) : exp (- IZR (Z.pos e) * ln (IZR r)) = exp (IZR (Z.neg e) * ln (IZR r)).","conclusion":"exp (- IZR (Z.pos e) * ln (IZR r)) = exp (IZR (Z.neg e) * ln (IZR r))","hypotheses":"(H : forall e0 : positive, bpow (Z.pos e0) = exp (IZR (Z.pos e0) * ln (IZR r))) (e : positive)","proofString":"now rewrite <- opp_IZR."},{"statement":"(e : Z) : sqrt (bpow (2 * e)) = bpow e.","conclusion":"sqrt (bpow (2 * e)) = bpow e","hypotheses":"(e : Z)","proofString":"change 2%Z with (1 + 1)%Z; rewrite Z.mul_add_distr_r, Z.mul_1_l, bpow_plus.\napply sqrt_square, bpow_ge_0."},{"statement":"(e : Z) : sqrt (bpow e * bpow e) = bpow e.","conclusion":"sqrt (bpow e * bpow e) = bpow e","hypotheses":"(e : Z)","proofString":"apply sqrt_square, bpow_ge_0."},{"statement":"(e : Z) : (bpow (e / 2) <= sqrt (bpow e))%R.","conclusion":"(bpow (e / 2) <= sqrt (bpow e))%R","hypotheses":"(e : Z)","proofString":"rewrite <- (sqrt_square (bpow _)); [|now apply bpow_ge_0].\napply sqrt_le_1_alt; rewrite <- bpow_plus; apply bpow_le.\nnow replace (_ + _)%Z with (2 * (e / 2))%Z by ring; apply Z_mult_div_ge."},{"statement":"(e : Z) : (sqrt (bpow (e / 2) * bpow (e / 2)) <= sqrt (bpow e))%R.","conclusion":"(sqrt (bpow (e / 2) * bpow (e / 2)) <= sqrt (bpow e))%R","hypotheses":"(e : Z)","proofString":"apply sqrt_le_1_alt; rewrite <- bpow_plus; apply bpow_le.\nnow replace (_ + _)%Z with (2 * (e / 2))%Z by ring; apply Z_mult_div_ge."},{"statement":"(e : Z) : (e / 2 + e / 2 <= e)%Z.","conclusion":"(e / 2 + e / 2 <= e)%Z","hypotheses":"(e : Z)","proofString":"now replace (_ + _)%Z with (2 * (e / 2))%Z by ring; apply Z_mult_div_ge."},{"statement":"(x : R) : mag_prop x.","conclusion":"mag_prop x","hypotheses":"(x : R)","proofString":"set (fact := ln (IZR r)).\nassert (0 < fact)%R.\napply exp_lt_inv.\nrewrite exp_0.\nunfold fact.\nrewrite exp_ln.\napply IZR_lt.\napply radix_gt_1.\napply radix_pos.\nexists (Zfloor (ln (Rabs x) / fact) + 1)%Z.\nintros Hx'.\ngeneralize (Rabs_pos_lt _ Hx').\nclear Hx'.\ngeneralize (Rabs x).\nclear x.\nintros x Hx.\nrewrite 2!bpow_exp.\nfold fact.\npattern x at 2 3 ; replace x with (exp (ln x * / fact * fact)).\nsplit.\nrewrite minus_IZR.\napply exp_le.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\nunfold Rminus.\nrewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb.\napply exp_increasing.\napply Rmult_lt_compat_r.\nexact H.\nrewrite plus_IZR.\napply Zfloor_ub.\nrewrite Rmult_assoc.\nrewrite Rinv_l.\nrewrite Rmult_1_r.\nnow apply exp_ln.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (fact : R) : (1 < exp (ln (IZR r)))%R.","conclusion":"(1 < exp (ln (IZR r)))%R","hypotheses":"(x : R) (fact : R)","proofString":"rewrite exp_ln.\napply IZR_lt.\napply radix_gt_1.\napply radix_pos."},{"statement":"(x : R) (fact : R) : (1 < IZR r)%R.","conclusion":"(1 < IZR r)%R","hypotheses":"(x : R) (fact : R)","proofString":"apply IZR_lt.\napply radix_gt_1."},{"statement":"(x : R) (fact : R) : (1 < r)%Z.","conclusion":"(1 < r)%Z","hypotheses":"(x : R) (fact : R)","proofString":"apply radix_gt_1."},{"statement":"(x : R) (fact : R) : (0 < IZR r)%R.","conclusion":"(0 < IZR r)%R","hypotheses":"(x : R) (fact : R)","proofString":"apply radix_pos."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (exp (IZR (Zfloor (ln x / fact) + 1 - 1) * fact) <= x <\n exp (IZR (Zfloor (ln x / fact) + 1) * fact))%R.","conclusion":"(exp (IZR (Zfloor (ln x / fact) + 1 - 1) * fact) <= x <\n exp (IZR (Zfloor (ln x / fact) + 1) * fact))%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"pattern x at 2 3 ; replace x with (exp (ln x * / fact * fact)).\nsplit.\nrewrite minus_IZR.\napply exp_le.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\nunfold Rminus.\nrewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb.\napply exp_increasing.\napply Rmult_lt_compat_r.\nexact H.\nrewrite plus_IZR.\napply Zfloor_ub.\nrewrite Rmult_assoc.\nrewrite Rinv_l.\nrewrite Rmult_1_r.\nnow apply exp_ln.\nnow apply Rgt_not_eq."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (exp (IZR (Zfloor (ln x / fact) + 1 - 1) * fact) <=\n exp (ln x * / fact * fact) < exp (IZR (Zfloor (ln x / fact) + 1) * fact))%R.","conclusion":"(exp (IZR (Zfloor (ln x / fact) + 1 - 1) * fact) <=\n exp (ln x * / fact * fact) < exp (IZR (Zfloor (ln x / fact) + 1) * fact))%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"split.\nrewrite minus_IZR.\napply exp_le.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\nunfold Rminus.\nrewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb.\napply exp_increasing.\napply Rmult_lt_compat_r.\nexact H.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (exp (IZR (Zfloor (ln x / fact) + 1 - 1) * fact) <=\n exp (ln x * / fact * fact))%R.","conclusion":"(exp (IZR (Zfloor (ln x / fact) + 1 - 1) * fact) <=\n exp (ln x * / fact * fact))%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite minus_IZR.\napply exp_le.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\nunfold Rminus.\nrewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (exp ((IZR (Zfloor (ln x / fact) + 1) - 1) * fact) <=\n exp (ln x * / fact * fact))%R.","conclusion":"(exp ((IZR (Zfloor (ln x / fact) + 1) - 1) * fact) <=\n exp (ln x * / fact * fact))%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"apply exp_le.\napply Rmult_le_compat_r.\nnow apply Rlt_le.\nunfold Rminus.\nrewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : ((IZR (Zfloor (ln x / fact) + 1) - 1) * fact <= ln x * / fact * fact)%R.","conclusion":"((IZR (Zfloor (ln x / fact) + 1) - 1) * fact <= ln x * / fact * fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"apply Rmult_le_compat_r.\nnow apply Rlt_le.\nunfold Rminus.\nrewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (0 <= fact)%R.","conclusion":"(0 <= fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"now apply Rlt_le."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (IZR (Zfloor (ln x / fact) + 1) - 1 <= ln x * / fact)%R.","conclusion":"(IZR (Zfloor (ln x / fact) + 1) - 1 <= ln x * / fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"unfold Rminus.\nrewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (IZR (Zfloor (ln x / fact) + 1) + - (1) <= ln x * / fact)%R.","conclusion":"(IZR (Zfloor (ln x / fact) + 1) + - (1) <= ln x * / fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite plus_IZR.\nrewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (IZR (Zfloor (ln x / fact)) + 1 + - (1) <= ln x * / fact)%R.","conclusion":"(IZR (Zfloor (ln x / fact)) + 1 + - (1) <= ln x * / fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite Rplus_assoc.\nrewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (IZR (Zfloor (ln x / fact)) + (1 + - (1)) <= ln x * / fact)%R.","conclusion":"(IZR (Zfloor (ln x / fact)) + (1 + - (1)) <= ln x * / fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite Rplus_opp_r, Rplus_0_r.\napply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (IZR (Zfloor (ln x / fact)) <= ln x * / fact)%R.","conclusion":"(IZR (Zfloor (ln x / fact)) <= ln x * / fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"apply Zfloor_lb."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (exp (ln x * / fact * fact) < exp (IZR (Zfloor (ln x / fact) + 1) * fact))%R.","conclusion":"(exp (ln x * / fact * fact) < exp (IZR (Zfloor (ln x / fact) + 1) * fact))%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"apply exp_increasing.\napply Rmult_lt_compat_r.\nexact H.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (ln x * / fact * fact < IZR (Zfloor (ln x / fact) + 1) * fact)%R.","conclusion":"(ln x * / fact * fact < IZR (Zfloor (ln x / fact) + 1) * fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"apply Rmult_lt_compat_r.\nexact H.\nrewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (0 < fact)%R.","conclusion":"(0 < fact)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"exact H."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (ln x * / fact < IZR (Zfloor (ln x / fact) + 1))%R.","conclusion":"(ln x * / fact < IZR (Zfloor (ln x / fact) + 1))%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite plus_IZR.\napply Zfloor_ub."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : (ln x * / fact < IZR (Zfloor (ln x / fact)) + 1)%R.","conclusion":"(ln x * / fact < IZR (Zfloor (ln x / fact)) + 1)%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"apply Zfloor_ub."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : exp (ln x * / fact * fact) = x.","conclusion":"exp (ln x * / fact * fact) = x","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite Rmult_assoc.\nrewrite Rinv_l.\nrewrite Rmult_1_r.\nnow apply exp_ln.\nnow apply Rgt_not_eq."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : exp (ln x * (/ fact * fact)) = x.","conclusion":"exp (ln x * (/ fact * fact)) = x","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite Rinv_l.\nrewrite Rmult_1_r.\nnow apply exp_ln.\nnow apply Rgt_not_eq."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : exp (ln x * 1) = x.","conclusion":"exp (ln x * 1) = x","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"rewrite Rmult_1_r.\nnow apply exp_ln."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : exp (ln x) = x.","conclusion":"exp (ln x) = x","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"now apply exp_ln."},{"statement":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R) : fact <> 0%R.","conclusion":"fact <> 0%R","hypotheses":"(fact : R) (H : (0 < fact)%R) (x : R) (Hx : (0 < x)%R)","proofString":"now apply Rgt_not_eq."},{"statement":"(e1 e2 : Z) (He : (bpow (e1 - 1) < bpow e2)%R) : (e1 <= e2)%Z.","conclusion":"(e1 <= e2)%Z","hypotheses":"(e1 e2 : Z) (He : (bpow (e1 - 1) < bpow e2)%R)","proofString":"rewrite (Zsucc_pred e1).\napply Zlt_le_succ.\nnow apply lt_bpow."},{"statement":"(e1 e2 : Z) (He : (bpow (e1 - 1) < bpow e2)%R) : (Z.succ (Z.pred e1) <= e2)%Z.","conclusion":"(Z.succ (Z.pred e1) <= e2)%Z","hypotheses":"(e1 e2 : Z) (He : (bpow (e1 - 1) < bpow e2)%R)","proofString":"apply Zlt_le_succ.\nnow apply lt_bpow."},{"statement":"(e1 e2 : Z) (He : (bpow (e1 - 1) < bpow e2)%R) : (Z.pred e1 < e2)%Z.","conclusion":"(Z.pred e1 < e2)%Z","hypotheses":"(e1 e2 : Z) (He : (bpow (e1 - 1) < bpow e2)%R)","proofString":"now apply lt_bpow."},{"statement":"(x : R) (e1 e2 : Z) (H1a : (bpow (e1 - 1) <= x)%R) (H1b : (x < bpow e1)%R) (H2a : (bpow (e2 - 1) <= x)%R) (H2b : (x < bpow e2)%R) : e1 = e2.","conclusion":"e1 = e2","hypotheses":"(x : R) (e1 e2 : Z) (H1a : (bpow (e1 - 1) <= x)%R) (H1b : (x < bpow e1)%R) (H2a : (bpow (e2 - 1) <= x)%R) (H2b : (x < bpow e2)%R)","proofString":"apply Zle_antisym ;  apply bpow_lt_bpow ;  apply Rle_lt_trans with x ;  assumption."},{"statement":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x = 0%R) : (Rabs x < bpow (e1 - 1))%R.","conclusion":"(Rabs x < bpow (e1 - 1))%R","hypotheses":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x = 0%R)","proofString":"rewrite Hx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x = 0%R) : (0 < bpow (e1 - 1))%R.","conclusion":"(0 < bpow (e1 - 1))%R","hypotheses":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x = 0%R)","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x <> 0%R) (e2 : Z) (Hx2 : x <> 0%R -> (bpow (e2 - 1) <= Rabs x < bpow e2)%R) : e2 = e1.","conclusion":"e2 = e1","hypotheses":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x <> 0%R) (e2 : Z) (Hx2 : x <> 0%R -> (bpow (e2 - 1) <= Rabs x < bpow e2)%R)","proofString":"apply bpow_unique with (2 := He).\nnow apply Hx2."},{"statement":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x <> 0%R) (e2 : Z) (Hx2 : x <> 0%R -> (bpow (e2 - 1) <= Rabs x < bpow e2)%R) : (bpow (e2 - 1) <= Rabs x < bpow e2)%R.","conclusion":"(bpow (e2 - 1) <= Rabs x < bpow e2)%R","hypotheses":"(x : R) (e1 : Z) (He : (bpow (e1 - 1) <= Rabs x < bpow e1)%R) (Hx : x <> 0%R) (e2 : Z) (Hx2 : x <> 0%R -> (bpow (e2 - 1) <= Rabs x < bpow e2)%R)","proofString":"now apply Hx2."},{"statement":"(x : R) (Hx : x <> 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) : (bpow (e - 1) <= Rabs (- x) < bpow e)%R.","conclusion":"(bpow (e - 1) <= Rabs (- x) < bpow e)%R","hypotheses":"(x : R) (Hx : x <> 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R)","proofString":"now rewrite Rabs_Ropp."},{"statement":"(x : R) : mag x = mag x.","conclusion":"mag x = mag x","hypotheses":"(x : R)","proofString":"apply refl_equal."},{"statement":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R) : (bpow (e1 - 1) <= Rabs (Rabs x) < bpow e1)%R.","conclusion":"(bpow (e1 - 1) <= Rabs (Rabs x) < bpow e1)%R","hypotheses":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R)","proofString":"rewrite 2!Rabs_pos_eq.\nexact He1.\napply Rle_trans with (2 := proj1 He1).\napply bpow_ge_0.\napply Rabs_pos."},{"statement":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R) : (bpow (e1 - 1) <= x < bpow e1)%R.","conclusion":"(bpow (e1 - 1) <= x < bpow e1)%R","hypotheses":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R)","proofString":"exact He1."},{"statement":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R)","proofString":"apply Rle_trans with (2 := proj1 He1).\napply bpow_ge_0."},{"statement":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R) : (0 <= bpow (e1 - 1))%R.","conclusion":"(0 <= bpow (e1 - 1))%R","hypotheses":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R)","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R) : (0 <= Rabs x)%R.","conclusion":"(0 <= Rabs x)%R","hypotheses":"(x : R) (e1 : Z) (He1 : (bpow (e1 - 1) <= x < bpow e1)%R)","proofString":"apply Rabs_pos."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) : (mag x <= mag y)%Z.","conclusion":"(mag x <= mag y)%Z","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R)","proofString":"destruct (mag x) as (ex, Hx).\ndestruct (mag y) as (ey, Hy).\nsimpl.\napply bpow_lt_bpow.\nspecialize (Hx H0x).\napply Rle_lt_trans with (1 := proj1 Hx).\napply Rle_lt_trans with (1 := Hxy).\napply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Build_mag_prop x ex Hx <= mag y)%Z.","conclusion":"(Build_mag_prop x ex Hx <= mag y)%Z","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"destruct (mag y) as (ey, Hy).\nsimpl.\napply bpow_lt_bpow.\nspecialize (Hx H0x).\napply Rle_lt_trans with (1 := proj1 Hx).\napply Rle_lt_trans with (1 := Hxy).\napply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (Build_mag_prop x ex Hx <= Build_mag_prop y ey Hy)%Z.","conclusion":"(Build_mag_prop x ex Hx <= Build_mag_prop y ey Hy)%Z","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"simpl.\napply bpow_lt_bpow.\nspecialize (Hx H0x).\napply Rle_lt_trans with (1 := proj1 Hx).\napply Rle_lt_trans with (1 := Hxy).\napply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (ex <= ey)%Z.","conclusion":"(ex <= ey)%Z","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"apply bpow_lt_bpow.\nspecialize (Hx H0x).\napply Rle_lt_trans with (1 := proj1 Hx).\napply Rle_lt_trans with (1 := Hxy).\napply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (bpow (ex - 1) < bpow ey)%R.","conclusion":"(bpow (ex - 1) < bpow ey)%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"specialize (Hx H0x).\napply Rle_lt_trans with (1 := proj1 Hx).\napply Rle_lt_trans with (1 := Hxy).\napply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (bpow (ex - 1) < bpow ey)%R.","conclusion":"(bpow (ex - 1) < bpow ey)%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"apply Rle_lt_trans with (1 := proj1 Hx).\napply Rle_lt_trans with (1 := Hxy).\napply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (Rabs x < bpow ey)%R.","conclusion":"(Rabs x < bpow ey)%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"apply Rle_lt_trans with (1 := Hxy).\napply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (Rabs y < bpow ey)%R.","conclusion":"(Rabs y < bpow ey)%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"apply Hy.\nintros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : y <> 0%R.","conclusion":"y <> 0%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"intros Hy'.\napply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R) : False.","conclusion":"False","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R)","proofString":"apply Rlt_not_le with (1 := Rabs_pos_lt _ H0x).\napply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R) : (Rabs x <= 0)%R.","conclusion":"(Rabs x <= 0)%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R)","proofString":"apply Rle_trans with (1 := Hxy).\nrewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R) : (Rabs y <= 0)%R.","conclusion":"(Rabs y <= 0)%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R)","proofString":"rewrite Hy', Rabs_R0.\napply Rle_refl."},{"statement":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R) : (0 <= 0)%R.","conclusion":"(0 <= 0)%R","hypotheses":"(x y : R) (H0x : x <> 0%R) (Hxy : (Rabs x <= Rabs y)%R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy' : y = 0%R)","proofString":"apply Rle_refl."},{"statement":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R) : (mag x <= mag y)%Z.","conclusion":"(mag x <= mag y)%Z","hypotheses":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"apply mag_le_abs.\nnow apply Rgt_not_eq.\nrewrite 2!Rabs_pos_eq.\nexact Hxy.\napply Rle_trans with (2 := Hxy).\nnow apply Rlt_le.\nnow apply Rlt_le."},{"statement":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R) : x <> 0%R.","conclusion":"x <> 0%R","hypotheses":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"now apply Rgt_not_eq."},{"statement":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R) : (Rabs x <= Rabs y)%R.","conclusion":"(Rabs x <= Rabs y)%R","hypotheses":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"rewrite 2!Rabs_pos_eq.\nexact Hxy.\napply Rle_trans with (2 := Hxy).\nnow apply Rlt_le.\nnow apply Rlt_le."},{"statement":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R) : (x <= y)%R.","conclusion":"(x <= y)%R","hypotheses":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"exact Hxy."},{"statement":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R) : (0 <= y)%R.","conclusion":"(0 <= y)%R","hypotheses":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"apply Rle_trans with (2 := Hxy).\nnow apply Rlt_le."},{"statement":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"now apply Rlt_le."},{"statement":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(x y : R) (H0x : (0 < x)%R) (Hxy : (x <= y)%R)","proofString":"now apply Rlt_le."},{"statement":"(x y : R) (Py : (0 < y)%R) : (mag x < mag y)%Z -> (x < y)%R.","conclusion":"(mag x < mag y)%Z -> (x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R)","proofString":"case (Rle_or_lt x 0); intros Px.\nintros H.\nnow apply Rle_lt_trans with 0%R.\ndestruct (mag x) as (ex, Hex).\ndestruct (mag y) as (ey, Hey).\nsimpl.\nintro H.\ndestruct Hex as (_,Hex); [now apply Rgt_not_eq|].\ndestruct Hey as (Hey,_); [now apply Rgt_not_eq|].\nrewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (x <= 0)%R) : (mag x < mag y)%Z -> (x < y)%R.","conclusion":"(mag x < mag y)%Z -> (x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (x <= 0)%R)","proofString":"intros H.\nnow apply Rle_lt_trans with 0%R."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (x <= 0)%R) (H : (mag x < mag y)%Z) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (x <= 0)%R) (H : (mag x < mag y)%Z)","proofString":"now apply Rle_lt_trans with 0%R."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) : (mag x < mag y)%Z -> (x < y)%R.","conclusion":"(mag x < mag y)%Z -> (x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R)","proofString":"destruct (mag x) as (ex, Hex).\ndestruct (mag y) as (ey, Hey).\nsimpl.\nintro H.\ndestruct Hex as (_,Hex); [now apply Rgt_not_eq|].\ndestruct Hey as (Hey,_); [now apply Rgt_not_eq|].\nrewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Build_mag_prop x ex Hex < mag y)%Z -> (x < y)%R.","conclusion":"(Build_mag_prop x ex Hex < mag y)%Z -> (x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"destruct (mag y) as (ey, Hey).\nsimpl.\nintro H.\ndestruct Hex as (_,Hex); [now apply Rgt_not_eq|].\ndestruct Hey as (Hey,_); [now apply Rgt_not_eq|].\nrewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (Build_mag_prop x ex Hex < Build_mag_prop y ey Hey)%Z -> (x < y)%R.","conclusion":"(Build_mag_prop x ex Hex < Build_mag_prop y ey Hey)%Z -> (x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"simpl.\nintro H.\ndestruct Hex as (_,Hex); [now apply Rgt_not_eq|].\ndestruct Hey as (Hey,_); [now apply Rgt_not_eq|].\nrewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (ex < ey)%Z -> (x < y)%R.","conclusion":"(ex < ey)%Z -> (x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"intro H.\ndestruct Hex as (_,Hex); [now apply Rgt_not_eq|].\ndestruct Hey as (Hey,_); [now apply Rgt_not_eq|].\nrewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (H : (ex < ey)%Z) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (H : (ex < ey)%Z)","proofString":"destruct Hex as (_,Hex); [now apply Rgt_not_eq|].\ndestruct Hey as (Hey,_); [now apply Rgt_not_eq|].\nrewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (H : (ex < ey)%Z) (Hex : (Rabs x < bpow ex)%R) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (H : (ex < ey)%Z) (Hex : (Rabs x < bpow ex)%R)","proofString":"destruct Hey as (Hey,_); [now apply Rgt_not_eq|].\nrewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (Rabs x < bpow ex)%R) (Hey : (bpow (ey - 1) <= Rabs y)%R) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (Rabs x < bpow ex)%R) (Hey : (bpow (ey - 1) <= Rabs y)%R)","proofString":"rewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le].\nrewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= Rabs y)%R) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= Rabs y)%R)","proofString":"rewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le].\napply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= y)%R) : (x < y)%R.","conclusion":"(x < y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= y)%R)","proofString":"apply (Rlt_le_trans _ _ _ Hex).\napply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= y)%R) : (bpow ex <= y)%R.","conclusion":"(bpow ex <= y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= y)%R)","proofString":"apply Rle_trans with (bpow (ey - 1)); [|exact Hey].\nnow apply bpow_le; lia."},{"statement":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= y)%R) : (bpow ex <= bpow (ey - 1))%R.","conclusion":"(bpow ex <= bpow (ey - 1))%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Px : (0 < x)%R) (ex ey : Z) (H : (ex < ey)%Z) (Hex : (x < bpow ex)%R) (Hey : (bpow (ey - 1) <= y)%R)","proofString":"now apply bpow_le; lia."},{"statement":"(e : Z) : (bpow (e + 1 - 1) <= Rabs (bpow e) < bpow (e + 1))%R.","conclusion":"(bpow (e + 1 - 1) <= Rabs (bpow e) < bpow (e + 1))%R","hypotheses":"(e : Z)","proofString":"rewrite Rabs_right.\nreplace (e + 1 - 1)%Z with e by ring.\nsplit.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ.\napply Rle_ge.\napply bpow_ge_0."},{"statement":"(e : Z) : (bpow (e + 1 - 1) <= bpow e < bpow (e + 1))%R.","conclusion":"(bpow (e + 1 - 1) <= bpow e < bpow (e + 1))%R","hypotheses":"(e : Z)","proofString":"replace (e + 1 - 1)%Z with e by ring.\nsplit.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ."},{"statement":"(e : Z) : (bpow e <= bpow e < bpow (e + 1))%R.","conclusion":"(bpow e <= bpow e < bpow (e + 1))%R","hypotheses":"(e : Z)","proofString":"split.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ."},{"statement":"(e : Z) : (bpow e <= bpow e)%R.","conclusion":"(bpow e <= bpow e)%R","hypotheses":"(e : Z)","proofString":"apply Rle_refl."},{"statement":"(e : Z) : (bpow e < bpow (e + 1))%R.","conclusion":"(bpow e < bpow (e + 1))%R","hypotheses":"(e : Z)","proofString":"apply bpow_lt.\napply Zlt_succ."},{"statement":"(e : Z) : (e < e + 1)%Z.","conclusion":"(e < e + 1)%Z","hypotheses":"(e : Z)","proofString":"apply Zlt_succ."},{"statement":"(e : Z) : (bpow e >= 0)%R.","conclusion":"(bpow e >= 0)%R","hypotheses":"(e : Z)","proofString":"apply Rle_ge.\napply bpow_ge_0."},{"statement":"(e : Z) : (0 <= bpow e)%R.","conclusion":"(0 <= bpow e)%R","hypotheses":"(e : Z)","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex + e - 1) <= Rabs (x * bpow e) < bpow (ex + e))%R.","conclusion":"(bpow (ex + e - 1) <= Rabs (x * bpow e) < bpow (ex + e))%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"rewrite Rabs_mult.\nrewrite (Rabs_pos_eq (bpow e)) by apply bpow_ge_0.\nsplit.\nreplace (ex + e - 1)%Z with (ex - 1 + e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Ex.\nrewrite bpow_plus.\napply Rmult_lt_compat_r.\napply bpow_gt_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex + e - 1) <= Rabs x * Rabs (bpow e) < bpow (ex + e))%R.","conclusion":"(bpow (ex + e - 1) <= Rabs x * Rabs (bpow e) < bpow (ex + e))%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"rewrite (Rabs_pos_eq (bpow e)) by apply bpow_ge_0.\nsplit.\nreplace (ex + e - 1)%Z with (ex - 1 + e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Ex.\nrewrite bpow_plus.\napply Rmult_lt_compat_r.\napply bpow_gt_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex + e - 1) <= Rabs x * bpow e < bpow (ex + e))%R.","conclusion":"(bpow (ex + e - 1) <= Rabs x * bpow e < bpow (ex + e))%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"split.\nreplace (ex + e - 1)%Z with (ex - 1 + e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Ex.\nrewrite bpow_plus.\napply Rmult_lt_compat_r.\napply bpow_gt_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex + e - 1) <= Rabs x * bpow e)%R.","conclusion":"(bpow (ex + e - 1) <= Rabs x * bpow e)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"replace (ex + e - 1)%Z with (ex - 1 + e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1 + e) <= Rabs x * bpow e)%R.","conclusion":"(bpow (ex - 1 + e) <= Rabs x * bpow e)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"rewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) * bpow e <= Rabs x * bpow e)%R.","conclusion":"(bpow (ex - 1) * bpow e <= Rabs x * bpow e)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= bpow e)%R.","conclusion":"(0 <= bpow e)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","conclusion":"(bpow (ex - 1) <= Rabs x)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs x * bpow e < bpow (ex + e))%R.","conclusion":"(Rabs x * bpow e < bpow (ex + e))%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"rewrite bpow_plus.\napply Rmult_lt_compat_r.\napply bpow_gt_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs x * bpow e < bpow ex * bpow e)%R.","conclusion":"(Rabs x * bpow e < bpow ex * bpow e)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply Rmult_lt_compat_r.\napply bpow_gt_0.\napply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 < bpow e)%R.","conclusion":"(0 < bpow e)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs x < bpow ex)%R.","conclusion":"(Rabs x < bpow ex)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply Ex."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) : (mag x <= e)%Z.","conclusion":"(mag x <= e)%Z","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R)","proofString":"destruct (mag x) as (ex, Ex) ; simpl.\nspecialize (Ex Zx).\napply bpow_lt_bpow.\nnow apply Rle_lt_trans with (Rabs x)."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (ex <= e)%Z.","conclusion":"(ex <= e)%Z","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"specialize (Ex Zx).\napply bpow_lt_bpow.\nnow apply Rle_lt_trans with (Rabs x)."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (ex <= e)%Z.","conclusion":"(ex <= e)%Z","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply bpow_lt_bpow.\nnow apply Rle_lt_trans with (Rabs x)."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) < bpow e)%R.","conclusion":"(bpow (ex - 1) < bpow e)%R","hypotheses":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"now apply Rle_lt_trans with (Rabs x)."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) : (e < mag x)%Z.","conclusion":"(e < mag x)%Z","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R)","proofString":"destruct (mag x) as (ex, Ex) ; simpl.\napply lt_bpow.\napply Rle_lt_trans with (1 := Hx).\napply Ex.\nintros Zx.\napply Rle_not_lt with (1 := Hx).\nrewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (e < ex)%Z.","conclusion":"(e < ex)%Z","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply lt_bpow.\napply Rle_lt_trans with (1 := Hx).\napply Ex.\nintros Zx.\napply Rle_not_lt with (1 := Hx).\nrewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow e < bpow ex)%R.","conclusion":"(bpow e < bpow ex)%R","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply Rle_lt_trans with (1 := Hx).\napply Ex.\nintros Zx.\napply Rle_not_lt with (1 := Hx).\nrewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs x < bpow ex)%R.","conclusion":"(Rabs x < bpow ex)%R","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"apply Ex.\nintros Zx.\napply Rle_not_lt with (1 := Hx).\nrewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : x <> 0%R.","conclusion":"x <> 0%R","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"intros Zx.\napply Rle_not_lt with (1 := Hx).\nrewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Zx : x = 0%R) : False.","conclusion":"False","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Zx : x = 0%R)","proofString":"apply Rle_not_lt with (1 := Hx).\nrewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Zx : x = 0%R) : (Rabs x < bpow e)%R.","conclusion":"(Rabs x < bpow e)%R","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Zx : x = 0%R)","proofString":"rewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Zx : x = 0%R) : (0 < bpow e)%R.","conclusion":"(0 < bpow e)%R","hypotheses":"(x : R) (e : Z) (Hx : (bpow e <= Rabs x)%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Zx : x = 0%R)","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R) : (e <= mag x)%Z.","conclusion":"(e <= mag x)%Z","hypotheses":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R)","proofString":"destruct (Rlt_or_le (Rabs x) (bpow e)) as [Hxe|Hxe].\nassert (mag x = e :> Z) as Hln.\nnow apply mag_unique; split.\nrewrite Hln.\nnow apply Z.le_refl.\napply Zlt_le_weak.\nnow apply mag_gt_bpow."},{"statement":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R) (Hxe : (Rabs x < bpow e)%R) : (e <= mag x)%Z.","conclusion":"(e <= mag x)%Z","hypotheses":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R) (Hxe : (Rabs x < bpow e)%R)","proofString":"assert (mag x = e :> Z) as Hln.\nnow apply mag_unique; split.\nrewrite Hln.\nnow apply Z.le_refl."},{"statement":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R) (Hxe : (bpow e <= Rabs x)%R) : (e <= mag x)%Z.","conclusion":"(e <= mag x)%Z","hypotheses":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R) (Hxe : (bpow e <= Rabs x)%R)","proofString":"apply Zlt_le_weak.\nnow apply mag_gt_bpow."},{"statement":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R) (Hxe : (bpow e <= Rabs x)%R) : (e < mag x)%Z.","conclusion":"(e < mag x)%Z","hypotheses":"(x : R) (e : Z) (H : (bpow (e - 1) <= Rabs x)%R) (Hxe : (bpow e <= Rabs x)%R)","proofString":"now apply mag_gt_bpow."},{"statement":"(x : R) : (Rabs x < bpow (mag x))%R.","conclusion":"(Rabs x < bpow (mag x))%R","hypotheses":"(x : R)","proofString":"destruct (Req_dec x 0) as [Zx|Zx].\nrewrite Zx, Rabs_R0.\napply bpow_gt_0.\ndestruct (mag x) as (ex, Ex) ; simpl.\nnow apply Ex."},{"statement":"(x : R) (Zx : x = 0%R) : (Rabs x < bpow (mag x))%R.","conclusion":"(Rabs x < bpow (mag x))%R","hypotheses":"(x : R) (Zx : x = 0%R)","proofString":"rewrite Zx, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x = 0%R) : (0 < bpow (mag 0))%R.","conclusion":"(0 < bpow (mag 0))%R","hypotheses":"(x : R) (Zx : x = 0%R)","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) : (Rabs x < bpow (mag x))%R.","conclusion":"(Rabs x < bpow (mag x))%R","hypotheses":"(x : R) (Zx : x <> 0%R)","proofString":"destruct (mag x) as (ex, Ex) ; simpl.\nnow apply Ex."},{"statement":"(x : R) (Zx : x <> 0%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs x < bpow ex)%R.","conclusion":"(Rabs x < bpow ex)%R","hypotheses":"(x : R) (Zx : x <> 0%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"now apply Ex."},{"statement":"(x : R) (Hx : x <> 0%R) : (bpow (mag x - 1) <= Rabs x)%R.","conclusion":"(bpow (mag x - 1) <= Rabs x)%R","hypotheses":"(x : R) (Hx : x <> 0%R)","proofString":"destruct (mag x) as (ex, Ex) ; simpl.\nnow apply Ex."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","conclusion":"(bpow (ex - 1) <= Rabs x)%R","hypotheses":"(x : R) (Hx : x <> 0%R) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"now apply Ex."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) : (mag (IZR m) <= e)%Z.","conclusion":"(mag (IZR m) <= e)%Z","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z)","proofString":"apply mag_le_bpow.\nnow apply IZR_neq.\ndestruct (Zle_or_lt 0 e).\nrewrite <- abs_IZR, <- IZR_Zpower with (1 := H).\nnow apply IZR_lt.\nelim Zm.\ncut (Z.abs m < 0)%Z.\nnow case m.\nclear -Hm H.\nnow destruct e."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) : IZR m <> 0%R.","conclusion":"IZR m <> 0%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z)","proofString":"now apply IZR_neq."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) : (Rabs (IZR m) < bpow e)%R.","conclusion":"(Rabs (IZR m) < bpow e)%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z)","proofString":"destruct (Zle_or_lt 0 e).\nrewrite <- abs_IZR, <- IZR_Zpower with (1 := H).\nnow apply IZR_lt.\nelim Zm.\ncut (Z.abs m < 0)%Z.\nnow case m.\nclear -Hm H.\nnow destruct e."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (0 <= e)%Z) : (Rabs (IZR m) < bpow e)%R.","conclusion":"(Rabs (IZR m) < bpow e)%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (0 <= e)%Z)","proofString":"rewrite <- abs_IZR, <- IZR_Zpower with (1 := H).\nnow apply IZR_lt."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (0 <= e)%Z) : (IZR (Z.abs m) < IZR (r ^ e))%R.","conclusion":"(IZR (Z.abs m) < IZR (r ^ e))%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (0 <= e)%Z)","proofString":"now apply IZR_lt."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z) : (Rabs (IZR m) < bpow e)%R.","conclusion":"(Rabs (IZR m) < bpow e)%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z)","proofString":"elim Zm.\ncut (Z.abs m < 0)%Z.\nnow case m.\nclear -Hm H.\nnow destruct e."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z) : m = 0%Z.","conclusion":"m = 0%Z","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z)","proofString":"cut (Z.abs m < 0)%Z.\nnow case m.\nclear -Hm H.\nnow destruct e."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z) : (Z.abs m < 0)%Z -> m = 0%Z.","conclusion":"(Z.abs m < 0)%Z -> m = 0%Z","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z)","proofString":"now case m."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z) : (Z.abs m < 0)%Z.","conclusion":"(Z.abs m < 0)%Z","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z)","proofString":"clear -Hm H.\nnow destruct e."},{"statement":"(m e : Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z) : (Z.abs m < 0)%Z.","conclusion":"(Z.abs m < 0)%Z","hypotheses":"(m e : Z) (Hm : (Z.abs m < r ^ e)%Z) (H : (e < 0)%Z)","proofString":"now destruct e."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) : (e < mag (IZR m))%Z.","conclusion":"(e < mag (IZR m))%Z","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z)","proofString":"apply mag_gt_bpow.\nrewrite <- abs_IZR.\ndestruct (Zle_or_lt 0 e).\nrewrite <- IZR_Zpower with (1 := H).\nnow apply IZR_le.\napply Rle_trans with (bpow 0).\napply bpow_le.\nnow apply Zlt_le_weak.\napply IZR_le.\nclear -Zm.\nlia."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) : (bpow e <= Rabs (IZR m))%R.","conclusion":"(bpow e <= Rabs (IZR m))%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z)","proofString":"rewrite <- abs_IZR.\ndestruct (Zle_or_lt 0 e).\nrewrite <- IZR_Zpower with (1 := H).\nnow apply IZR_le.\napply Rle_trans with (bpow 0).\napply bpow_le.\nnow apply Zlt_le_weak.\napply IZR_le.\nclear -Zm.\nlia."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) : (bpow e <= IZR (Z.abs m))%R.","conclusion":"(bpow e <= IZR (Z.abs m))%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z)","proofString":"destruct (Zle_or_lt 0 e).\nrewrite <- IZR_Zpower with (1 := H).\nnow apply IZR_le.\napply Rle_trans with (bpow 0).\napply bpow_le.\nnow apply Zlt_le_weak.\napply IZR_le.\nclear -Zm.\nlia."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (0 <= e)%Z) : (bpow e <= IZR (Z.abs m))%R.","conclusion":"(bpow e <= IZR (Z.abs m))%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (0 <= e)%Z)","proofString":"rewrite <- IZR_Zpower with (1 := H).\nnow apply IZR_le."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (0 <= e)%Z) : (IZR (r ^ e) <= IZR (Z.abs m))%R.","conclusion":"(IZR (r ^ e) <= IZR (Z.abs m))%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (0 <= e)%Z)","proofString":"now apply IZR_le."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z) : (bpow e <= IZR (Z.abs m))%R.","conclusion":"(bpow e <= IZR (Z.abs m))%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z)","proofString":"apply Rle_trans with (bpow 0).\napply bpow_le.\nnow apply Zlt_le_weak.\napply IZR_le.\nclear -Zm.\nlia."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z) : (bpow e <= bpow 0)%R.","conclusion":"(bpow e <= bpow 0)%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z)","proofString":"apply bpow_le.\nnow apply Zlt_le_weak."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z) : (e <= 0)%Z.","conclusion":"(e <= 0)%Z","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z)","proofString":"now apply Zlt_le_weak."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z) : (bpow 0 <= IZR (Z.abs m))%R.","conclusion":"(bpow 0 <= IZR (Z.abs m))%R","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z)","proofString":"apply IZR_le.\nclear -Zm.\nlia."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z) : (1 <= Z.abs m)%Z.","conclusion":"(1 <= Z.abs m)%Z","hypotheses":"(m e : Z) (Zm : m <> 0%Z) (Hm : (r ^ e <= Z.abs m)%Z) (H : (e < 0)%Z)","proofString":"clear -Zm.\nlia."},{"statement":"(m : Z) (Zm : m <> 0%Z) : (1 <= Z.abs m)%Z.","conclusion":"(1 <= Z.abs m)%Z","hypotheses":"(m : Z) (Zm : m <> 0%Z)","proofString":"lia."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) : (mag x + mag y - 1 <= mag (x * y) <= mag x + mag y)%Z.","conclusion":"(mag x + mag y - 1 <= mag (x * y) <= mag x + mag y)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R)","proofString":"destruct (mag x) as (ex, Hx2).\ndestruct (mag y) as (ey, Hy2).\nsimpl.\ndestruct (Hx2 Hx) as (Hx21,Hx22); clear Hx2.\ndestruct (Hy2 Hy) as (Hy21,Hy22); clear Hy2.\nassert (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R).\nreplace (ex + ey -1 -1)%Z with (ex - 1 + (ey - 1))%Z; [|ring].\nrewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0.\nassert (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R).\nrewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex : Z) (Hx2 : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Build_mag_prop x ex Hx2 + mag y - 1 <= mag (x * y) <=\n Build_mag_prop x ex Hx2 + mag y)%Z.","conclusion":"(Build_mag_prop x ex Hx2 + mag y - 1 <= mag (x * y) <=\n Build_mag_prop x ex Hx2 + mag y)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex : Z) (Hx2 : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"destruct (mag y) as (ey, Hy2).\nsimpl.\ndestruct (Hx2 Hx) as (Hx21,Hx22); clear Hx2.\ndestruct (Hy2 Hy) as (Hy21,Hy22); clear Hy2.\nassert (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R).\nreplace (ex + ey -1 -1)%Z with (ex - 1 + (ey - 1))%Z; [|ring].\nrewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0.\nassert (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R).\nrewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex : Z) (Hx2 : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy2 : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (Build_mag_prop x ex Hx2 + Build_mag_prop y ey Hy2 - 1 <= \n mag (x * y) <= Build_mag_prop x ex Hx2 + Build_mag_prop y ey Hy2)%Z.","conclusion":"(Build_mag_prop x ex Hx2 + Build_mag_prop y ey Hy2 - 1 <= \n mag (x * y) <= Build_mag_prop x ex Hx2 + Build_mag_prop y ey Hy2)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex : Z) (Hx2 : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy2 : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"simpl.\ndestruct (Hx2 Hx) as (Hx21,Hx22); clear Hx2.\ndestruct (Hy2 Hy) as (Hy21,Hy22); clear Hy2.\nassert (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R).\nreplace (ex + ey -1 -1)%Z with (ex - 1 + (ey - 1))%Z; [|ring].\nrewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0.\nassert (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R).\nrewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex : Z) (Hx2 : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy2 : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (ex + ey - 1 <= mag (x * y) <= ex + ey)%Z.","conclusion":"(ex + ey - 1 <= mag (x * y) <= ex + ey)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex : Z) (Hx2 : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hy2 : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"destruct (Hx2 Hx) as (Hx21,Hx22); clear Hx2.\ndestruct (Hy2 Hy) as (Hy21,Hy22); clear Hy2.\nassert (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R).\nreplace (ex + ey -1 -1)%Z with (ex - 1 + (ey - 1))%Z; [|ring].\nrewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0.\nassert (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R).\nrewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hy2 : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) : (ex + ey - 1 <= mag (x * y) <= ex + ey)%Z.","conclusion":"(ex + ey - 1 <= mag (x * y) <= ex + ey)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hy2 : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R)","proofString":"destruct (Hy2 Hy) as (Hy21,Hy22); clear Hy2.\nassert (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R).\nreplace (ex + ey -1 -1)%Z with (ex - 1 + (ey - 1))%Z; [|ring].\nrewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0.\nassert (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R).\nrewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) : (ex + ey - 1 <= mag (x * y) <= ex + ey)%Z.","conclusion":"(ex + ey - 1 <= mag (x * y) <= ex + ey)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R)","proofString":"assert (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R).\nreplace (ex + ey -1 -1)%Z with (ex - 1 + (ey - 1))%Z; [|ring].\nrewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0.\nassert (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R).\nrewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R.","conclusion":"(bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R)","proofString":"replace (ex + ey -1 -1)%Z with (ex - 1 + (ey - 1))%Z; [|ring].\nrewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) : (bpow (ex - 1 + (ey - 1)) <= Rabs (x * y))%R.","conclusion":"(bpow (ex - 1 + (ey - 1)) <= Rabs (x * y))%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R)","proofString":"rewrite bpow_plus.\nrewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) : (bpow (ex - 1) * bpow (ey - 1) <= Rabs (x * y))%R.","conclusion":"(bpow (ex - 1) * bpow (ey - 1) <= Rabs (x * y))%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R)","proofString":"rewrite Rabs_mult.\nnow apply Rmult_le_compat; try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) : (bpow (ex - 1) * bpow (ey - 1) <= Rabs x * Rabs y)%R.","conclusion":"(bpow (ex - 1) * bpow (ey - 1) <= Rabs x * Rabs y)%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R)","proofString":"now apply Rmult_le_compat; try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) : (ex + ey - 1 <= mag (x * y) <= ex + ey)%Z.","conclusion":"(ex + ey - 1 <= mag (x * y) <= ex + ey)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R)","proofString":"assert (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R).\nrewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) : (Rabs (x * y) < bpow (ex + ey))%R.","conclusion":"(Rabs (x * y) < bpow (ex + ey))%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R)","proofString":"rewrite Rabs_mult.\nrewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) : (Rabs x * Rabs y < bpow (ex + ey))%R.","conclusion":"(Rabs x * Rabs y < bpow (ex + ey))%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R)","proofString":"rewrite bpow_plus.\napply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) : (Rabs x * Rabs y < bpow ex * bpow ey)%R.","conclusion":"(Rabs x * Rabs y < bpow ex * bpow ey)%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R)","proofString":"apply Rmult_le_0_lt_compat; try assumption.\nnow apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0.\nnow apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) : (0 <= Rabs x)%R.","conclusion":"(0 <= Rabs x)%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R)","proofString":"now apply Rle_trans with (bpow (ex - 1)); try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) : (0 <= Rabs y)%R.","conclusion":"(0 <= Rabs y)%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R)","proofString":"now apply Rle_trans with (bpow (ey - 1)); try apply bpow_ge_0."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R) : (ex + ey - 1 <= mag (x * y) <= ex + ey)%Z.","conclusion":"(ex + ey - 1 <= mag (x * y) <= ex + ey)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R)","proofString":"split.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R) : (ex + ey - 1 <= mag (x * y))%Z.","conclusion":"(ex + ey - 1 <= mag (x * y))%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R)","proofString":"now apply mag_ge_bpow."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R) : (mag (x * y) <= ex + ey)%Z.","conclusion":"(mag (x * y) <= ex + ey)%Z","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R)","proofString":"apply mag_le_bpow.\nnow apply Rmult_integral_contrapositive_currified.\nassumption."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R) : (x * y)%R <> 0%R.","conclusion":"(x * y)%R <> 0%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R)","proofString":"now apply Rmult_integral_contrapositive_currified."},{"statement":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R) : (Rabs (x * y) < bpow (ex + ey))%R.","conclusion":"(Rabs (x * y) < bpow (ex + ey))%R","hypotheses":"(x y : R) (Hx : x <> 0%R) (Hy : y <> 0%R) (ex ey : Z) (Hx21 : (bpow (ex - 1) <= Rabs x)%R) (Hx22 : (Rabs x < bpow ex)%R) (Hy21 : (bpow (ey - 1) <= Rabs y)%R) (Hy22 : (Rabs y < bpow ey)%R) (Hxy : (bpow (ex + ey - 1 - 1) <= Rabs (x * y))%R) (Hxy2 : (Rabs (x * y) < bpow (ex + ey))%R)","proofString":"assumption."},{"statement":"(2 <= r)%Z.","conclusion":"(2 <= r)%Z","hypotheses":"","proofString":"destruct r as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) : (2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z.","conclusion":"(2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z","hypotheses":"(beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true)","proofString":"now apply Zle_bool_imp_le."},{"statement":"(Hr : (2 <= r)%Z) : forall x y : R,\n(0 < y)%R -> (y <= x)%R -> (mag x <= mag (x + y) <= mag x + 1)%Z.","conclusion":"forall x y : R,\n(0 < y)%R -> (y <= x)%R -> (mag x <= mag (x + y) <= mag x + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z)","proofString":"intros x y Hy Hxy.\nassert (Hx : (0 < x)%R) by apply (Rlt_le_trans _ _ _ Hy Hxy).\ndestruct (mag x) as (ex,Hex); simpl.\ndestruct Hex as (Hex0,Hex1); [now apply Rgt_not_eq|].\nassert (Haxy : (Rabs (x + y) < bpow (ex + 1))%R).\nrewrite bpow_plus_1.\napply Rlt_le_trans with (2 * bpow ex)%R.\nrewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat.\napply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le.\nassert (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R).\napply (Rle_trans _ _ _ Hex0).\nrewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) : (mag x <= mag (x + y) <= mag x + 1)%Z.","conclusion":"(mag x <= mag (x + y) <= mag x + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R)","proofString":"assert (Hx : (0 < x)%R) by apply (Rlt_le_trans _ _ _ Hy Hxy).\ndestruct (mag x) as (ex,Hex); simpl.\ndestruct Hex as (Hex0,Hex1); [now apply Rgt_not_eq|].\nassert (Haxy : (Rabs (x + y) < bpow (ex + 1))%R).\nrewrite bpow_plus_1.\napply Rlt_le_trans with (2 * bpow ex)%R.\nrewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat.\napply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le.\nassert (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R).\napply (Rle_trans _ _ _ Hex0).\nrewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) : (mag x <= mag (x + y) <= mag x + 1)%Z.","conclusion":"(mag x <= mag (x + y) <= mag x + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R)","proofString":"destruct (mag x) as (ex,Hex); simpl.\ndestruct Hex as (Hex0,Hex1); [now apply Rgt_not_eq|].\nassert (Haxy : (Rabs (x + y) < bpow (ex + 1))%R).\nrewrite bpow_plus_1.\napply Rlt_le_trans with (2 * bpow ex)%R.\nrewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat.\napply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le.\nassert (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R).\napply (Rle_trans _ _ _ Hex0).\nrewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (ex <= mag (x + y) <= ex + 1)%Z.","conclusion":"(ex <= mag (x + y) <= ex + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"destruct Hex as (Hex0,Hex1); [now apply Rgt_not_eq|].\nassert (Haxy : (Rabs (x + y) < bpow (ex + 1))%R).\nrewrite bpow_plus_1.\napply Rlt_le_trans with (2 * bpow ex)%R.\nrewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat.\napply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le.\nassert (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R).\napply (Rle_trans _ _ _ Hex0).\nrewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (ex <= mag (x + y) <= ex + 1)%Z.","conclusion":"(ex <= mag (x + y) <= ex + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"assert (Haxy : (Rabs (x + y) < bpow (ex + 1))%R).\nrewrite bpow_plus_1.\napply Rlt_le_trans with (2 * bpow ex)%R.\nrewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat.\napply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le.\nassert (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R).\napply (Rle_trans _ _ _ Hex0).\nrewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (Rabs (x + y) < bpow (ex + 1))%R.","conclusion":"(Rabs (x + y) < bpow (ex + 1))%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"rewrite bpow_plus_1.\napply Rlt_le_trans with (2 * bpow ex)%R.\nrewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat.\napply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (Rabs (x + y) < IZR r * bpow ex)%R.","conclusion":"(Rabs (x + y) < IZR r * bpow ex)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"apply Rlt_le_trans with (2 * bpow ex)%R.\nrewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat.\napply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (Rabs (x + y) < 2 * bpow ex)%R.","conclusion":"(Rabs (x + y) < 2 * bpow ex)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"rewrite Rabs_pos_eq.\napply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2.\nrewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (x + y < 2 * bpow ex)%R.","conclusion":"(x + y < 2 * bpow ex)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"apply Rle_lt_trans with (2 * Rabs x)%R.\nrewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (x + y <= 2 * Rabs x)%R.","conclusion":"(x + y <= 2 * Rabs x)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"rewrite Rabs_pos_eq.\nreplace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l.\nnow apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (x + y <= 2 * x)%R.","conclusion":"(x + y <= 2 * x)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"replace (2 * x)%R with (x + x)%R by ring.\nnow apply Rplus_le_compat_l."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (x + y <= x + x)%R.","conclusion":"(x + y <= x + x)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"now apply Rplus_le_compat_l."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"now apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (2 * Rabs x < 2 * bpow ex)%R.","conclusion":"(2 * Rabs x < 2 * bpow ex)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"apply Rmult_lt_compat_l with (2 := Hex1).\nexact Rlt_0_2."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (0 < 2)%R.","conclusion":"(0 < 2)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"exact Rlt_0_2."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (0 <= x + y)%R.","conclusion":"(0 <= x + y)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"rewrite <- (Rplus_0_l 0).\nnow apply Rlt_le, Rplus_lt_compat."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (0 + 0 <= x + y)%R.","conclusion":"(0 + 0 <= x + y)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"now apply Rlt_le, Rplus_lt_compat."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (2 * bpow ex <= IZR r * bpow ex)%R.","conclusion":"(2 * bpow ex <= IZR r * bpow ex)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"apply Rmult_le_compat_r.\nnow apply bpow_ge_0.\nnow apply IZR_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (0 <= bpow ex)%R.","conclusion":"(0 <= bpow ex)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"now apply bpow_ge_0."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) : (2 <= IZR r)%R.","conclusion":"(2 <= IZR r)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R)","proofString":"now apply IZR_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) : (ex <= mag (x + y) <= ex + 1)%Z.","conclusion":"(ex <= mag (x + y) <= ex + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R)","proofString":"assert (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R).\napply (Rle_trans _ _ _ Hex0).\nrewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\nsplit.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) : (bpow (ex - 1) <= Rabs (x + y))%R.","conclusion":"(bpow (ex - 1) <= Rabs (x + y))%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R)","proofString":"apply (Rle_trans _ _ _ Hex0).\nrewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) : (Rabs x <= Rabs (x + y))%R.","conclusion":"(Rabs x <= Rabs (x + y))%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R)","proofString":"rewrite Rabs_right; [|now apply Rgt_ge].\napply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) : (x <= Rabs (x + y))%R.","conclusion":"(x <= Rabs (x + y))%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R)","proofString":"apply Rabs_ge; right.\nrewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) : (x <= x + y)%R.","conclusion":"(x <= x + y)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R)","proofString":"rewrite <- (Rplus_0_r x) at 1.\napply Rplus_le_compat_l.\nnow apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) : (x + 0 <= x + y)%R.","conclusion":"(x + 0 <= x + y)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R)","proofString":"apply Rplus_le_compat_l.\nnow apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) : (0 <= y)%R.","conclusion":"(0 <= y)%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R)","proofString":"now apply Rlt_le."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R) : (ex <= mag (x + y) <= ex + 1)%Z.","conclusion":"(ex <= mag (x + y) <= ex + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R)","proofString":"split.\nnow apply mag_ge_bpow.\napply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R) : (ex <= mag (x + y))%Z.","conclusion":"(ex <= mag (x + y))%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R)","proofString":"now apply mag_ge_bpow."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R) : (mag (x + y) <= ex + 1)%Z.","conclusion":"(mag (x + y) <= ex + 1)%Z","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R)","proofString":"apply mag_le_bpow.\nnow apply tech_Rplus; [apply Rlt_le|].\nexact Haxy."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R) : (x + y)%R <> 0%R.","conclusion":"(x + y)%R <> 0%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R)","proofString":"now apply tech_Rplus; [apply Rlt_le|]."},{"statement":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R) : (Rabs (x + y) < bpow (ex + 1))%R.","conclusion":"(Rabs (x + y) < bpow (ex + 1))%R","hypotheses":"(Hr : (2 <= r)%Z) (x y : R) (Hy : (0 < y)%R) (Hxy : (y <= x)%R) (Hx : (0 < x)%R) (ex : Z) (Hex0 : (bpow (ex - 1) <= Rabs x)%R) (Hex1 : (Rabs x < bpow ex)%R) (Haxy : (Rabs (x + y) < bpow (ex + 1))%R) (Haxy2 : (bpow (ex - 1) <= Rabs (x + y))%R)","proofString":"exact Haxy."},{"statement":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) : (mag (x - y) <= mag x)%Z.","conclusion":"(mag (x - y) <= mag x)%Z","hypotheses":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R)","proofString":"assert (Px : (0 < x)%R) by apply (Rlt_trans _ _ _ Py Hxy).\napply mag_le.\nnow apply Rlt_Rminus.\nrewrite <- (Rplus_0_r x) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar; apply Rlt_le."},{"statement":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R) : (mag (x - y) <= mag x)%Z.","conclusion":"(mag (x - y) <= mag x)%Z","hypotheses":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R)","proofString":"apply mag_le.\nnow apply Rlt_Rminus.\nrewrite <- (Rplus_0_r x) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar; apply Rlt_le."},{"statement":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R) : (0 < x - y)%R.","conclusion":"(0 < x - y)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R)","proofString":"now apply Rlt_Rminus."},{"statement":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R) : (x - y <= x)%R.","conclusion":"(x - y <= x)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R)","proofString":"rewrite <- (Rplus_0_r x) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar; apply Rlt_le."},{"statement":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R) : (x - y <= x + 0)%R.","conclusion":"(x - y <= x + 0)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R)","proofString":"apply Rplus_le_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_le_contravar; apply Rlt_le."},{"statement":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R) : (- y <= 0)%R.","conclusion":"(- y <= 0)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R)","proofString":"rewrite <- Ropp_0.\nnow apply Ropp_le_contravar; apply Rlt_le."},{"statement":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R) : (- y <= - 0)%R.","conclusion":"(- y <= - 0)%R","hypotheses":"(x y : R) (Py : (0 < y)%R) (Hxy : (y < x)%R) (Px : (0 < x)%R)","proofString":"now apply Ropp_le_contravar; apply Rlt_le."},{"statement":"(2 <= r)%Z.","conclusion":"(2 <= r)%Z","hypotheses":"","proofString":"destruct r as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) : (2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z.","conclusion":"(2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z","hypotheses":"(beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true)","proofString":"now apply Zle_bool_imp_le."},{"statement":"(Hbeta : (2 <= r)%Z) : forall x y : R,\n(0 < x)%R ->\n(0 < y)%R -> (mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x - y))%Z.","conclusion":"forall x y : R,\n(0 < x)%R ->\n(0 < y)%R -> (mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z)","proofString":"intros x y Px Py Hln.\nassert (Oxy : (y < x)%R); [apply lt_mag;[assumption|lia]|].\ndestruct (mag x) as (ex,Hex).\ndestruct (mag y) as (ey,Hey).\nsimpl in Hln |- *.\ndestruct Hex as (Hex,_); [now apply Rgt_not_eq|].\ndestruct Hey as (_,Hey); [now apply Rgt_not_eq|].\nassert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (Hln : (mag y <= mag x - 2)%Z) : (mag x - 1 <= mag (x - y))%Z.","conclusion":"(mag x - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (Hln : (mag y <= mag x - 2)%Z)","proofString":"assert (Oxy : (y < x)%R); [apply lt_mag;[assumption|lia]|].\ndestruct (mag x) as (ex,Hex).\ndestruct (mag y) as (ey,Hey).\nsimpl in Hln |- *.\ndestruct Hex as (Hex,_); [now apply Rgt_not_eq|].\ndestruct Hey as (_,Hey); [now apply Rgt_not_eq|].\nassert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (Hln : (mag y <= mag x - 2)%Z) (Oxy : (y < x)%R) : (mag x - 1 <= mag (x - y))%Z.","conclusion":"(mag x - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (Hln : (mag y <= mag x - 2)%Z) (Oxy : (y < x)%R)","proofString":"destruct (mag x) as (ex,Hex).\ndestruct (mag y) as (ey,Hey).\nsimpl in Hln |- *.\ndestruct Hex as (Hex,_); [now apply Rgt_not_eq|].\ndestruct Hey as (_,Hey); [now apply Rgt_not_eq|].\nassert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hln : (mag y <= Build_mag_prop x ex Hex - 2)%Z) (Oxy : (y < x)%R) : (Build_mag_prop x ex Hex - 1 <= mag (x - y))%Z.","conclusion":"(Build_mag_prop x ex Hex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hln : (mag y <= Build_mag_prop x ex Hex - 2)%Z) (Oxy : (y < x)%R)","proofString":"destruct (mag y) as (ey,Hey).\nsimpl in Hln |- *.\ndestruct Hex as (Hex,_); [now apply Rgt_not_eq|].\ndestruct Hey as (_,Hey); [now apply Rgt_not_eq|].\nassert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hln : (Build_mag_prop y ey Hey <= Build_mag_prop x ex Hex - 2)%Z) (Oxy : (y < x)%R) : (Build_mag_prop x ex Hex - 1 <= mag (x - y))%Z.","conclusion":"(Build_mag_prop x ex Hex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hln : (Build_mag_prop y ey Hey <= Build_mag_prop x ex Hex - 2)%Z) (Oxy : (y < x)%R)","proofString":"simpl in Hln |- *.\ndestruct Hex as (Hex,_); [now apply Rgt_not_eq|].\ndestruct Hey as (_,Hey); [now apply Rgt_not_eq|].\nassert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) : (ex - 1 <= mag (x - y))%Z.","conclusion":"(ex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R)","proofString":"destruct Hex as (Hex,_); [now apply Rgt_not_eq|].\ndestruct Hey as (_,Hey); [now apply Rgt_not_eq|].\nassert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) : (ex - 1 <= mag (x - y))%Z.","conclusion":"(ex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R)","proofString":"destruct Hey as (_,Hey); [now apply Rgt_not_eq|].\nassert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (ex - 1 <= mag (x - y))%Z.","conclusion":"(ex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"assert (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R).\nring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le].\nassert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (bpow (ex - 2) + bpow (ex - 2) <= x)%R.","conclusion":"(bpow (ex - 2) + bpow (ex - 2) <= x)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"ring_simplify.\napply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (2 * bpow (ex - 2) <= x)%R.","conclusion":"(2 * bpow (ex - 2) <= x)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"apply Rle_trans with (bpow (ex - 1)).\nreplace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le.\nnow rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (2 * bpow (ex - 2) <= bpow (ex - 1))%R.","conclusion":"(2 * bpow (ex - 2) <= bpow (ex - 1))%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"replace (ex - 1)%Z with (ex - 2 + 1)%Z by ring.\nrewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (2 * bpow (ex - 2) <= bpow (ex - 2 + 1))%R.","conclusion":"(2 * bpow (ex - 2) <= bpow (ex - 2 + 1))%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"rewrite bpow_plus_1.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (2 * bpow (ex - 2) <= IZR r * bpow (ex - 2))%R.","conclusion":"(2 * bpow (ex - 2) <= IZR r * bpow (ex - 2))%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"apply Rmult_le_compat_r; [now apply bpow_ge_0|].\nnow apply IZR_le."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (2 <= IZR r)%R.","conclusion":"(2 <= IZR r)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"now apply IZR_le."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) : (bpow (ex - 1) <= x)%R.","conclusion":"(bpow (ex - 1) <= x)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R)","proofString":"now rewrite Rabs_right in Hex; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) : (ex - 1 <= mag (x - y))%Z.","conclusion":"(ex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R)","proofString":"assert (Hby : (y < bpow (ex - 2))%R).\napply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le.\nassert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) : (y < bpow (ex - 2))%R.","conclusion":"(y < bpow (ex - 2))%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R)","proofString":"apply Rlt_le_trans with (bpow ey).\nnow rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le].\nnow apply bpow_le."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) : (y < bpow ey)%R.","conclusion":"(y < bpow ey)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R)","proofString":"now rewrite Rabs_right in Hey; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) : (bpow ey <= bpow (ex - 2))%R.","conclusion":"(bpow ey <= bpow (ex - 2))%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R)","proofString":"now apply bpow_le."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) : (ex - 1 <= mag (x - y))%Z.","conclusion":"(ex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R)","proofString":"assert (Hbxy : (bpow (ex - 2) <= x - y)%R).\napply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat.\napply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) : (bpow (ex - 2) <= x - y)%R.","conclusion":"(bpow (ex - 2) <= x - y)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R)","proofString":"apply Ropp_lt_contravar in Hby.\napply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (- bpow (ex - 2) < - y)%R) : (bpow (ex - 2) <= x - y)%R.","conclusion":"(bpow (ex - 2) <= x - y)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (- bpow (ex - 2) < - y)%R)","proofString":"apply Rlt_le in Hby.\nreplace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (- bpow (ex - 2) <= - y)%R) : (bpow (ex - 2) <= x - y)%R.","conclusion":"(bpow (ex - 2) <= x - y)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (- bpow (ex - 2) <= - y)%R)","proofString":"replace (bpow (ex - 2))%R with (bpow (ex - 2) + bpow (ex - 2)                                                  - bpow (ex - 2))%R by ring.\nnow apply Rplus_le_compat."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (- bpow (ex - 2) <= - y)%R) : (bpow (ex - 2) + bpow (ex - 2) - bpow (ex - 2) <= x - y)%R.","conclusion":"(bpow (ex - 2) + bpow (ex - 2) - bpow (ex - 2) <= x - y)%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (- bpow (ex - 2) <= - y)%R)","proofString":"now apply Rplus_le_compat."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) (Hbxy : (bpow (ex - 2) <= x - y)%R) : (ex - 1 <= mag (x - y))%Z.","conclusion":"(ex - 1 <= mag (x - y))%Z","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) (Hbxy : (bpow (ex - 2) <= x - y)%R)","proofString":"apply mag_ge_bpow.\nreplace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) (Hbxy : (bpow (ex - 2) <= x - y)%R) : (bpow (ex - 1 - 1) <= Rabs (x - y))%R.","conclusion":"(bpow (ex - 1 - 1) <= Rabs (x - y))%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) (Hbxy : (bpow (ex - 2) <= x - y)%R)","proofString":"replace (ex - 1 - 1)%Z with (ex - 2)%Z by ring.\nnow apply Rabs_ge; right."},{"statement":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) (Hbxy : (bpow (ex - 2) <= x - y)%R) : (bpow (ex - 2) <= Rabs (x - y))%R.","conclusion":"(bpow (ex - 2) <= Rabs (x - y))%R","hypotheses":"(Hbeta : (2 <= r)%Z) (x y : R) (Px : (0 < x)%R) (Py : (0 < y)%R) (ex ey : Z) (Hln : (ey <= ex - 2)%Z) (Oxy : (y < x)%R) (Hex : (bpow (ex - 1) <= Rabs x)%R) (Hey : (Rabs y < bpow ey)%R) (Hbx : (bpow (ex - 2) + bpow (ex - 2) <= x)%R) (Hby : (y < bpow (ex - 2))%R) (Hbxy : (bpow (ex - 2) <= x - y)%R)","proofString":"now apply Rabs_ge; right."},{"statement":"(x y : R) (Zx : x <> 0%R) : (mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x + y))%Z.","conclusion":"(mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R)","proofString":"destruct (Req_dec y 0) as [Zy|Zy].\nintros _.\nrewrite Zy, Rplus_0_r.\nlia.\nrewrite <- (mag_abs x), <- (mag_abs y).\nintros Hm.\nassert (H: Rabs x <> Rabs y).\nintros H.\napply Zlt_not_le with (2 := Hm).\nrewrite H.\nlia.\napply mag_minus_lb in Hm ; try now apply Rabs_pos_lt.\napply Z.le_trans with (1 := Hm).\napply mag_le_abs.\nnow apply Rminus_eq_contra.\nrewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y = 0%R) : (mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x + y))%Z.","conclusion":"(mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y = 0%R)","proofString":"intros _.\nrewrite Zy, Rplus_0_r.\nlia."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y = 0%R) : (mag x - 1 <= mag (x + y))%Z.","conclusion":"(mag x - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y = 0%R)","proofString":"rewrite Zy, Rplus_0_r.\nlia."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y = 0%R) : (mag x - 1 <= mag x)%Z.","conclusion":"(mag x - 1 <= mag x)%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y = 0%R)","proofString":"lia."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) : (mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x + y))%Z.","conclusion":"(mag y <= mag x - 2)%Z -> (mag x - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R)","proofString":"rewrite <- (mag_abs x), <- (mag_abs y).\nintros Hm.\nassert (H: Rabs x <> Rabs y).\nintros H.\napply Zlt_not_le with (2 := Hm).\nrewrite H.\nlia.\napply mag_minus_lb in Hm ; try now apply Rabs_pos_lt.\napply Z.le_trans with (1 := Hm).\napply mag_le_abs.\nnow apply Rminus_eq_contra.\nrewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) : (mag (Rabs y) <= mag (Rabs x) - 2)%Z -> (mag (Rabs x) - 1 <= mag (x + y))%Z.","conclusion":"(mag (Rabs y) <= mag (Rabs x) - 2)%Z -> (mag (Rabs x) - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R)","proofString":"intros Hm.\nassert (H: Rabs x <> Rabs y).\nintros H.\napply Zlt_not_le with (2 := Hm).\nrewrite H.\nlia.\napply mag_minus_lb in Hm ; try now apply Rabs_pos_lt.\napply Z.le_trans with (1 := Hm).\napply mag_le_abs.\nnow apply Rminus_eq_contra.\nrewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) : (mag (Rabs x) - 1 <= mag (x + y))%Z.","conclusion":"(mag (Rabs x) - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z)","proofString":"assert (H: Rabs x <> Rabs y).\nintros H.\napply Zlt_not_le with (2 := Hm).\nrewrite H.\nlia.\napply mag_minus_lb in Hm ; try now apply Rabs_pos_lt.\napply Z.le_trans with (1 := Hm).\napply mag_le_abs.\nnow apply Rminus_eq_contra.\nrewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) : Rabs x <> Rabs y.","conclusion":"Rabs x <> Rabs y","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z)","proofString":"intros H.\napply Zlt_not_le with (2 := Hm).\nrewrite H.\nlia."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x = Rabs y) : False.","conclusion":"False","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x = Rabs y)","proofString":"apply Zlt_not_le with (2 := Hm).\nrewrite H.\nlia."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x = Rabs y) : (mag (Rabs x) - 2 < mag (Rabs y))%Z.","conclusion":"(mag (Rabs x) - 2 < mag (Rabs y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x = Rabs y)","proofString":"rewrite H.\nlia."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x = Rabs y) : (mag (Rabs y) - 2 < mag (Rabs y))%Z.","conclusion":"(mag (Rabs y) - 2 < mag (Rabs y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x = Rabs y)","proofString":"lia."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x <> Rabs y) : (mag (Rabs x) - 1 <= mag (x + y))%Z.","conclusion":"(mag (Rabs x) - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs y) <= mag (Rabs x) - 2)%Z) (H : Rabs x <> Rabs y)","proofString":"apply mag_minus_lb in Hm ; try now apply Rabs_pos_lt.\napply Z.le_trans with (1 := Hm).\napply mag_le_abs.\nnow apply Rminus_eq_contra.\nrewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y) : (mag (Rabs x) - 1 <= mag (x + y))%Z.","conclusion":"(mag (Rabs x) - 1 <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y)","proofString":"apply Z.le_trans with (1 := Hm).\napply mag_le_abs.\nnow apply Rminus_eq_contra.\nrewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y) : (mag (Rabs x - Rabs y) <= mag (x + y))%Z.","conclusion":"(mag (Rabs x - Rabs y) <= mag (x + y))%Z","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y)","proofString":"apply mag_le_abs.\nnow apply Rminus_eq_contra.\nrewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y) : (Rabs x - Rabs y)%R <> 0%R.","conclusion":"(Rabs x - Rabs y)%R <> 0%R","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y)","proofString":"now apply Rminus_eq_contra."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y) : (Rabs (Rabs x - Rabs y) <= Rabs (x + y))%R.","conclusion":"(Rabs (Rabs x - Rabs y) <= Rabs (x + y))%R","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y)","proofString":"rewrite <- (Ropp_involutive y).\nrewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y) : (Rabs (Rabs x - Rabs (- - y)) <= Rabs (x + - - y))%R.","conclusion":"(Rabs (Rabs x - Rabs (- - y)) <= Rabs (x + - - y))%R","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y)","proofString":"rewrite Rabs_Ropp.\napply Rabs_triang_inv2."},{"statement":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y) : (Rabs (Rabs x - Rabs (- y)) <= Rabs (x + - - y))%R.","conclusion":"(Rabs (Rabs x - Rabs (- y)) <= Rabs (x + - - y))%R","hypotheses":"(x y : R) (Zx : x <> 0%R) (Zy : y <> 0%R) (Hm : (mag (Rabs x) - 1 <= mag (Rabs x - Rabs y))%Z) (H : Rabs x <> Rabs y)","proofString":"apply Rabs_triang_inv2."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) : (mag x - mag y <= mag (x / y) <= mag x - mag y + 1)%Z.","conclusion":"(mag x - mag y <= mag (x / y) <= mag x - mag y + 1)%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R)","proofString":"destruct (mag x) as (ex,Hex).\ndestruct (mag y) as (ey,Hey).\nsimpl.\nunfold Rdiv.\nassert (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R).\nrewrite Rabs_Rinv by easy.\nsplit.\nrewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey.\nreplace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey.\nsplit.\napply mag_ge_bpow.\nreplace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy.\napply mag_le_bpow.\napply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat.\nreplace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Build_mag_prop x ex Hex - mag y <= mag (x / y) <=\n Build_mag_prop x ex Hex - mag y + 1)%Z.","conclusion":"(Build_mag_prop x ex Hex - mag y <= mag (x / y) <=\n Build_mag_prop x ex Hex - mag y + 1)%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R)","proofString":"destruct (mag y) as (ey,Hey).\nsimpl.\nunfold Rdiv.\nassert (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R).\nrewrite Rabs_Rinv by easy.\nsplit.\nrewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey.\nreplace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey.\nsplit.\napply mag_ge_bpow.\nreplace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy.\napply mag_le_bpow.\napply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat.\nreplace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (Build_mag_prop x ex Hex - Build_mag_prop y ey Hey <= \n mag (x / y) <= Build_mag_prop x ex Hex - Build_mag_prop y ey Hey + 1)%Z.","conclusion":"(Build_mag_prop x ex Hex - Build_mag_prop y ey Hey <= \n mag (x / y) <= Build_mag_prop x ex Hex - Build_mag_prop y ey Hey + 1)%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"simpl.\nunfold Rdiv.\nassert (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R).\nrewrite Rabs_Rinv by easy.\nsplit.\nrewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey.\nreplace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey.\nsplit.\napply mag_ge_bpow.\nreplace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy.\napply mag_le_bpow.\napply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat.\nreplace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (ex - ey <= mag (x / y) <= ex - ey + 1)%Z.","conclusion":"(ex - ey <= mag (x / y) <= ex - ey + 1)%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"unfold Rdiv.\nassert (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R).\nrewrite Rabs_Rinv by easy.\nsplit.\nrewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey.\nreplace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey.\nsplit.\napply mag_ge_bpow.\nreplace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy.\napply mag_le_bpow.\napply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat.\nreplace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (ex - ey <= mag (x * / y) <= ex - ey + 1)%Z.","conclusion":"(ex - ey <= mag (x * / y) <= ex - ey + 1)%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"assert (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R).\nrewrite Rabs_Rinv by easy.\nsplit.\nrewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey.\nreplace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey.\nsplit.\napply mag_ge_bpow.\nreplace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy.\napply mag_le_bpow.\napply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat.\nreplace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R.","conclusion":"(bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"rewrite Rabs_Rinv by easy.\nsplit.\nrewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey.\nreplace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (bpow (- ey) < / Rabs y <= bpow (- ey + 1))%R.","conclusion":"(bpow (- ey) < / Rabs y <= bpow (- ey + 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"split.\nrewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey.\nreplace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (bpow (- ey) < / Rabs y)%R.","conclusion":"(bpow (- ey) < / Rabs y)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"rewrite bpow_opp.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (/ bpow ey < / Rabs y)%R.","conclusion":"(/ bpow ey < / Rabs y)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"apply Rinv_lt_contravar.\napply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0.\nnow apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (0 < Rabs y * bpow ey)%R.","conclusion":"(0 < Rabs y * bpow ey)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"apply Rmult_lt_0_compat.\nnow apply Rabs_pos_lt.\nnow apply bpow_gt_0."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (0 < Rabs y)%R.","conclusion":"(0 < Rabs y)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"now apply Rabs_pos_lt."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (0 < bpow ey)%R.","conclusion":"(0 < bpow ey)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"now apply bpow_gt_0."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (Rabs y < bpow ey)%R.","conclusion":"(Rabs y < bpow ey)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"now apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (/ Rabs y <= bpow (- ey + 1))%R.","conclusion":"(/ Rabs y <= bpow (- ey + 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"replace (_ + _)%Z with (- (ey - 1))%Z by ring.\nrewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (/ Rabs y <= bpow (- (ey - 1)))%R.","conclusion":"(/ Rabs y <= bpow (- (ey - 1)))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"rewrite bpow_opp.\napply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (/ Rabs y <= / bpow (ey - 1))%R.","conclusion":"(/ Rabs y <= / bpow (ey - 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"apply Rinv_le; [now apply bpow_gt_0|].\nnow apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : (bpow (ey - 1) <= Rabs y)%R.","conclusion":"(bpow (ey - 1) <= Rabs y)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R)","proofString":"now apply Hey."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (ex - ey <= mag (x * / y) <= ex - ey + 1)%Z.","conclusion":"(ex - ey <= mag (x * / y) <= ex - ey + 1)%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"split.\napply mag_ge_bpow.\nreplace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy.\napply mag_le_bpow.\napply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat.\nreplace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (ex - ey <= mag (x * / y))%Z.","conclusion":"(ex - ey <= mag (x * / y))%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply mag_ge_bpow.\nreplace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (bpow (ex - ey - 1) <= Rabs (x * / y))%R.","conclusion":"(bpow (ex - ey - 1) <= Rabs (x * / y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"replace (_ - _)%Z with (ex - 1 - ey)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (bpow (ex - 1 - ey) <= Rabs (x * / y))%R.","conclusion":"(bpow (ex - 1 - ey) <= Rabs (x * / y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"unfold Zminus at 1; rewrite bpow_plus.\nrewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (bpow (ex - 1) * bpow (- ey) <= Rabs (x * / y))%R.","conclusion":"(bpow (ex - 1) * bpow (- ey) <= Rabs (x * / y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"rewrite Rabs_mult.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (bpow (ex - 1) * bpow (- ey) <= Rabs x * Rabs (/ y))%R.","conclusion":"(bpow (ex - 1) * bpow (- ey) <= Rabs x * Rabs (/ y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nnow apply Hex.\nnow apply Rlt_le; apply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (0 <= bpow (ex - 1))%R.","conclusion":"(0 <= bpow (ex - 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"now apply bpow_ge_0."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (0 <= bpow (- ey))%R.","conclusion":"(0 <= bpow (- ey))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"now apply bpow_ge_0."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (bpow (ex - 1) <= Rabs x)%R.","conclusion":"(bpow (ex - 1) <= Rabs x)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"now apply Hex."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (bpow (- ey) <= Rabs (/ y))%R.","conclusion":"(bpow (- ey) <= Rabs (/ y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"now apply Rlt_le; apply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (mag (x * / y) <= ex - ey + 1)%Z.","conclusion":"(mag (x * / y) <= ex - ey + 1)%Z","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply mag_le_bpow.\napply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat.\nreplace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (x * / y)%R <> 0%R.","conclusion":"(x * / y)%R <> 0%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply Rmult_integral_contrapositive_currified.\nexact Px.\nnow apply Rinv_neq_0_compat."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : x <> 0%R.","conclusion":"x <> 0%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"exact Px."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (/ y)%R <> 0%R.","conclusion":"(/ y)%R <> 0%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"now apply Rinv_neq_0_compat."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (Rabs (x * / y) < bpow (ex - ey + 1))%R.","conclusion":"(Rabs (x * / y) < bpow (ex - ey + 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"replace (_ + 1)%Z with (ex + (- ey + 1))%Z by ring.\nrewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (Rabs (x * / y) < bpow (ex + (- ey + 1)))%R.","conclusion":"(Rabs (x * / y) < bpow (ex + (- ey + 1)))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"rewrite bpow_plus.\napply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (Rabs (x * / y) < bpow ex * bpow (- ey + 1))%R.","conclusion":"(Rabs (x * / y) < bpow ex * bpow (- ey + 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply Rlt_le_trans with (bpow ex * Rabs (/ y))%R.\nrewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (Rabs (x * / y) < bpow ex * Rabs (/ y))%R.","conclusion":"(Rabs (x * / y) < bpow ex * Rabs (/ y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"rewrite Rabs_mult.\napply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (Rabs x * Rabs (/ y) < bpow ex * Rabs (/ y))%R.","conclusion":"(Rabs x * Rabs (/ y) < bpow ex * Rabs (/ y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply Rmult_lt_compat_r.\napply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat.\nnow apply Hex."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (0 < Rabs (/ y))%R.","conclusion":"(0 < Rabs (/ y))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply Rabs_pos_lt.\nnow apply Rinv_neq_0_compat."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (/ y)%R <> 0%R.","conclusion":"(/ y)%R <> 0%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"now apply Rinv_neq_0_compat."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (Rabs x < bpow ex)%R.","conclusion":"(Rabs x < bpow ex)%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"now apply Hex."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (bpow ex * Rabs (/ y) <= bpow ex * bpow (- ey + 1))%R.","conclusion":"(bpow ex * Rabs (/ y) <= bpow ex * bpow (- ey + 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply Rmult_le_compat_l; [now apply bpow_ge_0|].\napply Heiy."},{"statement":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R) : (Rabs (/ y) <= bpow (- ey + 1))%R.","conclusion":"(Rabs (/ y) <= bpow (- ey + 1))%R","hypotheses":"(x y : R) (Px : x <> 0%R) (Py : y <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Heiy : (bpow (- ey) < Rabs (/ y) <= bpow (- ey + 1))%R)","proofString":"apply Heiy."},{"statement":"(x : R) (Px : (0 < x)%R) : (bpow (Z.div2 (mag x + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (mag x + 1)))%R.","conclusion":"(bpow (Z.div2 (mag x + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (mag x + 1)))%R","hypotheses":"(x : R) (Px : (0 < x)%R)","proofString":"destruct mag as [e He].\nsimpl.\nspecialize (He (Rgt_not_eq _ _ Px)).\nrewrite Rabs_pos_eq in He by now apply Rlt_le.\nsplit.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_le_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rle_trans with (2 := proj1 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_lt_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : (bpow (Z.div2 (Build_mag_prop x e He + 1) - 1) <= \n Rabs (sqrt x) < bpow (Z.div2 (Build_mag_prop x e He + 1)))%R.","conclusion":"(bpow (Z.div2 (Build_mag_prop x e He + 1) - 1) <= \n Rabs (sqrt x) < bpow (Z.div2 (Build_mag_prop x e He + 1)))%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R)","proofString":"simpl.\nspecialize (He (Rgt_not_eq _ _ Px)).\nrewrite Rabs_pos_eq in He by now apply Rlt_le.\nsplit.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_le_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rle_trans with (2 := proj1 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_lt_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : (bpow (Z.div2 (e + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (e + 1)))%R.","conclusion":"(bpow (Z.div2 (e + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (e + 1)))%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R)","proofString":"specialize (He (Rgt_not_eq _ _ Px)).\nrewrite Rabs_pos_eq in He by now apply Rlt_le.\nsplit.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_le_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rle_trans with (2 := proj1 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_lt_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) : (bpow (Z.div2 (e + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (e + 1)))%R.","conclusion":"(bpow (Z.div2 (e + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (e + 1)))%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R)","proofString":"rewrite Rabs_pos_eq in He by now apply Rlt_le.\nsplit.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_le_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rle_trans with (2 := proj1 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_lt_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : (bpow (Z.div2 (e + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (e + 1)))%R.","conclusion":"(bpow (Z.div2 (e + 1) - 1) <= Rabs (sqrt x) < bpow (Z.div2 (e + 1)))%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"split.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_le_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rle_trans with (2 := proj1 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia.\nrewrite <- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0.\napply Rsqr_lt_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : (Rabs (sqrt x) < Rabs (bpow (Z.div2 (e + 1))))%R.","conclusion":"(Rabs (sqrt x) < Rabs (bpow (Z.div2 (e + 1))))%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"apply Rsqr_lt_abs_0.\nrewrite Rsqr_sqrt by now apply Rlt_le.\napply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : ((sqrt x)² < (bpow (Z.div2 (e + 1)))²)%R.","conclusion":"((sqrt x)² < (bpow (Z.div2 (e + 1)))²)%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"rewrite Rsqr_sqrt by now apply Rlt_le.\napply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : (x < (bpow (Z.div2 (e + 1)))²)%R.","conclusion":"(x < (bpow (Z.div2 (e + 1)))²)%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"apply Rlt_le_trans with (1 := proj2 He).\nunfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : (bpow e <= (bpow (Z.div2 (e + 1)))²)%R.","conclusion":"(bpow e <= (bpow (Z.div2 (e + 1)))²)%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"unfold Rsqr ; rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : (bpow e <= bpow (Z.div2 (e + 1) + Z.div2 (e + 1)))%R.","conclusion":"(bpow e <= bpow (Z.div2 (e + 1) + Z.div2 (e + 1)))%R","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"apply bpow_le.\ngeneralize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : (e <= Z.div2 (e + 1) + Z.div2 (e + 1))%Z.","conclusion":"(e <= Z.div2 (e + 1) + Z.div2 (e + 1))%Z","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"generalize (Zdiv2_odd_eqn (e + 1)).\ndestruct Z.odd ; intros ; lia."},{"statement":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R) : (e + 1)%Z = (2 * Z.div2 (e + 1) + (if Z.odd (e + 1) then 1 else 0))%Z ->\n(e <= Z.div2 (e + 1) + Z.div2 (e + 1))%Z.","conclusion":"(e + 1)%Z = (2 * Z.div2 (e + 1) + (if Z.odd (e + 1) then 1 else 0))%Z ->\n(e <= Z.div2 (e + 1) + Z.div2 (e + 1))%Z","hypotheses":"(x : R) (Px : (0 < x)%R) (e : Z) (He : (bpow (e - 1) <= x < bpow e)%R)","proofString":"destruct Z.odd ; intros ; lia."},{"statement":"(1 < r)%Z.","conclusion":"(1 < r)%Z","hypotheses":"","proofString":"assert (H := Zle_bool_imp_le _ _ (radix_prop r)); revert H.\nnow apply Z.lt_le_trans."},{"statement":"(2 <= r)%Z -> (1 < r)%Z.","conclusion":"(2 <= r)%Z -> (1 < r)%Z","hypotheses":"","proofString":"now apply Z.lt_le_trans."},{"statement":"(m : Z) : IZR (SpecFloat.cond_Zopp true m) = cond_Ropp true (IZR m).","conclusion":"IZR (SpecFloat.cond_Zopp true m) = cond_Ropp true (IZR m)","hypotheses":"(m : Z)","proofString":"apply opp_IZR."},{"statement":"(m : Z) : IZR (SpecFloat.cond_Zopp false m) = cond_Ropp false (IZR m).","conclusion":"IZR (SpecFloat.cond_Zopp false m) = cond_Ropp false (IZR m)","hypotheses":"(m : Z)","proofString":"apply refl_equal."},{"statement":"(m : R) : Rabs (cond_Ropp true m) = Rabs m.","conclusion":"Rabs (cond_Ropp true m) = Rabs m","hypotheses":"(m : R)","proofString":"apply Rabs_Ropp."},{"statement":"(m : R) : Rabs (cond_Ropp false m) = Rabs m.","conclusion":"Rabs (cond_Ropp false m) = Rabs m","hypotheses":"(m : R)","proofString":"apply refl_equal."},{"statement":"(m : R) : cond_Ropp (Rlt_bool m 0) m = Rabs m.","conclusion":"cond_Ropp (Rlt_bool m 0) m = Rabs m","hypotheses":"(m : R)","proofString":"apply sym_eq.\ncase Rlt_bool_spec ; intros Hm.\nnow apply Rabs_left.\nnow apply Rabs_pos_eq."},{"statement":"(m : R) : Rabs m = cond_Ropp (Rlt_bool m 0) m.","conclusion":"Rabs m = cond_Ropp (Rlt_bool m 0) m","hypotheses":"(m : R)","proofString":"case Rlt_bool_spec ; intros Hm.\nnow apply Rabs_left.\nnow apply Rabs_pos_eq."},{"statement":"(m : R) (Hm : (m < 0)%R) : Rabs m = cond_Ropp true m.","conclusion":"Rabs m = cond_Ropp true m","hypotheses":"(m : R) (Hm : (m < 0)%R)","proofString":"now apply Rabs_left."},{"statement":"(m : R) (Hm : (0 <= m)%R) : Rabs m = cond_Ropp false m.","conclusion":"Rabs m = cond_Ropp false m","hypotheses":"(m : R) (Hm : (0 <= m)%R)","proofString":"now apply Rabs_pos_eq."},{"statement":"(x : R) (sx : bool) (Hx : (0 < x)%R) : Rlt_bool (cond_Ropp sx x) 0 = sx.","conclusion":"Rlt_bool (cond_Ropp sx x) 0 = sx","hypotheses":"(x : R) (sx : bool) (Hx : (0 < x)%R)","proofString":"destruct sx; simpl.\napply Rlt_bool_true.\nnow apply Ropp_lt_gt_0_contravar.\napply Rlt_bool_false.\nnow left."},{"statement":"(x : R) (Hx : (0 < x)%R) : Rlt_bool (- x) 0 = true.","conclusion":"Rlt_bool (- x) 0 = true","hypotheses":"(x : R) (Hx : (0 < x)%R)","proofString":"apply Rlt_bool_true.\nnow apply Ropp_lt_gt_0_contravar."},{"statement":"(x : R) (Hx : (0 < x)%R) : (- x < 0)%R.","conclusion":"(- x < 0)%R","hypotheses":"(x : R) (Hx : (0 < x)%R)","proofString":"now apply Ropp_lt_gt_0_contravar."},{"statement":"(x : R) (Hx : (0 < x)%R) : Rlt_bool x 0 = false.","conclusion":"Rlt_bool x 0 = false","hypotheses":"(x : R) (Hx : (0 < x)%R)","proofString":"apply Rlt_bool_false.\nnow left."},{"statement":"(x : R) (Hx : (0 < x)%R) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(x : R) (Hx : (0 < x)%R)","proofString":"now left."},{"statement":"(x : R) : cond_Ropp true (cond_Ropp true x) = x.","conclusion":"cond_Ropp true (cond_Ropp true x) = x","hypotheses":"(x : R)","proofString":"apply Ropp_involutive."},{"statement":"(x : R) : cond_Ropp false (cond_Ropp false x) = x.","conclusion":"cond_Ropp false (cond_Ropp false x) = x","hypotheses":"(x : R)","proofString":"apply refl_equal."},{"statement":"(b : bool) (x y : R) (H : cond_Ropp b x = cond_Ropp b y) : x = y.","conclusion":"x = y","hypotheses":"(b : bool) (x y : R) (H : cond_Ropp b x = cond_Ropp b y)","proofString":"rewrite <- (cond_Ropp_involutive b x), H.\napply cond_Ropp_involutive."},{"statement":"(b : bool) (x y : R) (H : cond_Ropp b x = cond_Ropp b y) : cond_Ropp b (cond_Ropp b y) = y.","conclusion":"cond_Ropp b (cond_Ropp b y) = y","hypotheses":"(b : bool) (x y : R) (H : cond_Ropp b x = cond_Ropp b y)","proofString":"apply cond_Ropp_involutive."},{"statement":"(x y : R) : cond_Ropp true (x * y) = (cond_Ropp true x * y)%R.","conclusion":"cond_Ropp true (x * y) = (cond_Ropp true x * y)%R","hypotheses":"(x y : R)","proofString":"apply sym_eq.\napply Ropp_mult_distr_l_reverse."},{"statement":"(x y : R) : (cond_Ropp true x * y)%R = cond_Ropp true (x * y).","conclusion":"(cond_Ropp true x * y)%R = cond_Ropp true (x * y)","hypotheses":"(x y : R)","proofString":"apply Ropp_mult_distr_l_reverse."},{"statement":"(x y : R) : cond_Ropp false (x * y) = (cond_Ropp false x * y)%R.","conclusion":"cond_Ropp false (x * y) = (cond_Ropp false x * y)%R","hypotheses":"(x y : R)","proofString":"apply refl_equal."},{"statement":"(x y : R) : cond_Ropp true (x * y) = (x * cond_Ropp true y)%R.","conclusion":"cond_Ropp true (x * y) = (x * cond_Ropp true y)%R","hypotheses":"(x y : R)","proofString":"apply sym_eq.\napply Ropp_mult_distr_r_reverse."},{"statement":"(x y : R) : (x * cond_Ropp true y)%R = cond_Ropp true (x * y).","conclusion":"(x * cond_Ropp true y)%R = cond_Ropp true (x * y)","hypotheses":"(x y : R)","proofString":"apply Ropp_mult_distr_r_reverse."},{"statement":"(x y : R) : cond_Ropp false (x * y) = (x * cond_Ropp false y)%R.","conclusion":"cond_Ropp false (x * y) = (x * cond_Ropp false y)%R","hypotheses":"(x y : R)","proofString":"apply refl_equal."},{"statement":"(x y : R) : cond_Ropp true (x + y) = (cond_Ropp true x + cond_Ropp true y)%R.","conclusion":"cond_Ropp true (x + y) = (cond_Ropp true x + cond_Ropp true y)%R","hypotheses":"(x y : R)","proofString":"apply Ropp_plus_distr."},{"statement":"(x y : R) : cond_Ropp false (x + y) = (cond_Ropp false x + cond_Ropp false y)%R.","conclusion":"cond_Ropp false (x + y) = (cond_Ropp false x + cond_Ropp false y)%R","hypotheses":"(x y : R)","proofString":"apply refl_equal."},{"statement":"forall n : nat, (0 < INR n + 1)%R.","conclusion":"forall n : nat, (0 < INR n + 1)%R","hypotheses":"","proofString":"intros N.\nrewrite <- S_INR.\napply lt_0_INR.\napply Nat.lt_0_succ."},{"statement":"(N : nat) : (0 < INR N + 1)%R.","conclusion":"(0 < INR N + 1)%R","hypotheses":"(N : nat)","proofString":"rewrite <- S_INR.\napply lt_0_INR.\napply Nat.lt_0_succ."},{"statement":"(N : nat) : (0 < INR (S N))%R.","conclusion":"(0 < INR (S N))%R","hypotheses":"(N : nat)","proofString":"apply lt_0_INR.\napply Nat.lt_0_succ."},{"statement":"(N : nat) : 0 < S N.","conclusion":"0 < S N","hypotheses":"(N : nat)","proofString":"apply Nat.lt_0_succ."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) : forall P : nat -> Prop,\n(forall n : nat, P n \\/ ~ P n) ->\n{n : nat | P n /\\ (forall i : nat, i < n -> ~ P i)} + {forall n : nat, ~ P n}.","conclusion":"forall P : nat -> Prop,\n(forall n : nat, P n \\/ ~ P n) ->\n{n : nat | P n /\\ (forall i : nat, i < n -> ~ P i)} + {forall n : nat, ~ P n}","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R)","proofString":"intros P HP.\nset (E y := exists n, (P n /\\ y = / (INR n + 1))%R \\/ (~ P n /\\ y = 0)%R).\nassert (HE: forall n, P n -> E (/ (INR n + 1))%R).\nintros n Pn.\nexists n.\nleft.\nnow split.\nassert (BE: is_upper_bound E 1).\nintros x [y [[_ ->]|[_ ->]]].\nrewrite <- Rinv_1 at 2.\napply Rinv_le.\nexact Rlt_0_1.\nrewrite <- S_INR.\napply (le_INR 1), le_n_S, le_0_n.\nexact Rle_0_1.\ndestruct (completeness E) as [l [ub lub]].\nnow exists 1%R.\ndestruct (HP O) as [H0|H0].\nexists 1%R.\nexists O.\nleft.\napply (conj H0).\nrewrite Rplus_0_l.\napply sym_eq, Rinv_1.\nexists 0%R.\nexists O.\nright.\nnow split.\ndestruct (Rle_lt_dec l 0) as [Hl|Hl].\nright.\nintros n Pn.\napply Rle_not_lt with (1 := Hl).\napply Rlt_le_trans with (/ (INR n + 1))%R.\nnow apply Rinv_0_lt_compat.\napply ub.\nnow apply HE.\nleft.\nset (N := Z.abs_nat (up (/l) - 2)).\nexists N.\nassert (HN: (INR N + 1 = IZR (up (/ l)) - 1)%R).\nunfold N.\nrewrite INR_IZR_INZ.\nrewrite inj_Zabs_nat.\nreplace (IZR (up (/ l)) - 1)%R with (IZR (up (/ l) - 2) + 1)%R.\napply (f_equal (fun v => IZR v + 1)%R).\napply Z.abs_eq.\napply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed.\nrewrite minus_IZR.\nsimpl.\nring.\nassert (H: forall i, (i < N)%nat -> ~ P i).\nintros i HiN Pi.\nunfold is_upper_bound in ub.\nrefine (Rle_not_lt _ _ (ub (/ (INR i + 1))%R _) _).\nnow apply HE.\nrewrite <- (Rinv_involutive l) by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n.\napply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed.\ndestruct (HP N) as [PN|PN].\nnow split.\nexfalso.\nrefine (Rle_not_lt _ _ (lub (/ (INR (S N) + 1))%R _) _).\nintros x [y [[Py ->]|[_ ->]]].\ndestruct (eq_nat_dec y N) as [HyN|HyN].\nelim PN.\nnow rewrite <- HyN.\napply Rinv_le.\napply Hi.\napply Rplus_le_compat_r.\napply Rnot_lt_le.\nintros Hy.\nrefine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia.\nnow apply Rlt_le, Rinv_0_lt_compat.\nrewrite S_INR, HN.\nring_simplify (IZR (up (/ l)) - 1 + 1)%R.\nrewrite <- (Rinv_involutive l) at 2 by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- Rinv_1.\napply Rinv_le.\nexact Hl.\nnow apply lub.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) : {n : nat | P n /\\ (forall i : nat, i < n -> ~ P i)} + {forall n : nat, ~ P n}.","conclusion":"{n : nat | P n /\\ (forall i : nat, i < n -> ~ P i)} + {forall n : nat, ~ P n}","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n)","proofString":"set (E y := exists n, (P n /\\ y = / (INR n + 1))%R \\/ (~ P n /\\ y = 0)%R).\nassert (HE: forall n, P n -> E (/ (INR n + 1))%R).\nintros n Pn.\nexists n.\nleft.\nnow split.\nassert (BE: is_upper_bound E 1).\nintros x [y [[_ ->]|[_ ->]]].\nrewrite <- Rinv_1 at 2.\napply Rinv_le.\nexact Rlt_0_1.\nrewrite <- S_INR.\napply (le_INR 1), le_n_S, le_0_n.\nexact Rle_0_1.\ndestruct (completeness E) as [l [ub lub]].\nnow exists 1%R.\ndestruct (HP O) as [H0|H0].\nexists 1%R.\nexists O.\nleft.\napply (conj H0).\nrewrite Rplus_0_l.\napply sym_eq, Rinv_1.\nexists 0%R.\nexists O.\nright.\nnow split.\ndestruct (Rle_lt_dec l 0) as [Hl|Hl].\nright.\nintros n Pn.\napply Rle_not_lt with (1 := Hl).\napply Rlt_le_trans with (/ (INR n + 1))%R.\nnow apply Rinv_0_lt_compat.\napply ub.\nnow apply HE.\nleft.\nset (N := Z.abs_nat (up (/l) - 2)).\nexists N.\nassert (HN: (INR N + 1 = IZR (up (/ l)) - 1)%R).\nunfold N.\nrewrite INR_IZR_INZ.\nrewrite inj_Zabs_nat.\nreplace (IZR (up (/ l)) - 1)%R with (IZR (up (/ l) - 2) + 1)%R.\napply (f_equal (fun v => IZR v + 1)%R).\napply Z.abs_eq.\napply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed.\nrewrite minus_IZR.\nsimpl.\nring.\nassert (H: forall i, (i < N)%nat -> ~ P i).\nintros i HiN Pi.\nunfold is_upper_bound in ub.\nrefine (Rle_not_lt _ _ (ub (/ (INR i + 1))%R _) _).\nnow apply HE.\nrewrite <- (Rinv_involutive l) by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n.\napply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed.\ndestruct (HP N) as [PN|PN].\nnow split.\nexfalso.\nrefine (Rle_not_lt _ _ (lub (/ (INR (S N) + 1))%R _) _).\nintros x [y [[Py ->]|[_ ->]]].\ndestruct (eq_nat_dec y N) as [HyN|HyN].\nelim PN.\nnow rewrite <- HyN.\napply Rinv_le.\napply Hi.\napply Rplus_le_compat_r.\napply Rnot_lt_le.\nintros Hy.\nrefine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia.\nnow apply Rlt_le, Rinv_0_lt_compat.\nrewrite S_INR, HN.\nring_simplify (IZR (up (/ l)) - 1 + 1)%R.\nrewrite <- (Rinv_involutive l) at 2 by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- Rinv_1.\napply Rinv_le.\nexact Hl.\nnow apply lub.\napply archimed."},{"statement":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (n : nat) (Pn : P n) : P n /\\ (/ (INR n + 1))%R = (/ (INR n + 1))%R \\/\n~ P n /\\ (/ (INR n + 1))%R = 0%R.","conclusion":"P n /\\ (/ (INR n + 1))%R = (/ (INR n + 1))%R \\/\n~ P n /\\ (/ (INR n + 1))%R = 0%R","hypotheses":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (n : nat) (Pn : P n)","proofString":"left.\nnow split."},{"statement":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (n : nat) (Pn : P n) : P n /\\ (/ (INR n + 1))%R = (/ (INR n + 1))%R.","conclusion":"P n /\\ (/ (INR n + 1))%R = (/ (INR n + 1))%R","hypotheses":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (n : nat) (Pn : P n)","proofString":"now split."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat) : (/ (INR y + 1) <= 1)%R.","conclusion":"(/ (INR y + 1) <= 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat)","proofString":"rewrite <- Rinv_1 at 2.\napply Rinv_le.\nexact Rlt_0_1.\nrewrite <- S_INR.\napply (le_INR 1), le_n_S, le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat) : (/ (INR y + 1) <= / 1)%R.","conclusion":"(/ (INR y + 1) <= / 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat)","proofString":"apply Rinv_le.\nexact Rlt_0_1.\nrewrite <- S_INR.\napply (le_INR 1), le_n_S, le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat) : (0 < 1)%R.","conclusion":"(0 < 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat)","proofString":"exact Rlt_0_1."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat) : (1 <= INR y + 1)%R.","conclusion":"(1 <= INR y + 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat)","proofString":"rewrite <- S_INR.\napply (le_INR 1), le_n_S, le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat) : (1 <= INR (S y))%R.","conclusion":"(1 <= INR (S y))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat)","proofString":"apply (le_INR 1), le_n_S, le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat) : (0 <= 1)%R.","conclusion":"(0 <= 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (y : nat)","proofString":"exact Rle_0_1."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) : bound E.","conclusion":"bound E","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1)","proofString":"now exists 1%R."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0) : P 0 /\\ 1%R = (/ (INR 0 + 1))%R \\/ ~ P 0 /\\ 1%R = 0%R.","conclusion":"P 0 /\\ 1%R = (/ (INR 0 + 1))%R \\/ ~ P 0 /\\ 1%R = 0%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0)","proofString":"left.\napply (conj H0).\nrewrite Rplus_0_l.\napply sym_eq, Rinv_1."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0) : P 0 /\\ 1%R = (/ (INR 0 + 1))%R.","conclusion":"P 0 /\\ 1%R = (/ (INR 0 + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0)","proofString":"apply (conj H0).\nrewrite Rplus_0_l.\napply sym_eq, Rinv_1."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0) : 1%R = (/ (INR 0 + 1))%R.","conclusion":"1%R = (/ (INR 0 + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0)","proofString":"rewrite Rplus_0_l.\napply sym_eq, Rinv_1."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0) : 1%R = (/ 1)%R.","conclusion":"1%R = (/ 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : P 0)","proofString":"apply sym_eq, Rinv_1."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : ~ P 0) : P 0 /\\ 0%R = (/ (INR 0 + 1))%R \\/ ~ P 0 /\\ 0%R = 0%R.","conclusion":"P 0 /\\ 0%R = (/ (INR 0 + 1))%R \\/ ~ P 0 /\\ 0%R = 0%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : ~ P 0)","proofString":"right.\nnow split."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : ~ P 0) : ~ P 0 /\\ 0%R = 0%R.","conclusion":"~ P 0 /\\ 0%R = 0%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (H0 : ~ P 0)","proofString":"now split."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) : {n : nat | P n /\\ (forall i : nat, i < n -> ~ P i)} + {forall n : nat, ~ P n}.","conclusion":"{n : nat | P n /\\ (forall i : nat, i < n -> ~ P i)} + {forall n : nat, ~ P n}","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R)","proofString":"right.\nintros n Pn.\napply Rle_not_lt with (1 := Hl).\napply Rlt_le_trans with (/ (INR n + 1))%R.\nnow apply Rinv_0_lt_compat.\napply ub.\nnow apply HE."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) : forall n : nat, ~ P n.","conclusion":"forall n : nat, ~ P n","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R)","proofString":"intros n Pn.\napply Rle_not_lt with (1 := Hl).\napply Rlt_le_trans with (/ (INR n + 1))%R.\nnow apply Rinv_0_lt_compat.\napply ub.\nnow apply HE."},{"statement":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n) : False.","conclusion":"False","hypotheses":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n)","proofString":"apply Rle_not_lt with (1 := Hl).\napply Rlt_le_trans with (/ (INR n + 1))%R.\nnow apply Rinv_0_lt_compat.\napply ub.\nnow apply HE."},{"statement":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n) : (0 < l)%R.","conclusion":"(0 < l)%R","hypotheses":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n)","proofString":"apply Rlt_le_trans with (/ (INR n + 1))%R.\nnow apply Rinv_0_lt_compat.\napply ub.\nnow apply HE."},{"statement":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n) : (0 < / (INR n + 1))%R.","conclusion":"(0 < / (INR n + 1))%R","hypotheses":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n)","proofString":"now apply Rinv_0_lt_compat."},{"statement":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n) : (/ (INR n + 1) <= l)%R.","conclusion":"(/ (INR n + 1) <= l)%R","hypotheses":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n)","proofString":"apply ub.\nnow apply HE."},{"statement":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n) : E (/ (INR n + 1))%R.","conclusion":"E (/ (INR n + 1))%R","hypotheses":"(Hi : forall n0 : nat, (0 < INR n0 + 1)%R) (P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (E : R -> Prop) (HE : forall n0 : nat, P n0 -> E (/ (INR n0 + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (l <= 0)%R) (n : nat) (Pn : P n)","proofString":"now apply HE."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (INR (Z.abs_nat (up (/ l) - 2)) + 1)%R = (IZR (up (/ l)) - 1)%R.","conclusion":"(INR (Z.abs_nat (up (/ l) - 2)) + 1)%R = (IZR (up (/ l)) - 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"rewrite INR_IZR_INZ.\nrewrite inj_Zabs_nat.\nreplace (IZR (up (/ l)) - 1)%R with (IZR (up (/ l) - 2) + 1)%R.\napply (f_equal (fun v => IZR v + 1)%R).\napply Z.abs_eq.\napply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed.\nrewrite minus_IZR.\nsimpl.\nring."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (IZR (Z.of_nat (Z.abs_nat (up (/ l) - 2))) + 1)%R = (IZR (up (/ l)) - 1)%R.","conclusion":"(IZR (Z.of_nat (Z.abs_nat (up (/ l) - 2))) + 1)%R = (IZR (up (/ l)) - 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"rewrite inj_Zabs_nat.\nreplace (IZR (up (/ l)) - 1)%R with (IZR (up (/ l) - 2) + 1)%R.\napply (f_equal (fun v => IZR v + 1)%R).\napply Z.abs_eq.\napply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed.\nrewrite minus_IZR.\nsimpl.\nring."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (IZR (Z.abs (up (/ l) - 2)) + 1)%R = (IZR (up (/ l)) - 1)%R.","conclusion":"(IZR (Z.abs (up (/ l) - 2)) + 1)%R = (IZR (up (/ l)) - 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"replace (IZR (up (/ l)) - 1)%R with (IZR (up (/ l) - 2) + 1)%R.\napply (f_equal (fun v => IZR v + 1)%R).\napply Z.abs_eq.\napply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed.\nrewrite minus_IZR.\nsimpl.\nring."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (IZR (Z.abs (up (/ l) - 2)) + 1)%R = (IZR (up (/ l) - 2) + 1)%R.","conclusion":"(IZR (Z.abs (up (/ l) - 2)) + 1)%R = (IZR (up (/ l) - 2) + 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply (f_equal (fun v => IZR v + 1)%R).\napply Z.abs_eq.\napply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : Z.abs (up (/ l) - 2) = (up (/ l) - 2)%Z.","conclusion":"Z.abs (up (/ l) - 2) = (up (/ l) - 2)%Z","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply Z.abs_eq.\napply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (0 <= up (/ l) - 2)%Z.","conclusion":"(0 <= up (/ l) - 2)%Z","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply Zle_minus_le_0.\napply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (2 <= up (/ l))%Z.","conclusion":"(2 <= up (/ l))%Z","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply (Zlt_le_succ 1).\napply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (1 < up (/ l))%Z.","conclusion":"(1 < up (/ l))%Z","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply lt_IZR.\napply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (1 < IZR (up (/ l)))%R.","conclusion":"(1 < IZR (up (/ l)))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply Rle_lt_trans with (/l)%R.\napply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (1 <= / l)%R.","conclusion":"(1 <= / l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply Rmult_le_reg_r with (1 := Hl).\nrewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (1 * l <= / l * l)%R.","conclusion":"(1 * l <= / l * l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"rewrite Rmult_1_l, Rinv_l by now apply Rgt_not_eq.\napply lub.\nexact BE."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (l <= 1)%R.","conclusion":"(l <= 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply lub.\nexact BE."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : is_upper_bound E 1.","conclusion":"is_upper_bound E 1","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"exact BE."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (/ l < IZR (up (/ l)))%R.","conclusion":"(/ l < IZR (up (/ l)))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"apply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (IZR (up (/ l) - 2) + 1)%R = (IZR (up (/ l)) - 1)%R.","conclusion":"(IZR (up (/ l) - 2) + 1)%R = (IZR (up (/ l)) - 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"rewrite minus_IZR.\nsimpl.\nring."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (IZR (up (/ l)) - 2 + 1)%R = (IZR (up (/ l)) - 1)%R.","conclusion":"(IZR (up (/ l)) - 2 + 1)%R = (IZR (up (/ l)) - 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"simpl.\nring."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) : (IZR (up (/ l)) - 2 + 1)%R = (IZR (up (/ l)) - 1)%R.","conclusion":"(IZR (up (/ l)) - 2 + 1)%R = (IZR (up (/ l)) - 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat)","proofString":"ring."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) : forall i : nat, i < N -> ~ P i.","conclusion":"forall i : nat, i < N -> ~ P i","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R)","proofString":"intros i HiN Pi.\nunfold is_upper_bound in ub.\nrefine (Rle_not_lt _ _ (ub (/ (INR i + 1))%R _) _).\nnow apply HE.\nrewrite <- (Rinv_involutive l) by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n.\napply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : False.","conclusion":"False","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"unfold is_upper_bound in ub.\nrefine (Rle_not_lt _ _ (ub (/ (INR i + 1))%R _) _).\nnow apply HE.\nrewrite <- (Rinv_involutive l) by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n.\napply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : False.","conclusion":"False","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"refine (Rle_not_lt _ _ (ub (/ (INR i + 1))%R _) _).\nnow apply HE.\nrewrite <- (Rinv_involutive l) by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n.\napply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : E (/ (INR i + 1))%R.","conclusion":"E (/ (INR i + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"now apply HE."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (l < / (INR i + 1))%R.","conclusion":"(l < / (INR i + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"rewrite <- (Rinv_involutive l) by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n.\napply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (/ / l < / (INR i + 1))%R.","conclusion":"(/ / l < / (INR i + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply Rinv_1_lt_contravar.\nrewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n.\napply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (1 <= INR i + 1)%R.","conclusion":"(1 <= INR i + 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"rewrite <- S_INR.\napply (le_INR 1).\napply le_n_S.\napply le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (1 <= INR (S i))%R.","conclusion":"(1 <= INR (S i))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply (le_INR 1).\napply le_n_S.\napply le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : 1 <= S i.","conclusion":"1 <= S i","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply le_n_S.\napply le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : 0 <= i.","conclusion":"0 <= i","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply le_0_n."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (INR i + 1 < / l)%R.","conclusion":"(INR i + 1 < / l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply Rlt_le_trans with (INR N + 1)%R.\napply Rplus_lt_compat_r.\nnow apply lt_INR.\nrewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (INR i + 1 < INR N + 1)%R.","conclusion":"(INR i + 1 < INR N + 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply Rplus_lt_compat_r.\nnow apply lt_INR."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (INR i < INR N)%R.","conclusion":"(INR i < INR N)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"now apply lt_INR."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (INR N + 1 <= / l)%R.","conclusion":"(INR N + 1 <= / l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"rewrite HN.\napply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (IZR (up (/ l)) - 1 <= / l)%R.","conclusion":"(IZR (up (/ l)) - 1 <= / l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply Rplus_le_reg_r with (-/l + 1)%R.\nring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (IZR (up (/ l)) - 1 + (- / l + 1) <= / l + (- / l + 1))%R.","conclusion":"(IZR (up (/ l)) - 1 + (- / l + 1) <= / l + (- / l + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"ring_simplify.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i) : (IZR (up (/ l)) - / l <= 1)%R.","conclusion":"(IZR (up (/ l)) - / l <= 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : forall x : R, E x -> (x <= l)%R) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (i : nat) (HiN : i < N) (Pi : P i)","proofString":"apply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : P N) : P N /\\ (forall i : nat, i < N -> ~ P i).","conclusion":"P N /\\ (forall i : nat, i < N -> ~ P i)","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : P N)","proofString":"now split."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) : (/ (INR y + 1) <= / (INR (S N) + 1))%R.","conclusion":"(/ (INR y + 1) <= / (INR (S N) + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y)","proofString":"destruct (eq_nat_dec y N) as [HyN|HyN].\nelim PN.\nnow rewrite <- HyN.\napply Rinv_le.\napply Hi.\napply Rplus_le_compat_r.\napply Rnot_lt_le.\nintros Hy.\nrefine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y = N) : (/ (INR y + 1) <= / (INR (S N) + 1))%R.","conclusion":"(/ (INR y + 1) <= / (INR (S N) + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y = N)","proofString":"elim PN.\nnow rewrite <- HyN."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y = N) : P N.","conclusion":"P N","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y = N)","proofString":"now rewrite <- HyN."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) : (/ (INR y + 1) <= / (INR (S N) + 1))%R.","conclusion":"(/ (INR y + 1) <= / (INR (S N) + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N)","proofString":"apply Rinv_le.\napply Hi.\napply Rplus_le_compat_r.\napply Rnot_lt_le.\nintros Hy.\nrefine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) : (0 < INR (S N) + 1)%R.","conclusion":"(0 < INR (S N) + 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N)","proofString":"apply Hi."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) : (INR (S N) + 1 <= INR y + 1)%R.","conclusion":"(INR (S N) + 1 <= INR y + 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N)","proofString":"apply Rplus_le_compat_r.\napply Rnot_lt_le.\nintros Hy.\nrefine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) : (INR (S N) <= INR y)%R.","conclusion":"(INR (S N) <= INR y)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N)","proofString":"apply Rnot_lt_le.\nintros Hy.\nrefine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) : ~ (INR y < INR (S N))%R.","conclusion":"~ (INR y < INR (S N))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N)","proofString":"intros Hy.\nrefine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) (Hy : (INR y < INR (S N))%R) : False.","conclusion":"False","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) (Hy : (INR y < INR (S N))%R)","proofString":"refine (H _ _ Py).\napply INR_lt in Hy.\nclear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) (Hy : (INR y < INR (S N))%R) : y < N.","conclusion":"y < N","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) (Hy : (INR y < INR (S N))%R)","proofString":"apply INR_lt in Hy.\nclear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) (Hy : y < S N) : y < N.","conclusion":"y < N","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) (Py : P y) (HyN : y <> N) (Hy : y < S N)","proofString":"clear -Hy HyN ; lia."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat) : (0 <= / (INR (S N) + 1))%R.","conclusion":"(0 <= / (INR (S N) + 1))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) (y : nat)","proofString":"now apply Rlt_le, Rinv_0_lt_compat."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (/ (INR (S N) + 1) < l)%R.","conclusion":"(/ (INR (S N) + 1) < l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"rewrite S_INR, HN.\nring_simplify (IZR (up (/ l)) - 1 + 1)%R.\nrewrite <- (Rinv_involutive l) at 2 by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- Rinv_1.\napply Rinv_le.\nexact Hl.\nnow apply lub.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (/ (IZR (up (/ l)) - 1 + 1) < l)%R.","conclusion":"(/ (IZR (up (/ l)) - 1 + 1) < l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"ring_simplify (IZR (up (/ l)) - 1 + 1)%R.\nrewrite <- (Rinv_involutive l) at 2 by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- Rinv_1.\napply Rinv_le.\nexact Hl.\nnow apply lub.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (/ IZR (up (/ l)) < l)%R.","conclusion":"(/ IZR (up (/ l)) < l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"rewrite <- (Rinv_involutive l) at 2 by now apply Rgt_not_eq.\napply Rinv_1_lt_contravar.\nrewrite <- Rinv_1.\napply Rinv_le.\nexact Hl.\nnow apply lub.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (/ IZR (up (/ l)) < / / l)%R.","conclusion":"(/ IZR (up (/ l)) < / / l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"apply Rinv_1_lt_contravar.\nrewrite <- Rinv_1.\napply Rinv_le.\nexact Hl.\nnow apply lub.\napply archimed."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (1 <= / l)%R.","conclusion":"(1 <= / l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"rewrite <- Rinv_1.\napply Rinv_le.\nexact Hl.\nnow apply lub."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (/ 1 <= / l)%R.","conclusion":"(/ 1 <= / l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"apply Rinv_le.\nexact Hl.\nnow apply lub."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (0 < l)%R.","conclusion":"(0 < l)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"exact Hl."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (l <= 1)%R.","conclusion":"(l <= 1)%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"now apply lub."},{"statement":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N) : (/ l < IZR (up (/ l)))%R.","conclusion":"(/ l < IZR (up (/ l)))%R","hypotheses":"(Hi : forall n : nat, (0 < INR n + 1)%R) (P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (E : R -> Prop) (HE : forall n : nat, P n -> E (/ (INR n + 1))%R) (BE : is_upper_bound E 1) (l : R) (ub : is_upper_bound E l) (lub : forall b : R, is_upper_bound E b -> (l <= b)%R) (Hl : (0 < l)%R) (N : nat) (HN : (INR N + 1)%R = (IZR (up (/ l)) - 1)%R) (H : forall i : nat, i < N -> ~ P i) (PN : ~ P N)","proofString":"apply archimed."},{"statement":"(P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) : {n : nat | P n} + {forall n : nat, ~ P n}.","conclusion":"{n : nat | P n} + {forall n : nat, ~ P n}","hypotheses":"(P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n)","proofString":"destruct (LPO_min P HP) as [[n [Pn _]]|Pn].\nleft.\nnow exists n.\nnow right."},{"statement":"(P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (n : nat) (Pn : P n) : {n0 : nat | P n0} + {forall n0 : nat, ~ P n0}.","conclusion":"{n0 : nat | P n0} + {forall n0 : nat, ~ P n0}","hypotheses":"(P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (n : nat) (Pn : P n)","proofString":"left.\nnow exists n."},{"statement":"(P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (n : nat) (Pn : P n) : {n0 : nat | P n0}.","conclusion":"{n0 : nat | P n0}","hypotheses":"(P : nat -> Prop) (HP : forall n0 : nat, P n0 \\/ ~ P n0) (n : nat) (Pn : P n)","proofString":"now exists n."},{"statement":"(P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (Pn : forall n : nat, ~ P n) : {n : nat | P n} + {forall n : nat, ~ P n}.","conclusion":"{n : nat | P n} + {forall n : nat, ~ P n}","hypotheses":"(P : nat -> Prop) (HP : forall n : nat, P n \\/ ~ P n) (Pn : forall n : nat, ~ P n)","proofString":"now right."},{"statement":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) : {n : Z | P n} + {forall n : Z, ~ P n}.","conclusion":"{n : Z | P n} + {forall n : Z, ~ P n}","hypotheses":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n)","proofString":"destruct (LPO (fun n => P (Z.of_nat n))) as [J|J].\nintros n; apply H.\ndestruct J as (n, Hn).\nleft; now exists (Z.of_nat n).\ndestruct (LPO (fun n => P (-Z.of_nat n)%Z)) as [K|K].\nintros n; apply H.\ndestruct K as (n, Hn).\nleft; now exists (-Z.of_nat n)%Z.\nright; intros n; case (Zle_or_lt 0 n); intros M.\nrewrite <- (Z.abs_eq n); trivial.\nrewrite <- Zabs2Nat.id_abs.\napply J.\nrewrite <- (Z.opp_involutive n).\nrewrite <- (Z.abs_neq n).\nrewrite <- Zabs2Nat.id_abs.\napply K.\nlia."},{"statement":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) : forall n : nat, P (Z.of_nat n) \\/ ~ P (Z.of_nat n).","conclusion":"forall n : nat, P (Z.of_nat n) \\/ ~ P (Z.of_nat n)","hypotheses":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n)","proofString":"intros n; apply H."},{"statement":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : {n : nat | P (Z.of_nat n)}) : {n : Z | P n} + {forall n : Z, ~ P n}.","conclusion":"{n : Z | P n} + {forall n : Z, ~ P n}","hypotheses":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : {n : nat | P (Z.of_nat n)})","proofString":"destruct J as (n, Hn).\nleft; now exists (Z.of_nat n)."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (n : nat) (Hn : P (Z.of_nat n)) : {n0 : Z | P n0} + {forall n0 : Z, ~ P n0}.","conclusion":"{n0 : Z | P n0} + {forall n0 : Z, ~ P n0}","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (n : nat) (Hn : P (Z.of_nat n))","proofString":"left; now exists (Z.of_nat n)."},{"statement":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n)) : {n : Z | P n} + {forall n : Z, ~ P n}.","conclusion":"{n : Z | P n} + {forall n : Z, ~ P n}","hypotheses":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n))","proofString":"destruct (LPO (fun n => P (-Z.of_nat n)%Z)) as [K|K].\nintros n; apply H.\ndestruct K as (n, Hn).\nleft; now exists (-Z.of_nat n)%Z.\nright; intros n; case (Zle_or_lt 0 n); intros M.\nrewrite <- (Z.abs_eq n); trivial.\nrewrite <- Zabs2Nat.id_abs.\napply J.\nrewrite <- (Z.opp_involutive n).\nrewrite <- (Z.abs_neq n).\nrewrite <- Zabs2Nat.id_abs.\napply K.\nlia."},{"statement":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n)) : forall n : nat, P (- Z.of_nat n)%Z \\/ ~ P (- Z.of_nat n)%Z.","conclusion":"forall n : nat, P (- Z.of_nat n)%Z \\/ ~ P (- Z.of_nat n)%Z","hypotheses":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n))","proofString":"intros n; apply H."},{"statement":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n)) (K : {n : nat | P (- Z.of_nat n)%Z}) : {n : Z | P n} + {forall n : Z, ~ P n}.","conclusion":"{n : Z | P n} + {forall n : Z, ~ P n}","hypotheses":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n)) (K : {n : nat | P (- Z.of_nat n)%Z})","proofString":"destruct K as (n, Hn).\nleft; now exists (-Z.of_nat n)%Z."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (n : nat) (Hn : P (- Z.of_nat n)%Z) : {n0 : Z | P n0} + {forall n0 : Z, ~ P n0}.","conclusion":"{n0 : Z | P n0} + {forall n0 : Z, ~ P n0}","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (n : nat) (Hn : P (- Z.of_nat n)%Z)","proofString":"left; now exists (-Z.of_nat n)%Z."},{"statement":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n)) (K : forall n : nat, ~ P (- Z.of_nat n)%Z) : {n : Z | P n} + {forall n : Z, ~ P n}.","conclusion":"{n : Z | P n} + {forall n : Z, ~ P n}","hypotheses":"(P : Z -> Prop) (H : forall n : Z, P n \\/ ~ P n) (J : forall n : nat, ~ P (Z.of_nat n)) (K : forall n : nat, ~ P (- Z.of_nat n)%Z)","proofString":"right; intros n; case (Zle_or_lt 0 n); intros M.\nrewrite <- (Z.abs_eq n); trivial.\nrewrite <- Zabs2Nat.id_abs.\napply J.\nrewrite <- (Z.opp_involutive n).\nrewrite <- (Z.abs_neq n).\nrewrite <- Zabs2Nat.id_abs.\napply K.\nlia."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (0 <= n)%Z) : ~ P n.","conclusion":"~ P n","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (0 <= n)%Z)","proofString":"rewrite <- (Z.abs_eq n); trivial.\nrewrite <- Zabs2Nat.id_abs.\napply J."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (0 <= n)%Z) : ~ P (Z.abs n).","conclusion":"~ P (Z.abs n)","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (0 <= n)%Z)","proofString":"rewrite <- Zabs2Nat.id_abs.\napply J."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (0 <= n)%Z) : ~ P (Z.of_nat (Z.abs_nat n)).","conclusion":"~ P (Z.of_nat (Z.abs_nat n))","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (0 <= n)%Z)","proofString":"apply J."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z) : ~ P n.","conclusion":"~ P n","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z)","proofString":"rewrite <- (Z.opp_involutive n).\nrewrite <- (Z.abs_neq n).\nrewrite <- Zabs2Nat.id_abs.\napply K.\nlia."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z) : ~ P (- - n)%Z.","conclusion":"~ P (- - n)%Z","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z)","proofString":"rewrite <- (Z.abs_neq n).\nrewrite <- Zabs2Nat.id_abs.\napply K.\nlia."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z) : ~ P (- Z.abs n)%Z.","conclusion":"~ P (- Z.abs n)%Z","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z)","proofString":"rewrite <- Zabs2Nat.id_abs.\napply K."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z) : ~ P (- Z.of_nat (Z.abs_nat n))%Z.","conclusion":"~ P (- Z.of_nat (Z.abs_nat n))%Z","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z)","proofString":"apply K."},{"statement":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z) : (n <= 0)%Z.","conclusion":"(n <= 0)%Z","hypotheses":"(P : Z -> Prop) (H : forall n0 : Z, P n0 \\/ ~ P n0) (J : forall n0 : nat, ~ P (Z.of_nat n0)) (K : forall n0 : nat, ~ P (- Z.of_nat n0)%Z) (n : Z) (M : (n < 0)%Z)","proofString":"lia."}]}