{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/xmm_cons/ConsistencyCommon.v","fileSamples":[{"statement":"(WF : Wf G) (cons_coherence : irreflexive (hb ⨾ eco^?)) (cons_atomicity : rmw ∩ (fr ⨾ co) ≡ ∅₂) : irreflexive (hb ⨾ eco).","conclusion":"irreflexive (hb ⨾ eco)","hypotheses":"(WF : Wf G) (cons_coherence : irreflexive (hb ⨾ eco^?)) (cons_atomicity : rmw ∩ (fr ⨾ co) ≡ ∅₂)","proofString":"apply irreflexive_inclusion   with (r' := hb ⨾ eco^?); eauto.\napply inclusion_seq_mon; basic_solver."},{"statement":"(WF : Wf G) (cons_coherence : irreflexive (hb ⨾ eco^?)) (cons_atomicity : rmw ∩ (fr ⨾ co) ≡ ∅₂) : hb ⨾ eco ⊆ hb ⨾ eco^?.","conclusion":"hb ⨾ eco ⊆ hb ⨾ eco^?","hypotheses":"(WF : Wf G) (cons_coherence : irreflexive (hb ⨾ eco^?)) (cons_atomicity : rmw ∩ (fr ⨾ co) ≡ ∅₂)","proofString":"apply inclusion_seq_mon; basic_solver."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive ((⦗E⦘ ⨾ ⦗W⦘ ⨾ rf^? ⨾ hb^?) ⨾ hb).","conclusion":"irreflexive ((⦗E⦘ ⨾ ⦗W⦘ ⨾ rf^? ⨾ hb^?) ⨾ hb)","hypotheses":"(WF : Wf G) (CONS : WCore.is_cons G)","proofString":"arewrite_id ⦗W⦘; arewrite_id ⦗E⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive\n  (⦗fun _ : actid => True⦘ ⨾ ⦗fun _ : actid => True⦘ ⨾ rf^? ⨾ hb^? ⨾ hb).","conclusion":"irreflexive\n  (⦗fun _ : actid => True⦘ ⨾ ⦗fun _ : actid => True⦘ ⨾ rf^? ⨾ hb^? ⨾ hb)","hypotheses":"(WF : Wf G) (CONS : WCore.is_cons G)","proofString":"rels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive (rf^? ⨾ hb^? ⨾ hb).","conclusion":"irreflexive (rf^? ⨾ hb^? ⨾ hb)","hypotheses":"(WF : Wf G) (CONS : WCore.is_cons G)","proofString":"arewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive (eco^? ⨾ hb^? ⨾ hb).","conclusion":"irreflexive (eco^? ⨾ hb^? ⨾ hb)","hypotheses":"(WF : Wf G) (CONS : WCore.is_cons G)","proofString":"generalize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) : irreflexive (eco^? ⨾ hb^? ⨾ hb).","conclusion":"irreflexive (eco^? ⨾ hb^? ⨾ hb)","hypotheses":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco)","proofString":"generalize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco^? ⨾ hb).","conclusion":"irreflexive (eco^? ⨾ hb)","hypotheses":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) (H0 : transitive hb)","proofString":"relsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco^? ⨾ hb).","conclusion":"irreflexive (eco^? ⨾ hb)","hypotheses":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) (H0 : transitive hb)","proofString":"by rotate 1; apply CONS."}]}